{"ast":null,"code":"/**\n * @fileoverview Disallows or enforces spaces inside of parentheses.\n * @author Jonathan Rajavuori\n */\n\"use strict\";\n\nrequire(\"core-js/modules/es.array.push.js\");\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce consistent spacing inside parentheses\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/space-in-parens\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      enum: [\"always\", \"never\"]\n    }, {\n      type: \"object\",\n      properties: {\n        exceptions: {\n          type: \"array\",\n          items: {\n            enum: [\"{}\", \"[]\", \"()\", \"empty\"]\n          },\n          uniqueItems: true\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      missingOpeningSpace: \"There must be a space after this paren.\",\n      missingClosingSpace: \"There must be a space before this paren.\",\n      rejectedOpeningSpace: \"There should be no space after this paren.\",\n      rejectedClosingSpace: \"There should be no space before this paren.\"\n    }\n  },\n  create(context) {\n    const ALWAYS = context.options[0] === \"always\",\n      exceptionsArrayOptions = context.options[1] && context.options[1].exceptions || [],\n      options = {};\n    let exceptions;\n    if (exceptionsArrayOptions.length) {\n      options.braceException = exceptionsArrayOptions.includes(\"{}\");\n      options.bracketException = exceptionsArrayOptions.includes(\"[]\");\n      options.parenException = exceptionsArrayOptions.includes(\"()\");\n      options.empty = exceptionsArrayOptions.includes(\"empty\");\n    }\n\n    /**\n     * Produces an object with the opener and closer exception values\n     * @returns {Object} `openers` and `closers` exception values\n     * @private\n     */\n    function getExceptions() {\n      const openers = [],\n        closers = [];\n      if (options.braceException) {\n        openers.push(\"{\");\n        closers.push(\"}\");\n      }\n      if (options.bracketException) {\n        openers.push(\"[\");\n        closers.push(\"]\");\n      }\n      if (options.parenException) {\n        openers.push(\"(\");\n        closers.push(\")\");\n      }\n      if (options.empty) {\n        openers.push(\")\");\n        closers.push(\"(\");\n      }\n      return {\n        openers,\n        closers\n      };\n    }\n\n    //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n    const sourceCode = context.getSourceCode();\n\n    /**\n     * Determines if a token is one of the exceptions for the opener paren\n     * @param {Object} token The token to check\n     * @returns {boolean} True if the token is one of the exceptions for the opener paren\n     */\n    function isOpenerException(token) {\n      return exceptions.openers.includes(token.value);\n    }\n\n    /**\n     * Determines if a token is one of the exceptions for the closer paren\n     * @param {Object} token The token to check\n     * @returns {boolean} True if the token is one of the exceptions for the closer paren\n     */\n    function isCloserException(token) {\n      return exceptions.closers.includes(token.value);\n    }\n\n    /**\n     * Determines if an opening paren is immediately followed by a required space\n     * @param {Object} openingParenToken The paren token\n     * @param {Object} tokenAfterOpeningParen The token after it\n     * @returns {boolean} True if the opening paren is missing a required space\n     */\n    function openerMissingSpace(openingParenToken, tokenAfterOpeningParen) {\n      if (sourceCode.isSpaceBetweenTokens(openingParenToken, tokenAfterOpeningParen)) {\n        return false;\n      }\n      if (!options.empty && astUtils.isClosingParenToken(tokenAfterOpeningParen)) {\n        return false;\n      }\n      if (ALWAYS) {\n        return !isOpenerException(tokenAfterOpeningParen);\n      }\n      return isOpenerException(tokenAfterOpeningParen);\n    }\n\n    /**\n     * Determines if an opening paren is immediately followed by a disallowed space\n     * @param {Object} openingParenToken The paren token\n     * @param {Object} tokenAfterOpeningParen The token after it\n     * @returns {boolean} True if the opening paren has a disallowed space\n     */\n    function openerRejectsSpace(openingParenToken, tokenAfterOpeningParen) {\n      if (!astUtils.isTokenOnSameLine(openingParenToken, tokenAfterOpeningParen)) {\n        return false;\n      }\n      if (tokenAfterOpeningParen.type === \"Line\") {\n        return false;\n      }\n      if (!sourceCode.isSpaceBetweenTokens(openingParenToken, tokenAfterOpeningParen)) {\n        return false;\n      }\n      if (ALWAYS) {\n        return isOpenerException(tokenAfterOpeningParen);\n      }\n      return !isOpenerException(tokenAfterOpeningParen);\n    }\n\n    /**\n     * Determines if a closing paren is immediately preceded by a required space\n     * @param {Object} tokenBeforeClosingParen The token before the paren\n     * @param {Object} closingParenToken The paren token\n     * @returns {boolean} True if the closing paren is missing a required space\n     */\n    function closerMissingSpace(tokenBeforeClosingParen, closingParenToken) {\n      if (sourceCode.isSpaceBetweenTokens(tokenBeforeClosingParen, closingParenToken)) {\n        return false;\n      }\n      if (!options.empty && astUtils.isOpeningParenToken(tokenBeforeClosingParen)) {\n        return false;\n      }\n      if (ALWAYS) {\n        return !isCloserException(tokenBeforeClosingParen);\n      }\n      return isCloserException(tokenBeforeClosingParen);\n    }\n\n    /**\n     * Determines if a closer paren is immediately preceded by a disallowed space\n     * @param {Object} tokenBeforeClosingParen The token before the paren\n     * @param {Object} closingParenToken The paren token\n     * @returns {boolean} True if the closing paren has a disallowed space\n     */\n    function closerRejectsSpace(tokenBeforeClosingParen, closingParenToken) {\n      if (!astUtils.isTokenOnSameLine(tokenBeforeClosingParen, closingParenToken)) {\n        return false;\n      }\n      if (!sourceCode.isSpaceBetweenTokens(tokenBeforeClosingParen, closingParenToken)) {\n        return false;\n      }\n      if (ALWAYS) {\n        return isCloserException(tokenBeforeClosingParen);\n      }\n      return !isCloserException(tokenBeforeClosingParen);\n    }\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    return {\n      Program: function checkParenSpaces(node) {\n        exceptions = getExceptions();\n        const tokens = sourceCode.tokensAndComments;\n        tokens.forEach((token, i) => {\n          const prevToken = tokens[i - 1];\n          const nextToken = tokens[i + 1];\n\n          // if token is not an opening or closing paren token, do nothing\n          if (!astUtils.isOpeningParenToken(token) && !astUtils.isClosingParenToken(token)) {\n            return;\n          }\n\n          // if token is an opening paren and is not followed by a required space\n          if (token.value === \"(\" && openerMissingSpace(token, nextToken)) {\n            context.report({\n              node,\n              loc: token.loc,\n              messageId: \"missingOpeningSpace\",\n              fix(fixer) {\n                return fixer.insertTextAfter(token, \" \");\n              }\n            });\n          }\n\n          // if token is an opening paren and is followed by a disallowed space\n          if (token.value === \"(\" && openerRejectsSpace(token, nextToken)) {\n            context.report({\n              node,\n              loc: {\n                start: token.loc.end,\n                end: nextToken.loc.start\n              },\n              messageId: \"rejectedOpeningSpace\",\n              fix(fixer) {\n                return fixer.removeRange([token.range[1], nextToken.range[0]]);\n              }\n            });\n          }\n\n          // if token is a closing paren and is not preceded by a required space\n          if (token.value === \")\" && closerMissingSpace(prevToken, token)) {\n            context.report({\n              node,\n              loc: token.loc,\n              messageId: \"missingClosingSpace\",\n              fix(fixer) {\n                return fixer.insertTextBefore(token, \" \");\n              }\n            });\n          }\n\n          // if token is a closing paren and is preceded by a disallowed space\n          if (token.value === \")\" && closerRejectsSpace(prevToken, token)) {\n            context.report({\n              node,\n              loc: {\n                start: prevToken.loc.end,\n                end: token.loc.start\n              },\n              messageId: \"rejectedClosingSpace\",\n              fix(fixer) {\n                return fixer.removeRange([prevToken.range[1], token.range[0]]);\n              }\n            });\n          }\n        });\n      }\n    };\n  }\n};","map":{"version":3,"names":["require","astUtils","module","exports","meta","type","docs","description","category","recommended","url","fixable","schema","enum","properties","exceptions","items","uniqueItems","additionalProperties","messages","missingOpeningSpace","missingClosingSpace","rejectedOpeningSpace","rejectedClosingSpace","create","context","ALWAYS","options","exceptionsArrayOptions","length","braceException","includes","bracketException","parenException","empty","getExceptions","openers","closers","push","sourceCode","getSourceCode","isOpenerException","token","value","isCloserException","openerMissingSpace","openingParenToken","tokenAfterOpeningParen","isSpaceBetweenTokens","isClosingParenToken","openerRejectsSpace","isTokenOnSameLine","closerMissingSpace","tokenBeforeClosingParen","closingParenToken","isOpeningParenToken","closerRejectsSpace","Program","checkParenSpaces","node","tokens","tokensAndComments","forEach","i","prevToken","nextToken","report","loc","messageId","fix","fixer","insertTextAfter","start","end","removeRange","range","insertTextBefore"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/space-in-parens.js"],"sourcesContent":["/**\n * @fileoverview Disallows or enforces spaces inside of parentheses.\n * @author Jonathan Rajavuori\n */\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce consistent spacing inside parentheses\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/space-in-parens\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                enum: [\"always\", \"never\"]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    exceptions: {\n                        type: \"array\",\n                        items: {\n                            enum: [\"{}\", \"[]\", \"()\", \"empty\"]\n                        },\n                        uniqueItems: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            missingOpeningSpace: \"There must be a space after this paren.\",\n            missingClosingSpace: \"There must be a space before this paren.\",\n            rejectedOpeningSpace: \"There should be no space after this paren.\",\n            rejectedClosingSpace: \"There should be no space before this paren.\"\n        }\n    },\n\n    create(context) {\n        const ALWAYS = context.options[0] === \"always\",\n            exceptionsArrayOptions = (context.options[1] && context.options[1].exceptions) || [],\n            options = {};\n\n        let exceptions;\n\n        if (exceptionsArrayOptions.length) {\n            options.braceException = exceptionsArrayOptions.includes(\"{}\");\n            options.bracketException = exceptionsArrayOptions.includes(\"[]\");\n            options.parenException = exceptionsArrayOptions.includes(\"()\");\n            options.empty = exceptionsArrayOptions.includes(\"empty\");\n        }\n\n        /**\n         * Produces an object with the opener and closer exception values\n         * @returns {Object} `openers` and `closers` exception values\n         * @private\n         */\n        function getExceptions() {\n            const openers = [],\n                closers = [];\n\n            if (options.braceException) {\n                openers.push(\"{\");\n                closers.push(\"}\");\n            }\n\n            if (options.bracketException) {\n                openers.push(\"[\");\n                closers.push(\"]\");\n            }\n\n            if (options.parenException) {\n                openers.push(\"(\");\n                closers.push(\")\");\n            }\n\n            if (options.empty) {\n                openers.push(\")\");\n                closers.push(\"(\");\n            }\n\n            return {\n                openers,\n                closers\n            };\n        }\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Determines if a token is one of the exceptions for the opener paren\n         * @param {Object} token The token to check\n         * @returns {boolean} True if the token is one of the exceptions for the opener paren\n         */\n        function isOpenerException(token) {\n            return exceptions.openers.includes(token.value);\n        }\n\n        /**\n         * Determines if a token is one of the exceptions for the closer paren\n         * @param {Object} token The token to check\n         * @returns {boolean} True if the token is one of the exceptions for the closer paren\n         */\n        function isCloserException(token) {\n            return exceptions.closers.includes(token.value);\n        }\n\n        /**\n         * Determines if an opening paren is immediately followed by a required space\n         * @param {Object} openingParenToken The paren token\n         * @param {Object} tokenAfterOpeningParen The token after it\n         * @returns {boolean} True if the opening paren is missing a required space\n         */\n        function openerMissingSpace(openingParenToken, tokenAfterOpeningParen) {\n            if (sourceCode.isSpaceBetweenTokens(openingParenToken, tokenAfterOpeningParen)) {\n                return false;\n            }\n\n            if (!options.empty && astUtils.isClosingParenToken(tokenAfterOpeningParen)) {\n                return false;\n            }\n\n            if (ALWAYS) {\n                return !isOpenerException(tokenAfterOpeningParen);\n            }\n            return isOpenerException(tokenAfterOpeningParen);\n        }\n\n        /**\n         * Determines if an opening paren is immediately followed by a disallowed space\n         * @param {Object} openingParenToken The paren token\n         * @param {Object} tokenAfterOpeningParen The token after it\n         * @returns {boolean} True if the opening paren has a disallowed space\n         */\n        function openerRejectsSpace(openingParenToken, tokenAfterOpeningParen) {\n            if (!astUtils.isTokenOnSameLine(openingParenToken, tokenAfterOpeningParen)) {\n                return false;\n            }\n\n            if (tokenAfterOpeningParen.type === \"Line\") {\n                return false;\n            }\n\n            if (!sourceCode.isSpaceBetweenTokens(openingParenToken, tokenAfterOpeningParen)) {\n                return false;\n            }\n\n            if (ALWAYS) {\n                return isOpenerException(tokenAfterOpeningParen);\n            }\n            return !isOpenerException(tokenAfterOpeningParen);\n        }\n\n        /**\n         * Determines if a closing paren is immediately preceded by a required space\n         * @param {Object} tokenBeforeClosingParen The token before the paren\n         * @param {Object} closingParenToken The paren token\n         * @returns {boolean} True if the closing paren is missing a required space\n         */\n        function closerMissingSpace(tokenBeforeClosingParen, closingParenToken) {\n            if (sourceCode.isSpaceBetweenTokens(tokenBeforeClosingParen, closingParenToken)) {\n                return false;\n            }\n\n            if (!options.empty && astUtils.isOpeningParenToken(tokenBeforeClosingParen)) {\n                return false;\n            }\n\n            if (ALWAYS) {\n                return !isCloserException(tokenBeforeClosingParen);\n            }\n            return isCloserException(tokenBeforeClosingParen);\n        }\n\n        /**\n         * Determines if a closer paren is immediately preceded by a disallowed space\n         * @param {Object} tokenBeforeClosingParen The token before the paren\n         * @param {Object} closingParenToken The paren token\n         * @returns {boolean} True if the closing paren has a disallowed space\n         */\n        function closerRejectsSpace(tokenBeforeClosingParen, closingParenToken) {\n            if (!astUtils.isTokenOnSameLine(tokenBeforeClosingParen, closingParenToken)) {\n                return false;\n            }\n\n            if (!sourceCode.isSpaceBetweenTokens(tokenBeforeClosingParen, closingParenToken)) {\n                return false;\n            }\n\n            if (ALWAYS) {\n                return isCloserException(tokenBeforeClosingParen);\n            }\n            return !isCloserException(tokenBeforeClosingParen);\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            Program: function checkParenSpaces(node) {\n                exceptions = getExceptions();\n                const tokens = sourceCode.tokensAndComments;\n\n                tokens.forEach((token, i) => {\n                    const prevToken = tokens[i - 1];\n                    const nextToken = tokens[i + 1];\n\n                    // if token is not an opening or closing paren token, do nothing\n                    if (!astUtils.isOpeningParenToken(token) && !astUtils.isClosingParenToken(token)) {\n                        return;\n                    }\n\n                    // if token is an opening paren and is not followed by a required space\n                    if (token.value === \"(\" && openerMissingSpace(token, nextToken)) {\n                        context.report({\n                            node,\n                            loc: token.loc,\n                            messageId: \"missingOpeningSpace\",\n                            fix(fixer) {\n                                return fixer.insertTextAfter(token, \" \");\n                            }\n                        });\n                    }\n\n                    // if token is an opening paren and is followed by a disallowed space\n                    if (token.value === \"(\" && openerRejectsSpace(token, nextToken)) {\n                        context.report({\n                            node,\n                            loc: { start: token.loc.end, end: nextToken.loc.start },\n                            messageId: \"rejectedOpeningSpace\",\n                            fix(fixer) {\n                                return fixer.removeRange([token.range[1], nextToken.range[0]]);\n                            }\n                        });\n                    }\n\n                    // if token is a closing paren and is not preceded by a required space\n                    if (token.value === \")\" && closerMissingSpace(prevToken, token)) {\n                        context.report({\n                            node,\n                            loc: token.loc,\n                            messageId: \"missingClosingSpace\",\n                            fix(fixer) {\n                                return fixer.insertTextBefore(token, \" \");\n                            }\n                        });\n                    }\n\n                    // if token is a closing paren and is preceded by a disallowed space\n                    if (token.value === \")\" && closerRejectsSpace(prevToken, token)) {\n                        context.report({\n                            node,\n                            loc: { start: prevToken.loc.end, end: token.loc.start },\n                            messageId: \"rejectedClosingSpace\",\n                            fix(fixer) {\n                                return fixer.removeRange([prevToken.range[1], token.range[0]]);\n                            }\n                        });\n                    }\n                });\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}