{"ast":null,"code":"/**\n * @fileoverview Rule to flag block statements that do not use the one true brace style\n * @author Ian Christian Myers\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce consistent brace style for blocks\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/brace-style\"\n    },\n    schema: [{\n      enum: [\"1tbs\", \"stroustrup\", \"allman\"]\n    }, {\n      type: \"object\",\n      properties: {\n        allowSingleLine: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    fixable: \"whitespace\",\n    messages: {\n      nextLineOpen: \"Opening curly brace does not appear on the same line as controlling statement.\",\n      sameLineOpen: \"Opening curly brace appears on the same line as controlling statement.\",\n      blockSameLine: \"Statement inside of curly braces should be on next line.\",\n      nextLineClose: \"Closing curly brace does not appear on the same line as the subsequent block.\",\n      singleLineClose: \"Closing curly brace should be on the same line as opening curly brace or on the line after the previous block.\",\n      sameLineClose: \"Closing curly brace appears on the same line as the subsequent block.\"\n    }\n  },\n  create(context) {\n    const style = context.options[0] || \"1tbs\",\n      params = context.options[1] || {},\n      sourceCode = context.getSourceCode();\n\n    //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    /**\n     * Fixes a place where a newline unexpectedly appears\n     * @param {Token} firstToken The token before the unexpected newline\n     * @param {Token} secondToken The token after the unexpected newline\n     * @returns {Function} A fixer function to remove the newlines between the tokens\n     */\n    function removeNewlineBetween(firstToken, secondToken) {\n      const textRange = [firstToken.range[1], secondToken.range[0]];\n      const textBetween = sourceCode.text.slice(textRange[0], textRange[1]);\n\n      // Don't do a fix if there is a comment between the tokens\n      if (textBetween.trim()) {\n        return null;\n      }\n      return fixer => fixer.replaceTextRange(textRange, \" \");\n    }\n\n    /**\n     * Validates a pair of curly brackets based on the user's config\n     * @param {Token} openingCurly The opening curly bracket\n     * @param {Token} closingCurly The closing curly bracket\n     * @returns {void}\n     */\n    function validateCurlyPair(openingCurly, closingCurly) {\n      const tokenBeforeOpeningCurly = sourceCode.getTokenBefore(openingCurly);\n      const tokenAfterOpeningCurly = sourceCode.getTokenAfter(openingCurly);\n      const tokenBeforeClosingCurly = sourceCode.getTokenBefore(closingCurly);\n      const singleLineException = params.allowSingleLine && astUtils.isTokenOnSameLine(openingCurly, closingCurly);\n      if (style !== \"allman\" && !astUtils.isTokenOnSameLine(tokenBeforeOpeningCurly, openingCurly)) {\n        context.report({\n          node: openingCurly,\n          messageId: \"nextLineOpen\",\n          fix: removeNewlineBetween(tokenBeforeOpeningCurly, openingCurly)\n        });\n      }\n      if (style === \"allman\" && astUtils.isTokenOnSameLine(tokenBeforeOpeningCurly, openingCurly) && !singleLineException) {\n        context.report({\n          node: openingCurly,\n          messageId: \"sameLineOpen\",\n          fix: fixer => fixer.insertTextBefore(openingCurly, \"\\n\")\n        });\n      }\n      if (astUtils.isTokenOnSameLine(openingCurly, tokenAfterOpeningCurly) && tokenAfterOpeningCurly !== closingCurly && !singleLineException) {\n        context.report({\n          node: openingCurly,\n          messageId: \"blockSameLine\",\n          fix: fixer => fixer.insertTextAfter(openingCurly, \"\\n\")\n        });\n      }\n      if (tokenBeforeClosingCurly !== openingCurly && !singleLineException && astUtils.isTokenOnSameLine(tokenBeforeClosingCurly, closingCurly)) {\n        context.report({\n          node: closingCurly,\n          messageId: \"singleLineClose\",\n          fix: fixer => fixer.insertTextBefore(closingCurly, \"\\n\")\n        });\n      }\n    }\n\n    /**\n     * Validates the location of a token that appears before a keyword (e.g. a newline before `else`)\n     * @param {Token} curlyToken The closing curly token. This is assumed to precede a keyword token (such as `else` or `finally`).\n     * @returns {void}\n     */\n    function validateCurlyBeforeKeyword(curlyToken) {\n      const keywordToken = sourceCode.getTokenAfter(curlyToken);\n      if (style === \"1tbs\" && !astUtils.isTokenOnSameLine(curlyToken, keywordToken)) {\n        context.report({\n          node: curlyToken,\n          messageId: \"nextLineClose\",\n          fix: removeNewlineBetween(curlyToken, keywordToken)\n        });\n      }\n      if (style !== \"1tbs\" && astUtils.isTokenOnSameLine(curlyToken, keywordToken)) {\n        context.report({\n          node: curlyToken,\n          messageId: \"sameLineClose\",\n          fix: fixer => fixer.insertTextAfter(curlyToken, \"\\n\")\n        });\n      }\n    }\n\n    //--------------------------------------------------------------------------\n    // Public API\n    //--------------------------------------------------------------------------\n\n    return {\n      BlockStatement(node) {\n        if (!astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type)) {\n          validateCurlyPair(sourceCode.getFirstToken(node), sourceCode.getLastToken(node));\n        }\n      },\n      ClassBody(node) {\n        validateCurlyPair(sourceCode.getFirstToken(node), sourceCode.getLastToken(node));\n      },\n      SwitchStatement(node) {\n        const closingCurly = sourceCode.getLastToken(node);\n        const openingCurly = sourceCode.getTokenBefore(node.cases.length ? node.cases[0] : closingCurly);\n        validateCurlyPair(openingCurly, closingCurly);\n      },\n      IfStatement(node) {\n        if (node.consequent.type === \"BlockStatement\" && node.alternate) {\n          // Handle the keyword after the `if` block (before `else`)\n          validateCurlyBeforeKeyword(sourceCode.getLastToken(node.consequent));\n        }\n      },\n      TryStatement(node) {\n        // Handle the keyword after the `try` block (before `catch` or `finally`)\n        validateCurlyBeforeKeyword(sourceCode.getLastToken(node.block));\n        if (node.handler && node.finalizer) {\n          // Handle the keyword after the `catch` block (before `finally`)\n          validateCurlyBeforeKeyword(sourceCode.getLastToken(node.handler.body));\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","module","exports","meta","type","docs","description","category","recommended","url","schema","enum","properties","allowSingleLine","default","additionalProperties","fixable","messages","nextLineOpen","sameLineOpen","blockSameLine","nextLineClose","singleLineClose","sameLineClose","create","context","style","options","params","sourceCode","getSourceCode","removeNewlineBetween","firstToken","secondToken","textRange","range","textBetween","text","slice","trim","fixer","replaceTextRange","validateCurlyPair","openingCurly","closingCurly","tokenBeforeOpeningCurly","getTokenBefore","tokenAfterOpeningCurly","getTokenAfter","tokenBeforeClosingCurly","singleLineException","isTokenOnSameLine","report","node","messageId","fix","insertTextBefore","insertTextAfter","validateCurlyBeforeKeyword","curlyToken","keywordToken","BlockStatement","STATEMENT_LIST_PARENTS","has","parent","getFirstToken","getLastToken","ClassBody","SwitchStatement","cases","length","IfStatement","consequent","alternate","TryStatement","block","handler","finalizer","body"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/brace-style.js"],"sourcesContent":["/**\n * @fileoverview Rule to flag block statements that do not use the one true brace style\n * @author Ian Christian Myers\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce consistent brace style for blocks\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/brace-style\"\n        },\n\n        schema: [\n            {\n                enum: [\"1tbs\", \"stroustrup\", \"allman\"]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    allowSingleLine: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: \"whitespace\",\n\n        messages: {\n            nextLineOpen: \"Opening curly brace does not appear on the same line as controlling statement.\",\n            sameLineOpen: \"Opening curly brace appears on the same line as controlling statement.\",\n            blockSameLine: \"Statement inside of curly braces should be on next line.\",\n            nextLineClose: \"Closing curly brace does not appear on the same line as the subsequent block.\",\n            singleLineClose: \"Closing curly brace should be on the same line as opening curly brace or on the line after the previous block.\",\n            sameLineClose: \"Closing curly brace appears on the same line as the subsequent block.\"\n        }\n    },\n\n    create(context) {\n        const style = context.options[0] || \"1tbs\",\n            params = context.options[1] || {},\n            sourceCode = context.getSourceCode();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Fixes a place where a newline unexpectedly appears\n         * @param {Token} firstToken The token before the unexpected newline\n         * @param {Token} secondToken The token after the unexpected newline\n         * @returns {Function} A fixer function to remove the newlines between the tokens\n         */\n        function removeNewlineBetween(firstToken, secondToken) {\n            const textRange = [firstToken.range[1], secondToken.range[0]];\n            const textBetween = sourceCode.text.slice(textRange[0], textRange[1]);\n\n            // Don't do a fix if there is a comment between the tokens\n            if (textBetween.trim()) {\n                return null;\n            }\n            return fixer => fixer.replaceTextRange(textRange, \" \");\n        }\n\n        /**\n         * Validates a pair of curly brackets based on the user's config\n         * @param {Token} openingCurly The opening curly bracket\n         * @param {Token} closingCurly The closing curly bracket\n         * @returns {void}\n         */\n        function validateCurlyPair(openingCurly, closingCurly) {\n            const tokenBeforeOpeningCurly = sourceCode.getTokenBefore(openingCurly);\n            const tokenAfterOpeningCurly = sourceCode.getTokenAfter(openingCurly);\n            const tokenBeforeClosingCurly = sourceCode.getTokenBefore(closingCurly);\n            const singleLineException = params.allowSingleLine && astUtils.isTokenOnSameLine(openingCurly, closingCurly);\n\n            if (style !== \"allman\" && !astUtils.isTokenOnSameLine(tokenBeforeOpeningCurly, openingCurly)) {\n                context.report({\n                    node: openingCurly,\n                    messageId: \"nextLineOpen\",\n                    fix: removeNewlineBetween(tokenBeforeOpeningCurly, openingCurly)\n                });\n            }\n\n            if (style === \"allman\" && astUtils.isTokenOnSameLine(tokenBeforeOpeningCurly, openingCurly) && !singleLineException) {\n                context.report({\n                    node: openingCurly,\n                    messageId: \"sameLineOpen\",\n                    fix: fixer => fixer.insertTextBefore(openingCurly, \"\\n\")\n                });\n            }\n\n            if (astUtils.isTokenOnSameLine(openingCurly, tokenAfterOpeningCurly) && tokenAfterOpeningCurly !== closingCurly && !singleLineException) {\n                context.report({\n                    node: openingCurly,\n                    messageId: \"blockSameLine\",\n                    fix: fixer => fixer.insertTextAfter(openingCurly, \"\\n\")\n                });\n            }\n\n            if (tokenBeforeClosingCurly !== openingCurly && !singleLineException && astUtils.isTokenOnSameLine(tokenBeforeClosingCurly, closingCurly)) {\n                context.report({\n                    node: closingCurly,\n                    messageId: \"singleLineClose\",\n                    fix: fixer => fixer.insertTextBefore(closingCurly, \"\\n\")\n                });\n            }\n        }\n\n        /**\n         * Validates the location of a token that appears before a keyword (e.g. a newline before `else`)\n         * @param {Token} curlyToken The closing curly token. This is assumed to precede a keyword token (such as `else` or `finally`).\n         * @returns {void}\n         */\n        function validateCurlyBeforeKeyword(curlyToken) {\n            const keywordToken = sourceCode.getTokenAfter(curlyToken);\n\n            if (style === \"1tbs\" && !astUtils.isTokenOnSameLine(curlyToken, keywordToken)) {\n                context.report({\n                    node: curlyToken,\n                    messageId: \"nextLineClose\",\n                    fix: removeNewlineBetween(curlyToken, keywordToken)\n                });\n            }\n\n            if (style !== \"1tbs\" && astUtils.isTokenOnSameLine(curlyToken, keywordToken)) {\n                context.report({\n                    node: curlyToken,\n                    messageId: \"sameLineClose\",\n                    fix: fixer => fixer.insertTextAfter(curlyToken, \"\\n\")\n                });\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n            BlockStatement(node) {\n                if (!astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type)) {\n                    validateCurlyPair(sourceCode.getFirstToken(node), sourceCode.getLastToken(node));\n                }\n            },\n            ClassBody(node) {\n                validateCurlyPair(sourceCode.getFirstToken(node), sourceCode.getLastToken(node));\n            },\n            SwitchStatement(node) {\n                const closingCurly = sourceCode.getLastToken(node);\n                const openingCurly = sourceCode.getTokenBefore(node.cases.length ? node.cases[0] : closingCurly);\n\n                validateCurlyPair(openingCurly, closingCurly);\n            },\n            IfStatement(node) {\n                if (node.consequent.type === \"BlockStatement\" && node.alternate) {\n\n                    // Handle the keyword after the `if` block (before `else`)\n                    validateCurlyBeforeKeyword(sourceCode.getLastToken(node.consequent));\n                }\n            },\n            TryStatement(node) {\n\n                // Handle the keyword after the `try` block (before `catch` or `finally`)\n                validateCurlyBeforeKeyword(sourceCode.getLastToken(node.block));\n\n                if (node.handler && node.finalizer) {\n\n                    // Handle the keyword after the `catch` block (before `finally`)\n                    validateCurlyBeforeKeyword(sourceCode.getLastToken(node.handler.body));\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}