{"ast":null,"code":"/**\n * @fileoverview Rule to check empty newline between class members\n * @author 薛定谔的猫<hh_2013@foxmail.com>\n */\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"require or disallow an empty line between class members\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/lines-between-class-members\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      enum: [\"always\", \"never\"]\n    }, {\n      type: \"object\",\n      properties: {\n        exceptAfterSingleLine: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      never: \"Unexpected blank line between class members.\",\n      always: \"Expected blank line between class members.\"\n    }\n  },\n  create(context) {\n    const options = [];\n    options[0] = context.options[0] || \"always\";\n    options[1] = context.options[1] || {\n      exceptAfterSingleLine: false\n    };\n    const sourceCode = context.getSourceCode();\n\n    /**\n     * Return the last token among the consecutive tokens that have no exceed max line difference in between, before the first token in the next member.\n     * @param {Token} prevLastToken The last token in the previous member node.\n     * @param {Token} nextFirstToken The first token in the next member node.\n     * @param {number} maxLine The maximum number of allowed line difference between consecutive tokens.\n     * @returns {Token} The last token among the consecutive tokens.\n     */\n    function findLastConsecutiveTokenAfter(prevLastToken, nextFirstToken, maxLine) {\n      const after = sourceCode.getTokenAfter(prevLastToken, {\n        includeComments: true\n      });\n      if (after !== nextFirstToken && after.loc.start.line - prevLastToken.loc.end.line <= maxLine) {\n        return findLastConsecutiveTokenAfter(after, nextFirstToken, maxLine);\n      }\n      return prevLastToken;\n    }\n\n    /**\n     * Return the first token among the consecutive tokens that have no exceed max line difference in between, after the last token in the previous member.\n     * @param {Token} nextFirstToken The first token in the next member node.\n     * @param {Token} prevLastToken The last token in the previous member node.\n     * @param {number} maxLine The maximum number of allowed line difference between consecutive tokens.\n     * @returns {Token} The first token among the consecutive tokens.\n     */\n    function findFirstConsecutiveTokenBefore(nextFirstToken, prevLastToken, maxLine) {\n      const before = sourceCode.getTokenBefore(nextFirstToken, {\n        includeComments: true\n      });\n      if (before !== prevLastToken && nextFirstToken.loc.start.line - before.loc.end.line <= maxLine) {\n        return findFirstConsecutiveTokenBefore(before, prevLastToken, maxLine);\n      }\n      return nextFirstToken;\n    }\n\n    /**\n     * Checks if there is a token or comment between two tokens.\n     * @param {Token} before The token before.\n     * @param {Token} after The token after.\n     * @returns {boolean} True if there is a token or comment between two tokens.\n     */\n    function hasTokenOrCommentBetween(before, after) {\n      return sourceCode.getTokensBetween(before, after, {\n        includeComments: true\n      }).length !== 0;\n    }\n    return {\n      ClassBody(node) {\n        const body = node.body;\n        for (let i = 0; i < body.length - 1; i++) {\n          const curFirst = sourceCode.getFirstToken(body[i]);\n          const curLast = sourceCode.getLastToken(body[i]);\n          const nextFirst = sourceCode.getFirstToken(body[i + 1]);\n          const isMulti = !astUtils.isTokenOnSameLine(curFirst, curLast);\n          const skip = !isMulti && options[1].exceptAfterSingleLine;\n          const beforePadding = findLastConsecutiveTokenAfter(curLast, nextFirst, 1);\n          const afterPadding = findFirstConsecutiveTokenBefore(nextFirst, curLast, 1);\n          const isPadded = afterPadding.loc.start.line - beforePadding.loc.end.line > 1;\n          const hasTokenInPadding = hasTokenOrCommentBetween(beforePadding, afterPadding);\n          const curLineLastToken = findLastConsecutiveTokenAfter(curLast, nextFirst, 0);\n          if (options[0] === \"always\" && !skip && !isPadded || options[0] === \"never\" && isPadded) {\n            context.report({\n              node: body[i + 1],\n              messageId: isPadded ? \"never\" : \"always\",\n              fix(fixer) {\n                if (hasTokenInPadding) {\n                  return null;\n                }\n                return isPadded ? fixer.replaceTextRange([beforePadding.range[1], afterPadding.range[0]], \"\\n\") : fixer.insertTextAfter(curLineLastToken, \"\\n\");\n              }\n            });\n          }\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","module","exports","meta","type","docs","description","category","recommended","url","fixable","schema","enum","properties","exceptAfterSingleLine","default","additionalProperties","messages","never","always","create","context","options","sourceCode","getSourceCode","findLastConsecutiveTokenAfter","prevLastToken","nextFirstToken","maxLine","after","getTokenAfter","includeComments","loc","start","line","end","findFirstConsecutiveTokenBefore","before","getTokenBefore","hasTokenOrCommentBetween","getTokensBetween","length","ClassBody","node","body","i","curFirst","getFirstToken","curLast","getLastToken","nextFirst","isMulti","isTokenOnSameLine","skip","beforePadding","afterPadding","isPadded","hasTokenInPadding","curLineLastToken","report","messageId","fix","fixer","replaceTextRange","range","insertTextAfter"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/lines-between-class-members.js"],"sourcesContent":["/**\n * @fileoverview Rule to check empty newline between class members\n * @author 薛定谔的猫<hh_2013@foxmail.com>\n */\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"require or disallow an empty line between class members\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/lines-between-class-members\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                enum: [\"always\", \"never\"]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    exceptAfterSingleLine: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n        messages: {\n            never: \"Unexpected blank line between class members.\",\n            always: \"Expected blank line between class members.\"\n        }\n    },\n\n    create(context) {\n\n        const options = [];\n\n        options[0] = context.options[0] || \"always\";\n        options[1] = context.options[1] || { exceptAfterSingleLine: false };\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Return the last token among the consecutive tokens that have no exceed max line difference in between, before the first token in the next member.\n         * @param {Token} prevLastToken The last token in the previous member node.\n         * @param {Token} nextFirstToken The first token in the next member node.\n         * @param {number} maxLine The maximum number of allowed line difference between consecutive tokens.\n         * @returns {Token} The last token among the consecutive tokens.\n         */\n        function findLastConsecutiveTokenAfter(prevLastToken, nextFirstToken, maxLine) {\n            const after = sourceCode.getTokenAfter(prevLastToken, { includeComments: true });\n\n            if (after !== nextFirstToken && after.loc.start.line - prevLastToken.loc.end.line <= maxLine) {\n                return findLastConsecutiveTokenAfter(after, nextFirstToken, maxLine);\n            }\n            return prevLastToken;\n        }\n\n        /**\n         * Return the first token among the consecutive tokens that have no exceed max line difference in between, after the last token in the previous member.\n         * @param {Token} nextFirstToken The first token in the next member node.\n         * @param {Token} prevLastToken The last token in the previous member node.\n         * @param {number} maxLine The maximum number of allowed line difference between consecutive tokens.\n         * @returns {Token} The first token among the consecutive tokens.\n         */\n        function findFirstConsecutiveTokenBefore(nextFirstToken, prevLastToken, maxLine) {\n            const before = sourceCode.getTokenBefore(nextFirstToken, { includeComments: true });\n\n            if (before !== prevLastToken && nextFirstToken.loc.start.line - before.loc.end.line <= maxLine) {\n                return findFirstConsecutiveTokenBefore(before, prevLastToken, maxLine);\n            }\n            return nextFirstToken;\n        }\n\n        /**\n         * Checks if there is a token or comment between two tokens.\n         * @param {Token} before The token before.\n         * @param {Token} after The token after.\n         * @returns {boolean} True if there is a token or comment between two tokens.\n         */\n        function hasTokenOrCommentBetween(before, after) {\n            return sourceCode.getTokensBetween(before, after, { includeComments: true }).length !== 0;\n        }\n\n        return {\n            ClassBody(node) {\n                const body = node.body;\n\n                for (let i = 0; i < body.length - 1; i++) {\n                    const curFirst = sourceCode.getFirstToken(body[i]);\n                    const curLast = sourceCode.getLastToken(body[i]);\n                    const nextFirst = sourceCode.getFirstToken(body[i + 1]);\n                    const isMulti = !astUtils.isTokenOnSameLine(curFirst, curLast);\n                    const skip = !isMulti && options[1].exceptAfterSingleLine;\n                    const beforePadding = findLastConsecutiveTokenAfter(curLast, nextFirst, 1);\n                    const afterPadding = findFirstConsecutiveTokenBefore(nextFirst, curLast, 1);\n                    const isPadded = afterPadding.loc.start.line - beforePadding.loc.end.line > 1;\n                    const hasTokenInPadding = hasTokenOrCommentBetween(beforePadding, afterPadding);\n                    const curLineLastToken = findLastConsecutiveTokenAfter(curLast, nextFirst, 0);\n\n                    if ((options[0] === \"always\" && !skip && !isPadded) ||\n                        (options[0] === \"never\" && isPadded)) {\n                        context.report({\n                            node: body[i + 1],\n                            messageId: isPadded ? \"never\" : \"always\",\n                            fix(fixer) {\n                                if (hasTokenInPadding) {\n                                    return null;\n                                }\n                                return isPadded\n                                    ? fixer.replaceTextRange([beforePadding.range[1], afterPadding.range[0]], \"\\n\")\n                                    : fixer.insertTextAfter(curLineLastToken, \"\\n\");\n                            }\n                        });\n                    }\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}