{"ast":null,"code":"/**\n * @fileoverview A class of the code path segment.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nrequire(\"core-js/modules/es.array.push.js\");\nconst debug = require(\"./debug-helpers\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given segment is reachable.\n * @param {CodePathSegment} segment A segment to check.\n * @returns {boolean} `true` if the segment is reachable.\n */\nfunction isReachable(segment) {\n  return segment.reachable;\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * A code path segment.\n */\nclass CodePathSegment {\n  // eslint-disable-next-line jsdoc/require-description\n  /**\n   * @param {string} id An identifier.\n   * @param {CodePathSegment[]} allPrevSegments An array of the previous segments.\n   *   This array includes unreachable segments.\n   * @param {boolean} reachable A flag which shows this is reachable.\n   */\n  constructor(id, allPrevSegments, reachable) {\n    /**\n     * The identifier of this code path.\n     * Rules use it to store additional information of each rule.\n     * @type {string}\n     */\n    this.id = id;\n\n    /**\n     * An array of the next segments.\n     * @type {CodePathSegment[]}\n     */\n    this.nextSegments = [];\n\n    /**\n     * An array of the previous segments.\n     * @type {CodePathSegment[]}\n     */\n    this.prevSegments = allPrevSegments.filter(isReachable);\n\n    /**\n     * An array of the next segments.\n     * This array includes unreachable segments.\n     * @type {CodePathSegment[]}\n     */\n    this.allNextSegments = [];\n\n    /**\n     * An array of the previous segments.\n     * This array includes unreachable segments.\n     * @type {CodePathSegment[]}\n     */\n    this.allPrevSegments = allPrevSegments;\n\n    /**\n     * A flag which shows this is reachable.\n     * @type {boolean}\n     */\n    this.reachable = reachable;\n\n    // Internal data.\n    Object.defineProperty(this, \"internal\", {\n      value: {\n        used: false,\n        loopedPrevSegments: []\n      }\n    });\n\n    /* istanbul ignore if */\n    if (debug.enabled) {\n      this.internal.nodes = [];\n    }\n  }\n\n  /**\n   * Checks a given previous segment is coming from the end of a loop.\n   * @param {CodePathSegment} segment A previous segment to check.\n   * @returns {boolean} `true` if the segment is coming from the end of a loop.\n   */\n  isLoopedPrevSegment(segment) {\n    return this.internal.loopedPrevSegments.indexOf(segment) !== -1;\n  }\n\n  /**\n   * Creates the root segment.\n   * @param {string} id An identifier.\n   * @returns {CodePathSegment} The created segment.\n   */\n  static newRoot(id) {\n    return new CodePathSegment(id, [], true);\n  }\n\n  /**\n   * Creates a segment that follows given segments.\n   * @param {string} id An identifier.\n   * @param {CodePathSegment[]} allPrevSegments An array of the previous segments.\n   * @returns {CodePathSegment} The created segment.\n   */\n  static newNext(id, allPrevSegments) {\n    return new CodePathSegment(id, CodePathSegment.flattenUnusedSegments(allPrevSegments), allPrevSegments.some(isReachable));\n  }\n\n  /**\n   * Creates an unreachable segment that follows given segments.\n   * @param {string} id An identifier.\n   * @param {CodePathSegment[]} allPrevSegments An array of the previous segments.\n   * @returns {CodePathSegment} The created segment.\n   */\n  static newUnreachable(id, allPrevSegments) {\n    const segment = new CodePathSegment(id, CodePathSegment.flattenUnusedSegments(allPrevSegments), false);\n\n    /*\n     * In `if (a) return a; foo();` case, the unreachable segment preceded by\n     * the return statement is not used but must not be remove.\n     */\n    CodePathSegment.markUsed(segment);\n    return segment;\n  }\n\n  /**\n   * Creates a segment that follows given segments.\n   * This factory method does not connect with `allPrevSegments`.\n   * But this inherits `reachable` flag.\n   * @param {string} id An identifier.\n   * @param {CodePathSegment[]} allPrevSegments An array of the previous segments.\n   * @returns {CodePathSegment} The created segment.\n   */\n  static newDisconnected(id, allPrevSegments) {\n    return new CodePathSegment(id, [], allPrevSegments.some(isReachable));\n  }\n\n  /**\n   * Makes a given segment being used.\n   *\n   * And this function registers the segment into the previous segments as a next.\n   * @param {CodePathSegment} segment A segment to mark.\n   * @returns {void}\n   */\n  static markUsed(segment) {\n    if (segment.internal.used) {\n      return;\n    }\n    segment.internal.used = true;\n    let i;\n    if (segment.reachable) {\n      for (i = 0; i < segment.allPrevSegments.length; ++i) {\n        const prevSegment = segment.allPrevSegments[i];\n        prevSegment.allNextSegments.push(segment);\n        prevSegment.nextSegments.push(segment);\n      }\n    } else {\n      for (i = 0; i < segment.allPrevSegments.length; ++i) {\n        segment.allPrevSegments[i].allNextSegments.push(segment);\n      }\n    }\n  }\n\n  /**\n   * Marks a previous segment as looped.\n   * @param {CodePathSegment} segment A segment.\n   * @param {CodePathSegment} prevSegment A previous segment to mark.\n   * @returns {void}\n   */\n  static markPrevSegmentAsLooped(segment, prevSegment) {\n    segment.internal.loopedPrevSegments.push(prevSegment);\n  }\n\n  /**\n   * Replaces unused segments with the previous segments of each unused segment.\n   * @param {CodePathSegment[]} segments An array of segments to replace.\n   * @returns {CodePathSegment[]} The replaced array.\n   */\n  static flattenUnusedSegments(segments) {\n    const done = Object.create(null);\n    const retv = [];\n    for (let i = 0; i < segments.length; ++i) {\n      const segment = segments[i];\n\n      // Ignores duplicated.\n      if (done[segment.id]) {\n        continue;\n      }\n\n      // Use previous segments if unused.\n      if (!segment.internal.used) {\n        for (let j = 0; j < segment.allPrevSegments.length; ++j) {\n          const prevSegment = segment.allPrevSegments[j];\n          if (!done[prevSegment.id]) {\n            done[prevSegment.id] = true;\n            retv.push(prevSegment);\n          }\n        }\n      } else {\n        done[segment.id] = true;\n        retv.push(segment);\n      }\n    }\n    return retv;\n  }\n}\nmodule.exports = CodePathSegment;","map":{"version":3,"names":["require","debug","isReachable","segment","reachable","CodePathSegment","constructor","id","allPrevSegments","nextSegments","prevSegments","filter","allNextSegments","Object","defineProperty","value","used","loopedPrevSegments","enabled","internal","nodes","isLoopedPrevSegment","indexOf","newRoot","newNext","flattenUnusedSegments","some","newUnreachable","markUsed","newDisconnected","i","length","prevSegment","push","markPrevSegmentAsLooped","segments","done","create","retv","j","module","exports"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/linter/code-path-analysis/code-path-segment.js"],"sourcesContent":["/**\n * @fileoverview A class of the code path segment.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst debug = require(\"./debug-helpers\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given segment is reachable.\n * @param {CodePathSegment} segment A segment to check.\n * @returns {boolean} `true` if the segment is reachable.\n */\nfunction isReachable(segment) {\n    return segment.reachable;\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * A code path segment.\n */\nclass CodePathSegment {\n\n    // eslint-disable-next-line jsdoc/require-description\n    /**\n     * @param {string} id An identifier.\n     * @param {CodePathSegment[]} allPrevSegments An array of the previous segments.\n     *   This array includes unreachable segments.\n     * @param {boolean} reachable A flag which shows this is reachable.\n     */\n    constructor(id, allPrevSegments, reachable) {\n\n        /**\n         * The identifier of this code path.\n         * Rules use it to store additional information of each rule.\n         * @type {string}\n         */\n        this.id = id;\n\n        /**\n         * An array of the next segments.\n         * @type {CodePathSegment[]}\n         */\n        this.nextSegments = [];\n\n        /**\n         * An array of the previous segments.\n         * @type {CodePathSegment[]}\n         */\n        this.prevSegments = allPrevSegments.filter(isReachable);\n\n        /**\n         * An array of the next segments.\n         * This array includes unreachable segments.\n         * @type {CodePathSegment[]}\n         */\n        this.allNextSegments = [];\n\n        /**\n         * An array of the previous segments.\n         * This array includes unreachable segments.\n         * @type {CodePathSegment[]}\n         */\n        this.allPrevSegments = allPrevSegments;\n\n        /**\n         * A flag which shows this is reachable.\n         * @type {boolean}\n         */\n        this.reachable = reachable;\n\n        // Internal data.\n        Object.defineProperty(this, \"internal\", {\n            value: {\n                used: false,\n                loopedPrevSegments: []\n            }\n        });\n\n        /* istanbul ignore if */\n        if (debug.enabled) {\n            this.internal.nodes = [];\n        }\n    }\n\n    /**\n     * Checks a given previous segment is coming from the end of a loop.\n     * @param {CodePathSegment} segment A previous segment to check.\n     * @returns {boolean} `true` if the segment is coming from the end of a loop.\n     */\n    isLoopedPrevSegment(segment) {\n        return this.internal.loopedPrevSegments.indexOf(segment) !== -1;\n    }\n\n    /**\n     * Creates the root segment.\n     * @param {string} id An identifier.\n     * @returns {CodePathSegment} The created segment.\n     */\n    static newRoot(id) {\n        return new CodePathSegment(id, [], true);\n    }\n\n    /**\n     * Creates a segment that follows given segments.\n     * @param {string} id An identifier.\n     * @param {CodePathSegment[]} allPrevSegments An array of the previous segments.\n     * @returns {CodePathSegment} The created segment.\n     */\n    static newNext(id, allPrevSegments) {\n        return new CodePathSegment(\n            id,\n            CodePathSegment.flattenUnusedSegments(allPrevSegments),\n            allPrevSegments.some(isReachable)\n        );\n    }\n\n    /**\n     * Creates an unreachable segment that follows given segments.\n     * @param {string} id An identifier.\n     * @param {CodePathSegment[]} allPrevSegments An array of the previous segments.\n     * @returns {CodePathSegment} The created segment.\n     */\n    static newUnreachable(id, allPrevSegments) {\n        const segment = new CodePathSegment(id, CodePathSegment.flattenUnusedSegments(allPrevSegments), false);\n\n        /*\n         * In `if (a) return a; foo();` case, the unreachable segment preceded by\n         * the return statement is not used but must not be remove.\n         */\n        CodePathSegment.markUsed(segment);\n\n        return segment;\n    }\n\n    /**\n     * Creates a segment that follows given segments.\n     * This factory method does not connect with `allPrevSegments`.\n     * But this inherits `reachable` flag.\n     * @param {string} id An identifier.\n     * @param {CodePathSegment[]} allPrevSegments An array of the previous segments.\n     * @returns {CodePathSegment} The created segment.\n     */\n    static newDisconnected(id, allPrevSegments) {\n        return new CodePathSegment(id, [], allPrevSegments.some(isReachable));\n    }\n\n    /**\n     * Makes a given segment being used.\n     *\n     * And this function registers the segment into the previous segments as a next.\n     * @param {CodePathSegment} segment A segment to mark.\n     * @returns {void}\n     */\n    static markUsed(segment) {\n        if (segment.internal.used) {\n            return;\n        }\n        segment.internal.used = true;\n\n        let i;\n\n        if (segment.reachable) {\n            for (i = 0; i < segment.allPrevSegments.length; ++i) {\n                const prevSegment = segment.allPrevSegments[i];\n\n                prevSegment.allNextSegments.push(segment);\n                prevSegment.nextSegments.push(segment);\n            }\n        } else {\n            for (i = 0; i < segment.allPrevSegments.length; ++i) {\n                segment.allPrevSegments[i].allNextSegments.push(segment);\n            }\n        }\n    }\n\n    /**\n     * Marks a previous segment as looped.\n     * @param {CodePathSegment} segment A segment.\n     * @param {CodePathSegment} prevSegment A previous segment to mark.\n     * @returns {void}\n     */\n    static markPrevSegmentAsLooped(segment, prevSegment) {\n        segment.internal.loopedPrevSegments.push(prevSegment);\n    }\n\n    /**\n     * Replaces unused segments with the previous segments of each unused segment.\n     * @param {CodePathSegment[]} segments An array of segments to replace.\n     * @returns {CodePathSegment[]} The replaced array.\n     */\n    static flattenUnusedSegments(segments) {\n        const done = Object.create(null);\n        const retv = [];\n\n        for (let i = 0; i < segments.length; ++i) {\n            const segment = segments[i];\n\n            // Ignores duplicated.\n            if (done[segment.id]) {\n                continue;\n            }\n\n            // Use previous segments if unused.\n            if (!segment.internal.used) {\n                for (let j = 0; j < segment.allPrevSegments.length; ++j) {\n                    const prevSegment = segment.allPrevSegments[j];\n\n                    if (!done[prevSegment.id]) {\n                        done[prevSegment.id] = true;\n                        retv.push(prevSegment);\n                    }\n                }\n            } else {\n                done[segment.id] = true;\n                retv.push(segment);\n            }\n        }\n\n        return retv;\n    }\n}\n\nmodule.exports = CodePathSegment;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}