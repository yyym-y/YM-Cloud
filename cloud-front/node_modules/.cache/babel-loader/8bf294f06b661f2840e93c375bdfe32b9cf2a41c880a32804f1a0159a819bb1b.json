{"ast":null,"code":"/**\n * @fileoverview Rule to enforce a single linebreak style.\n * @author Erik Mueller\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce consistent linebreak style\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/linebreak-style\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      enum: [\"unix\", \"windows\"]\n    }],\n    messages: {\n      expectedLF: \"Expected linebreaks to be 'LF' but found 'CRLF'.\",\n      expectedCRLF: \"Expected linebreaks to be 'CRLF' but found 'LF'.\"\n    }\n  },\n  create(context) {\n    const sourceCode = context.getSourceCode();\n\n    //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    /**\n     * Builds a fix function that replaces text at the specified range in the source text.\n     * @param {int[]} range The range to replace\n     * @param {string} text The text to insert.\n     * @returns {Function} Fixer function\n     * @private\n     */\n    function createFix(range, text) {\n      return function (fixer) {\n        return fixer.replaceTextRange(range, text);\n      };\n    }\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    return {\n      Program: function checkForLinebreakStyle(node) {\n        const linebreakStyle = context.options[0] || \"unix\",\n          expectedLF = linebreakStyle === \"unix\",\n          expectedLFChars = expectedLF ? \"\\n\" : \"\\r\\n\",\n          source = sourceCode.getText(),\n          pattern = astUtils.createGlobalLinebreakMatcher();\n        let match;\n        let i = 0;\n        while ((match = pattern.exec(source)) !== null) {\n          i++;\n          if (match[0] === expectedLFChars) {\n            continue;\n          }\n          const index = match.index;\n          const range = [index, index + match[0].length];\n          context.report({\n            node,\n            loc: {\n              start: {\n                line: i,\n                column: sourceCode.lines[i - 1].length\n              },\n              end: {\n                line: i + 1,\n                column: 0\n              }\n            },\n            messageId: expectedLF ? \"expectedLF\" : \"expectedCRLF\",\n            fix: createFix(range, expectedLFChars)\n          });\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","module","exports","meta","type","docs","description","category","recommended","url","fixable","schema","enum","messages","expectedLF","expectedCRLF","create","context","sourceCode","getSourceCode","createFix","range","text","fixer","replaceTextRange","Program","checkForLinebreakStyle","node","linebreakStyle","options","expectedLFChars","source","getText","pattern","createGlobalLinebreakMatcher","match","i","exec","index","length","report","loc","start","line","column","lines","end","messageId","fix"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/linebreak-style.js"],"sourcesContent":["/**\n * @fileoverview Rule to enforce a single linebreak style.\n * @author Erik Mueller\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce consistent linebreak style\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/linebreak-style\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                enum: [\"unix\", \"windows\"]\n            }\n        ],\n        messages: {\n            expectedLF: \"Expected linebreaks to be 'LF' but found 'CRLF'.\",\n            expectedCRLF: \"Expected linebreaks to be 'CRLF' but found 'LF'.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Builds a fix function that replaces text at the specified range in the source text.\n         * @param {int[]} range The range to replace\n         * @param {string} text The text to insert.\n         * @returns {Function} Fixer function\n         * @private\n         */\n        function createFix(range, text) {\n            return function(fixer) {\n                return fixer.replaceTextRange(range, text);\n            };\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            Program: function checkForLinebreakStyle(node) {\n                const linebreakStyle = context.options[0] || \"unix\",\n                    expectedLF = linebreakStyle === \"unix\",\n                    expectedLFChars = expectedLF ? \"\\n\" : \"\\r\\n\",\n                    source = sourceCode.getText(),\n                    pattern = astUtils.createGlobalLinebreakMatcher();\n                let match;\n\n                let i = 0;\n\n                while ((match = pattern.exec(source)) !== null) {\n                    i++;\n                    if (match[0] === expectedLFChars) {\n                        continue;\n                    }\n\n                    const index = match.index;\n                    const range = [index, index + match[0].length];\n\n                    context.report({\n                        node,\n                        loc: {\n                            start: {\n                                line: i,\n                                column: sourceCode.lines[i - 1].length\n                            },\n                            end: {\n                                line: i + 1,\n                                column: 0\n                            }\n                        },\n                        messageId: expectedLF ? \"expectedLF\" : \"expectedCRLF\",\n                        fix: createFix(range, expectedLFChars)\n                    });\n                }\n            }\n        };\n    }\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA,YAAY;;AAEZ;AACA;AACA;AAEA,MAAMA,QAAQ,GAAGC,OAAO,CAAC,mBAAmB,CAAC;;AAE7C;AACA;AACA;;AAEAC,MAAM,CAACC,OAAO,GAAG;EACbC,IAAI,EAAE;IACFC,IAAI,EAAE,QAAQ;IAEdC,IAAI,EAAE;MACFC,WAAW,EAAE,oCAAoC;MACjDC,QAAQ,EAAE,kBAAkB;MAC5BC,WAAW,EAAE,KAAK;MAClBC,GAAG,EAAE;IACT,CAAC;IAEDC,OAAO,EAAE,YAAY;IAErBC,MAAM,EAAE,CACJ;MACIC,IAAI,EAAE,CAAC,MAAM,EAAE,SAAS;IAC5B,CAAC,CACJ;IACDC,QAAQ,EAAE;MACNC,UAAU,EAAE,kDAAkD;MAC9DC,YAAY,EAAE;IAClB;EACJ,CAAC;EAEDC,MAAMA,CAACC,OAAO,EAAE;IACZ,MAAMC,UAAU,GAAGD,OAAO,CAACE,aAAa,CAAC,CAAC;;IAE1C;IACA;IACA;;IAEA;AACR;AACA;AACA;AACA;AACA;AACA;IACQ,SAASC,SAASA,CAACC,KAAK,EAAEC,IAAI,EAAE;MAC5B,OAAO,UAASC,KAAK,EAAE;QACnB,OAAOA,KAAK,CAACC,gBAAgB,CAACH,KAAK,EAAEC,IAAI,CAAC;MAC9C,CAAC;IACL;;IAEA;IACA;IACA;;IAEA,OAAO;MACHG,OAAO,EAAE,SAASC,sBAAsBA,CAACC,IAAI,EAAE;QAC3C,MAAMC,cAAc,GAAGX,OAAO,CAACY,OAAO,CAAC,CAAC,CAAC,IAAI,MAAM;UAC/Cf,UAAU,GAAGc,cAAc,KAAK,MAAM;UACtCE,eAAe,GAAGhB,UAAU,GAAG,IAAI,GAAG,MAAM;UAC5CiB,MAAM,GAAGb,UAAU,CAACc,OAAO,CAAC,CAAC;UAC7BC,OAAO,GAAGlC,QAAQ,CAACmC,4BAA4B,CAAC,CAAC;QACrD,IAAIC,KAAK;QAET,IAAIC,CAAC,GAAG,CAAC;QAET,OAAO,CAACD,KAAK,GAAGF,OAAO,CAACI,IAAI,CAACN,MAAM,CAAC,MAAM,IAAI,EAAE;UAC5CK,CAAC,EAAE;UACH,IAAID,KAAK,CAAC,CAAC,CAAC,KAAKL,eAAe,EAAE;YAC9B;UACJ;UAEA,MAAMQ,KAAK,GAAGH,KAAK,CAACG,KAAK;UACzB,MAAMjB,KAAK,GAAG,CAACiB,KAAK,EAAEA,KAAK,GAAGH,KAAK,CAAC,CAAC,CAAC,CAACI,MAAM,CAAC;UAE9CtB,OAAO,CAACuB,MAAM,CAAC;YACXb,IAAI;YACJc,GAAG,EAAE;cACDC,KAAK,EAAE;gBACHC,IAAI,EAAEP,CAAC;gBACPQ,MAAM,EAAE1B,UAAU,CAAC2B,KAAK,CAACT,CAAC,GAAG,CAAC,CAAC,CAACG;cACpC,CAAC;cACDO,GAAG,EAAE;gBACDH,IAAI,EAAEP,CAAC,GAAG,CAAC;gBACXQ,MAAM,EAAE;cACZ;YACJ,CAAC;YACDG,SAAS,EAAEjC,UAAU,GAAG,YAAY,GAAG,cAAc;YACrDkC,GAAG,EAAE5B,SAAS,CAACC,KAAK,EAAES,eAAe;UACzC,CAAC,CAAC;QACN;MACJ;IACJ,CAAC;EACL;AACJ,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}