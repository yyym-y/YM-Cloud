{"ast":null,"code":"/**\n * @fileoverview Rule to enforce linebreaks after open and before close array brackets\n * @author Jan Peer Stöcklmair <https://github.com/JPeer264>\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce linebreaks after opening and before closing array brackets\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/array-bracket-newline\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      oneOf: [{\n        enum: [\"always\", \"never\", \"consistent\"]\n      }, {\n        type: \"object\",\n        properties: {\n          multiline: {\n            type: \"boolean\"\n          },\n          minItems: {\n            type: [\"integer\", \"null\"],\n            minimum: 0\n          }\n        },\n        additionalProperties: false\n      }]\n    }],\n    messages: {\n      unexpectedOpeningLinebreak: \"There should be no linebreak after '['.\",\n      unexpectedClosingLinebreak: \"There should be no linebreak before ']'.\",\n      missingOpeningLinebreak: \"A linebreak is required after '['.\",\n      missingClosingLinebreak: \"A linebreak is required before ']'.\"\n    }\n  },\n  create(context) {\n    const sourceCode = context.getSourceCode();\n\n    //----------------------------------------------------------------------\n    // Helpers\n    //----------------------------------------------------------------------\n\n    /**\n     * Normalizes a given option value.\n     * @param {string|Object|undefined} option An option value to parse.\n     * @returns {{multiline: boolean, minItems: number}} Normalized option object.\n     */\n    function normalizeOptionValue(option) {\n      let consistent = false;\n      let multiline = false;\n      let minItems = 0;\n      if (option) {\n        if (option === \"consistent\") {\n          consistent = true;\n          minItems = Number.POSITIVE_INFINITY;\n        } else if (option === \"always\" || option.minItems === 0) {\n          minItems = 0;\n        } else if (option === \"never\") {\n          minItems = Number.POSITIVE_INFINITY;\n        } else {\n          multiline = Boolean(option.multiline);\n          minItems = option.minItems || Number.POSITIVE_INFINITY;\n        }\n      } else {\n        consistent = false;\n        multiline = true;\n        minItems = Number.POSITIVE_INFINITY;\n      }\n      return {\n        consistent,\n        multiline,\n        minItems\n      };\n    }\n\n    /**\n     * Normalizes a given option value.\n     * @param {string|Object|undefined} options An option value to parse.\n     * @returns {{ArrayExpression: {multiline: boolean, minItems: number}, ArrayPattern: {multiline: boolean, minItems: number}}} Normalized option object.\n     */\n    function normalizeOptions(options) {\n      const value = normalizeOptionValue(options);\n      return {\n        ArrayExpression: value,\n        ArrayPattern: value\n      };\n    }\n\n    /**\n     * Reports that there shouldn't be a linebreak after the first token\n     * @param {ASTNode} node The node to report in the event of an error.\n     * @param {Token} token The token to use for the report.\n     * @returns {void}\n     */\n    function reportNoBeginningLinebreak(node, token) {\n      context.report({\n        node,\n        loc: token.loc,\n        messageId: \"unexpectedOpeningLinebreak\",\n        fix(fixer) {\n          const nextToken = sourceCode.getTokenAfter(token, {\n            includeComments: true\n          });\n          if (astUtils.isCommentToken(nextToken)) {\n            return null;\n          }\n          return fixer.removeRange([token.range[1], nextToken.range[0]]);\n        }\n      });\n    }\n\n    /**\n     * Reports that there shouldn't be a linebreak before the last token\n     * @param {ASTNode} node The node to report in the event of an error.\n     * @param {Token} token The token to use for the report.\n     * @returns {void}\n     */\n    function reportNoEndingLinebreak(node, token) {\n      context.report({\n        node,\n        loc: token.loc,\n        messageId: \"unexpectedClosingLinebreak\",\n        fix(fixer) {\n          const previousToken = sourceCode.getTokenBefore(token, {\n            includeComments: true\n          });\n          if (astUtils.isCommentToken(previousToken)) {\n            return null;\n          }\n          return fixer.removeRange([previousToken.range[1], token.range[0]]);\n        }\n      });\n    }\n\n    /**\n     * Reports that there should be a linebreak after the first token\n     * @param {ASTNode} node The node to report in the event of an error.\n     * @param {Token} token The token to use for the report.\n     * @returns {void}\n     */\n    function reportRequiredBeginningLinebreak(node, token) {\n      context.report({\n        node,\n        loc: token.loc,\n        messageId: \"missingOpeningLinebreak\",\n        fix(fixer) {\n          return fixer.insertTextAfter(token, \"\\n\");\n        }\n      });\n    }\n\n    /**\n     * Reports that there should be a linebreak before the last token\n     * @param {ASTNode} node The node to report in the event of an error.\n     * @param {Token} token The token to use for the report.\n     * @returns {void}\n     */\n    function reportRequiredEndingLinebreak(node, token) {\n      context.report({\n        node,\n        loc: token.loc,\n        messageId: \"missingClosingLinebreak\",\n        fix(fixer) {\n          return fixer.insertTextBefore(token, \"\\n\");\n        }\n      });\n    }\n\n    /**\n     * Reports a given node if it violated this rule.\n     * @param {ASTNode} node A node to check. This is an ArrayExpression node or an ArrayPattern node.\n     * @returns {void}\n     */\n    function check(node) {\n      const elements = node.elements;\n      const normalizedOptions = normalizeOptions(context.options[0]);\n      const options = normalizedOptions[node.type];\n      const openBracket = sourceCode.getFirstToken(node);\n      const closeBracket = sourceCode.getLastToken(node);\n      const firstIncComment = sourceCode.getTokenAfter(openBracket, {\n        includeComments: true\n      });\n      const lastIncComment = sourceCode.getTokenBefore(closeBracket, {\n        includeComments: true\n      });\n      const first = sourceCode.getTokenAfter(openBracket);\n      const last = sourceCode.getTokenBefore(closeBracket);\n      const needsLinebreaks = elements.length >= options.minItems || options.multiline && elements.length > 0 && firstIncComment.loc.start.line !== lastIncComment.loc.end.line || elements.length === 0 && firstIncComment.type === \"Block\" && firstIncComment.loc.start.line !== lastIncComment.loc.end.line && firstIncComment === lastIncComment || options.consistent && openBracket.loc.end.line !== first.loc.start.line;\n\n      /*\n       * Use tokens or comments to check multiline or not.\n       * But use only tokens to check whether linebreaks are needed.\n       * This allows:\n       *     var arr = [ // eslint-disable-line foo\n       *         'a'\n       *     ]\n       */\n\n      if (needsLinebreaks) {\n        if (astUtils.isTokenOnSameLine(openBracket, first)) {\n          reportRequiredBeginningLinebreak(node, openBracket);\n        }\n        if (astUtils.isTokenOnSameLine(last, closeBracket)) {\n          reportRequiredEndingLinebreak(node, closeBracket);\n        }\n      } else {\n        if (!astUtils.isTokenOnSameLine(openBracket, first)) {\n          reportNoBeginningLinebreak(node, openBracket);\n        }\n        if (!astUtils.isTokenOnSameLine(last, closeBracket)) {\n          reportNoEndingLinebreak(node, closeBracket);\n        }\n      }\n    }\n\n    //----------------------------------------------------------------------\n    // Public\n    //----------------------------------------------------------------------\n\n    return {\n      ArrayPattern: check,\n      ArrayExpression: check\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","module","exports","meta","type","docs","description","category","recommended","url","fixable","schema","oneOf","enum","properties","multiline","minItems","minimum","additionalProperties","messages","unexpectedOpeningLinebreak","unexpectedClosingLinebreak","missingOpeningLinebreak","missingClosingLinebreak","create","context","sourceCode","getSourceCode","normalizeOptionValue","option","consistent","Number","POSITIVE_INFINITY","Boolean","normalizeOptions","options","value","ArrayExpression","ArrayPattern","reportNoBeginningLinebreak","node","token","report","loc","messageId","fix","fixer","nextToken","getTokenAfter","includeComments","isCommentToken","removeRange","range","reportNoEndingLinebreak","previousToken","getTokenBefore","reportRequiredBeginningLinebreak","insertTextAfter","reportRequiredEndingLinebreak","insertTextBefore","check","elements","normalizedOptions","openBracket","getFirstToken","closeBracket","getLastToken","firstIncComment","lastIncComment","first","last","needsLinebreaks","length","start","line","end","isTokenOnSameLine"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/array-bracket-newline.js"],"sourcesContent":["/**\n * @fileoverview Rule to enforce linebreaks after open and before close array brackets\n * @author Jan Peer Stöcklmair <https://github.com/JPeer264>\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce linebreaks after opening and before closing array brackets\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/array-bracket-newline\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"always\", \"never\", \"consistent\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            multiline: {\n                                type: \"boolean\"\n                            },\n                            minItems: {\n                                type: [\"integer\", \"null\"],\n                                minimum: 0\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ],\n\n        messages: {\n            unexpectedOpeningLinebreak: \"There should be no linebreak after '['.\",\n            unexpectedClosingLinebreak: \"There should be no linebreak before ']'.\",\n            missingOpeningLinebreak: \"A linebreak is required after '['.\",\n            missingClosingLinebreak: \"A linebreak is required before ']'.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n\n        //----------------------------------------------------------------------\n        // Helpers\n        //----------------------------------------------------------------------\n\n        /**\n         * Normalizes a given option value.\n         * @param {string|Object|undefined} option An option value to parse.\n         * @returns {{multiline: boolean, minItems: number}} Normalized option object.\n         */\n        function normalizeOptionValue(option) {\n            let consistent = false;\n            let multiline = false;\n            let minItems = 0;\n\n            if (option) {\n                if (option === \"consistent\") {\n                    consistent = true;\n                    minItems = Number.POSITIVE_INFINITY;\n                } else if (option === \"always\" || option.minItems === 0) {\n                    minItems = 0;\n                } else if (option === \"never\") {\n                    minItems = Number.POSITIVE_INFINITY;\n                } else {\n                    multiline = Boolean(option.multiline);\n                    minItems = option.minItems || Number.POSITIVE_INFINITY;\n                }\n            } else {\n                consistent = false;\n                multiline = true;\n                minItems = Number.POSITIVE_INFINITY;\n            }\n\n            return { consistent, multiline, minItems };\n        }\n\n        /**\n         * Normalizes a given option value.\n         * @param {string|Object|undefined} options An option value to parse.\n         * @returns {{ArrayExpression: {multiline: boolean, minItems: number}, ArrayPattern: {multiline: boolean, minItems: number}}} Normalized option object.\n         */\n        function normalizeOptions(options) {\n            const value = normalizeOptionValue(options);\n\n            return { ArrayExpression: value, ArrayPattern: value };\n        }\n\n        /**\n         * Reports that there shouldn't be a linebreak after the first token\n         * @param {ASTNode} node The node to report in the event of an error.\n         * @param {Token} token The token to use for the report.\n         * @returns {void}\n         */\n        function reportNoBeginningLinebreak(node, token) {\n            context.report({\n                node,\n                loc: token.loc,\n                messageId: \"unexpectedOpeningLinebreak\",\n                fix(fixer) {\n                    const nextToken = sourceCode.getTokenAfter(token, { includeComments: true });\n\n                    if (astUtils.isCommentToken(nextToken)) {\n                        return null;\n                    }\n\n                    return fixer.removeRange([token.range[1], nextToken.range[0]]);\n                }\n            });\n        }\n\n        /**\n         * Reports that there shouldn't be a linebreak before the last token\n         * @param {ASTNode} node The node to report in the event of an error.\n         * @param {Token} token The token to use for the report.\n         * @returns {void}\n         */\n        function reportNoEndingLinebreak(node, token) {\n            context.report({\n                node,\n                loc: token.loc,\n                messageId: \"unexpectedClosingLinebreak\",\n                fix(fixer) {\n                    const previousToken = sourceCode.getTokenBefore(token, { includeComments: true });\n\n                    if (astUtils.isCommentToken(previousToken)) {\n                        return null;\n                    }\n\n                    return fixer.removeRange([previousToken.range[1], token.range[0]]);\n                }\n            });\n        }\n\n        /**\n         * Reports that there should be a linebreak after the first token\n         * @param {ASTNode} node The node to report in the event of an error.\n         * @param {Token} token The token to use for the report.\n         * @returns {void}\n         */\n        function reportRequiredBeginningLinebreak(node, token) {\n            context.report({\n                node,\n                loc: token.loc,\n                messageId: \"missingOpeningLinebreak\",\n                fix(fixer) {\n                    return fixer.insertTextAfter(token, \"\\n\");\n                }\n            });\n        }\n\n        /**\n         * Reports that there should be a linebreak before the last token\n         * @param {ASTNode} node The node to report in the event of an error.\n         * @param {Token} token The token to use for the report.\n         * @returns {void}\n         */\n        function reportRequiredEndingLinebreak(node, token) {\n            context.report({\n                node,\n                loc: token.loc,\n                messageId: \"missingClosingLinebreak\",\n                fix(fixer) {\n                    return fixer.insertTextBefore(token, \"\\n\");\n                }\n            });\n        }\n\n        /**\n         * Reports a given node if it violated this rule.\n         * @param {ASTNode} node A node to check. This is an ArrayExpression node or an ArrayPattern node.\n         * @returns {void}\n         */\n        function check(node) {\n            const elements = node.elements;\n            const normalizedOptions = normalizeOptions(context.options[0]);\n            const options = normalizedOptions[node.type];\n            const openBracket = sourceCode.getFirstToken(node);\n            const closeBracket = sourceCode.getLastToken(node);\n            const firstIncComment = sourceCode.getTokenAfter(openBracket, { includeComments: true });\n            const lastIncComment = sourceCode.getTokenBefore(closeBracket, { includeComments: true });\n            const first = sourceCode.getTokenAfter(openBracket);\n            const last = sourceCode.getTokenBefore(closeBracket);\n\n            const needsLinebreaks = (\n                elements.length >= options.minItems ||\n                (\n                    options.multiline &&\n                    elements.length > 0 &&\n                    firstIncComment.loc.start.line !== lastIncComment.loc.end.line\n                ) ||\n                (\n                    elements.length === 0 &&\n                    firstIncComment.type === \"Block\" &&\n                    firstIncComment.loc.start.line !== lastIncComment.loc.end.line &&\n                    firstIncComment === lastIncComment\n                ) ||\n                (\n                    options.consistent &&\n                    openBracket.loc.end.line !== first.loc.start.line\n                )\n            );\n\n            /*\n             * Use tokens or comments to check multiline or not.\n             * But use only tokens to check whether linebreaks are needed.\n             * This allows:\n             *     var arr = [ // eslint-disable-line foo\n             *         'a'\n             *     ]\n             */\n\n            if (needsLinebreaks) {\n                if (astUtils.isTokenOnSameLine(openBracket, first)) {\n                    reportRequiredBeginningLinebreak(node, openBracket);\n                }\n                if (astUtils.isTokenOnSameLine(last, closeBracket)) {\n                    reportRequiredEndingLinebreak(node, closeBracket);\n                }\n            } else {\n                if (!astUtils.isTokenOnSameLine(openBracket, first)) {\n                    reportNoBeginningLinebreak(node, openBracket);\n                }\n                if (!astUtils.isTokenOnSameLine(last, closeBracket)) {\n                    reportNoEndingLinebreak(node, closeBracket);\n                }\n            }\n        }\n\n        //----------------------------------------------------------------------\n        // Public\n        //----------------------------------------------------------------------\n\n        return {\n            ArrayPattern: check,\n            ArrayExpression: check\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}