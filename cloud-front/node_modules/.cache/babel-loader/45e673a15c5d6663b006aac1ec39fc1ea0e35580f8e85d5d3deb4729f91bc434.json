{"ast":null,"code":"/**\n * @fileoverview Rule to flag updates of imported bindings.\n * @author Toru Nagashima <https://github.com/mysticatea>\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\nconst {\n  findVariable\n} = require(\"eslint-utils\");\nconst astUtils = require(\"./utils/ast-utils\");\nconst WellKnownMutationFunctions = {\n  Object: /^(?:assign|definePropert(?:y|ies)|freeze|setPrototypeOf)$/u,\n  Reflect: /^(?:(?:define|delete)Property|set(?:PrototypeOf)?)$/u\n};\n\n/**\n * Check if a given node is LHS of an assignment node.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} `true` if the node is LHS.\n */\nfunction isAssignmentLeft(node) {\n  const {\n    parent\n  } = node;\n  return parent.type === \"AssignmentExpression\" && parent.left === node ||\n  // Destructuring assignments\n  parent.type === \"ArrayPattern\" || parent.type === \"Property\" && parent.value === node && parent.parent.type === \"ObjectPattern\" || parent.type === \"RestElement\" || parent.type === \"AssignmentPattern\" && parent.left === node;\n}\n\n/**\n * Check if a given node is the operand of mutation unary operator.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} `true` if the node is the operand of mutation unary operator.\n */\nfunction isOperandOfMutationUnaryOperator(node) {\n  const argumentNode = node.parent.type === \"ChainExpression\" ? node.parent : node;\n  const {\n    parent\n  } = argumentNode;\n  return parent.type === \"UpdateExpression\" && parent.argument === argumentNode || parent.type === \"UnaryExpression\" && parent.operator === \"delete\" && parent.argument === argumentNode;\n}\n\n/**\n * Check if a given node is the iteration variable of `for-in`/`for-of` syntax.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} `true` if the node is the iteration variable.\n */\nfunction isIterationVariable(node) {\n  const {\n    parent\n  } = node;\n  return parent.type === \"ForInStatement\" && parent.left === node || parent.type === \"ForOfStatement\" && parent.left === node;\n}\n\n/**\n * Check if a given node is at the first argument of a well-known mutation function.\n * - `Object.assign`\n * - `Object.defineProperty`\n * - `Object.defineProperties`\n * - `Object.freeze`\n * - `Object.setPrototypeOf`\n * - `Reflect.defineProperty`\n * - `Reflect.deleteProperty`\n * - `Reflect.set`\n * - `Reflect.setPrototypeOf`\n * @param {ASTNode} node The node to check.\n * @param {Scope} scope A `escope.Scope` object to find variable (whichever).\n * @returns {boolean} `true` if the node is at the first argument of a well-known mutation function.\n */\nfunction isArgumentOfWellKnownMutationFunction(node, scope) {\n  const {\n    parent\n  } = node;\n  if (parent.type !== \"CallExpression\" || parent.arguments[0] !== node) {\n    return false;\n  }\n  const callee = astUtils.skipChainExpression(parent.callee);\n  if (!astUtils.isSpecificMemberAccess(callee, \"Object\", WellKnownMutationFunctions.Object) && !astUtils.isSpecificMemberAccess(callee, \"Reflect\", WellKnownMutationFunctions.Reflect)) {\n    return false;\n  }\n  const variable = findVariable(scope, callee.object);\n  return variable !== null && variable.scope.type === \"global\";\n}\n\n/**\n * Check if the identifier node is placed at to update members.\n * @param {ASTNode} id The Identifier node to check.\n * @param {Scope} scope A `escope.Scope` object to find variable (whichever).\n * @returns {boolean} `true` if the member of `id` was updated.\n */\nfunction isMemberWrite(id, scope) {\n  const {\n    parent\n  } = id;\n  return parent.type === \"MemberExpression\" && parent.object === id && (isAssignmentLeft(parent) || isOperandOfMutationUnaryOperator(parent) || isIterationVariable(parent)) || isArgumentOfWellKnownMutationFunction(id, scope);\n}\n\n/**\n * Get the mutation node.\n * @param {ASTNode} id The Identifier node to get.\n * @returns {ASTNode} The mutation node.\n */\nfunction getWriteNode(id) {\n  let node = id.parent;\n  while (node && node.type !== \"AssignmentExpression\" && node.type !== \"UpdateExpression\" && node.type !== \"UnaryExpression\" && node.type !== \"CallExpression\" && node.type !== \"ForInStatement\" && node.type !== \"ForOfStatement\") {\n    node = node.parent;\n  }\n  return node || id;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow assigning to imported bindings\",\n      category: \"Possible Errors\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-import-assign\"\n    },\n    schema: [],\n    messages: {\n      readonly: \"'{{name}}' is read-only.\",\n      readonlyMember: \"The members of '{{name}}' are read-only.\"\n    }\n  },\n  create(context) {\n    return {\n      ImportDeclaration(node) {\n        const scope = context.getScope();\n        for (const variable of context.getDeclaredVariables(node)) {\n          const shouldCheckMembers = variable.defs.some(d => d.node.type === \"ImportNamespaceSpecifier\");\n          let prevIdNode = null;\n          for (const reference of variable.references) {\n            const idNode = reference.identifier;\n\n            /*\n             * AssignmentPattern (e.g. `[a = 0] = b`) makes two write\n             * references for the same identifier. This should skip\n             * the one of the two in order to prevent redundant reports.\n             */\n            if (idNode === prevIdNode) {\n              continue;\n            }\n            prevIdNode = idNode;\n            if (reference.isWrite()) {\n              context.report({\n                node: getWriteNode(idNode),\n                messageId: \"readonly\",\n                data: {\n                  name: idNode.name\n                }\n              });\n            } else if (shouldCheckMembers && isMemberWrite(idNode, scope)) {\n              context.report({\n                node: getWriteNode(idNode),\n                messageId: \"readonlyMember\",\n                data: {\n                  name: idNode.name\n                }\n              });\n            }\n          }\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["findVariable","require","astUtils","WellKnownMutationFunctions","Object","Reflect","isAssignmentLeft","node","parent","type","left","value","isOperandOfMutationUnaryOperator","argumentNode","argument","operator","isIterationVariable","isArgumentOfWellKnownMutationFunction","scope","arguments","callee","skipChainExpression","isSpecificMemberAccess","variable","object","isMemberWrite","id","getWriteNode","module","exports","meta","docs","description","category","recommended","url","schema","messages","readonly","readonlyMember","create","context","ImportDeclaration","getScope","getDeclaredVariables","shouldCheckMembers","defs","some","d","prevIdNode","reference","references","idNode","identifier","isWrite","report","messageId","data","name"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/no-import-assign.js"],"sourcesContent":["/**\n * @fileoverview Rule to flag updates of imported bindings.\n * @author Toru Nagashima <https://github.com/mysticatea>\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst { findVariable } = require(\"eslint-utils\");\nconst astUtils = require(\"./utils/ast-utils\");\n\nconst WellKnownMutationFunctions = {\n    Object: /^(?:assign|definePropert(?:y|ies)|freeze|setPrototypeOf)$/u,\n    Reflect: /^(?:(?:define|delete)Property|set(?:PrototypeOf)?)$/u\n};\n\n/**\n * Check if a given node is LHS of an assignment node.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} `true` if the node is LHS.\n */\nfunction isAssignmentLeft(node) {\n    const { parent } = node;\n\n    return (\n        (\n            parent.type === \"AssignmentExpression\" &&\n            parent.left === node\n        ) ||\n\n        // Destructuring assignments\n        parent.type === \"ArrayPattern\" ||\n        (\n            parent.type === \"Property\" &&\n            parent.value === node &&\n            parent.parent.type === \"ObjectPattern\"\n        ) ||\n        parent.type === \"RestElement\" ||\n        (\n            parent.type === \"AssignmentPattern\" &&\n            parent.left === node\n        )\n    );\n}\n\n/**\n * Check if a given node is the operand of mutation unary operator.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} `true` if the node is the operand of mutation unary operator.\n */\nfunction isOperandOfMutationUnaryOperator(node) {\n    const argumentNode = node.parent.type === \"ChainExpression\"\n        ? node.parent\n        : node;\n    const { parent } = argumentNode;\n\n    return (\n        (\n            parent.type === \"UpdateExpression\" &&\n            parent.argument === argumentNode\n        ) ||\n        (\n            parent.type === \"UnaryExpression\" &&\n            parent.operator === \"delete\" &&\n            parent.argument === argumentNode\n        )\n    );\n}\n\n/**\n * Check if a given node is the iteration variable of `for-in`/`for-of` syntax.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} `true` if the node is the iteration variable.\n */\nfunction isIterationVariable(node) {\n    const { parent } = node;\n\n    return (\n        (\n            parent.type === \"ForInStatement\" &&\n            parent.left === node\n        ) ||\n        (\n            parent.type === \"ForOfStatement\" &&\n            parent.left === node\n        )\n    );\n}\n\n/**\n * Check if a given node is at the first argument of a well-known mutation function.\n * - `Object.assign`\n * - `Object.defineProperty`\n * - `Object.defineProperties`\n * - `Object.freeze`\n * - `Object.setPrototypeOf`\n * - `Reflect.defineProperty`\n * - `Reflect.deleteProperty`\n * - `Reflect.set`\n * - `Reflect.setPrototypeOf`\n * @param {ASTNode} node The node to check.\n * @param {Scope} scope A `escope.Scope` object to find variable (whichever).\n * @returns {boolean} `true` if the node is at the first argument of a well-known mutation function.\n */\nfunction isArgumentOfWellKnownMutationFunction(node, scope) {\n    const { parent } = node;\n\n    if (parent.type !== \"CallExpression\" || parent.arguments[0] !== node) {\n        return false;\n    }\n    const callee = astUtils.skipChainExpression(parent.callee);\n\n    if (\n        !astUtils.isSpecificMemberAccess(callee, \"Object\", WellKnownMutationFunctions.Object) &&\n        !astUtils.isSpecificMemberAccess(callee, \"Reflect\", WellKnownMutationFunctions.Reflect)\n    ) {\n        return false;\n    }\n    const variable = findVariable(scope, callee.object);\n\n    return variable !== null && variable.scope.type === \"global\";\n}\n\n/**\n * Check if the identifier node is placed at to update members.\n * @param {ASTNode} id The Identifier node to check.\n * @param {Scope} scope A `escope.Scope` object to find variable (whichever).\n * @returns {boolean} `true` if the member of `id` was updated.\n */\nfunction isMemberWrite(id, scope) {\n    const { parent } = id;\n\n    return (\n        (\n            parent.type === \"MemberExpression\" &&\n            parent.object === id &&\n            (\n                isAssignmentLeft(parent) ||\n                isOperandOfMutationUnaryOperator(parent) ||\n                isIterationVariable(parent)\n            )\n        ) ||\n        isArgumentOfWellKnownMutationFunction(id, scope)\n    );\n}\n\n/**\n * Get the mutation node.\n * @param {ASTNode} id The Identifier node to get.\n * @returns {ASTNode} The mutation node.\n */\nfunction getWriteNode(id) {\n    let node = id.parent;\n\n    while (\n        node &&\n        node.type !== \"AssignmentExpression\" &&\n        node.type !== \"UpdateExpression\" &&\n        node.type !== \"UnaryExpression\" &&\n        node.type !== \"CallExpression\" &&\n        node.type !== \"ForInStatement\" &&\n        node.type !== \"ForOfStatement\"\n    ) {\n        node = node.parent;\n    }\n\n    return node || id;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow assigning to imported bindings\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-import-assign\"\n        },\n\n        schema: [],\n\n        messages: {\n            readonly: \"'{{name}}' is read-only.\",\n            readonlyMember: \"The members of '{{name}}' are read-only.\"\n        }\n    },\n\n    create(context) {\n        return {\n            ImportDeclaration(node) {\n                const scope = context.getScope();\n\n                for (const variable of context.getDeclaredVariables(node)) {\n                    const shouldCheckMembers = variable.defs.some(\n                        d => d.node.type === \"ImportNamespaceSpecifier\"\n                    );\n                    let prevIdNode = null;\n\n                    for (const reference of variable.references) {\n                        const idNode = reference.identifier;\n\n                        /*\n                         * AssignmentPattern (e.g. `[a = 0] = b`) makes two write\n                         * references for the same identifier. This should skip\n                         * the one of the two in order to prevent redundant reports.\n                         */\n                        if (idNode === prevIdNode) {\n                            continue;\n                        }\n                        prevIdNode = idNode;\n\n                        if (reference.isWrite()) {\n                            context.report({\n                                node: getWriteNode(idNode),\n                                messageId: \"readonly\",\n                                data: { name: idNode.name }\n                            });\n                        } else if (shouldCheckMembers && isMemberWrite(idNode, scope)) {\n                            context.report({\n                                node: getWriteNode(idNode),\n                                messageId: \"readonlyMember\",\n                                data: { name: idNode.name }\n                            });\n                        }\n                    }\n                }\n            }\n        };\n\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}