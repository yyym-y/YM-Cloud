{"ast":null,"code":"/**\n * @fileoverview Rule to flag use of constructors without capital letters\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst CAPS_ALLOWED = [\"Array\", \"Boolean\", \"Date\", \"Error\", \"Function\", \"Number\", \"Object\", \"RegExp\", \"String\", \"Symbol\", \"BigInt\"];\n\n/**\n * Ensure that if the key is provided, it must be an array.\n * @param {Object} obj Object to check with `key`.\n * @param {string} key Object key to check on `obj`.\n * @param {*} fallback If obj[key] is not present, this will be returned.\n * @returns {string[]} Returns obj[key] if it's an Array, otherwise `fallback`\n */\nfunction checkArray(obj, key, fallback) {\n  /* istanbul ignore if */\n  if (Object.prototype.hasOwnProperty.call(obj, key) && !Array.isArray(obj[key])) {\n    throw new TypeError(`${key}, if provided, must be an Array`);\n  }\n  return obj[key] || fallback;\n}\n\n/**\n * A reducer function to invert an array to an Object mapping the string form of the key, to `true`.\n * @param {Object} map Accumulator object for the reduce.\n * @param {string} key Object key to set to `true`.\n * @returns {Object} Returns the updated Object for further reduction.\n */\nfunction invert(map, key) {\n  map[key] = true;\n  return map;\n}\n\n/**\n * Creates an object with the cap is new exceptions as its keys and true as their values.\n * @param {Object} config Rule configuration\n * @returns {Object} Object with cap is new exceptions.\n */\nfunction calculateCapIsNewExceptions(config) {\n  let capIsNewExceptions = checkArray(config, \"capIsNewExceptions\", CAPS_ALLOWED);\n  if (capIsNewExceptions !== CAPS_ALLOWED) {\n    capIsNewExceptions = capIsNewExceptions.concat(CAPS_ALLOWED);\n  }\n  return capIsNewExceptions.reduce(invert, {});\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require constructor names to begin with a capital letter\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/new-cap\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        newIsCap: {\n          type: \"boolean\",\n          default: true\n        },\n        capIsNew: {\n          type: \"boolean\",\n          default: true\n        },\n        newIsCapExceptions: {\n          type: \"array\",\n          items: {\n            type: \"string\"\n          }\n        },\n        newIsCapExceptionPattern: {\n          type: \"string\"\n        },\n        capIsNewExceptions: {\n          type: \"array\",\n          items: {\n            type: \"string\"\n          }\n        },\n        capIsNewExceptionPattern: {\n          type: \"string\"\n        },\n        properties: {\n          type: \"boolean\",\n          default: true\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      upper: \"A function with a name starting with an uppercase letter should only be used as a constructor.\",\n      lower: \"A constructor name should not start with a lowercase letter.\"\n    }\n  },\n  create(context) {\n    const config = Object.assign({}, context.options[0]);\n    config.newIsCap = config.newIsCap !== false;\n    config.capIsNew = config.capIsNew !== false;\n    const skipProperties = config.properties === false;\n    const newIsCapExceptions = checkArray(config, \"newIsCapExceptions\", []).reduce(invert, {});\n    const newIsCapExceptionPattern = config.newIsCapExceptionPattern ? new RegExp(config.newIsCapExceptionPattern, \"u\") : null;\n    const capIsNewExceptions = calculateCapIsNewExceptions(config);\n    const capIsNewExceptionPattern = config.capIsNewExceptionPattern ? new RegExp(config.capIsNewExceptionPattern, \"u\") : null;\n    const listeners = {};\n    const sourceCode = context.getSourceCode();\n\n    //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    /**\n     * Get exact callee name from expression\n     * @param {ASTNode} node CallExpression or NewExpression node\n     * @returns {string} name\n     */\n    function extractNameFromExpression(node) {\n      return node.callee.type === \"Identifier\" ? node.callee.name : astUtils.getStaticPropertyName(node.callee) || \"\";\n    }\n\n    /**\n     * Returns the capitalization state of the string -\n     * Whether the first character is uppercase, lowercase, or non-alphabetic\n     * @param {string} str String\n     * @returns {string} capitalization state: \"non-alpha\", \"lower\", or \"upper\"\n     */\n    function getCap(str) {\n      const firstChar = str.charAt(0);\n      const firstCharLower = firstChar.toLowerCase();\n      const firstCharUpper = firstChar.toUpperCase();\n      if (firstCharLower === firstCharUpper) {\n        // char has no uppercase variant, so it's non-alphabetic\n        return \"non-alpha\";\n      }\n      if (firstChar === firstCharLower) {\n        return \"lower\";\n      }\n      return \"upper\";\n    }\n\n    /**\n     * Check if capitalization is allowed for a CallExpression\n     * @param {Object} allowedMap Object mapping calleeName to a Boolean\n     * @param {ASTNode} node CallExpression node\n     * @param {string} calleeName Capitalized callee name from a CallExpression\n     * @param {Object} pattern RegExp object from options pattern\n     * @returns {boolean} Returns true if the callee may be capitalized\n     */\n    function isCapAllowed(allowedMap, node, calleeName, pattern) {\n      const sourceText = sourceCode.getText(node.callee);\n      if (allowedMap[calleeName] || allowedMap[sourceText]) {\n        return true;\n      }\n      if (pattern && pattern.test(sourceText)) {\n        return true;\n      }\n      const callee = astUtils.skipChainExpression(node.callee);\n      if (calleeName === \"UTC\" && callee.type === \"MemberExpression\") {\n        // allow if callee is Date.UTC\n        return callee.object.type === \"Identifier\" && callee.object.name === \"Date\";\n      }\n      return skipProperties && callee.type === \"MemberExpression\";\n    }\n\n    /**\n     * Reports the given messageId for the given node. The location will be the start of the property or the callee.\n     * @param {ASTNode} node CallExpression or NewExpression node.\n     * @param {string} messageId The messageId to report.\n     * @returns {void}\n     */\n    function report(node, messageId) {\n      let callee = astUtils.skipChainExpression(node.callee);\n      if (callee.type === \"MemberExpression\") {\n        callee = callee.property;\n      }\n      context.report({\n        node,\n        loc: callee.loc,\n        messageId\n      });\n    }\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    if (config.newIsCap) {\n      listeners.NewExpression = function (node) {\n        const constructorName = extractNameFromExpression(node);\n        if (constructorName) {\n          const capitalization = getCap(constructorName);\n          const isAllowed = capitalization !== \"lower\" || isCapAllowed(newIsCapExceptions, node, constructorName, newIsCapExceptionPattern);\n          if (!isAllowed) {\n            report(node, \"lower\");\n          }\n        }\n      };\n    }\n    if (config.capIsNew) {\n      listeners.CallExpression = function (node) {\n        const calleeName = extractNameFromExpression(node);\n        if (calleeName) {\n          const capitalization = getCap(calleeName);\n          const isAllowed = capitalization !== \"upper\" || isCapAllowed(capIsNewExceptions, node, calleeName, capIsNewExceptionPattern);\n          if (!isAllowed) {\n            report(node, \"upper\");\n          }\n        }\n      };\n    }\n    return listeners;\n  }\n};","map":{"version":3,"names":["astUtils","require","CAPS_ALLOWED","checkArray","obj","key","fallback","Object","prototype","hasOwnProperty","call","Array","isArray","TypeError","invert","map","calculateCapIsNewExceptions","config","capIsNewExceptions","concat","reduce","module","exports","meta","type","docs","description","category","recommended","url","schema","properties","newIsCap","default","capIsNew","newIsCapExceptions","items","newIsCapExceptionPattern","capIsNewExceptionPattern","additionalProperties","messages","upper","lower","create","context","assign","options","skipProperties","RegExp","listeners","sourceCode","getSourceCode","extractNameFromExpression","node","callee","name","getStaticPropertyName","getCap","str","firstChar","charAt","firstCharLower","toLowerCase","firstCharUpper","toUpperCase","isCapAllowed","allowedMap","calleeName","pattern","sourceText","getText","test","skipChainExpression","object","report","messageId","property","loc","NewExpression","constructorName","capitalization","isAllowed","CallExpression"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/new-cap.js"],"sourcesContent":["/**\n * @fileoverview Rule to flag use of constructors without capital letters\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst CAPS_ALLOWED = [\n    \"Array\",\n    \"Boolean\",\n    \"Date\",\n    \"Error\",\n    \"Function\",\n    \"Number\",\n    \"Object\",\n    \"RegExp\",\n    \"String\",\n    \"Symbol\",\n    \"BigInt\"\n];\n\n/**\n * Ensure that if the key is provided, it must be an array.\n * @param {Object} obj Object to check with `key`.\n * @param {string} key Object key to check on `obj`.\n * @param {*} fallback If obj[key] is not present, this will be returned.\n * @returns {string[]} Returns obj[key] if it's an Array, otherwise `fallback`\n */\nfunction checkArray(obj, key, fallback) {\n\n    /* istanbul ignore if */\n    if (Object.prototype.hasOwnProperty.call(obj, key) && !Array.isArray(obj[key])) {\n        throw new TypeError(`${key}, if provided, must be an Array`);\n    }\n    return obj[key] || fallback;\n}\n\n/**\n * A reducer function to invert an array to an Object mapping the string form of the key, to `true`.\n * @param {Object} map Accumulator object for the reduce.\n * @param {string} key Object key to set to `true`.\n * @returns {Object} Returns the updated Object for further reduction.\n */\nfunction invert(map, key) {\n    map[key] = true;\n    return map;\n}\n\n/**\n * Creates an object with the cap is new exceptions as its keys and true as their values.\n * @param {Object} config Rule configuration\n * @returns {Object} Object with cap is new exceptions.\n */\nfunction calculateCapIsNewExceptions(config) {\n    let capIsNewExceptions = checkArray(config, \"capIsNewExceptions\", CAPS_ALLOWED);\n\n    if (capIsNewExceptions !== CAPS_ALLOWED) {\n        capIsNewExceptions = capIsNewExceptions.concat(CAPS_ALLOWED);\n    }\n\n    return capIsNewExceptions.reduce(invert, {});\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require constructor names to begin with a capital letter\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/new-cap\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    newIsCap: {\n                        type: \"boolean\",\n                        default: true\n                    },\n                    capIsNew: {\n                        type: \"boolean\",\n                        default: true\n                    },\n                    newIsCapExceptions: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        }\n                    },\n                    newIsCapExceptionPattern: {\n                        type: \"string\"\n                    },\n                    capIsNewExceptions: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        }\n                    },\n                    capIsNewExceptionPattern: {\n                        type: \"string\"\n                    },\n                    properties: {\n                        type: \"boolean\",\n                        default: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n        messages: {\n            upper: \"A function with a name starting with an uppercase letter should only be used as a constructor.\",\n            lower: \"A constructor name should not start with a lowercase letter.\"\n        }\n    },\n\n    create(context) {\n\n        const config = Object.assign({}, context.options[0]);\n\n        config.newIsCap = config.newIsCap !== false;\n        config.capIsNew = config.capIsNew !== false;\n        const skipProperties = config.properties === false;\n\n        const newIsCapExceptions = checkArray(config, \"newIsCapExceptions\", []).reduce(invert, {});\n        const newIsCapExceptionPattern = config.newIsCapExceptionPattern ? new RegExp(config.newIsCapExceptionPattern, \"u\") : null;\n\n        const capIsNewExceptions = calculateCapIsNewExceptions(config);\n        const capIsNewExceptionPattern = config.capIsNewExceptionPattern ? new RegExp(config.capIsNewExceptionPattern, \"u\") : null;\n\n        const listeners = {};\n\n        const sourceCode = context.getSourceCode();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Get exact callee name from expression\n         * @param {ASTNode} node CallExpression or NewExpression node\n         * @returns {string} name\n         */\n        function extractNameFromExpression(node) {\n            return node.callee.type === \"Identifier\"\n                ? node.callee.name\n                : astUtils.getStaticPropertyName(node.callee) || \"\";\n        }\n\n        /**\n         * Returns the capitalization state of the string -\n         * Whether the first character is uppercase, lowercase, or non-alphabetic\n         * @param {string} str String\n         * @returns {string} capitalization state: \"non-alpha\", \"lower\", or \"upper\"\n         */\n        function getCap(str) {\n            const firstChar = str.charAt(0);\n\n            const firstCharLower = firstChar.toLowerCase();\n            const firstCharUpper = firstChar.toUpperCase();\n\n            if (firstCharLower === firstCharUpper) {\n\n                // char has no uppercase variant, so it's non-alphabetic\n                return \"non-alpha\";\n            }\n            if (firstChar === firstCharLower) {\n                return \"lower\";\n            }\n            return \"upper\";\n\n        }\n\n        /**\n         * Check if capitalization is allowed for a CallExpression\n         * @param {Object} allowedMap Object mapping calleeName to a Boolean\n         * @param {ASTNode} node CallExpression node\n         * @param {string} calleeName Capitalized callee name from a CallExpression\n         * @param {Object} pattern RegExp object from options pattern\n         * @returns {boolean} Returns true if the callee may be capitalized\n         */\n        function isCapAllowed(allowedMap, node, calleeName, pattern) {\n            const sourceText = sourceCode.getText(node.callee);\n\n            if (allowedMap[calleeName] || allowedMap[sourceText]) {\n                return true;\n            }\n\n            if (pattern && pattern.test(sourceText)) {\n                return true;\n            }\n\n            const callee = astUtils.skipChainExpression(node.callee);\n\n            if (calleeName === \"UTC\" && callee.type === \"MemberExpression\") {\n\n                // allow if callee is Date.UTC\n                return callee.object.type === \"Identifier\" &&\n                    callee.object.name === \"Date\";\n            }\n\n            return skipProperties && callee.type === \"MemberExpression\";\n        }\n\n        /**\n         * Reports the given messageId for the given node. The location will be the start of the property or the callee.\n         * @param {ASTNode} node CallExpression or NewExpression node.\n         * @param {string} messageId The messageId to report.\n         * @returns {void}\n         */\n        function report(node, messageId) {\n            let callee = astUtils.skipChainExpression(node.callee);\n\n            if (callee.type === \"MemberExpression\") {\n                callee = callee.property;\n            }\n\n            context.report({ node, loc: callee.loc, messageId });\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        if (config.newIsCap) {\n            listeners.NewExpression = function(node) {\n\n                const constructorName = extractNameFromExpression(node);\n\n                if (constructorName) {\n                    const capitalization = getCap(constructorName);\n                    const isAllowed = capitalization !== \"lower\" || isCapAllowed(newIsCapExceptions, node, constructorName, newIsCapExceptionPattern);\n\n                    if (!isAllowed) {\n                        report(node, \"lower\");\n                    }\n                }\n            };\n        }\n\n        if (config.capIsNew) {\n            listeners.CallExpression = function(node) {\n\n                const calleeName = extractNameFromExpression(node);\n\n                if (calleeName) {\n                    const capitalization = getCap(calleeName);\n                    const isAllowed = capitalization !== \"upper\" || isCapAllowed(capIsNewExceptions, node, calleeName, capIsNewExceptionPattern);\n\n                    if (!isAllowed) {\n                        report(node, \"upper\");\n                    }\n                }\n            };\n        }\n\n        return listeners;\n    }\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA,YAAY;;AAEZ;AACA;AACA;AAEA,MAAMA,QAAQ,GAAGC,OAAO,CAAC,mBAAmB,CAAC;;AAE7C;AACA;AACA;;AAEA,MAAMC,YAAY,GAAG,CACjB,OAAO,EACP,SAAS,EACT,MAAM,EACN,OAAO,EACP,UAAU,EACV,QAAQ,EACR,QAAQ,EACR,QAAQ,EACR,QAAQ,EACR,QAAQ,EACR,QAAQ,CACX;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,UAAUA,CAACC,GAAG,EAAEC,GAAG,EAAEC,QAAQ,EAAE;EAEpC;EACA,IAAIC,MAAM,CAACC,SAAS,CAACC,cAAc,CAACC,IAAI,CAACN,GAAG,EAAEC,GAAG,CAAC,IAAI,CAACM,KAAK,CAACC,OAAO,CAACR,GAAG,CAACC,GAAG,CAAC,CAAC,EAAE;IAC5E,MAAM,IAAIQ,SAAS,CAAE,GAAER,GAAI,iCAAgC,CAAC;EAChE;EACA,OAAOD,GAAG,CAACC,GAAG,CAAC,IAAIC,QAAQ;AAC/B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASQ,MAAMA,CAACC,GAAG,EAAEV,GAAG,EAAE;EACtBU,GAAG,CAACV,GAAG,CAAC,GAAG,IAAI;EACf,OAAOU,GAAG;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASC,2BAA2BA,CAACC,MAAM,EAAE;EACzC,IAAIC,kBAAkB,GAAGf,UAAU,CAACc,MAAM,EAAE,oBAAoB,EAAEf,YAAY,CAAC;EAE/E,IAAIgB,kBAAkB,KAAKhB,YAAY,EAAE;IACrCgB,kBAAkB,GAAGA,kBAAkB,CAACC,MAAM,CAACjB,YAAY,CAAC;EAChE;EAEA,OAAOgB,kBAAkB,CAACE,MAAM,CAACN,MAAM,EAAE,CAAC,CAAC,CAAC;AAChD;;AAEA;AACA;AACA;;AAEAO,MAAM,CAACC,OAAO,GAAG;EACbC,IAAI,EAAE;IACFC,IAAI,EAAE,YAAY;IAElBC,IAAI,EAAE;MACFC,WAAW,EAAE,0DAA0D;MACvEC,QAAQ,EAAE,kBAAkB;MAC5BC,WAAW,EAAE,KAAK;MAClBC,GAAG,EAAE;IACT,CAAC;IAEDC,MAAM,EAAE,CACJ;MACIN,IAAI,EAAE,QAAQ;MACdO,UAAU,EAAE;QACRC,QAAQ,EAAE;UACNR,IAAI,EAAE,SAAS;UACfS,OAAO,EAAE;QACb,CAAC;QACDC,QAAQ,EAAE;UACNV,IAAI,EAAE,SAAS;UACfS,OAAO,EAAE;QACb,CAAC;QACDE,kBAAkB,EAAE;UAChBX,IAAI,EAAE,OAAO;UACbY,KAAK,EAAE;YACHZ,IAAI,EAAE;UACV;QACJ,CAAC;QACDa,wBAAwB,EAAE;UACtBb,IAAI,EAAE;QACV,CAAC;QACDN,kBAAkB,EAAE;UAChBM,IAAI,EAAE,OAAO;UACbY,KAAK,EAAE;YACHZ,IAAI,EAAE;UACV;QACJ,CAAC;QACDc,wBAAwB,EAAE;UACtBd,IAAI,EAAE;QACV,CAAC;QACDO,UAAU,EAAE;UACRP,IAAI,EAAE,SAAS;UACfS,OAAO,EAAE;QACb;MACJ,CAAC;MACDM,oBAAoB,EAAE;IAC1B,CAAC,CACJ;IACDC,QAAQ,EAAE;MACNC,KAAK,EAAE,gGAAgG;MACvGC,KAAK,EAAE;IACX;EACJ,CAAC;EAEDC,MAAMA,CAACC,OAAO,EAAE;IAEZ,MAAM3B,MAAM,GAAGV,MAAM,CAACsC,MAAM,CAAC,CAAC,CAAC,EAAED,OAAO,CAACE,OAAO,CAAC,CAAC,CAAC,CAAC;IAEpD7B,MAAM,CAACe,QAAQ,GAAGf,MAAM,CAACe,QAAQ,KAAK,KAAK;IAC3Cf,MAAM,CAACiB,QAAQ,GAAGjB,MAAM,CAACiB,QAAQ,KAAK,KAAK;IAC3C,MAAMa,cAAc,GAAG9B,MAAM,CAACc,UAAU,KAAK,KAAK;IAElD,MAAMI,kBAAkB,GAAGhC,UAAU,CAACc,MAAM,EAAE,oBAAoB,EAAE,EAAE,CAAC,CAACG,MAAM,CAACN,MAAM,EAAE,CAAC,CAAC,CAAC;IAC1F,MAAMuB,wBAAwB,GAAGpB,MAAM,CAACoB,wBAAwB,GAAG,IAAIW,MAAM,CAAC/B,MAAM,CAACoB,wBAAwB,EAAE,GAAG,CAAC,GAAG,IAAI;IAE1H,MAAMnB,kBAAkB,GAAGF,2BAA2B,CAACC,MAAM,CAAC;IAC9D,MAAMqB,wBAAwB,GAAGrB,MAAM,CAACqB,wBAAwB,GAAG,IAAIU,MAAM,CAAC/B,MAAM,CAACqB,wBAAwB,EAAE,GAAG,CAAC,GAAG,IAAI;IAE1H,MAAMW,SAAS,GAAG,CAAC,CAAC;IAEpB,MAAMC,UAAU,GAAGN,OAAO,CAACO,aAAa,CAAC,CAAC;;IAE1C;IACA;IACA;;IAEA;AACR;AACA;AACA;AACA;IACQ,SAASC,yBAAyBA,CAACC,IAAI,EAAE;MACrC,OAAOA,IAAI,CAACC,MAAM,CAAC9B,IAAI,KAAK,YAAY,GAClC6B,IAAI,CAACC,MAAM,CAACC,IAAI,GAChBvD,QAAQ,CAACwD,qBAAqB,CAACH,IAAI,CAACC,MAAM,CAAC,IAAI,EAAE;IAC3D;;IAEA;AACR;AACA;AACA;AACA;AACA;IACQ,SAASG,MAAMA,CAACC,GAAG,EAAE;MACjB,MAAMC,SAAS,GAAGD,GAAG,CAACE,MAAM,CAAC,CAAC,CAAC;MAE/B,MAAMC,cAAc,GAAGF,SAAS,CAACG,WAAW,CAAC,CAAC;MAC9C,MAAMC,cAAc,GAAGJ,SAAS,CAACK,WAAW,CAAC,CAAC;MAE9C,IAAIH,cAAc,KAAKE,cAAc,EAAE;QAEnC;QACA,OAAO,WAAW;MACtB;MACA,IAAIJ,SAAS,KAAKE,cAAc,EAAE;QAC9B,OAAO,OAAO;MAClB;MACA,OAAO,OAAO;IAElB;;IAEA;AACR;AACA;AACA;AACA;AACA;AACA;AACA;IACQ,SAASI,YAAYA,CAACC,UAAU,EAAEb,IAAI,EAAEc,UAAU,EAAEC,OAAO,EAAE;MACzD,MAAMC,UAAU,GAAGnB,UAAU,CAACoB,OAAO,CAACjB,IAAI,CAACC,MAAM,CAAC;MAElD,IAAIY,UAAU,CAACC,UAAU,CAAC,IAAID,UAAU,CAACG,UAAU,CAAC,EAAE;QAClD,OAAO,IAAI;MACf;MAEA,IAAID,OAAO,IAAIA,OAAO,CAACG,IAAI,CAACF,UAAU,CAAC,EAAE;QACrC,OAAO,IAAI;MACf;MAEA,MAAMf,MAAM,GAAGtD,QAAQ,CAACwE,mBAAmB,CAACnB,IAAI,CAACC,MAAM,CAAC;MAExD,IAAIa,UAAU,KAAK,KAAK,IAAIb,MAAM,CAAC9B,IAAI,KAAK,kBAAkB,EAAE;QAE5D;QACA,OAAO8B,MAAM,CAACmB,MAAM,CAACjD,IAAI,KAAK,YAAY,IACtC8B,MAAM,CAACmB,MAAM,CAAClB,IAAI,KAAK,MAAM;MACrC;MAEA,OAAOR,cAAc,IAAIO,MAAM,CAAC9B,IAAI,KAAK,kBAAkB;IAC/D;;IAEA;AACR;AACA;AACA;AACA;AACA;IACQ,SAASkD,MAAMA,CAACrB,IAAI,EAAEsB,SAAS,EAAE;MAC7B,IAAIrB,MAAM,GAAGtD,QAAQ,CAACwE,mBAAmB,CAACnB,IAAI,CAACC,MAAM,CAAC;MAEtD,IAAIA,MAAM,CAAC9B,IAAI,KAAK,kBAAkB,EAAE;QACpC8B,MAAM,GAAGA,MAAM,CAACsB,QAAQ;MAC5B;MAEAhC,OAAO,CAAC8B,MAAM,CAAC;QAAErB,IAAI;QAAEwB,GAAG,EAAEvB,MAAM,CAACuB,GAAG;QAAEF;MAAU,CAAC,CAAC;IACxD;;IAEA;IACA;IACA;;IAEA,IAAI1D,MAAM,CAACe,QAAQ,EAAE;MACjBiB,SAAS,CAAC6B,aAAa,GAAG,UAASzB,IAAI,EAAE;QAErC,MAAM0B,eAAe,GAAG3B,yBAAyB,CAACC,IAAI,CAAC;QAEvD,IAAI0B,eAAe,EAAE;UACjB,MAAMC,cAAc,GAAGvB,MAAM,CAACsB,eAAe,CAAC;UAC9C,MAAME,SAAS,GAAGD,cAAc,KAAK,OAAO,IAAIf,YAAY,CAAC9B,kBAAkB,EAAEkB,IAAI,EAAE0B,eAAe,EAAE1C,wBAAwB,CAAC;UAEjI,IAAI,CAAC4C,SAAS,EAAE;YACZP,MAAM,CAACrB,IAAI,EAAE,OAAO,CAAC;UACzB;QACJ;MACJ,CAAC;IACL;IAEA,IAAIpC,MAAM,CAACiB,QAAQ,EAAE;MACjBe,SAAS,CAACiC,cAAc,GAAG,UAAS7B,IAAI,EAAE;QAEtC,MAAMc,UAAU,GAAGf,yBAAyB,CAACC,IAAI,CAAC;QAElD,IAAIc,UAAU,EAAE;UACZ,MAAMa,cAAc,GAAGvB,MAAM,CAACU,UAAU,CAAC;UACzC,MAAMc,SAAS,GAAGD,cAAc,KAAK,OAAO,IAAIf,YAAY,CAAC/C,kBAAkB,EAAEmC,IAAI,EAAEc,UAAU,EAAE7B,wBAAwB,CAAC;UAE5H,IAAI,CAAC2C,SAAS,EAAE;YACZP,MAAM,CAACrB,IAAI,EAAE,OAAO,CAAC;UACzB;QACJ;MACJ,CAAC;IACL;IAEA,OAAOJ,SAAS;EACpB;AACJ,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}