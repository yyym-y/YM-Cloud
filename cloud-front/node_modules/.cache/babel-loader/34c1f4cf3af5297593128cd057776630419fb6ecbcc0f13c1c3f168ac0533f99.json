{"ast":null,"code":"/**\n * @fileoverview Rule to flag declared but unused variables\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nrequire(\"core-js/modules/es.array.push.js\");\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/**\n * Bag of data used for formatting the `unusedVar` lint message.\n * @typedef {Object} UnusedVarMessageData\n * @property {string} varName The name of the unused var.\n * @property {'defined'|'assigned a value'} action Description of the vars state.\n * @property {string} additional Any additional info to be appended at the end.\n */\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow unused variables\",\n      category: \"Variables\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-unused-vars\"\n    },\n    schema: [{\n      oneOf: [{\n        enum: [\"all\", \"local\"]\n      }, {\n        type: \"object\",\n        properties: {\n          vars: {\n            enum: [\"all\", \"local\"]\n          },\n          varsIgnorePattern: {\n            type: \"string\"\n          },\n          args: {\n            enum: [\"all\", \"after-used\", \"none\"]\n          },\n          ignoreRestSiblings: {\n            type: \"boolean\"\n          },\n          argsIgnorePattern: {\n            type: \"string\"\n          },\n          caughtErrors: {\n            enum: [\"all\", \"none\"]\n          },\n          caughtErrorsIgnorePattern: {\n            type: \"string\"\n          }\n        },\n        additionalProperties: false\n      }]\n    }],\n    messages: {\n      unusedVar: \"'{{varName}}' is {{action}} but never used{{additional}}.\"\n    }\n  },\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const REST_PROPERTY_TYPE = /^(?:RestElement|(?:Experimental)?RestProperty)$/u;\n    const config = {\n      vars: \"all\",\n      args: \"after-used\",\n      ignoreRestSiblings: false,\n      caughtErrors: \"none\"\n    };\n    const firstOption = context.options[0];\n    if (firstOption) {\n      if (typeof firstOption === \"string\") {\n        config.vars = firstOption;\n      } else {\n        config.vars = firstOption.vars || config.vars;\n        config.args = firstOption.args || config.args;\n        config.ignoreRestSiblings = firstOption.ignoreRestSiblings || config.ignoreRestSiblings;\n        config.caughtErrors = firstOption.caughtErrors || config.caughtErrors;\n        if (firstOption.varsIgnorePattern) {\n          config.varsIgnorePattern = new RegExp(firstOption.varsIgnorePattern, \"u\");\n        }\n        if (firstOption.argsIgnorePattern) {\n          config.argsIgnorePattern = new RegExp(firstOption.argsIgnorePattern, \"u\");\n        }\n        if (firstOption.caughtErrorsIgnorePattern) {\n          config.caughtErrorsIgnorePattern = new RegExp(firstOption.caughtErrorsIgnorePattern, \"u\");\n        }\n      }\n    }\n\n    /**\n     * Generates the message data about the variable being defined and unused,\n     * including the ignore pattern if configured.\n     * @param {Variable} unusedVar eslint-scope variable object.\n     * @returns {UnusedVarMessageData} The message data to be used with this unused variable.\n     */\n    function getDefinedMessageData(unusedVar) {\n      const defType = unusedVar.defs && unusedVar.defs[0] && unusedVar.defs[0].type;\n      let type;\n      let pattern;\n      if (defType === \"CatchClause\" && config.caughtErrorsIgnorePattern) {\n        type = \"args\";\n        pattern = config.caughtErrorsIgnorePattern.toString();\n      } else if (defType === \"Parameter\" && config.argsIgnorePattern) {\n        type = \"args\";\n        pattern = config.argsIgnorePattern.toString();\n      } else if (defType !== \"Parameter\" && config.varsIgnorePattern) {\n        type = \"vars\";\n        pattern = config.varsIgnorePattern.toString();\n      }\n      const additional = type ? `. Allowed unused ${type} must match ${pattern}` : \"\";\n      return {\n        varName: unusedVar.name,\n        action: \"defined\",\n        additional\n      };\n    }\n\n    /**\n     * Generate the warning message about the variable being\n     * assigned and unused, including the ignore pattern if configured.\n     * @param {Variable} unusedVar eslint-scope variable object.\n     * @returns {UnusedVarMessageData} The message data to be used with this unused variable.\n     */\n    function getAssignedMessageData(unusedVar) {\n      const additional = config.varsIgnorePattern ? `. Allowed unused vars must match ${config.varsIgnorePattern.toString()}` : \"\";\n      return {\n        varName: unusedVar.name,\n        action: \"assigned a value\",\n        additional\n      };\n    }\n\n    //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    const STATEMENT_TYPE = /(?:Statement|Declaration)$/u;\n\n    /**\n     * Determines if a given variable is being exported from a module.\n     * @param {Variable} variable eslint-scope variable object.\n     * @returns {boolean} True if the variable is exported, false if not.\n     * @private\n     */\n    function isExported(variable) {\n      const definition = variable.defs[0];\n      if (definition) {\n        let node = definition.node;\n        if (node.type === \"VariableDeclarator\") {\n          node = node.parent;\n        } else if (definition.type === \"Parameter\") {\n          return false;\n        }\n        return node.parent.type.indexOf(\"Export\") === 0;\n      }\n      return false;\n    }\n\n    /**\n     * Checks whether a node is a sibling of the rest property or not.\n     * @param {ASTNode} node a node to check\n     * @returns {boolean} True if the node is a sibling of the rest property, otherwise false.\n     */\n    function hasRestSibling(node) {\n      return node.type === \"Property\" && node.parent.type === \"ObjectPattern\" && REST_PROPERTY_TYPE.test(node.parent.properties[node.parent.properties.length - 1].type);\n    }\n\n    /**\n     * Determines if a variable has a sibling rest property\n     * @param {Variable} variable eslint-scope variable object.\n     * @returns {boolean} True if the variable is exported, false if not.\n     * @private\n     */\n    function hasRestSpreadSibling(variable) {\n      if (config.ignoreRestSiblings) {\n        const hasRestSiblingDefinition = variable.defs.some(def => hasRestSibling(def.name.parent));\n        const hasRestSiblingReference = variable.references.some(ref => hasRestSibling(ref.identifier.parent));\n        return hasRestSiblingDefinition || hasRestSiblingReference;\n      }\n      return false;\n    }\n\n    /**\n     * Determines if a reference is a read operation.\n     * @param {Reference} ref An eslint-scope Reference\n     * @returns {boolean} whether the given reference represents a read operation\n     * @private\n     */\n    function isReadRef(ref) {\n      return ref.isRead();\n    }\n\n    /**\n     * Determine if an identifier is referencing an enclosing function name.\n     * @param {Reference} ref The reference to check.\n     * @param {ASTNode[]} nodes The candidate function nodes.\n     * @returns {boolean} True if it's a self-reference, false if not.\n     * @private\n     */\n    function isSelfReference(ref, nodes) {\n      let scope = ref.from;\n      while (scope) {\n        if (nodes.indexOf(scope.block) >= 0) {\n          return true;\n        }\n        scope = scope.upper;\n      }\n      return false;\n    }\n\n    /**\n     * Gets a list of function definitions for a specified variable.\n     * @param {Variable} variable eslint-scope variable object.\n     * @returns {ASTNode[]} Function nodes.\n     * @private\n     */\n    function getFunctionDefinitions(variable) {\n      const functionDefinitions = [];\n      variable.defs.forEach(def => {\n        const {\n          type,\n          node\n        } = def;\n\n        // FunctionDeclarations\n        if (type === \"FunctionName\") {\n          functionDefinitions.push(node);\n        }\n\n        // FunctionExpressions\n        if (type === \"Variable\" && node.init && (node.init.type === \"FunctionExpression\" || node.init.type === \"ArrowFunctionExpression\")) {\n          functionDefinitions.push(node.init);\n        }\n      });\n      return functionDefinitions;\n    }\n\n    /**\n     * Checks the position of given nodes.\n     * @param {ASTNode} inner A node which is expected as inside.\n     * @param {ASTNode} outer A node which is expected as outside.\n     * @returns {boolean} `true` if the `inner` node exists in the `outer` node.\n     * @private\n     */\n    function isInside(inner, outer) {\n      return inner.range[0] >= outer.range[0] && inner.range[1] <= outer.range[1];\n    }\n\n    /**\n     * If a given reference is left-hand side of an assignment, this gets\n     * the right-hand side node of the assignment.\n     *\n     * In the following cases, this returns null.\n     *\n     * - The reference is not the LHS of an assignment expression.\n     * - The reference is inside of a loop.\n     * - The reference is inside of a function scope which is different from\n     *   the declaration.\n     * @param {eslint-scope.Reference} ref A reference to check.\n     * @param {ASTNode} prevRhsNode The previous RHS node.\n     * @returns {ASTNode|null} The RHS node or null.\n     * @private\n     */\n    function getRhsNode(ref, prevRhsNode) {\n      const id = ref.identifier;\n      const parent = id.parent;\n      const grandparent = parent.parent;\n      const refScope = ref.from.variableScope;\n      const varScope = ref.resolved.scope.variableScope;\n      const canBeUsedLater = refScope !== varScope || astUtils.isInLoop(id);\n\n      /*\n       * Inherits the previous node if this reference is in the node.\n       * This is for `a = a + a`-like code.\n       */\n      if (prevRhsNode && isInside(id, prevRhsNode)) {\n        return prevRhsNode;\n      }\n      if (parent.type === \"AssignmentExpression\" && grandparent.type === \"ExpressionStatement\" && id === parent.left && !canBeUsedLater) {\n        return parent.right;\n      }\n      return null;\n    }\n\n    /**\n     * Checks whether a given function node is stored to somewhere or not.\n     * If the function node is stored, the function can be used later.\n     * @param {ASTNode} funcNode A function node to check.\n     * @param {ASTNode} rhsNode The RHS node of the previous assignment.\n     * @returns {boolean} `true` if under the following conditions:\n     *      - the funcNode is assigned to a variable.\n     *      - the funcNode is bound as an argument of a function call.\n     *      - the function is bound to a property and the object satisfies above conditions.\n     * @private\n     */\n    function isStorableFunction(funcNode, rhsNode) {\n      let node = funcNode;\n      let parent = funcNode.parent;\n      while (parent && isInside(parent, rhsNode)) {\n        switch (parent.type) {\n          case \"SequenceExpression\":\n            if (parent.expressions[parent.expressions.length - 1] !== node) {\n              return false;\n            }\n            break;\n          case \"CallExpression\":\n          case \"NewExpression\":\n            return parent.callee !== node;\n          case \"AssignmentExpression\":\n          case \"TaggedTemplateExpression\":\n          case \"YieldExpression\":\n            return true;\n          default:\n            if (STATEMENT_TYPE.test(parent.type)) {\n              /*\n               * If it encountered statements, this is a complex pattern.\n               * Since analyzing complex patterns is hard, this returns `true` to avoid false positive.\n               */\n              return true;\n            }\n        }\n        node = parent;\n        parent = parent.parent;\n      }\n      return false;\n    }\n\n    /**\n     * Checks whether a given Identifier node exists inside of a function node which can be used later.\n     *\n     * \"can be used later\" means:\n     * - the function is assigned to a variable.\n     * - the function is bound to a property and the object can be used later.\n     * - the function is bound as an argument of a function call.\n     *\n     * If a reference exists in a function which can be used later, the reference is read when the function is called.\n     * @param {ASTNode} id An Identifier node to check.\n     * @param {ASTNode} rhsNode The RHS node of the previous assignment.\n     * @returns {boolean} `true` if the `id` node exists inside of a function node which can be used later.\n     * @private\n     */\n    function isInsideOfStorableFunction(id, rhsNode) {\n      const funcNode = astUtils.getUpperFunction(id);\n      return funcNode && isInside(funcNode, rhsNode) && isStorableFunction(funcNode, rhsNode);\n    }\n\n    /**\n     * Checks whether a given node is unused expression or not.\n     * @param {ASTNode} node The node itself\n     * @returns {boolean} The node is an unused expression.\n     * @private\n     */\n    function isUnusedExpression(node) {\n      const parent = node.parent;\n      if (parent.type === \"ExpressionStatement\") {\n        return true;\n      }\n      if (parent.type === \"SequenceExpression\") {\n        const isLastExpression = parent.expressions[parent.expressions.length - 1] === node;\n        if (!isLastExpression) {\n          return true;\n        }\n        return isUnusedExpression(parent);\n      }\n      return false;\n    }\n\n    /**\n     * Checks whether a given reference is a read to update itself or not.\n     * @param {eslint-scope.Reference} ref A reference to check.\n     * @param {ASTNode} rhsNode The RHS node of the previous assignment.\n     * @returns {boolean} The reference is a read to update itself.\n     * @private\n     */\n    function isReadForItself(ref, rhsNode) {\n      const id = ref.identifier;\n      const parent = id.parent;\n      return ref.isRead() && (\n      // self update. e.g. `a += 1`, `a++`\n      parent.type === \"AssignmentExpression\" && parent.left === id && isUnusedExpression(parent) || parent.type === \"UpdateExpression\" && isUnusedExpression(parent) ||\n      // in RHS of an assignment for itself. e.g. `a = a + 1`\n\n      rhsNode && isInside(id, rhsNode) && !isInsideOfStorableFunction(id, rhsNode));\n    }\n\n    /**\n     * Determine if an identifier is used either in for-in loops.\n     * @param {Reference} ref The reference to check.\n     * @returns {boolean} whether reference is used in the for-in loops\n     * @private\n     */\n    function isForInRef(ref) {\n      let target = ref.identifier.parent;\n\n      // \"for (var ...) { return; }\"\n      if (target.type === \"VariableDeclarator\") {\n        target = target.parent.parent;\n      }\n      if (target.type !== \"ForInStatement\") {\n        return false;\n      }\n\n      // \"for (...) { return; }\"\n      if (target.body.type === \"BlockStatement\") {\n        target = target.body.body[0];\n\n        // \"for (...) return;\"\n      } else {\n        target = target.body;\n      }\n\n      // For empty loop body\n      if (!target) {\n        return false;\n      }\n      return target.type === \"ReturnStatement\";\n    }\n\n    /**\n     * Determines if the variable is used.\n     * @param {Variable} variable The variable to check.\n     * @returns {boolean} True if the variable is used\n     * @private\n     */\n    function isUsedVariable(variable) {\n      const functionNodes = getFunctionDefinitions(variable),\n        isFunctionDefinition = functionNodes.length > 0;\n      let rhsNode = null;\n      return variable.references.some(ref => {\n        if (isForInRef(ref)) {\n          return true;\n        }\n        const forItself = isReadForItself(ref, rhsNode);\n        rhsNode = getRhsNode(ref, rhsNode);\n        return isReadRef(ref) && !forItself && !(isFunctionDefinition && isSelfReference(ref, functionNodes));\n      });\n    }\n\n    /**\n     * Checks whether the given variable is after the last used parameter.\n     * @param {eslint-scope.Variable} variable The variable to check.\n     * @returns {boolean} `true` if the variable is defined after the last\n     * used parameter.\n     */\n    function isAfterLastUsedArg(variable) {\n      const def = variable.defs[0];\n      const params = context.getDeclaredVariables(def.node);\n      const posteriorParams = params.slice(params.indexOf(variable) + 1);\n\n      // If any used parameters occur after this parameter, do not report.\n      return !posteriorParams.some(v => v.references.length > 0 || v.eslintUsed);\n    }\n\n    /**\n     * Gets an array of variables without read references.\n     * @param {Scope} scope an eslint-scope Scope object.\n     * @param {Variable[]} unusedVars an array that saving result.\n     * @returns {Variable[]} unused variables of the scope and descendant scopes.\n     * @private\n     */\n    function collectUnusedVariables(scope, unusedVars) {\n      const variables = scope.variables;\n      const childScopes = scope.childScopes;\n      let i, l;\n      if (scope.type !== \"global\" || config.vars === \"all\") {\n        for (i = 0, l = variables.length; i < l; ++i) {\n          const variable = variables[i];\n\n          // skip a variable of class itself name in the class scope\n          if (scope.type === \"class\" && scope.block.id === variable.identifiers[0]) {\n            continue;\n          }\n\n          // skip function expression names and variables marked with markVariableAsUsed()\n          if (scope.functionExpressionScope || variable.eslintUsed) {\n            continue;\n          }\n\n          // skip implicit \"arguments\" variable\n          if (scope.type === \"function\" && variable.name === \"arguments\" && variable.identifiers.length === 0) {\n            continue;\n          }\n\n          // explicit global variables don't have definitions.\n          const def = variable.defs[0];\n          if (def) {\n            const type = def.type;\n\n            // skip catch variables\n            if (type === \"CatchClause\") {\n              if (config.caughtErrors === \"none\") {\n                continue;\n              }\n\n              // skip ignored parameters\n              if (config.caughtErrorsIgnorePattern && config.caughtErrorsIgnorePattern.test(def.name.name)) {\n                continue;\n              }\n            }\n            if (type === \"Parameter\") {\n              // skip any setter argument\n              if ((def.node.parent.type === \"Property\" || def.node.parent.type === \"MethodDefinition\") && def.node.parent.kind === \"set\") {\n                continue;\n              }\n\n              // if \"args\" option is \"none\", skip any parameter\n              if (config.args === \"none\") {\n                continue;\n              }\n\n              // skip ignored parameters\n              if (config.argsIgnorePattern && config.argsIgnorePattern.test(def.name.name)) {\n                continue;\n              }\n\n              // if \"args\" option is \"after-used\", skip used variables\n              if (config.args === \"after-used\" && astUtils.isFunction(def.name.parent) && !isAfterLastUsedArg(variable)) {\n                continue;\n              }\n            } else {\n              // skip ignored variables\n              if (config.varsIgnorePattern && config.varsIgnorePattern.test(def.name.name)) {\n                continue;\n              }\n            }\n          }\n          if (!isUsedVariable(variable) && !isExported(variable) && !hasRestSpreadSibling(variable)) {\n            unusedVars.push(variable);\n          }\n        }\n      }\n      for (i = 0, l = childScopes.length; i < l; ++i) {\n        collectUnusedVariables(childScopes[i], unusedVars);\n      }\n      return unusedVars;\n    }\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    return {\n      \"Program:exit\"(programNode) {\n        const unusedVars = collectUnusedVariables(context.getScope(), []);\n        for (let i = 0, l = unusedVars.length; i < l; ++i) {\n          const unusedVar = unusedVars[i];\n\n          // Report the first declaration.\n          if (unusedVar.defs.length > 0) {\n            // report last write reference, https://github.com/eslint/eslint/issues/14324\n            const writeReferences = unusedVar.references.filter(ref => ref.isWrite() && ref.from.variableScope === unusedVar.scope.variableScope);\n            let referenceToReport;\n            if (writeReferences.length > 0) {\n              referenceToReport = writeReferences[writeReferences.length - 1];\n            }\n            context.report({\n              node: referenceToReport ? referenceToReport.identifier : unusedVar.identifiers[0],\n              messageId: \"unusedVar\",\n              data: unusedVar.references.some(ref => ref.isWrite()) ? getAssignedMessageData(unusedVar) : getDefinedMessageData(unusedVar)\n            });\n\n            // If there are no regular declaration, report the first `/*globals*/` comment directive.\n          } else if (unusedVar.eslintExplicitGlobalComments) {\n            const directiveComment = unusedVar.eslintExplicitGlobalComments[0];\n            context.report({\n              node: programNode,\n              loc: astUtils.getNameLocationInGlobalDirectiveComment(sourceCode, directiveComment, unusedVar.name),\n              messageId: \"unusedVar\",\n              data: getDefinedMessageData(unusedVar)\n            });\n          }\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["require","astUtils","module","exports","meta","type","docs","description","category","recommended","url","schema","oneOf","enum","properties","vars","varsIgnorePattern","args","ignoreRestSiblings","argsIgnorePattern","caughtErrors","caughtErrorsIgnorePattern","additionalProperties","messages","unusedVar","create","context","sourceCode","getSourceCode","REST_PROPERTY_TYPE","config","firstOption","options","RegExp","getDefinedMessageData","defType","defs","pattern","toString","additional","varName","name","action","getAssignedMessageData","STATEMENT_TYPE","isExported","variable","definition","node","parent","indexOf","hasRestSibling","test","length","hasRestSpreadSibling","hasRestSiblingDefinition","some","def","hasRestSiblingReference","references","ref","identifier","isReadRef","isRead","isSelfReference","nodes","scope","from","block","upper","getFunctionDefinitions","functionDefinitions","forEach","push","init","isInside","inner","outer","range","getRhsNode","prevRhsNode","id","grandparent","refScope","variableScope","varScope","resolved","canBeUsedLater","isInLoop","left","right","isStorableFunction","funcNode","rhsNode","expressions","callee","isInsideOfStorableFunction","getUpperFunction","isUnusedExpression","isLastExpression","isReadForItself","isForInRef","target","body","isUsedVariable","functionNodes","isFunctionDefinition","forItself","isAfterLastUsedArg","params","getDeclaredVariables","posteriorParams","slice","v","eslintUsed","collectUnusedVariables","unusedVars","variables","childScopes","i","l","identifiers","functionExpressionScope","kind","isFunction","Program:exit","programNode","getScope","writeReferences","filter","isWrite","referenceToReport","report","messageId","data","eslintExplicitGlobalComments","directiveComment","loc","getNameLocationInGlobalDirectiveComment"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/no-unused-vars.js"],"sourcesContent":["/**\n * @fileoverview Rule to flag declared but unused variables\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/**\n * Bag of data used for formatting the `unusedVar` lint message.\n * @typedef {Object} UnusedVarMessageData\n * @property {string} varName The name of the unused var.\n * @property {'defined'|'assigned a value'} action Description of the vars state.\n * @property {string} additional Any additional info to be appended at the end.\n */\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow unused variables\",\n            category: \"Variables\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-unused-vars\"\n        },\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"all\", \"local\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            vars: {\n                                enum: [\"all\", \"local\"]\n                            },\n                            varsIgnorePattern: {\n                                type: \"string\"\n                            },\n                            args: {\n                                enum: [\"all\", \"after-used\", \"none\"]\n                            },\n                            ignoreRestSiblings: {\n                                type: \"boolean\"\n                            },\n                            argsIgnorePattern: {\n                                type: \"string\"\n                            },\n                            caughtErrors: {\n                                enum: [\"all\", \"none\"]\n                            },\n                            caughtErrorsIgnorePattern: {\n                                type: \"string\"\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ],\n\n        messages: {\n            unusedVar: \"'{{varName}}' is {{action}} but never used{{additional}}.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        const REST_PROPERTY_TYPE = /^(?:RestElement|(?:Experimental)?RestProperty)$/u;\n\n        const config = {\n            vars: \"all\",\n            args: \"after-used\",\n            ignoreRestSiblings: false,\n            caughtErrors: \"none\"\n        };\n\n        const firstOption = context.options[0];\n\n        if (firstOption) {\n            if (typeof firstOption === \"string\") {\n                config.vars = firstOption;\n            } else {\n                config.vars = firstOption.vars || config.vars;\n                config.args = firstOption.args || config.args;\n                config.ignoreRestSiblings = firstOption.ignoreRestSiblings || config.ignoreRestSiblings;\n                config.caughtErrors = firstOption.caughtErrors || config.caughtErrors;\n\n                if (firstOption.varsIgnorePattern) {\n                    config.varsIgnorePattern = new RegExp(firstOption.varsIgnorePattern, \"u\");\n                }\n\n                if (firstOption.argsIgnorePattern) {\n                    config.argsIgnorePattern = new RegExp(firstOption.argsIgnorePattern, \"u\");\n                }\n\n                if (firstOption.caughtErrorsIgnorePattern) {\n                    config.caughtErrorsIgnorePattern = new RegExp(firstOption.caughtErrorsIgnorePattern, \"u\");\n                }\n            }\n        }\n\n        /**\n         * Generates the message data about the variable being defined and unused,\n         * including the ignore pattern if configured.\n         * @param {Variable} unusedVar eslint-scope variable object.\n         * @returns {UnusedVarMessageData} The message data to be used with this unused variable.\n         */\n        function getDefinedMessageData(unusedVar) {\n            const defType = unusedVar.defs && unusedVar.defs[0] && unusedVar.defs[0].type;\n            let type;\n            let pattern;\n\n            if (defType === \"CatchClause\" && config.caughtErrorsIgnorePattern) {\n                type = \"args\";\n                pattern = config.caughtErrorsIgnorePattern.toString();\n            } else if (defType === \"Parameter\" && config.argsIgnorePattern) {\n                type = \"args\";\n                pattern = config.argsIgnorePattern.toString();\n            } else if (defType !== \"Parameter\" && config.varsIgnorePattern) {\n                type = \"vars\";\n                pattern = config.varsIgnorePattern.toString();\n            }\n\n            const additional = type ? `. Allowed unused ${type} must match ${pattern}` : \"\";\n\n            return {\n                varName: unusedVar.name,\n                action: \"defined\",\n                additional\n            };\n        }\n\n        /**\n         * Generate the warning message about the variable being\n         * assigned and unused, including the ignore pattern if configured.\n         * @param {Variable} unusedVar eslint-scope variable object.\n         * @returns {UnusedVarMessageData} The message data to be used with this unused variable.\n         */\n        function getAssignedMessageData(unusedVar) {\n            const additional = config.varsIgnorePattern ? `. Allowed unused vars must match ${config.varsIgnorePattern.toString()}` : \"\";\n\n            return {\n                varName: unusedVar.name,\n                action: \"assigned a value\",\n                additional\n            };\n        }\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        const STATEMENT_TYPE = /(?:Statement|Declaration)$/u;\n\n        /**\n         * Determines if a given variable is being exported from a module.\n         * @param {Variable} variable eslint-scope variable object.\n         * @returns {boolean} True if the variable is exported, false if not.\n         * @private\n         */\n        function isExported(variable) {\n\n            const definition = variable.defs[0];\n\n            if (definition) {\n\n                let node = definition.node;\n\n                if (node.type === \"VariableDeclarator\") {\n                    node = node.parent;\n                } else if (definition.type === \"Parameter\") {\n                    return false;\n                }\n\n                return node.parent.type.indexOf(\"Export\") === 0;\n            }\n            return false;\n\n        }\n\n        /**\n         * Checks whether a node is a sibling of the rest property or not.\n         * @param {ASTNode} node a node to check\n         * @returns {boolean} True if the node is a sibling of the rest property, otherwise false.\n         */\n        function hasRestSibling(node) {\n            return node.type === \"Property\" &&\n                node.parent.type === \"ObjectPattern\" &&\n                REST_PROPERTY_TYPE.test(node.parent.properties[node.parent.properties.length - 1].type);\n        }\n\n        /**\n         * Determines if a variable has a sibling rest property\n         * @param {Variable} variable eslint-scope variable object.\n         * @returns {boolean} True if the variable is exported, false if not.\n         * @private\n         */\n        function hasRestSpreadSibling(variable) {\n            if (config.ignoreRestSiblings) {\n                const hasRestSiblingDefinition = variable.defs.some(def => hasRestSibling(def.name.parent));\n                const hasRestSiblingReference = variable.references.some(ref => hasRestSibling(ref.identifier.parent));\n\n                return hasRestSiblingDefinition || hasRestSiblingReference;\n            }\n\n            return false;\n        }\n\n        /**\n         * Determines if a reference is a read operation.\n         * @param {Reference} ref An eslint-scope Reference\n         * @returns {boolean} whether the given reference represents a read operation\n         * @private\n         */\n        function isReadRef(ref) {\n            return ref.isRead();\n        }\n\n        /**\n         * Determine if an identifier is referencing an enclosing function name.\n         * @param {Reference} ref The reference to check.\n         * @param {ASTNode[]} nodes The candidate function nodes.\n         * @returns {boolean} True if it's a self-reference, false if not.\n         * @private\n         */\n        function isSelfReference(ref, nodes) {\n            let scope = ref.from;\n\n            while (scope) {\n                if (nodes.indexOf(scope.block) >= 0) {\n                    return true;\n                }\n\n                scope = scope.upper;\n            }\n\n            return false;\n        }\n\n        /**\n         * Gets a list of function definitions for a specified variable.\n         * @param {Variable} variable eslint-scope variable object.\n         * @returns {ASTNode[]} Function nodes.\n         * @private\n         */\n        function getFunctionDefinitions(variable) {\n            const functionDefinitions = [];\n\n            variable.defs.forEach(def => {\n                const { type, node } = def;\n\n                // FunctionDeclarations\n                if (type === \"FunctionName\") {\n                    functionDefinitions.push(node);\n                }\n\n                // FunctionExpressions\n                if (type === \"Variable\" && node.init &&\n                    (node.init.type === \"FunctionExpression\" || node.init.type === \"ArrowFunctionExpression\")) {\n                    functionDefinitions.push(node.init);\n                }\n            });\n            return functionDefinitions;\n        }\n\n        /**\n         * Checks the position of given nodes.\n         * @param {ASTNode} inner A node which is expected as inside.\n         * @param {ASTNode} outer A node which is expected as outside.\n         * @returns {boolean} `true` if the `inner` node exists in the `outer` node.\n         * @private\n         */\n        function isInside(inner, outer) {\n            return (\n                inner.range[0] >= outer.range[0] &&\n                inner.range[1] <= outer.range[1]\n            );\n        }\n\n        /**\n         * If a given reference is left-hand side of an assignment, this gets\n         * the right-hand side node of the assignment.\n         *\n         * In the following cases, this returns null.\n         *\n         * - The reference is not the LHS of an assignment expression.\n         * - The reference is inside of a loop.\n         * - The reference is inside of a function scope which is different from\n         *   the declaration.\n         * @param {eslint-scope.Reference} ref A reference to check.\n         * @param {ASTNode} prevRhsNode The previous RHS node.\n         * @returns {ASTNode|null} The RHS node or null.\n         * @private\n         */\n        function getRhsNode(ref, prevRhsNode) {\n            const id = ref.identifier;\n            const parent = id.parent;\n            const grandparent = parent.parent;\n            const refScope = ref.from.variableScope;\n            const varScope = ref.resolved.scope.variableScope;\n            const canBeUsedLater = refScope !== varScope || astUtils.isInLoop(id);\n\n            /*\n             * Inherits the previous node if this reference is in the node.\n             * This is for `a = a + a`-like code.\n             */\n            if (prevRhsNode && isInside(id, prevRhsNode)) {\n                return prevRhsNode;\n            }\n\n            if (parent.type === \"AssignmentExpression\" &&\n                grandparent.type === \"ExpressionStatement\" &&\n                id === parent.left &&\n                !canBeUsedLater\n            ) {\n                return parent.right;\n            }\n            return null;\n        }\n\n        /**\n         * Checks whether a given function node is stored to somewhere or not.\n         * If the function node is stored, the function can be used later.\n         * @param {ASTNode} funcNode A function node to check.\n         * @param {ASTNode} rhsNode The RHS node of the previous assignment.\n         * @returns {boolean} `true` if under the following conditions:\n         *      - the funcNode is assigned to a variable.\n         *      - the funcNode is bound as an argument of a function call.\n         *      - the function is bound to a property and the object satisfies above conditions.\n         * @private\n         */\n        function isStorableFunction(funcNode, rhsNode) {\n            let node = funcNode;\n            let parent = funcNode.parent;\n\n            while (parent && isInside(parent, rhsNode)) {\n                switch (parent.type) {\n                    case \"SequenceExpression\":\n                        if (parent.expressions[parent.expressions.length - 1] !== node) {\n                            return false;\n                        }\n                        break;\n\n                    case \"CallExpression\":\n                    case \"NewExpression\":\n                        return parent.callee !== node;\n\n                    case \"AssignmentExpression\":\n                    case \"TaggedTemplateExpression\":\n                    case \"YieldExpression\":\n                        return true;\n\n                    default:\n                        if (STATEMENT_TYPE.test(parent.type)) {\n\n                            /*\n                             * If it encountered statements, this is a complex pattern.\n                             * Since analyzing complex patterns is hard, this returns `true` to avoid false positive.\n                             */\n                            return true;\n                        }\n                }\n\n                node = parent;\n                parent = parent.parent;\n            }\n\n            return false;\n        }\n\n        /**\n         * Checks whether a given Identifier node exists inside of a function node which can be used later.\n         *\n         * \"can be used later\" means:\n         * - the function is assigned to a variable.\n         * - the function is bound to a property and the object can be used later.\n         * - the function is bound as an argument of a function call.\n         *\n         * If a reference exists in a function which can be used later, the reference is read when the function is called.\n         * @param {ASTNode} id An Identifier node to check.\n         * @param {ASTNode} rhsNode The RHS node of the previous assignment.\n         * @returns {boolean} `true` if the `id` node exists inside of a function node which can be used later.\n         * @private\n         */\n        function isInsideOfStorableFunction(id, rhsNode) {\n            const funcNode = astUtils.getUpperFunction(id);\n\n            return (\n                funcNode &&\n                isInside(funcNode, rhsNode) &&\n                isStorableFunction(funcNode, rhsNode)\n            );\n        }\n\n        /**\n         * Checks whether a given node is unused expression or not.\n         * @param {ASTNode} node The node itself\n         * @returns {boolean} The node is an unused expression.\n         * @private\n         */\n        function isUnusedExpression(node) {\n            const parent = node.parent;\n\n            if (parent.type === \"ExpressionStatement\") {\n                return true;\n            }\n\n            if (parent.type === \"SequenceExpression\") {\n                const isLastExpression = parent.expressions[parent.expressions.length - 1] === node;\n\n                if (!isLastExpression) {\n                    return true;\n                }\n                return isUnusedExpression(parent);\n            }\n\n            return false;\n        }\n\n        /**\n         * Checks whether a given reference is a read to update itself or not.\n         * @param {eslint-scope.Reference} ref A reference to check.\n         * @param {ASTNode} rhsNode The RHS node of the previous assignment.\n         * @returns {boolean} The reference is a read to update itself.\n         * @private\n         */\n        function isReadForItself(ref, rhsNode) {\n            const id = ref.identifier;\n            const parent = id.parent;\n\n            return ref.isRead() && (\n\n                // self update. e.g. `a += 1`, `a++`\n                (\n                    (\n                        parent.type === \"AssignmentExpression\" &&\n                        parent.left === id &&\n                        isUnusedExpression(parent)\n                    ) ||\n                    (\n                        parent.type === \"UpdateExpression\" &&\n                        isUnusedExpression(parent)\n                    )\n                ) ||\n\n                // in RHS of an assignment for itself. e.g. `a = a + 1`\n                (\n                    rhsNode &&\n                    isInside(id, rhsNode) &&\n                    !isInsideOfStorableFunction(id, rhsNode)\n                )\n            );\n        }\n\n        /**\n         * Determine if an identifier is used either in for-in loops.\n         * @param {Reference} ref The reference to check.\n         * @returns {boolean} whether reference is used in the for-in loops\n         * @private\n         */\n        function isForInRef(ref) {\n            let target = ref.identifier.parent;\n\n\n            // \"for (var ...) { return; }\"\n            if (target.type === \"VariableDeclarator\") {\n                target = target.parent.parent;\n            }\n\n            if (target.type !== \"ForInStatement\") {\n                return false;\n            }\n\n            // \"for (...) { return; }\"\n            if (target.body.type === \"BlockStatement\") {\n                target = target.body.body[0];\n\n            // \"for (...) return;\"\n            } else {\n                target = target.body;\n            }\n\n            // For empty loop body\n            if (!target) {\n                return false;\n            }\n\n            return target.type === \"ReturnStatement\";\n        }\n\n        /**\n         * Determines if the variable is used.\n         * @param {Variable} variable The variable to check.\n         * @returns {boolean} True if the variable is used\n         * @private\n         */\n        function isUsedVariable(variable) {\n            const functionNodes = getFunctionDefinitions(variable),\n                isFunctionDefinition = functionNodes.length > 0;\n            let rhsNode = null;\n\n            return variable.references.some(ref => {\n                if (isForInRef(ref)) {\n                    return true;\n                }\n\n                const forItself = isReadForItself(ref, rhsNode);\n\n                rhsNode = getRhsNode(ref, rhsNode);\n\n                return (\n                    isReadRef(ref) &&\n                    !forItself &&\n                    !(isFunctionDefinition && isSelfReference(ref, functionNodes))\n                );\n            });\n        }\n\n        /**\n         * Checks whether the given variable is after the last used parameter.\n         * @param {eslint-scope.Variable} variable The variable to check.\n         * @returns {boolean} `true` if the variable is defined after the last\n         * used parameter.\n         */\n        function isAfterLastUsedArg(variable) {\n            const def = variable.defs[0];\n            const params = context.getDeclaredVariables(def.node);\n            const posteriorParams = params.slice(params.indexOf(variable) + 1);\n\n            // If any used parameters occur after this parameter, do not report.\n            return !posteriorParams.some(v => v.references.length > 0 || v.eslintUsed);\n        }\n\n        /**\n         * Gets an array of variables without read references.\n         * @param {Scope} scope an eslint-scope Scope object.\n         * @param {Variable[]} unusedVars an array that saving result.\n         * @returns {Variable[]} unused variables of the scope and descendant scopes.\n         * @private\n         */\n        function collectUnusedVariables(scope, unusedVars) {\n            const variables = scope.variables;\n            const childScopes = scope.childScopes;\n            let i, l;\n\n            if (scope.type !== \"global\" || config.vars === \"all\") {\n                for (i = 0, l = variables.length; i < l; ++i) {\n                    const variable = variables[i];\n\n                    // skip a variable of class itself name in the class scope\n                    if (scope.type === \"class\" && scope.block.id === variable.identifiers[0]) {\n                        continue;\n                    }\n\n                    // skip function expression names and variables marked with markVariableAsUsed()\n                    if (scope.functionExpressionScope || variable.eslintUsed) {\n                        continue;\n                    }\n\n                    // skip implicit \"arguments\" variable\n                    if (scope.type === \"function\" && variable.name === \"arguments\" && variable.identifiers.length === 0) {\n                        continue;\n                    }\n\n                    // explicit global variables don't have definitions.\n                    const def = variable.defs[0];\n\n                    if (def) {\n                        const type = def.type;\n\n                        // skip catch variables\n                        if (type === \"CatchClause\") {\n                            if (config.caughtErrors === \"none\") {\n                                continue;\n                            }\n\n                            // skip ignored parameters\n                            if (config.caughtErrorsIgnorePattern && config.caughtErrorsIgnorePattern.test(def.name.name)) {\n                                continue;\n                            }\n                        }\n\n                        if (type === \"Parameter\") {\n\n                            // skip any setter argument\n                            if ((def.node.parent.type === \"Property\" || def.node.parent.type === \"MethodDefinition\") && def.node.parent.kind === \"set\") {\n                                continue;\n                            }\n\n                            // if \"args\" option is \"none\", skip any parameter\n                            if (config.args === \"none\") {\n                                continue;\n                            }\n\n                            // skip ignored parameters\n                            if (config.argsIgnorePattern && config.argsIgnorePattern.test(def.name.name)) {\n                                continue;\n                            }\n\n                            // if \"args\" option is \"after-used\", skip used variables\n                            if (config.args === \"after-used\" && astUtils.isFunction(def.name.parent) && !isAfterLastUsedArg(variable)) {\n                                continue;\n                            }\n                        } else {\n\n                            // skip ignored variables\n                            if (config.varsIgnorePattern && config.varsIgnorePattern.test(def.name.name)) {\n                                continue;\n                            }\n                        }\n                    }\n\n                    if (!isUsedVariable(variable) && !isExported(variable) && !hasRestSpreadSibling(variable)) {\n                        unusedVars.push(variable);\n                    }\n                }\n            }\n\n            for (i = 0, l = childScopes.length; i < l; ++i) {\n                collectUnusedVariables(childScopes[i], unusedVars);\n            }\n\n            return unusedVars;\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            \"Program:exit\"(programNode) {\n                const unusedVars = collectUnusedVariables(context.getScope(), []);\n\n                for (let i = 0, l = unusedVars.length; i < l; ++i) {\n                    const unusedVar = unusedVars[i];\n\n                    // Report the first declaration.\n                    if (unusedVar.defs.length > 0) {\n\n                        // report last write reference, https://github.com/eslint/eslint/issues/14324\n                        const writeReferences = unusedVar.references.filter(ref => ref.isWrite() && ref.from.variableScope === unusedVar.scope.variableScope);\n\n                        let referenceToReport;\n\n                        if (writeReferences.length > 0) {\n                            referenceToReport = writeReferences[writeReferences.length - 1];\n                        }\n\n                        context.report({\n                            node: referenceToReport ? referenceToReport.identifier : unusedVar.identifiers[0],\n                            messageId: \"unusedVar\",\n                            data: unusedVar.references.some(ref => ref.isWrite())\n                                ? getAssignedMessageData(unusedVar)\n                                : getDefinedMessageData(unusedVar)\n                        });\n\n                    // If there are no regular declaration, report the first `/*globals*/` comment directive.\n                    } else if (unusedVar.eslintExplicitGlobalComments) {\n                        const directiveComment = unusedVar.eslintExplicitGlobalComments[0];\n\n                        context.report({\n                            node: programNode,\n                            loc: astUtils.getNameLocationInGlobalDirectiveComment(sourceCode, directiveComment, unusedVar.name),\n                            messageId: \"unusedVar\",\n                            data: getDefinedMessageData(unusedVar)\n                        });\n                    }\n                }\n            }\n        };\n\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}