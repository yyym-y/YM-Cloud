{"ast":null,"code":"'use strict';\n\nrequire(\"core-js/modules/es.array.push.js\");\nconst XHTMLEntities = require('./xhtml');\nconst hexNumber = /^[\\da-fA-F]+$/;\nconst decimalNumber = /^\\d+$/;\n\n// The map to `acorn-jsx` tokens from `acorn` namespace objects.\nconst acornJsxMap = new WeakMap();\n\n// Get the original tokens for the given `acorn` namespace object.\nfunction getJsxTokens(acorn) {\n  acorn = acorn.Parser.acorn || acorn;\n  let acornJsx = acornJsxMap.get(acorn);\n  if (!acornJsx) {\n    const tt = acorn.tokTypes;\n    const TokContext = acorn.TokContext;\n    const TokenType = acorn.TokenType;\n    const tc_oTag = new TokContext('<tag', false);\n    const tc_cTag = new TokContext('</tag', false);\n    const tc_expr = new TokContext('<tag>...</tag>', true, true);\n    const tokContexts = {\n      tc_oTag: tc_oTag,\n      tc_cTag: tc_cTag,\n      tc_expr: tc_expr\n    };\n    const tokTypes = {\n      jsxName: new TokenType('jsxName'),\n      jsxText: new TokenType('jsxText', {\n        beforeExpr: true\n      }),\n      jsxTagStart: new TokenType('jsxTagStart', {\n        startsExpr: true\n      }),\n      jsxTagEnd: new TokenType('jsxTagEnd')\n    };\n    tokTypes.jsxTagStart.updateContext = function () {\n      this.context.push(tc_expr); // treat as beginning of JSX expression\n      this.context.push(tc_oTag); // start opening tag context\n      this.exprAllowed = false;\n    };\n    tokTypes.jsxTagEnd.updateContext = function (prevType) {\n      let out = this.context.pop();\n      if (out === tc_oTag && prevType === tt.slash || out === tc_cTag) {\n        this.context.pop();\n        this.exprAllowed = this.curContext() === tc_expr;\n      } else {\n        this.exprAllowed = true;\n      }\n    };\n    acornJsx = {\n      tokContexts: tokContexts,\n      tokTypes: tokTypes\n    };\n    acornJsxMap.set(acorn, acornJsx);\n  }\n  return acornJsx;\n}\n\n// Transforms JSX element name to string.\n\nfunction getQualifiedJSXName(object) {\n  if (!object) return object;\n  if (object.type === 'JSXIdentifier') return object.name;\n  if (object.type === 'JSXNamespacedName') return object.namespace.name + ':' + object.name.name;\n  if (object.type === 'JSXMemberExpression') return getQualifiedJSXName(object.object) + '.' + getQualifiedJSXName(object.property);\n}\nmodule.exports = function (options) {\n  options = options || {};\n  return function (Parser) {\n    return plugin({\n      allowNamespaces: options.allowNamespaces !== false,\n      allowNamespacedObjects: !!options.allowNamespacedObjects\n    }, Parser);\n  };\n};\n\n// This is `tokTypes` of the peer dep.\n// This can be different instances from the actual `tokTypes` this plugin uses.\nObject.defineProperty(module.exports, \"tokTypes\", {\n  get: function get_tokTypes() {\n    return getJsxTokens(require(\"acorn\")).tokTypes;\n  },\n  configurable: true,\n  enumerable: true\n});\nfunction plugin(options, Parser) {\n  const acorn = Parser.acorn || require(\"acorn\");\n  const acornJsx = getJsxTokens(acorn);\n  const tt = acorn.tokTypes;\n  const tok = acornJsx.tokTypes;\n  const tokContexts = acorn.tokContexts;\n  const tc_oTag = acornJsx.tokContexts.tc_oTag;\n  const tc_cTag = acornJsx.tokContexts.tc_cTag;\n  const tc_expr = acornJsx.tokContexts.tc_expr;\n  const isNewLine = acorn.isNewLine;\n  const isIdentifierStart = acorn.isIdentifierStart;\n  const isIdentifierChar = acorn.isIdentifierChar;\n  return class extends Parser {\n    // Expose actual `tokTypes` and `tokContexts` to other plugins.\n    static get acornJsx() {\n      return acornJsx;\n    }\n\n    // Reads inline JSX contents token.\n    jsx_readToken() {\n      let out = '',\n        chunkStart = this.pos;\n      for (;;) {\n        if (this.pos >= this.input.length) this.raise(this.start, 'Unterminated JSX contents');\n        let ch = this.input.charCodeAt(this.pos);\n        switch (ch) {\n          case 60: // '<'\n          case 123:\n            // '{'\n            if (this.pos === this.start) {\n              if (ch === 60 && this.exprAllowed) {\n                ++this.pos;\n                return this.finishToken(tok.jsxTagStart);\n              }\n              return this.getTokenFromCode(ch);\n            }\n            out += this.input.slice(chunkStart, this.pos);\n            return this.finishToken(tok.jsxText, out);\n          case 38:\n            // '&'\n            out += this.input.slice(chunkStart, this.pos);\n            out += this.jsx_readEntity();\n            chunkStart = this.pos;\n            break;\n          case 62: // '>'\n          case 125:\n            // '}'\n            this.raise(this.pos, \"Unexpected token `\" + this.input[this.pos] + \"`. Did you mean `\" + (ch === 62 ? \"&gt;\" : \"&rbrace;\") + \"` or \" + \"`{\\\"\" + this.input[this.pos] + \"\\\"}\" + \"`?\");\n          default:\n            if (isNewLine(ch)) {\n              out += this.input.slice(chunkStart, this.pos);\n              out += this.jsx_readNewLine(true);\n              chunkStart = this.pos;\n            } else {\n              ++this.pos;\n            }\n        }\n      }\n    }\n    jsx_readNewLine(normalizeCRLF) {\n      let ch = this.input.charCodeAt(this.pos);\n      let out;\n      ++this.pos;\n      if (ch === 13 && this.input.charCodeAt(this.pos) === 10) {\n        ++this.pos;\n        out = normalizeCRLF ? '\\n' : '\\r\\n';\n      } else {\n        out = String.fromCharCode(ch);\n      }\n      if (this.options.locations) {\n        ++this.curLine;\n        this.lineStart = this.pos;\n      }\n      return out;\n    }\n    jsx_readString(quote) {\n      let out = '',\n        chunkStart = ++this.pos;\n      for (;;) {\n        if (this.pos >= this.input.length) this.raise(this.start, 'Unterminated string constant');\n        let ch = this.input.charCodeAt(this.pos);\n        if (ch === quote) break;\n        if (ch === 38) {\n          // '&'\n          out += this.input.slice(chunkStart, this.pos);\n          out += this.jsx_readEntity();\n          chunkStart = this.pos;\n        } else if (isNewLine(ch)) {\n          out += this.input.slice(chunkStart, this.pos);\n          out += this.jsx_readNewLine(false);\n          chunkStart = this.pos;\n        } else {\n          ++this.pos;\n        }\n      }\n      out += this.input.slice(chunkStart, this.pos++);\n      return this.finishToken(tt.string, out);\n    }\n    jsx_readEntity() {\n      let str = '',\n        count = 0,\n        entity;\n      let ch = this.input[this.pos];\n      if (ch !== '&') this.raise(this.pos, 'Entity must start with an ampersand');\n      let startPos = ++this.pos;\n      while (this.pos < this.input.length && count++ < 10) {\n        ch = this.input[this.pos++];\n        if (ch === ';') {\n          if (str[0] === '#') {\n            if (str[1] === 'x') {\n              str = str.substr(2);\n              if (hexNumber.test(str)) entity = String.fromCharCode(parseInt(str, 16));\n            } else {\n              str = str.substr(1);\n              if (decimalNumber.test(str)) entity = String.fromCharCode(parseInt(str, 10));\n            }\n          } else {\n            entity = XHTMLEntities[str];\n          }\n          break;\n        }\n        str += ch;\n      }\n      if (!entity) {\n        this.pos = startPos;\n        return '&';\n      }\n      return entity;\n    }\n\n    // Read a JSX identifier (valid tag or attribute name).\n    //\n    // Optimized version since JSX identifiers can't contain\n    // escape characters and so can be read as single slice.\n    // Also assumes that first character was already checked\n    // by isIdentifierStart in readToken.\n\n    jsx_readWord() {\n      let ch,\n        start = this.pos;\n      do {\n        ch = this.input.charCodeAt(++this.pos);\n      } while (isIdentifierChar(ch) || ch === 45); // '-'\n      return this.finishToken(tok.jsxName, this.input.slice(start, this.pos));\n    }\n\n    // Parse next token as JSX identifier\n\n    jsx_parseIdentifier() {\n      let node = this.startNode();\n      if (this.type === tok.jsxName) node.name = this.value;else if (this.type.keyword) node.name = this.type.keyword;else this.unexpected();\n      this.next();\n      return this.finishNode(node, 'JSXIdentifier');\n    }\n\n    // Parse namespaced identifier.\n\n    jsx_parseNamespacedName() {\n      let startPos = this.start,\n        startLoc = this.startLoc;\n      let name = this.jsx_parseIdentifier();\n      if (!options.allowNamespaces || !this.eat(tt.colon)) return name;\n      var node = this.startNodeAt(startPos, startLoc);\n      node.namespace = name;\n      node.name = this.jsx_parseIdentifier();\n      return this.finishNode(node, 'JSXNamespacedName');\n    }\n\n    // Parses element name in any form - namespaced, member\n    // or single identifier.\n\n    jsx_parseElementName() {\n      if (this.type === tok.jsxTagEnd) return '';\n      let startPos = this.start,\n        startLoc = this.startLoc;\n      let node = this.jsx_parseNamespacedName();\n      if (this.type === tt.dot && node.type === 'JSXNamespacedName' && !options.allowNamespacedObjects) {\n        this.unexpected();\n      }\n      while (this.eat(tt.dot)) {\n        let newNode = this.startNodeAt(startPos, startLoc);\n        newNode.object = node;\n        newNode.property = this.jsx_parseIdentifier();\n        node = this.finishNode(newNode, 'JSXMemberExpression');\n      }\n      return node;\n    }\n\n    // Parses any type of JSX attribute value.\n\n    jsx_parseAttributeValue() {\n      switch (this.type) {\n        case tt.braceL:\n          let node = this.jsx_parseExpressionContainer();\n          if (node.expression.type === 'JSXEmptyExpression') this.raise(node.start, 'JSX attributes must only be assigned a non-empty expression');\n          return node;\n        case tok.jsxTagStart:\n        case tt.string:\n          return this.parseExprAtom();\n        default:\n          this.raise(this.start, 'JSX value should be either an expression or a quoted JSX text');\n      }\n    }\n\n    // JSXEmptyExpression is unique type since it doesn't actually parse anything,\n    // and so it should start at the end of last read token (left brace) and finish\n    // at the beginning of the next one (right brace).\n\n    jsx_parseEmptyExpression() {\n      let node = this.startNodeAt(this.lastTokEnd, this.lastTokEndLoc);\n      return this.finishNodeAt(node, 'JSXEmptyExpression', this.start, this.startLoc);\n    }\n\n    // Parses JSX expression enclosed into curly brackets.\n\n    jsx_parseExpressionContainer() {\n      let node = this.startNode();\n      this.next();\n      node.expression = this.type === tt.braceR ? this.jsx_parseEmptyExpression() : this.parseExpression();\n      this.expect(tt.braceR);\n      return this.finishNode(node, 'JSXExpressionContainer');\n    }\n\n    // Parses following JSX attribute name-value pair.\n\n    jsx_parseAttribute() {\n      let node = this.startNode();\n      if (this.eat(tt.braceL)) {\n        this.expect(tt.ellipsis);\n        node.argument = this.parseMaybeAssign();\n        this.expect(tt.braceR);\n        return this.finishNode(node, 'JSXSpreadAttribute');\n      }\n      node.name = this.jsx_parseNamespacedName();\n      node.value = this.eat(tt.eq) ? this.jsx_parseAttributeValue() : null;\n      return this.finishNode(node, 'JSXAttribute');\n    }\n\n    // Parses JSX opening tag starting after '<'.\n\n    jsx_parseOpeningElementAt(startPos, startLoc) {\n      let node = this.startNodeAt(startPos, startLoc);\n      node.attributes = [];\n      let nodeName = this.jsx_parseElementName();\n      if (nodeName) node.name = nodeName;\n      while (this.type !== tt.slash && this.type !== tok.jsxTagEnd) node.attributes.push(this.jsx_parseAttribute());\n      node.selfClosing = this.eat(tt.slash);\n      this.expect(tok.jsxTagEnd);\n      return this.finishNode(node, nodeName ? 'JSXOpeningElement' : 'JSXOpeningFragment');\n    }\n\n    // Parses JSX closing tag starting after '</'.\n\n    jsx_parseClosingElementAt(startPos, startLoc) {\n      let node = this.startNodeAt(startPos, startLoc);\n      let nodeName = this.jsx_parseElementName();\n      if (nodeName) node.name = nodeName;\n      this.expect(tok.jsxTagEnd);\n      return this.finishNode(node, nodeName ? 'JSXClosingElement' : 'JSXClosingFragment');\n    }\n\n    // Parses entire JSX element, including it's opening tag\n    // (starting after '<'), attributes, contents and closing tag.\n\n    jsx_parseElementAt(startPos, startLoc) {\n      let node = this.startNodeAt(startPos, startLoc);\n      let children = [];\n      let openingElement = this.jsx_parseOpeningElementAt(startPos, startLoc);\n      let closingElement = null;\n      if (!openingElement.selfClosing) {\n        contents: for (;;) {\n          switch (this.type) {\n            case tok.jsxTagStart:\n              startPos = this.start;\n              startLoc = this.startLoc;\n              this.next();\n              if (this.eat(tt.slash)) {\n                closingElement = this.jsx_parseClosingElementAt(startPos, startLoc);\n                break contents;\n              }\n              children.push(this.jsx_parseElementAt(startPos, startLoc));\n              break;\n            case tok.jsxText:\n              children.push(this.parseExprAtom());\n              break;\n            case tt.braceL:\n              children.push(this.jsx_parseExpressionContainer());\n              break;\n            default:\n              this.unexpected();\n          }\n        }\n        if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {\n          this.raise(closingElement.start, 'Expected corresponding JSX closing tag for <' + getQualifiedJSXName(openingElement.name) + '>');\n        }\n      }\n      let fragmentOrElement = openingElement.name ? 'Element' : 'Fragment';\n      node['opening' + fragmentOrElement] = openingElement;\n      node['closing' + fragmentOrElement] = closingElement;\n      node.children = children;\n      if (this.type === tt.relational && this.value === \"<\") {\n        this.raise(this.start, \"Adjacent JSX elements must be wrapped in an enclosing tag\");\n      }\n      return this.finishNode(node, 'JSX' + fragmentOrElement);\n    }\n\n    // Parse JSX text\n\n    jsx_parseText() {\n      let node = this.parseLiteral(this.value);\n      node.type = \"JSXText\";\n      return node;\n    }\n\n    // Parses entire JSX element from current position.\n\n    jsx_parseElement() {\n      let startPos = this.start,\n        startLoc = this.startLoc;\n      this.next();\n      return this.jsx_parseElementAt(startPos, startLoc);\n    }\n    parseExprAtom(refShortHandDefaultPos) {\n      if (this.type === tok.jsxText) return this.jsx_parseText();else if (this.type === tok.jsxTagStart) return this.jsx_parseElement();else return super.parseExprAtom(refShortHandDefaultPos);\n    }\n    readToken(code) {\n      let context = this.curContext();\n      if (context === tc_expr) return this.jsx_readToken();\n      if (context === tc_oTag || context === tc_cTag) {\n        if (isIdentifierStart(code)) return this.jsx_readWord();\n        if (code == 62) {\n          ++this.pos;\n          return this.finishToken(tok.jsxTagEnd);\n        }\n        if ((code === 34 || code === 39) && context == tc_oTag) return this.jsx_readString(code);\n      }\n      if (code === 60 && this.exprAllowed && this.input.charCodeAt(this.pos + 1) !== 33) {\n        ++this.pos;\n        return this.finishToken(tok.jsxTagStart);\n      }\n      return super.readToken(code);\n    }\n    updateContext(prevType) {\n      if (this.type == tt.braceL) {\n        var curContext = this.curContext();\n        if (curContext == tc_oTag) this.context.push(tokContexts.b_expr);else if (curContext == tc_expr) this.context.push(tokContexts.b_tmpl);else super.updateContext(prevType);\n        this.exprAllowed = true;\n      } else if (this.type === tt.slash && prevType === tok.jsxTagStart) {\n        this.context.length -= 2; // do not consider JSX expr -> JSX open tag -> ... anymore\n        this.context.push(tc_cTag); // reconsider as closing tag context\n        this.exprAllowed = false;\n      } else {\n        return super.updateContext(prevType);\n      }\n    }\n  };\n}","map":{"version":3,"names":["require","XHTMLEntities","hexNumber","decimalNumber","acornJsxMap","WeakMap","getJsxTokens","acorn","Parser","acornJsx","get","tt","tokTypes","TokContext","TokenType","tc_oTag","tc_cTag","tc_expr","tokContexts","jsxName","jsxText","beforeExpr","jsxTagStart","startsExpr","jsxTagEnd","updateContext","context","push","exprAllowed","prevType","out","pop","slash","curContext","set","getQualifiedJSXName","object","type","name","namespace","property","module","exports","options","plugin","allowNamespaces","allowNamespacedObjects","Object","defineProperty","get_tokTypes","configurable","enumerable","tok","isNewLine","isIdentifierStart","isIdentifierChar","jsx_readToken","chunkStart","pos","input","length","raise","start","ch","charCodeAt","finishToken","getTokenFromCode","slice","jsx_readEntity","jsx_readNewLine","normalizeCRLF","String","fromCharCode","locations","curLine","lineStart","jsx_readString","quote","string","str","count","entity","startPos","substr","test","parseInt","jsx_readWord","jsx_parseIdentifier","node","startNode","value","keyword","unexpected","next","finishNode","jsx_parseNamespacedName","startLoc","eat","colon","startNodeAt","jsx_parseElementName","dot","newNode","jsx_parseAttributeValue","braceL","jsx_parseExpressionContainer","expression","parseExprAtom","jsx_parseEmptyExpression","lastTokEnd","lastTokEndLoc","finishNodeAt","braceR","parseExpression","expect","jsx_parseAttribute","ellipsis","argument","parseMaybeAssign","eq","jsx_parseOpeningElementAt","attributes","nodeName","selfClosing","jsx_parseClosingElementAt","jsx_parseElementAt","children","openingElement","closingElement","contents","fragmentOrElement","relational","jsx_parseText","parseLiteral","jsx_parseElement","refShortHandDefaultPos","readToken","code","b_expr","b_tmpl"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/acorn-jsx/index.js"],"sourcesContent":["'use strict';\n\nconst XHTMLEntities = require('./xhtml');\n\nconst hexNumber = /^[\\da-fA-F]+$/;\nconst decimalNumber = /^\\d+$/;\n\n// The map to `acorn-jsx` tokens from `acorn` namespace objects.\nconst acornJsxMap = new WeakMap();\n\n// Get the original tokens for the given `acorn` namespace object.\nfunction getJsxTokens(acorn) {\n  acorn = acorn.Parser.acorn || acorn;\n  let acornJsx = acornJsxMap.get(acorn);\n  if (!acornJsx) {\n    const tt = acorn.tokTypes;\n    const TokContext = acorn.TokContext;\n    const TokenType = acorn.TokenType;\n    const tc_oTag = new TokContext('<tag', false);\n    const tc_cTag = new TokContext('</tag', false);\n    const tc_expr = new TokContext('<tag>...</tag>', true, true);\n    const tokContexts = {\n      tc_oTag: tc_oTag,\n      tc_cTag: tc_cTag,\n      tc_expr: tc_expr\n    };\n    const tokTypes = {\n      jsxName: new TokenType('jsxName'),\n      jsxText: new TokenType('jsxText', {beforeExpr: true}),\n      jsxTagStart: new TokenType('jsxTagStart', {startsExpr: true}),\n      jsxTagEnd: new TokenType('jsxTagEnd')\n    };\n\n    tokTypes.jsxTagStart.updateContext = function() {\n      this.context.push(tc_expr); // treat as beginning of JSX expression\n      this.context.push(tc_oTag); // start opening tag context\n      this.exprAllowed = false;\n    };\n    tokTypes.jsxTagEnd.updateContext = function(prevType) {\n      let out = this.context.pop();\n      if (out === tc_oTag && prevType === tt.slash || out === tc_cTag) {\n        this.context.pop();\n        this.exprAllowed = this.curContext() === tc_expr;\n      } else {\n        this.exprAllowed = true;\n      }\n    };\n\n    acornJsx = { tokContexts: tokContexts, tokTypes: tokTypes };\n    acornJsxMap.set(acorn, acornJsx);\n  }\n\n  return acornJsx;\n}\n\n// Transforms JSX element name to string.\n\nfunction getQualifiedJSXName(object) {\n  if (!object)\n    return object;\n\n  if (object.type === 'JSXIdentifier')\n    return object.name;\n\n  if (object.type === 'JSXNamespacedName')\n    return object.namespace.name + ':' + object.name.name;\n\n  if (object.type === 'JSXMemberExpression')\n    return getQualifiedJSXName(object.object) + '.' +\n    getQualifiedJSXName(object.property);\n}\n\nmodule.exports = function(options) {\n  options = options || {};\n  return function(Parser) {\n    return plugin({\n      allowNamespaces: options.allowNamespaces !== false,\n      allowNamespacedObjects: !!options.allowNamespacedObjects\n    }, Parser);\n  };\n};\n\n// This is `tokTypes` of the peer dep.\n// This can be different instances from the actual `tokTypes` this plugin uses.\nObject.defineProperty(module.exports, \"tokTypes\", {\n  get: function get_tokTypes() {\n    return getJsxTokens(require(\"acorn\")).tokTypes;\n  },\n  configurable: true,\n  enumerable: true\n});\n\nfunction plugin(options, Parser) {\n  const acorn = Parser.acorn || require(\"acorn\");\n  const acornJsx = getJsxTokens(acorn);\n  const tt = acorn.tokTypes;\n  const tok = acornJsx.tokTypes;\n  const tokContexts = acorn.tokContexts;\n  const tc_oTag = acornJsx.tokContexts.tc_oTag;\n  const tc_cTag = acornJsx.tokContexts.tc_cTag;\n  const tc_expr = acornJsx.tokContexts.tc_expr;\n  const isNewLine = acorn.isNewLine;\n  const isIdentifierStart = acorn.isIdentifierStart;\n  const isIdentifierChar = acorn.isIdentifierChar;\n\n  return class extends Parser {\n    // Expose actual `tokTypes` and `tokContexts` to other plugins.\n    static get acornJsx() {\n      return acornJsx;\n    }\n\n    // Reads inline JSX contents token.\n    jsx_readToken() {\n      let out = '', chunkStart = this.pos;\n      for (;;) {\n        if (this.pos >= this.input.length)\n          this.raise(this.start, 'Unterminated JSX contents');\n        let ch = this.input.charCodeAt(this.pos);\n\n        switch (ch) {\n        case 60: // '<'\n        case 123: // '{'\n          if (this.pos === this.start) {\n            if (ch === 60 && this.exprAllowed) {\n              ++this.pos;\n              return this.finishToken(tok.jsxTagStart);\n            }\n            return this.getTokenFromCode(ch);\n          }\n          out += this.input.slice(chunkStart, this.pos);\n          return this.finishToken(tok.jsxText, out);\n\n        case 38: // '&'\n          out += this.input.slice(chunkStart, this.pos);\n          out += this.jsx_readEntity();\n          chunkStart = this.pos;\n          break;\n\n        case 62: // '>'\n        case 125: // '}'\n          this.raise(\n            this.pos,\n            \"Unexpected token `\" + this.input[this.pos] + \"`. Did you mean `\" +\n              (ch === 62 ? \"&gt;\" : \"&rbrace;\") + \"` or \" + \"`{\\\"\" + this.input[this.pos] + \"\\\"}\" + \"`?\"\n          );\n\n        default:\n          if (isNewLine(ch)) {\n            out += this.input.slice(chunkStart, this.pos);\n            out += this.jsx_readNewLine(true);\n            chunkStart = this.pos;\n          } else {\n            ++this.pos;\n          }\n        }\n      }\n    }\n\n    jsx_readNewLine(normalizeCRLF) {\n      let ch = this.input.charCodeAt(this.pos);\n      let out;\n      ++this.pos;\n      if (ch === 13 && this.input.charCodeAt(this.pos) === 10) {\n        ++this.pos;\n        out = normalizeCRLF ? '\\n' : '\\r\\n';\n      } else {\n        out = String.fromCharCode(ch);\n      }\n      if (this.options.locations) {\n        ++this.curLine;\n        this.lineStart = this.pos;\n      }\n\n      return out;\n    }\n\n    jsx_readString(quote) {\n      let out = '', chunkStart = ++this.pos;\n      for (;;) {\n        if (this.pos >= this.input.length)\n          this.raise(this.start, 'Unterminated string constant');\n        let ch = this.input.charCodeAt(this.pos);\n        if (ch === quote) break;\n        if (ch === 38) { // '&'\n          out += this.input.slice(chunkStart, this.pos);\n          out += this.jsx_readEntity();\n          chunkStart = this.pos;\n        } else if (isNewLine(ch)) {\n          out += this.input.slice(chunkStart, this.pos);\n          out += this.jsx_readNewLine(false);\n          chunkStart = this.pos;\n        } else {\n          ++this.pos;\n        }\n      }\n      out += this.input.slice(chunkStart, this.pos++);\n      return this.finishToken(tt.string, out);\n    }\n\n    jsx_readEntity() {\n      let str = '', count = 0, entity;\n      let ch = this.input[this.pos];\n      if (ch !== '&')\n        this.raise(this.pos, 'Entity must start with an ampersand');\n      let startPos = ++this.pos;\n      while (this.pos < this.input.length && count++ < 10) {\n        ch = this.input[this.pos++];\n        if (ch === ';') {\n          if (str[0] === '#') {\n            if (str[1] === 'x') {\n              str = str.substr(2);\n              if (hexNumber.test(str))\n                entity = String.fromCharCode(parseInt(str, 16));\n            } else {\n              str = str.substr(1);\n              if (decimalNumber.test(str))\n                entity = String.fromCharCode(parseInt(str, 10));\n            }\n          } else {\n            entity = XHTMLEntities[str];\n          }\n          break;\n        }\n        str += ch;\n      }\n      if (!entity) {\n        this.pos = startPos;\n        return '&';\n      }\n      return entity;\n    }\n\n    // Read a JSX identifier (valid tag or attribute name).\n    //\n    // Optimized version since JSX identifiers can't contain\n    // escape characters and so can be read as single slice.\n    // Also assumes that first character was already checked\n    // by isIdentifierStart in readToken.\n\n    jsx_readWord() {\n      let ch, start = this.pos;\n      do {\n        ch = this.input.charCodeAt(++this.pos);\n      } while (isIdentifierChar(ch) || ch === 45); // '-'\n      return this.finishToken(tok.jsxName, this.input.slice(start, this.pos));\n    }\n\n    // Parse next token as JSX identifier\n\n    jsx_parseIdentifier() {\n      let node = this.startNode();\n      if (this.type === tok.jsxName)\n        node.name = this.value;\n      else if (this.type.keyword)\n        node.name = this.type.keyword;\n      else\n        this.unexpected();\n      this.next();\n      return this.finishNode(node, 'JSXIdentifier');\n    }\n\n    // Parse namespaced identifier.\n\n    jsx_parseNamespacedName() {\n      let startPos = this.start, startLoc = this.startLoc;\n      let name = this.jsx_parseIdentifier();\n      if (!options.allowNamespaces || !this.eat(tt.colon)) return name;\n      var node = this.startNodeAt(startPos, startLoc);\n      node.namespace = name;\n      node.name = this.jsx_parseIdentifier();\n      return this.finishNode(node, 'JSXNamespacedName');\n    }\n\n    // Parses element name in any form - namespaced, member\n    // or single identifier.\n\n    jsx_parseElementName() {\n      if (this.type === tok.jsxTagEnd) return '';\n      let startPos = this.start, startLoc = this.startLoc;\n      let node = this.jsx_parseNamespacedName();\n      if (this.type === tt.dot && node.type === 'JSXNamespacedName' && !options.allowNamespacedObjects) {\n        this.unexpected();\n      }\n      while (this.eat(tt.dot)) {\n        let newNode = this.startNodeAt(startPos, startLoc);\n        newNode.object = node;\n        newNode.property = this.jsx_parseIdentifier();\n        node = this.finishNode(newNode, 'JSXMemberExpression');\n      }\n      return node;\n    }\n\n    // Parses any type of JSX attribute value.\n\n    jsx_parseAttributeValue() {\n      switch (this.type) {\n      case tt.braceL:\n        let node = this.jsx_parseExpressionContainer();\n        if (node.expression.type === 'JSXEmptyExpression')\n          this.raise(node.start, 'JSX attributes must only be assigned a non-empty expression');\n        return node;\n\n      case tok.jsxTagStart:\n      case tt.string:\n        return this.parseExprAtom();\n\n      default:\n        this.raise(this.start, 'JSX value should be either an expression or a quoted JSX text');\n      }\n    }\n\n    // JSXEmptyExpression is unique type since it doesn't actually parse anything,\n    // and so it should start at the end of last read token (left brace) and finish\n    // at the beginning of the next one (right brace).\n\n    jsx_parseEmptyExpression() {\n      let node = this.startNodeAt(this.lastTokEnd, this.lastTokEndLoc);\n      return this.finishNodeAt(node, 'JSXEmptyExpression', this.start, this.startLoc);\n    }\n\n    // Parses JSX expression enclosed into curly brackets.\n\n    jsx_parseExpressionContainer() {\n      let node = this.startNode();\n      this.next();\n      node.expression = this.type === tt.braceR\n        ? this.jsx_parseEmptyExpression()\n        : this.parseExpression();\n      this.expect(tt.braceR);\n      return this.finishNode(node, 'JSXExpressionContainer');\n    }\n\n    // Parses following JSX attribute name-value pair.\n\n    jsx_parseAttribute() {\n      let node = this.startNode();\n      if (this.eat(tt.braceL)) {\n        this.expect(tt.ellipsis);\n        node.argument = this.parseMaybeAssign();\n        this.expect(tt.braceR);\n        return this.finishNode(node, 'JSXSpreadAttribute');\n      }\n      node.name = this.jsx_parseNamespacedName();\n      node.value = this.eat(tt.eq) ? this.jsx_parseAttributeValue() : null;\n      return this.finishNode(node, 'JSXAttribute');\n    }\n\n    // Parses JSX opening tag starting after '<'.\n\n    jsx_parseOpeningElementAt(startPos, startLoc) {\n      let node = this.startNodeAt(startPos, startLoc);\n      node.attributes = [];\n      let nodeName = this.jsx_parseElementName();\n      if (nodeName) node.name = nodeName;\n      while (this.type !== tt.slash && this.type !== tok.jsxTagEnd)\n        node.attributes.push(this.jsx_parseAttribute());\n      node.selfClosing = this.eat(tt.slash);\n      this.expect(tok.jsxTagEnd);\n      return this.finishNode(node, nodeName ? 'JSXOpeningElement' : 'JSXOpeningFragment');\n    }\n\n    // Parses JSX closing tag starting after '</'.\n\n    jsx_parseClosingElementAt(startPos, startLoc) {\n      let node = this.startNodeAt(startPos, startLoc);\n      let nodeName = this.jsx_parseElementName();\n      if (nodeName) node.name = nodeName;\n      this.expect(tok.jsxTagEnd);\n      return this.finishNode(node, nodeName ? 'JSXClosingElement' : 'JSXClosingFragment');\n    }\n\n    // Parses entire JSX element, including it's opening tag\n    // (starting after '<'), attributes, contents and closing tag.\n\n    jsx_parseElementAt(startPos, startLoc) {\n      let node = this.startNodeAt(startPos, startLoc);\n      let children = [];\n      let openingElement = this.jsx_parseOpeningElementAt(startPos, startLoc);\n      let closingElement = null;\n\n      if (!openingElement.selfClosing) {\n        contents: for (;;) {\n          switch (this.type) {\n          case tok.jsxTagStart:\n            startPos = this.start; startLoc = this.startLoc;\n            this.next();\n            if (this.eat(tt.slash)) {\n              closingElement = this.jsx_parseClosingElementAt(startPos, startLoc);\n              break contents;\n            }\n            children.push(this.jsx_parseElementAt(startPos, startLoc));\n            break;\n\n          case tok.jsxText:\n            children.push(this.parseExprAtom());\n            break;\n\n          case tt.braceL:\n            children.push(this.jsx_parseExpressionContainer());\n            break;\n\n          default:\n            this.unexpected();\n          }\n        }\n        if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {\n          this.raise(\n            closingElement.start,\n            'Expected corresponding JSX closing tag for <' + getQualifiedJSXName(openingElement.name) + '>');\n        }\n      }\n      let fragmentOrElement = openingElement.name ? 'Element' : 'Fragment';\n\n      node['opening' + fragmentOrElement] = openingElement;\n      node['closing' + fragmentOrElement] = closingElement;\n      node.children = children;\n      if (this.type === tt.relational && this.value === \"<\") {\n        this.raise(this.start, \"Adjacent JSX elements must be wrapped in an enclosing tag\");\n      }\n      return this.finishNode(node, 'JSX' + fragmentOrElement);\n    }\n\n    // Parse JSX text\n\n    jsx_parseText() {\n      let node = this.parseLiteral(this.value);\n      node.type = \"JSXText\";\n      return node;\n    }\n\n    // Parses entire JSX element from current position.\n\n    jsx_parseElement() {\n      let startPos = this.start, startLoc = this.startLoc;\n      this.next();\n      return this.jsx_parseElementAt(startPos, startLoc);\n    }\n\n    parseExprAtom(refShortHandDefaultPos) {\n      if (this.type === tok.jsxText)\n        return this.jsx_parseText();\n      else if (this.type === tok.jsxTagStart)\n        return this.jsx_parseElement();\n      else\n        return super.parseExprAtom(refShortHandDefaultPos);\n    }\n\n    readToken(code) {\n      let context = this.curContext();\n\n      if (context === tc_expr) return this.jsx_readToken();\n\n      if (context === tc_oTag || context === tc_cTag) {\n        if (isIdentifierStart(code)) return this.jsx_readWord();\n\n        if (code == 62) {\n          ++this.pos;\n          return this.finishToken(tok.jsxTagEnd);\n        }\n\n        if ((code === 34 || code === 39) && context == tc_oTag)\n          return this.jsx_readString(code);\n      }\n\n      if (code === 60 && this.exprAllowed && this.input.charCodeAt(this.pos + 1) !== 33) {\n        ++this.pos;\n        return this.finishToken(tok.jsxTagStart);\n      }\n      return super.readToken(code);\n    }\n\n    updateContext(prevType) {\n      if (this.type == tt.braceL) {\n        var curContext = this.curContext();\n        if (curContext == tc_oTag) this.context.push(tokContexts.b_expr);\n        else if (curContext == tc_expr) this.context.push(tokContexts.b_tmpl);\n        else super.updateContext(prevType);\n        this.exprAllowed = true;\n      } else if (this.type === tt.slash && prevType === tok.jsxTagStart) {\n        this.context.length -= 2; // do not consider JSX expr -> JSX open tag -> ... anymore\n        this.context.push(tc_cTag); // reconsider as closing tag context\n        this.exprAllowed = false;\n      } else {\n        return super.updateContext(prevType);\n      }\n    }\n  };\n}\n"],"mappings":"AAAA,YAAY;;AAACA,OAAA;AAEb,MAAMC,aAAa,GAAGD,OAAO,CAAC,SAAS,CAAC;AAExC,MAAME,SAAS,GAAG,eAAe;AACjC,MAAMC,aAAa,GAAG,OAAO;;AAE7B;AACA,MAAMC,WAAW,GAAG,IAAIC,OAAO,CAAC,CAAC;;AAEjC;AACA,SAASC,YAAYA,CAACC,KAAK,EAAE;EAC3BA,KAAK,GAAGA,KAAK,CAACC,MAAM,CAACD,KAAK,IAAIA,KAAK;EACnC,IAAIE,QAAQ,GAAGL,WAAW,CAACM,GAAG,CAACH,KAAK,CAAC;EACrC,IAAI,CAACE,QAAQ,EAAE;IACb,MAAME,EAAE,GAAGJ,KAAK,CAACK,QAAQ;IACzB,MAAMC,UAAU,GAAGN,KAAK,CAACM,UAAU;IACnC,MAAMC,SAAS,GAAGP,KAAK,CAACO,SAAS;IACjC,MAAMC,OAAO,GAAG,IAAIF,UAAU,CAAC,MAAM,EAAE,KAAK,CAAC;IAC7C,MAAMG,OAAO,GAAG,IAAIH,UAAU,CAAC,OAAO,EAAE,KAAK,CAAC;IAC9C,MAAMI,OAAO,GAAG,IAAIJ,UAAU,CAAC,gBAAgB,EAAE,IAAI,EAAE,IAAI,CAAC;IAC5D,MAAMK,WAAW,GAAG;MAClBH,OAAO,EAAEA,OAAO;MAChBC,OAAO,EAAEA,OAAO;MAChBC,OAAO,EAAEA;IACX,CAAC;IACD,MAAML,QAAQ,GAAG;MACfO,OAAO,EAAE,IAAIL,SAAS,CAAC,SAAS,CAAC;MACjCM,OAAO,EAAE,IAAIN,SAAS,CAAC,SAAS,EAAE;QAACO,UAAU,EAAE;MAAI,CAAC,CAAC;MACrDC,WAAW,EAAE,IAAIR,SAAS,CAAC,aAAa,EAAE;QAACS,UAAU,EAAE;MAAI,CAAC,CAAC;MAC7DC,SAAS,EAAE,IAAIV,SAAS,CAAC,WAAW;IACtC,CAAC;IAEDF,QAAQ,CAACU,WAAW,CAACG,aAAa,GAAG,YAAW;MAC9C,IAAI,CAACC,OAAO,CAACC,IAAI,CAACV,OAAO,CAAC,CAAC,CAAC;MAC5B,IAAI,CAACS,OAAO,CAACC,IAAI,CAACZ,OAAO,CAAC,CAAC,CAAC;MAC5B,IAAI,CAACa,WAAW,GAAG,KAAK;IAC1B,CAAC;IACDhB,QAAQ,CAACY,SAAS,CAACC,aAAa,GAAG,UAASI,QAAQ,EAAE;MACpD,IAAIC,GAAG,GAAG,IAAI,CAACJ,OAAO,CAACK,GAAG,CAAC,CAAC;MAC5B,IAAID,GAAG,KAAKf,OAAO,IAAIc,QAAQ,KAAKlB,EAAE,CAACqB,KAAK,IAAIF,GAAG,KAAKd,OAAO,EAAE;QAC/D,IAAI,CAACU,OAAO,CAACK,GAAG,CAAC,CAAC;QAClB,IAAI,CAACH,WAAW,GAAG,IAAI,CAACK,UAAU,CAAC,CAAC,KAAKhB,OAAO;MAClD,CAAC,MAAM;QACL,IAAI,CAACW,WAAW,GAAG,IAAI;MACzB;IACF,CAAC;IAEDnB,QAAQ,GAAG;MAAES,WAAW,EAAEA,WAAW;MAAEN,QAAQ,EAAEA;IAAS,CAAC;IAC3DR,WAAW,CAAC8B,GAAG,CAAC3B,KAAK,EAAEE,QAAQ,CAAC;EAClC;EAEA,OAAOA,QAAQ;AACjB;;AAEA;;AAEA,SAAS0B,mBAAmBA,CAACC,MAAM,EAAE;EACnC,IAAI,CAACA,MAAM,EACT,OAAOA,MAAM;EAEf,IAAIA,MAAM,CAACC,IAAI,KAAK,eAAe,EACjC,OAAOD,MAAM,CAACE,IAAI;EAEpB,IAAIF,MAAM,CAACC,IAAI,KAAK,mBAAmB,EACrC,OAAOD,MAAM,CAACG,SAAS,CAACD,IAAI,GAAG,GAAG,GAAGF,MAAM,CAACE,IAAI,CAACA,IAAI;EAEvD,IAAIF,MAAM,CAACC,IAAI,KAAK,qBAAqB,EACvC,OAAOF,mBAAmB,CAACC,MAAM,CAACA,MAAM,CAAC,GAAG,GAAG,GAC/CD,mBAAmB,CAACC,MAAM,CAACI,QAAQ,CAAC;AACxC;AAEAC,MAAM,CAACC,OAAO,GAAG,UAASC,OAAO,EAAE;EACjCA,OAAO,GAAGA,OAAO,IAAI,CAAC,CAAC;EACvB,OAAO,UAASnC,MAAM,EAAE;IACtB,OAAOoC,MAAM,CAAC;MACZC,eAAe,EAAEF,OAAO,CAACE,eAAe,KAAK,KAAK;MAClDC,sBAAsB,EAAE,CAAC,CAACH,OAAO,CAACG;IACpC,CAAC,EAAEtC,MAAM,CAAC;EACZ,CAAC;AACH,CAAC;;AAED;AACA;AACAuC,MAAM,CAACC,cAAc,CAACP,MAAM,CAACC,OAAO,EAAE,UAAU,EAAE;EAChDhC,GAAG,EAAE,SAASuC,YAAYA,CAAA,EAAG;IAC3B,OAAO3C,YAAY,CAACN,OAAO,CAAC,OAAO,CAAC,CAAC,CAACY,QAAQ;EAChD,CAAC;EACDsC,YAAY,EAAE,IAAI;EAClBC,UAAU,EAAE;AACd,CAAC,CAAC;AAEF,SAASP,MAAMA,CAACD,OAAO,EAAEnC,MAAM,EAAE;EAC/B,MAAMD,KAAK,GAAGC,MAAM,CAACD,KAAK,IAAIP,OAAO,CAAC,OAAO,CAAC;EAC9C,MAAMS,QAAQ,GAAGH,YAAY,CAACC,KAAK,CAAC;EACpC,MAAMI,EAAE,GAAGJ,KAAK,CAACK,QAAQ;EACzB,MAAMwC,GAAG,GAAG3C,QAAQ,CAACG,QAAQ;EAC7B,MAAMM,WAAW,GAAGX,KAAK,CAACW,WAAW;EACrC,MAAMH,OAAO,GAAGN,QAAQ,CAACS,WAAW,CAACH,OAAO;EAC5C,MAAMC,OAAO,GAAGP,QAAQ,CAACS,WAAW,CAACF,OAAO;EAC5C,MAAMC,OAAO,GAAGR,QAAQ,CAACS,WAAW,CAACD,OAAO;EAC5C,MAAMoC,SAAS,GAAG9C,KAAK,CAAC8C,SAAS;EACjC,MAAMC,iBAAiB,GAAG/C,KAAK,CAAC+C,iBAAiB;EACjD,MAAMC,gBAAgB,GAAGhD,KAAK,CAACgD,gBAAgB;EAE/C,OAAO,cAAc/C,MAAM,CAAC;IAC1B;IACA,WAAWC,QAAQA,CAAA,EAAG;MACpB,OAAOA,QAAQ;IACjB;;IAEA;IACA+C,aAAaA,CAAA,EAAG;MACd,IAAI1B,GAAG,GAAG,EAAE;QAAE2B,UAAU,GAAG,IAAI,CAACC,GAAG;MACnC,SAAS;QACP,IAAI,IAAI,CAACA,GAAG,IAAI,IAAI,CAACC,KAAK,CAACC,MAAM,EAC/B,IAAI,CAACC,KAAK,CAAC,IAAI,CAACC,KAAK,EAAE,2BAA2B,CAAC;QACrD,IAAIC,EAAE,GAAG,IAAI,CAACJ,KAAK,CAACK,UAAU,CAAC,IAAI,CAACN,GAAG,CAAC;QAExC,QAAQK,EAAE;UACV,KAAK,EAAE,CAAC,CAAC;UACT,KAAK,GAAG;YAAE;YACR,IAAI,IAAI,CAACL,GAAG,KAAK,IAAI,CAACI,KAAK,EAAE;cAC3B,IAAIC,EAAE,KAAK,EAAE,IAAI,IAAI,CAACnC,WAAW,EAAE;gBACjC,EAAE,IAAI,CAAC8B,GAAG;gBACV,OAAO,IAAI,CAACO,WAAW,CAACb,GAAG,CAAC9B,WAAW,CAAC;cAC1C;cACA,OAAO,IAAI,CAAC4C,gBAAgB,CAACH,EAAE,CAAC;YAClC;YACAjC,GAAG,IAAI,IAAI,CAAC6B,KAAK,CAACQ,KAAK,CAACV,UAAU,EAAE,IAAI,CAACC,GAAG,CAAC;YAC7C,OAAO,IAAI,CAACO,WAAW,CAACb,GAAG,CAAChC,OAAO,EAAEU,GAAG,CAAC;UAE3C,KAAK,EAAE;YAAE;YACPA,GAAG,IAAI,IAAI,CAAC6B,KAAK,CAACQ,KAAK,CAACV,UAAU,EAAE,IAAI,CAACC,GAAG,CAAC;YAC7C5B,GAAG,IAAI,IAAI,CAACsC,cAAc,CAAC,CAAC;YAC5BX,UAAU,GAAG,IAAI,CAACC,GAAG;YACrB;UAEF,KAAK,EAAE,CAAC,CAAC;UACT,KAAK,GAAG;YAAE;YACR,IAAI,CAACG,KAAK,CACR,IAAI,CAACH,GAAG,EACR,oBAAoB,GAAG,IAAI,CAACC,KAAK,CAAC,IAAI,CAACD,GAAG,CAAC,GAAG,mBAAmB,IAC9DK,EAAE,KAAK,EAAE,GAAG,MAAM,GAAG,UAAU,CAAC,GAAG,OAAO,GAAG,MAAM,GAAG,IAAI,CAACJ,KAAK,CAAC,IAAI,CAACD,GAAG,CAAC,GAAG,KAAK,GAAG,IAC1F,CAAC;UAEH;YACE,IAAIL,SAAS,CAACU,EAAE,CAAC,EAAE;cACjBjC,GAAG,IAAI,IAAI,CAAC6B,KAAK,CAACQ,KAAK,CAACV,UAAU,EAAE,IAAI,CAACC,GAAG,CAAC;cAC7C5B,GAAG,IAAI,IAAI,CAACuC,eAAe,CAAC,IAAI,CAAC;cACjCZ,UAAU,GAAG,IAAI,CAACC,GAAG;YACvB,CAAC,MAAM;cACL,EAAE,IAAI,CAACA,GAAG;YACZ;QACF;MACF;IACF;IAEAW,eAAeA,CAACC,aAAa,EAAE;MAC7B,IAAIP,EAAE,GAAG,IAAI,CAACJ,KAAK,CAACK,UAAU,CAAC,IAAI,CAACN,GAAG,CAAC;MACxC,IAAI5B,GAAG;MACP,EAAE,IAAI,CAAC4B,GAAG;MACV,IAAIK,EAAE,KAAK,EAAE,IAAI,IAAI,CAACJ,KAAK,CAACK,UAAU,CAAC,IAAI,CAACN,GAAG,CAAC,KAAK,EAAE,EAAE;QACvD,EAAE,IAAI,CAACA,GAAG;QACV5B,GAAG,GAAGwC,aAAa,GAAG,IAAI,GAAG,MAAM;MACrC,CAAC,MAAM;QACLxC,GAAG,GAAGyC,MAAM,CAACC,YAAY,CAACT,EAAE,CAAC;MAC/B;MACA,IAAI,IAAI,CAACpB,OAAO,CAAC8B,SAAS,EAAE;QAC1B,EAAE,IAAI,CAACC,OAAO;QACd,IAAI,CAACC,SAAS,GAAG,IAAI,CAACjB,GAAG;MAC3B;MAEA,OAAO5B,GAAG;IACZ;IAEA8C,cAAcA,CAACC,KAAK,EAAE;MACpB,IAAI/C,GAAG,GAAG,EAAE;QAAE2B,UAAU,GAAG,EAAE,IAAI,CAACC,GAAG;MACrC,SAAS;QACP,IAAI,IAAI,CAACA,GAAG,IAAI,IAAI,CAACC,KAAK,CAACC,MAAM,EAC/B,IAAI,CAACC,KAAK,CAAC,IAAI,CAACC,KAAK,EAAE,8BAA8B,CAAC;QACxD,IAAIC,EAAE,GAAG,IAAI,CAACJ,KAAK,CAACK,UAAU,CAAC,IAAI,CAACN,GAAG,CAAC;QACxC,IAAIK,EAAE,KAAKc,KAAK,EAAE;QAClB,IAAId,EAAE,KAAK,EAAE,EAAE;UAAE;UACfjC,GAAG,IAAI,IAAI,CAAC6B,KAAK,CAACQ,KAAK,CAACV,UAAU,EAAE,IAAI,CAACC,GAAG,CAAC;UAC7C5B,GAAG,IAAI,IAAI,CAACsC,cAAc,CAAC,CAAC;UAC5BX,UAAU,GAAG,IAAI,CAACC,GAAG;QACvB,CAAC,MAAM,IAAIL,SAAS,CAACU,EAAE,CAAC,EAAE;UACxBjC,GAAG,IAAI,IAAI,CAAC6B,KAAK,CAACQ,KAAK,CAACV,UAAU,EAAE,IAAI,CAACC,GAAG,CAAC;UAC7C5B,GAAG,IAAI,IAAI,CAACuC,eAAe,CAAC,KAAK,CAAC;UAClCZ,UAAU,GAAG,IAAI,CAACC,GAAG;QACvB,CAAC,MAAM;UACL,EAAE,IAAI,CAACA,GAAG;QACZ;MACF;MACA5B,GAAG,IAAI,IAAI,CAAC6B,KAAK,CAACQ,KAAK,CAACV,UAAU,EAAE,IAAI,CAACC,GAAG,EAAE,CAAC;MAC/C,OAAO,IAAI,CAACO,WAAW,CAACtD,EAAE,CAACmE,MAAM,EAAEhD,GAAG,CAAC;IACzC;IAEAsC,cAAcA,CAAA,EAAG;MACf,IAAIW,GAAG,GAAG,EAAE;QAAEC,KAAK,GAAG,CAAC;QAAEC,MAAM;MAC/B,IAAIlB,EAAE,GAAG,IAAI,CAACJ,KAAK,CAAC,IAAI,CAACD,GAAG,CAAC;MAC7B,IAAIK,EAAE,KAAK,GAAG,EACZ,IAAI,CAACF,KAAK,CAAC,IAAI,CAACH,GAAG,EAAE,qCAAqC,CAAC;MAC7D,IAAIwB,QAAQ,GAAG,EAAE,IAAI,CAACxB,GAAG;MACzB,OAAO,IAAI,CAACA,GAAG,GAAG,IAAI,CAACC,KAAK,CAACC,MAAM,IAAIoB,KAAK,EAAE,GAAG,EAAE,EAAE;QACnDjB,EAAE,GAAG,IAAI,CAACJ,KAAK,CAAC,IAAI,CAACD,GAAG,EAAE,CAAC;QAC3B,IAAIK,EAAE,KAAK,GAAG,EAAE;UACd,IAAIgB,GAAG,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;YAClB,IAAIA,GAAG,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;cAClBA,GAAG,GAAGA,GAAG,CAACI,MAAM,CAAC,CAAC,CAAC;cACnB,IAAIjF,SAAS,CAACkF,IAAI,CAACL,GAAG,CAAC,EACrBE,MAAM,GAAGV,MAAM,CAACC,YAAY,CAACa,QAAQ,CAACN,GAAG,EAAE,EAAE,CAAC,CAAC;YACnD,CAAC,MAAM;cACLA,GAAG,GAAGA,GAAG,CAACI,MAAM,CAAC,CAAC,CAAC;cACnB,IAAIhF,aAAa,CAACiF,IAAI,CAACL,GAAG,CAAC,EACzBE,MAAM,GAAGV,MAAM,CAACC,YAAY,CAACa,QAAQ,CAACN,GAAG,EAAE,EAAE,CAAC,CAAC;YACnD;UACF,CAAC,MAAM;YACLE,MAAM,GAAGhF,aAAa,CAAC8E,GAAG,CAAC;UAC7B;UACA;QACF;QACAA,GAAG,IAAIhB,EAAE;MACX;MACA,IAAI,CAACkB,MAAM,EAAE;QACX,IAAI,CAACvB,GAAG,GAAGwB,QAAQ;QACnB,OAAO,GAAG;MACZ;MACA,OAAOD,MAAM;IACf;;IAEA;IACA;IACA;IACA;IACA;IACA;;IAEAK,YAAYA,CAAA,EAAG;MACb,IAAIvB,EAAE;QAAED,KAAK,GAAG,IAAI,CAACJ,GAAG;MACxB,GAAG;QACDK,EAAE,GAAG,IAAI,CAACJ,KAAK,CAACK,UAAU,CAAC,EAAE,IAAI,CAACN,GAAG,CAAC;MACxC,CAAC,QAAQH,gBAAgB,CAACQ,EAAE,CAAC,IAAIA,EAAE,KAAK,EAAE,EAAE,CAAC;MAC7C,OAAO,IAAI,CAACE,WAAW,CAACb,GAAG,CAACjC,OAAO,EAAE,IAAI,CAACwC,KAAK,CAACQ,KAAK,CAACL,KAAK,EAAE,IAAI,CAACJ,GAAG,CAAC,CAAC;IACzE;;IAEA;;IAEA6B,mBAAmBA,CAAA,EAAG;MACpB,IAAIC,IAAI,GAAG,IAAI,CAACC,SAAS,CAAC,CAAC;MAC3B,IAAI,IAAI,CAACpD,IAAI,KAAKe,GAAG,CAACjC,OAAO,EAC3BqE,IAAI,CAAClD,IAAI,GAAG,IAAI,CAACoD,KAAK,CAAC,KACpB,IAAI,IAAI,CAACrD,IAAI,CAACsD,OAAO,EACxBH,IAAI,CAAClD,IAAI,GAAG,IAAI,CAACD,IAAI,CAACsD,OAAO,CAAC,KAE9B,IAAI,CAACC,UAAU,CAAC,CAAC;MACnB,IAAI,CAACC,IAAI,CAAC,CAAC;MACX,OAAO,IAAI,CAACC,UAAU,CAACN,IAAI,EAAE,eAAe,CAAC;IAC/C;;IAEA;;IAEAO,uBAAuBA,CAAA,EAAG;MACxB,IAAIb,QAAQ,GAAG,IAAI,CAACpB,KAAK;QAAEkC,QAAQ,GAAG,IAAI,CAACA,QAAQ;MACnD,IAAI1D,IAAI,GAAG,IAAI,CAACiD,mBAAmB,CAAC,CAAC;MACrC,IAAI,CAAC5C,OAAO,CAACE,eAAe,IAAI,CAAC,IAAI,CAACoD,GAAG,CAACtF,EAAE,CAACuF,KAAK,CAAC,EAAE,OAAO5D,IAAI;MAChE,IAAIkD,IAAI,GAAG,IAAI,CAACW,WAAW,CAACjB,QAAQ,EAAEc,QAAQ,CAAC;MAC/CR,IAAI,CAACjD,SAAS,GAAGD,IAAI;MACrBkD,IAAI,CAAClD,IAAI,GAAG,IAAI,CAACiD,mBAAmB,CAAC,CAAC;MACtC,OAAO,IAAI,CAACO,UAAU,CAACN,IAAI,EAAE,mBAAmB,CAAC;IACnD;;IAEA;IACA;;IAEAY,oBAAoBA,CAAA,EAAG;MACrB,IAAI,IAAI,CAAC/D,IAAI,KAAKe,GAAG,CAAC5B,SAAS,EAAE,OAAO,EAAE;MAC1C,IAAI0D,QAAQ,GAAG,IAAI,CAACpB,KAAK;QAAEkC,QAAQ,GAAG,IAAI,CAACA,QAAQ;MACnD,IAAIR,IAAI,GAAG,IAAI,CAACO,uBAAuB,CAAC,CAAC;MACzC,IAAI,IAAI,CAAC1D,IAAI,KAAK1B,EAAE,CAAC0F,GAAG,IAAIb,IAAI,CAACnD,IAAI,KAAK,mBAAmB,IAAI,CAACM,OAAO,CAACG,sBAAsB,EAAE;QAChG,IAAI,CAAC8C,UAAU,CAAC,CAAC;MACnB;MACA,OAAO,IAAI,CAACK,GAAG,CAACtF,EAAE,CAAC0F,GAAG,CAAC,EAAE;QACvB,IAAIC,OAAO,GAAG,IAAI,CAACH,WAAW,CAACjB,QAAQ,EAAEc,QAAQ,CAAC;QAClDM,OAAO,CAAClE,MAAM,GAAGoD,IAAI;QACrBc,OAAO,CAAC9D,QAAQ,GAAG,IAAI,CAAC+C,mBAAmB,CAAC,CAAC;QAC7CC,IAAI,GAAG,IAAI,CAACM,UAAU,CAACQ,OAAO,EAAE,qBAAqB,CAAC;MACxD;MACA,OAAOd,IAAI;IACb;;IAEA;;IAEAe,uBAAuBA,CAAA,EAAG;MACxB,QAAQ,IAAI,CAAClE,IAAI;QACjB,KAAK1B,EAAE,CAAC6F,MAAM;UACZ,IAAIhB,IAAI,GAAG,IAAI,CAACiB,4BAA4B,CAAC,CAAC;UAC9C,IAAIjB,IAAI,CAACkB,UAAU,CAACrE,IAAI,KAAK,oBAAoB,EAC/C,IAAI,CAACwB,KAAK,CAAC2B,IAAI,CAAC1B,KAAK,EAAE,6DAA6D,CAAC;UACvF,OAAO0B,IAAI;QAEb,KAAKpC,GAAG,CAAC9B,WAAW;QACpB,KAAKX,EAAE,CAACmE,MAAM;UACZ,OAAO,IAAI,CAAC6B,aAAa,CAAC,CAAC;QAE7B;UACE,IAAI,CAAC9C,KAAK,CAAC,IAAI,CAACC,KAAK,EAAE,+DAA+D,CAAC;MACzF;IACF;;IAEA;IACA;IACA;;IAEA8C,wBAAwBA,CAAA,EAAG;MACzB,IAAIpB,IAAI,GAAG,IAAI,CAACW,WAAW,CAAC,IAAI,CAACU,UAAU,EAAE,IAAI,CAACC,aAAa,CAAC;MAChE,OAAO,IAAI,CAACC,YAAY,CAACvB,IAAI,EAAE,oBAAoB,EAAE,IAAI,CAAC1B,KAAK,EAAE,IAAI,CAACkC,QAAQ,CAAC;IACjF;;IAEA;;IAEAS,4BAA4BA,CAAA,EAAG;MAC7B,IAAIjB,IAAI,GAAG,IAAI,CAACC,SAAS,CAAC,CAAC;MAC3B,IAAI,CAACI,IAAI,CAAC,CAAC;MACXL,IAAI,CAACkB,UAAU,GAAG,IAAI,CAACrE,IAAI,KAAK1B,EAAE,CAACqG,MAAM,GACrC,IAAI,CAACJ,wBAAwB,CAAC,CAAC,GAC/B,IAAI,CAACK,eAAe,CAAC,CAAC;MAC1B,IAAI,CAACC,MAAM,CAACvG,EAAE,CAACqG,MAAM,CAAC;MACtB,OAAO,IAAI,CAAClB,UAAU,CAACN,IAAI,EAAE,wBAAwB,CAAC;IACxD;;IAEA;;IAEA2B,kBAAkBA,CAAA,EAAG;MACnB,IAAI3B,IAAI,GAAG,IAAI,CAACC,SAAS,CAAC,CAAC;MAC3B,IAAI,IAAI,CAACQ,GAAG,CAACtF,EAAE,CAAC6F,MAAM,CAAC,EAAE;QACvB,IAAI,CAACU,MAAM,CAACvG,EAAE,CAACyG,QAAQ,CAAC;QACxB5B,IAAI,CAAC6B,QAAQ,GAAG,IAAI,CAACC,gBAAgB,CAAC,CAAC;QACvC,IAAI,CAACJ,MAAM,CAACvG,EAAE,CAACqG,MAAM,CAAC;QACtB,OAAO,IAAI,CAAClB,UAAU,CAACN,IAAI,EAAE,oBAAoB,CAAC;MACpD;MACAA,IAAI,CAAClD,IAAI,GAAG,IAAI,CAACyD,uBAAuB,CAAC,CAAC;MAC1CP,IAAI,CAACE,KAAK,GAAG,IAAI,CAACO,GAAG,CAACtF,EAAE,CAAC4G,EAAE,CAAC,GAAG,IAAI,CAAChB,uBAAuB,CAAC,CAAC,GAAG,IAAI;MACpE,OAAO,IAAI,CAACT,UAAU,CAACN,IAAI,EAAE,cAAc,CAAC;IAC9C;;IAEA;;IAEAgC,yBAAyBA,CAACtC,QAAQ,EAAEc,QAAQ,EAAE;MAC5C,IAAIR,IAAI,GAAG,IAAI,CAACW,WAAW,CAACjB,QAAQ,EAAEc,QAAQ,CAAC;MAC/CR,IAAI,CAACiC,UAAU,GAAG,EAAE;MACpB,IAAIC,QAAQ,GAAG,IAAI,CAACtB,oBAAoB,CAAC,CAAC;MAC1C,IAAIsB,QAAQ,EAAElC,IAAI,CAAClD,IAAI,GAAGoF,QAAQ;MAClC,OAAO,IAAI,CAACrF,IAAI,KAAK1B,EAAE,CAACqB,KAAK,IAAI,IAAI,CAACK,IAAI,KAAKe,GAAG,CAAC5B,SAAS,EAC1DgE,IAAI,CAACiC,UAAU,CAAC9F,IAAI,CAAC,IAAI,CAACwF,kBAAkB,CAAC,CAAC,CAAC;MACjD3B,IAAI,CAACmC,WAAW,GAAG,IAAI,CAAC1B,GAAG,CAACtF,EAAE,CAACqB,KAAK,CAAC;MACrC,IAAI,CAACkF,MAAM,CAAC9D,GAAG,CAAC5B,SAAS,CAAC;MAC1B,OAAO,IAAI,CAACsE,UAAU,CAACN,IAAI,EAAEkC,QAAQ,GAAG,mBAAmB,GAAG,oBAAoB,CAAC;IACrF;;IAEA;;IAEAE,yBAAyBA,CAAC1C,QAAQ,EAAEc,QAAQ,EAAE;MAC5C,IAAIR,IAAI,GAAG,IAAI,CAACW,WAAW,CAACjB,QAAQ,EAAEc,QAAQ,CAAC;MAC/C,IAAI0B,QAAQ,GAAG,IAAI,CAACtB,oBAAoB,CAAC,CAAC;MAC1C,IAAIsB,QAAQ,EAAElC,IAAI,CAAClD,IAAI,GAAGoF,QAAQ;MAClC,IAAI,CAACR,MAAM,CAAC9D,GAAG,CAAC5B,SAAS,CAAC;MAC1B,OAAO,IAAI,CAACsE,UAAU,CAACN,IAAI,EAAEkC,QAAQ,GAAG,mBAAmB,GAAG,oBAAoB,CAAC;IACrF;;IAEA;IACA;;IAEAG,kBAAkBA,CAAC3C,QAAQ,EAAEc,QAAQ,EAAE;MACrC,IAAIR,IAAI,GAAG,IAAI,CAACW,WAAW,CAACjB,QAAQ,EAAEc,QAAQ,CAAC;MAC/C,IAAI8B,QAAQ,GAAG,EAAE;MACjB,IAAIC,cAAc,GAAG,IAAI,CAACP,yBAAyB,CAACtC,QAAQ,EAAEc,QAAQ,CAAC;MACvE,IAAIgC,cAAc,GAAG,IAAI;MAEzB,IAAI,CAACD,cAAc,CAACJ,WAAW,EAAE;QAC/BM,QAAQ,EAAE,SAAS;UACjB,QAAQ,IAAI,CAAC5F,IAAI;YACjB,KAAKe,GAAG,CAAC9B,WAAW;cAClB4D,QAAQ,GAAG,IAAI,CAACpB,KAAK;cAAEkC,QAAQ,GAAG,IAAI,CAACA,QAAQ;cAC/C,IAAI,CAACH,IAAI,CAAC,CAAC;cACX,IAAI,IAAI,CAACI,GAAG,CAACtF,EAAE,CAACqB,KAAK,CAAC,EAAE;gBACtBgG,cAAc,GAAG,IAAI,CAACJ,yBAAyB,CAAC1C,QAAQ,EAAEc,QAAQ,CAAC;gBACnE,MAAMiC,QAAQ;cAChB;cACAH,QAAQ,CAACnG,IAAI,CAAC,IAAI,CAACkG,kBAAkB,CAAC3C,QAAQ,EAAEc,QAAQ,CAAC,CAAC;cAC1D;YAEF,KAAK5C,GAAG,CAAChC,OAAO;cACd0G,QAAQ,CAACnG,IAAI,CAAC,IAAI,CAACgF,aAAa,CAAC,CAAC,CAAC;cACnC;YAEF,KAAKhG,EAAE,CAAC6F,MAAM;cACZsB,QAAQ,CAACnG,IAAI,CAAC,IAAI,CAAC8E,4BAA4B,CAAC,CAAC,CAAC;cAClD;YAEF;cACE,IAAI,CAACb,UAAU,CAAC,CAAC;UACnB;QACF;QACA,IAAIzD,mBAAmB,CAAC6F,cAAc,CAAC1F,IAAI,CAAC,KAAKH,mBAAmB,CAAC4F,cAAc,CAACzF,IAAI,CAAC,EAAE;UACzF,IAAI,CAACuB,KAAK,CACRmE,cAAc,CAAClE,KAAK,EACpB,8CAA8C,GAAG3B,mBAAmB,CAAC4F,cAAc,CAACzF,IAAI,CAAC,GAAG,GAAG,CAAC;QACpG;MACF;MACA,IAAI4F,iBAAiB,GAAGH,cAAc,CAACzF,IAAI,GAAG,SAAS,GAAG,UAAU;MAEpEkD,IAAI,CAAC,SAAS,GAAG0C,iBAAiB,CAAC,GAAGH,cAAc;MACpDvC,IAAI,CAAC,SAAS,GAAG0C,iBAAiB,CAAC,GAAGF,cAAc;MACpDxC,IAAI,CAACsC,QAAQ,GAAGA,QAAQ;MACxB,IAAI,IAAI,CAACzF,IAAI,KAAK1B,EAAE,CAACwH,UAAU,IAAI,IAAI,CAACzC,KAAK,KAAK,GAAG,EAAE;QACrD,IAAI,CAAC7B,KAAK,CAAC,IAAI,CAACC,KAAK,EAAE,2DAA2D,CAAC;MACrF;MACA,OAAO,IAAI,CAACgC,UAAU,CAACN,IAAI,EAAE,KAAK,GAAG0C,iBAAiB,CAAC;IACzD;;IAEA;;IAEAE,aAAaA,CAAA,EAAG;MACd,IAAI5C,IAAI,GAAG,IAAI,CAAC6C,YAAY,CAAC,IAAI,CAAC3C,KAAK,CAAC;MACxCF,IAAI,CAACnD,IAAI,GAAG,SAAS;MACrB,OAAOmD,IAAI;IACb;;IAEA;;IAEA8C,gBAAgBA,CAAA,EAAG;MACjB,IAAIpD,QAAQ,GAAG,IAAI,CAACpB,KAAK;QAAEkC,QAAQ,GAAG,IAAI,CAACA,QAAQ;MACnD,IAAI,CAACH,IAAI,CAAC,CAAC;MACX,OAAO,IAAI,CAACgC,kBAAkB,CAAC3C,QAAQ,EAAEc,QAAQ,CAAC;IACpD;IAEAW,aAAaA,CAAC4B,sBAAsB,EAAE;MACpC,IAAI,IAAI,CAAClG,IAAI,KAAKe,GAAG,CAAChC,OAAO,EAC3B,OAAO,IAAI,CAACgH,aAAa,CAAC,CAAC,CAAC,KACzB,IAAI,IAAI,CAAC/F,IAAI,KAAKe,GAAG,CAAC9B,WAAW,EACpC,OAAO,IAAI,CAACgH,gBAAgB,CAAC,CAAC,CAAC,KAE/B,OAAO,KAAK,CAAC3B,aAAa,CAAC4B,sBAAsB,CAAC;IACtD;IAEAC,SAASA,CAACC,IAAI,EAAE;MACd,IAAI/G,OAAO,GAAG,IAAI,CAACO,UAAU,CAAC,CAAC;MAE/B,IAAIP,OAAO,KAAKT,OAAO,EAAE,OAAO,IAAI,CAACuC,aAAa,CAAC,CAAC;MAEpD,IAAI9B,OAAO,KAAKX,OAAO,IAAIW,OAAO,KAAKV,OAAO,EAAE;QAC9C,IAAIsC,iBAAiB,CAACmF,IAAI,CAAC,EAAE,OAAO,IAAI,CAACnD,YAAY,CAAC,CAAC;QAEvD,IAAImD,IAAI,IAAI,EAAE,EAAE;UACd,EAAE,IAAI,CAAC/E,GAAG;UACV,OAAO,IAAI,CAACO,WAAW,CAACb,GAAG,CAAC5B,SAAS,CAAC;QACxC;QAEA,IAAI,CAACiH,IAAI,KAAK,EAAE,IAAIA,IAAI,KAAK,EAAE,KAAK/G,OAAO,IAAIX,OAAO,EACpD,OAAO,IAAI,CAAC6D,cAAc,CAAC6D,IAAI,CAAC;MACpC;MAEA,IAAIA,IAAI,KAAK,EAAE,IAAI,IAAI,CAAC7G,WAAW,IAAI,IAAI,CAAC+B,KAAK,CAACK,UAAU,CAAC,IAAI,CAACN,GAAG,GAAG,CAAC,CAAC,KAAK,EAAE,EAAE;QACjF,EAAE,IAAI,CAACA,GAAG;QACV,OAAO,IAAI,CAACO,WAAW,CAACb,GAAG,CAAC9B,WAAW,CAAC;MAC1C;MACA,OAAO,KAAK,CAACkH,SAAS,CAACC,IAAI,CAAC;IAC9B;IAEAhH,aAAaA,CAACI,QAAQ,EAAE;MACtB,IAAI,IAAI,CAACQ,IAAI,IAAI1B,EAAE,CAAC6F,MAAM,EAAE;QAC1B,IAAIvE,UAAU,GAAG,IAAI,CAACA,UAAU,CAAC,CAAC;QAClC,IAAIA,UAAU,IAAIlB,OAAO,EAAE,IAAI,CAACW,OAAO,CAACC,IAAI,CAACT,WAAW,CAACwH,MAAM,CAAC,CAAC,KAC5D,IAAIzG,UAAU,IAAIhB,OAAO,EAAE,IAAI,CAACS,OAAO,CAACC,IAAI,CAACT,WAAW,CAACyH,MAAM,CAAC,CAAC,KACjE,KAAK,CAAClH,aAAa,CAACI,QAAQ,CAAC;QAClC,IAAI,CAACD,WAAW,GAAG,IAAI;MACzB,CAAC,MAAM,IAAI,IAAI,CAACS,IAAI,KAAK1B,EAAE,CAACqB,KAAK,IAAIH,QAAQ,KAAKuB,GAAG,CAAC9B,WAAW,EAAE;QACjE,IAAI,CAACI,OAAO,CAACkC,MAAM,IAAI,CAAC,CAAC,CAAC;QAC1B,IAAI,CAAClC,OAAO,CAACC,IAAI,CAACX,OAAO,CAAC,CAAC,CAAC;QAC5B,IAAI,CAACY,WAAW,GAAG,KAAK;MAC1B,CAAC,MAAM;QACL,OAAO,KAAK,CAACH,aAAa,CAACI,QAAQ,CAAC;MACtC;IACF;EACF,CAAC;AACH"},"metadata":{},"sourceType":"script","externalDependencies":[]}