{"ast":null,"code":"/**\n * @fileoverview Rule that warns about used warning comments\n * @author Alexander Schmidt <https://github.com/lxanders>\n */\n\n\"use strict\";\n\nrequire(\"core-js/modules/es.array.push.js\");\nconst escapeRegExp = require(\"escape-string-regexp\");\nconst astUtils = require(\"./utils/ast-utils\");\nconst CHAR_LIMIT = 40;\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow specified warning terms in comments\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-warning-comments\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        terms: {\n          type: \"array\",\n          items: {\n            type: \"string\"\n          }\n        },\n        location: {\n          enum: [\"start\", \"anywhere\"]\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unexpectedComment: \"Unexpected '{{matchedTerm}}' comment: '{{comment}}'.\"\n    }\n  },\n  create(context) {\n    const sourceCode = context.getSourceCode(),\n      configuration = context.options[0] || {},\n      warningTerms = configuration.terms || [\"todo\", \"fixme\", \"xxx\"],\n      location = configuration.location || \"start\",\n      selfConfigRegEx = /\\bno-warning-comments\\b/u;\n\n    /**\n     * Convert a warning term into a RegExp which will match a comment containing that whole word in the specified\n     * location (\"start\" or \"anywhere\"). If the term starts or ends with non word characters, then the match will not\n     * require word boundaries on that side.\n     * @param {string} term A term to convert to a RegExp\n     * @returns {RegExp} The term converted to a RegExp\n     */\n    function convertToRegExp(term) {\n      const escaped = escapeRegExp(term);\n      const wordBoundary = \"\\\\b\";\n      const eitherOrWordBoundary = `|${wordBoundary}`;\n      let prefix;\n\n      /*\n       * If the term ends in a word character (a-z0-9_), ensure a word\n       * boundary at the end, so that substrings do not get falsely\n       * matched. eg \"todo\" in a string such as \"mastodon\".\n       * If the term ends in a non-word character, then \\b won't match on\n       * the boundary to the next non-word character, which would likely\n       * be a space. For example `/\\bFIX!\\b/.test('FIX! blah') === false`.\n       * In these cases, use no bounding match. Same applies for the\n       * prefix, handled below.\n       */\n      const suffix = /\\w$/u.test(term) ? \"\\\\b\" : \"\";\n      if (location === \"start\") {\n        /*\n         * When matching at the start, ignore leading whitespace, and\n         * there's no need to worry about word boundaries.\n         */\n        prefix = \"^\\\\s*\";\n      } else if (/^\\w/u.test(term)) {\n        prefix = wordBoundary;\n      } else {\n        prefix = \"\";\n      }\n      if (location === \"start\") {\n        /*\n         * For location \"start\" the regex should be\n         * ^\\s*TERM\\b.  This checks the word boundary\n         * at the beginning of the comment.\n         */\n        return new RegExp(prefix + escaped + suffix, \"iu\");\n      }\n\n      /*\n       * For location \"anywhere\" the regex should be\n       * \\bTERM\\b|\\bTERM\\b, this checks the entire comment\n       * for the term.\n       */\n      return new RegExp(prefix + escaped + suffix + eitherOrWordBoundary + term + wordBoundary, \"iu\");\n    }\n    const warningRegExps = warningTerms.map(convertToRegExp);\n\n    /**\n     * Checks the specified comment for matches of the configured warning terms and returns the matches.\n     * @param {string} comment The comment which is checked.\n     * @returns {Array} All matched warning terms for this comment.\n     */\n    function commentContainsWarningTerm(comment) {\n      const matches = [];\n      warningRegExps.forEach((regex, index) => {\n        if (regex.test(comment)) {\n          matches.push(warningTerms[index]);\n        }\n      });\n      return matches;\n    }\n\n    /**\n     * Checks the specified node for matching warning comments and reports them.\n     * @param {ASTNode} node The AST node being checked.\n     * @returns {void} undefined.\n     */\n    function checkComment(node) {\n      const comment = node.value;\n      if (astUtils.isDirectiveComment(node) && selfConfigRegEx.test(comment)) {\n        return;\n      }\n      const matches = commentContainsWarningTerm(comment);\n      matches.forEach(matchedTerm => {\n        let commentToDisplay = \"\";\n        let truncated = false;\n        for (const c of comment.trim().split(/\\s+/u)) {\n          const tmp = commentToDisplay ? `${commentToDisplay} ${c}` : c;\n          if (tmp.length <= CHAR_LIMIT) {\n            commentToDisplay = tmp;\n          } else {\n            truncated = true;\n            break;\n          }\n        }\n        context.report({\n          node,\n          messageId: \"unexpectedComment\",\n          data: {\n            matchedTerm,\n            comment: `${commentToDisplay}${truncated ? \"...\" : \"\"}`\n          }\n        });\n      });\n    }\n    return {\n      Program() {\n        const comments = sourceCode.getAllComments();\n        comments.filter(token => token.type !== \"Shebang\").forEach(checkComment);\n      }\n    };\n  }\n};","map":{"version":3,"names":["require","escapeRegExp","astUtils","CHAR_LIMIT","module","exports","meta","type","docs","description","category","recommended","url","schema","properties","terms","items","location","enum","additionalProperties","messages","unexpectedComment","create","context","sourceCode","getSourceCode","configuration","options","warningTerms","selfConfigRegEx","convertToRegExp","term","escaped","wordBoundary","eitherOrWordBoundary","prefix","suffix","test","RegExp","warningRegExps","map","commentContainsWarningTerm","comment","matches","forEach","regex","index","push","checkComment","node","value","isDirectiveComment","matchedTerm","commentToDisplay","truncated","c","trim","split","tmp","length","report","messageId","data","Program","comments","getAllComments","filter","token"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/no-warning-comments.js"],"sourcesContent":["/**\n * @fileoverview Rule that warns about used warning comments\n * @author Alexander Schmidt <https://github.com/lxanders>\n */\n\n\"use strict\";\n\nconst escapeRegExp = require(\"escape-string-regexp\");\nconst astUtils = require(\"./utils/ast-utils\");\n\nconst CHAR_LIMIT = 40;\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow specified warning terms in comments\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-warning-comments\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    terms: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        }\n                    },\n                    location: {\n                        enum: [\"start\", \"anywhere\"]\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            unexpectedComment: \"Unexpected '{{matchedTerm}}' comment: '{{comment}}'.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode(),\n            configuration = context.options[0] || {},\n            warningTerms = configuration.terms || [\"todo\", \"fixme\", \"xxx\"],\n            location = configuration.location || \"start\",\n            selfConfigRegEx = /\\bno-warning-comments\\b/u;\n\n        /**\n         * Convert a warning term into a RegExp which will match a comment containing that whole word in the specified\n         * location (\"start\" or \"anywhere\"). If the term starts or ends with non word characters, then the match will not\n         * require word boundaries on that side.\n         * @param {string} term A term to convert to a RegExp\n         * @returns {RegExp} The term converted to a RegExp\n         */\n        function convertToRegExp(term) {\n            const escaped = escapeRegExp(term);\n            const wordBoundary = \"\\\\b\";\n            const eitherOrWordBoundary = `|${wordBoundary}`;\n            let prefix;\n\n            /*\n             * If the term ends in a word character (a-z0-9_), ensure a word\n             * boundary at the end, so that substrings do not get falsely\n             * matched. eg \"todo\" in a string such as \"mastodon\".\n             * If the term ends in a non-word character, then \\b won't match on\n             * the boundary to the next non-word character, which would likely\n             * be a space. For example `/\\bFIX!\\b/.test('FIX! blah') === false`.\n             * In these cases, use no bounding match. Same applies for the\n             * prefix, handled below.\n             */\n            const suffix = /\\w$/u.test(term) ? \"\\\\b\" : \"\";\n\n            if (location === \"start\") {\n\n                /*\n                 * When matching at the start, ignore leading whitespace, and\n                 * there's no need to worry about word boundaries.\n                 */\n                prefix = \"^\\\\s*\";\n            } else if (/^\\w/u.test(term)) {\n                prefix = wordBoundary;\n            } else {\n                prefix = \"\";\n            }\n\n            if (location === \"start\") {\n\n                /*\n                 * For location \"start\" the regex should be\n                 * ^\\s*TERM\\b.  This checks the word boundary\n                 * at the beginning of the comment.\n                 */\n                return new RegExp(prefix + escaped + suffix, \"iu\");\n            }\n\n            /*\n             * For location \"anywhere\" the regex should be\n             * \\bTERM\\b|\\bTERM\\b, this checks the entire comment\n             * for the term.\n             */\n            return new RegExp(\n                prefix +\n                    escaped +\n                    suffix +\n                    eitherOrWordBoundary +\n                    term +\n                    wordBoundary,\n                \"iu\"\n            );\n        }\n\n        const warningRegExps = warningTerms.map(convertToRegExp);\n\n        /**\n         * Checks the specified comment for matches of the configured warning terms and returns the matches.\n         * @param {string} comment The comment which is checked.\n         * @returns {Array} All matched warning terms for this comment.\n         */\n        function commentContainsWarningTerm(comment) {\n            const matches = [];\n\n            warningRegExps.forEach((regex, index) => {\n                if (regex.test(comment)) {\n                    matches.push(warningTerms[index]);\n                }\n            });\n\n            return matches;\n        }\n\n        /**\n         * Checks the specified node for matching warning comments and reports them.\n         * @param {ASTNode} node The AST node being checked.\n         * @returns {void} undefined.\n         */\n        function checkComment(node) {\n            const comment = node.value;\n\n            if (\n                astUtils.isDirectiveComment(node) &&\n                selfConfigRegEx.test(comment)\n            ) {\n                return;\n            }\n\n            const matches = commentContainsWarningTerm(comment);\n\n            matches.forEach(matchedTerm => {\n                let commentToDisplay = \"\";\n                let truncated = false;\n\n                for (const c of comment.trim().split(/\\s+/u)) {\n                    const tmp = commentToDisplay ? `${commentToDisplay} ${c}` : c;\n\n                    if (tmp.length <= CHAR_LIMIT) {\n                        commentToDisplay = tmp;\n                    } else {\n                        truncated = true;\n                        break;\n                    }\n                }\n\n                context.report({\n                    node,\n                    messageId: \"unexpectedComment\",\n                    data: {\n                        matchedTerm,\n                        comment: `${commentToDisplay}${\n                            truncated ? \"...\" : \"\"\n                        }`\n                    }\n                });\n            });\n        }\n\n        return {\n            Program() {\n                const comments = sourceCode.getAllComments();\n\n                comments\n                    .filter(token => token.type !== \"Shebang\")\n                    .forEach(checkComment);\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}