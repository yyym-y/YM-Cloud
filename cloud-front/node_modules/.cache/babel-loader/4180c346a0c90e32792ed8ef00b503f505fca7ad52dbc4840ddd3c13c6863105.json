{"ast":null,"code":"/**\n * @fileoverview Rule to flag numbers that will lose significant figure precision at runtime\n * @author Jacob Moore\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow literal numbers that lose precision\",\n      category: \"Possible Errors\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-loss-of-precision\"\n    },\n    schema: [],\n    messages: {\n      noLossOfPrecision: \"This number literal will lose precision at runtime.\"\n    }\n  },\n  create(context) {\n    /**\n     * Returns whether the node is number literal\n     * @param {Node} node the node literal being evaluated\n     * @returns {boolean} true if the node is a number literal\n     */\n    function isNumber(node) {\n      return typeof node.value === \"number\";\n    }\n\n    /**\n     * Gets the source code of the given number literal. Removes `_` numeric separators from the result.\n     * @param {Node} node the number `Literal` node\n     * @returns {string} raw source code of the literal, without numeric separators\n     */\n    function getRaw(node) {\n      return node.raw.replace(/_/gu, \"\");\n    }\n\n    /**\n     * Checks whether the number is  base ten\n     * @param {ASTNode} node the node being evaluated\n     * @returns {boolean} true if the node is in base ten\n     */\n    function isBaseTen(node) {\n      const prefixes = [\"0x\", \"0X\", \"0b\", \"0B\", \"0o\", \"0O\"];\n      return prefixes.every(prefix => !node.raw.startsWith(prefix)) && !/^0[0-7]+$/u.test(node.raw);\n    }\n\n    /**\n     * Checks that the user-intended non-base ten number equals the actual number after is has been converted to the Number type\n     * @param {Node} node the node being evaluated\n     * @returns {boolean} true if they do not match\n     */\n    function notBaseTenLosesPrecision(node) {\n      const rawString = getRaw(node).toUpperCase();\n      let base = 0;\n      if (rawString.startsWith(\"0B\")) {\n        base = 2;\n      } else if (rawString.startsWith(\"0X\")) {\n        base = 16;\n      } else {\n        base = 8;\n      }\n      return !rawString.endsWith(node.value.toString(base).toUpperCase());\n    }\n\n    /**\n     * Adds a decimal point to the numeric string at index 1\n     * @param {string} stringNumber the numeric string without any decimal point\n     * @returns {string} the numeric string with a decimal point in the proper place\n     */\n    function addDecimalPointToNumber(stringNumber) {\n      return `${stringNumber.slice(0, 1)}.${stringNumber.slice(1)}`;\n    }\n\n    /**\n     * Returns the number stripped of leading zeros\n     * @param {string} numberAsString the string representation of the number\n     * @returns {string} the stripped string\n     */\n    function removeLeadingZeros(numberAsString) {\n      return numberAsString.replace(/^0*/u, \"\");\n    }\n\n    /**\n     * Returns the number stripped of trailing zeros\n     * @param {string} numberAsString the string representation of the number\n     * @returns {string} the stripped string\n     */\n    function removeTrailingZeros(numberAsString) {\n      return numberAsString.replace(/0*$/u, \"\");\n    }\n\n    /**\n     * Converts an integer to to an object containing the integer's coefficient and order of magnitude\n     * @param {string} stringInteger the string representation of the integer being converted\n     * @returns {Object} the object containing the integer's coefficient and order of magnitude\n     */\n    function normalizeInteger(stringInteger) {\n      const significantDigits = removeTrailingZeros(removeLeadingZeros(stringInteger));\n      return {\n        magnitude: stringInteger.startsWith(\"0\") ? stringInteger.length - 2 : stringInteger.length - 1,\n        coefficient: addDecimalPointToNumber(significantDigits)\n      };\n    }\n\n    /**\n     *\n     * Converts a float to to an object containing the floats's coefficient and order of magnitude\n     * @param {string} stringFloat the string representation of the float being converted\n     * @returns {Object} the object containing the integer's coefficient and order of magnitude\n     */\n    function normalizeFloat(stringFloat) {\n      const trimmedFloat = removeLeadingZeros(stringFloat);\n      if (trimmedFloat.startsWith(\".\")) {\n        const decimalDigits = trimmedFloat.split(\".\").pop();\n        const significantDigits = removeLeadingZeros(decimalDigits);\n        return {\n          magnitude: significantDigits.length - decimalDigits.length - 1,\n          coefficient: addDecimalPointToNumber(significantDigits)\n        };\n      }\n      return {\n        magnitude: trimmedFloat.indexOf(\".\") - 1,\n        coefficient: addDecimalPointToNumber(trimmedFloat.replace(\".\", \"\"))\n      };\n    }\n\n    /**\n     * Converts a base ten number to proper scientific notation\n     * @param {string} stringNumber the string representation of the base ten number to be converted\n     * @returns {string} the number converted to scientific notation\n     */\n    function convertNumberToScientificNotation(stringNumber) {\n      const splitNumber = stringNumber.replace(\"E\", \"e\").split(\"e\");\n      const originalCoefficient = splitNumber[0];\n      const normalizedNumber = stringNumber.includes(\".\") ? normalizeFloat(originalCoefficient) : normalizeInteger(originalCoefficient);\n      const normalizedCoefficient = normalizedNumber.coefficient;\n      const magnitude = splitNumber.length > 1 ? parseInt(splitNumber[1], 10) + normalizedNumber.magnitude : normalizedNumber.magnitude;\n      return `${normalizedCoefficient}e${magnitude}`;\n    }\n\n    /**\n     * Checks that the user-intended base ten number equals the actual number after is has been converted to the Number type\n     * @param {Node} node the node being evaluated\n     * @returns {boolean} true if they do not match\n     */\n    function baseTenLosesPrecision(node) {\n      const normalizedRawNumber = convertNumberToScientificNotation(getRaw(node));\n      const requestedPrecision = normalizedRawNumber.split(\"e\")[0].replace(\".\", \"\").length;\n      if (requestedPrecision > 100) {\n        return true;\n      }\n      const storedNumber = node.value.toPrecision(requestedPrecision);\n      const normalizedStoredNumber = convertNumberToScientificNotation(storedNumber);\n      return normalizedRawNumber !== normalizedStoredNumber;\n    }\n\n    /**\n     * Checks that the user-intended number equals the actual number after is has been converted to the Number type\n     * @param {Node} node the node being evaluated\n     * @returns {boolean} true if they do not match\n     */\n    function losesPrecision(node) {\n      return isBaseTen(node) ? baseTenLosesPrecision(node) : notBaseTenLosesPrecision(node);\n    }\n    return {\n      Literal(node) {\n        if (node.value && isNumber(node) && losesPrecision(node)) {\n          context.report({\n            messageId: \"noLossOfPrecision\",\n            node\n          });\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["module","exports","meta","type","docs","description","category","recommended","url","schema","messages","noLossOfPrecision","create","context","isNumber","node","value","getRaw","raw","replace","isBaseTen","prefixes","every","prefix","startsWith","test","notBaseTenLosesPrecision","rawString","toUpperCase","base","endsWith","toString","addDecimalPointToNumber","stringNumber","slice","removeLeadingZeros","numberAsString","removeTrailingZeros","normalizeInteger","stringInteger","significantDigits","magnitude","length","coefficient","normalizeFloat","stringFloat","trimmedFloat","decimalDigits","split","pop","indexOf","convertNumberToScientificNotation","splitNumber","originalCoefficient","normalizedNumber","includes","normalizedCoefficient","parseInt","baseTenLosesPrecision","normalizedRawNumber","requestedPrecision","storedNumber","toPrecision","normalizedStoredNumber","losesPrecision","Literal","report","messageId"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/no-loss-of-precision.js"],"sourcesContent":["/**\n * @fileoverview Rule to flag numbers that will lose significant figure precision at runtime\n * @author Jacob Moore\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow literal numbers that lose precision\",\n            category: \"Possible Errors\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-loss-of-precision\"\n        },\n        schema: [],\n        messages: {\n            noLossOfPrecision: \"This number literal will lose precision at runtime.\"\n        }\n    },\n\n    create(context) {\n\n        /**\n         * Returns whether the node is number literal\n         * @param {Node} node the node literal being evaluated\n         * @returns {boolean} true if the node is a number literal\n         */\n        function isNumber(node) {\n            return typeof node.value === \"number\";\n        }\n\n        /**\n         * Gets the source code of the given number literal. Removes `_` numeric separators from the result.\n         * @param {Node} node the number `Literal` node\n         * @returns {string} raw source code of the literal, without numeric separators\n         */\n        function getRaw(node) {\n            return node.raw.replace(/_/gu, \"\");\n        }\n\n        /**\n         * Checks whether the number is  base ten\n         * @param {ASTNode} node the node being evaluated\n         * @returns {boolean} true if the node is in base ten\n         */\n        function isBaseTen(node) {\n            const prefixes = [\"0x\", \"0X\", \"0b\", \"0B\", \"0o\", \"0O\"];\n\n            return prefixes.every(prefix => !node.raw.startsWith(prefix)) &&\n            !/^0[0-7]+$/u.test(node.raw);\n        }\n\n        /**\n         * Checks that the user-intended non-base ten number equals the actual number after is has been converted to the Number type\n         * @param {Node} node the node being evaluated\n         * @returns {boolean} true if they do not match\n         */\n        function notBaseTenLosesPrecision(node) {\n            const rawString = getRaw(node).toUpperCase();\n            let base = 0;\n\n            if (rawString.startsWith(\"0B\")) {\n                base = 2;\n            } else if (rawString.startsWith(\"0X\")) {\n                base = 16;\n            } else {\n                base = 8;\n            }\n\n            return !rawString.endsWith(node.value.toString(base).toUpperCase());\n        }\n\n        /**\n         * Adds a decimal point to the numeric string at index 1\n         * @param {string} stringNumber the numeric string without any decimal point\n         * @returns {string} the numeric string with a decimal point in the proper place\n         */\n        function addDecimalPointToNumber(stringNumber) {\n            return `${stringNumber.slice(0, 1)}.${stringNumber.slice(1)}`;\n        }\n\n        /**\n         * Returns the number stripped of leading zeros\n         * @param {string} numberAsString the string representation of the number\n         * @returns {string} the stripped string\n         */\n        function removeLeadingZeros(numberAsString) {\n            return numberAsString.replace(/^0*/u, \"\");\n        }\n\n        /**\n         * Returns the number stripped of trailing zeros\n         * @param {string} numberAsString the string representation of the number\n         * @returns {string} the stripped string\n         */\n        function removeTrailingZeros(numberAsString) {\n            return numberAsString.replace(/0*$/u, \"\");\n        }\n\n        /**\n         * Converts an integer to to an object containing the integer's coefficient and order of magnitude\n         * @param {string} stringInteger the string representation of the integer being converted\n         * @returns {Object} the object containing the integer's coefficient and order of magnitude\n         */\n        function normalizeInteger(stringInteger) {\n            const significantDigits = removeTrailingZeros(removeLeadingZeros(stringInteger));\n\n            return {\n                magnitude: stringInteger.startsWith(\"0\") ? stringInteger.length - 2 : stringInteger.length - 1,\n                coefficient: addDecimalPointToNumber(significantDigits)\n            };\n        }\n\n        /**\n         *\n         * Converts a float to to an object containing the floats's coefficient and order of magnitude\n         * @param {string} stringFloat the string representation of the float being converted\n         * @returns {Object} the object containing the integer's coefficient and order of magnitude\n         */\n        function normalizeFloat(stringFloat) {\n            const trimmedFloat = removeLeadingZeros(stringFloat);\n\n            if (trimmedFloat.startsWith(\".\")) {\n                const decimalDigits = trimmedFloat.split(\".\").pop();\n                const significantDigits = removeLeadingZeros(decimalDigits);\n\n                return {\n                    magnitude: significantDigits.length - decimalDigits.length - 1,\n                    coefficient: addDecimalPointToNumber(significantDigits)\n                };\n\n            }\n            return {\n                magnitude: trimmedFloat.indexOf(\".\") - 1,\n                coefficient: addDecimalPointToNumber(trimmedFloat.replace(\".\", \"\"))\n\n            };\n        }\n\n\n        /**\n         * Converts a base ten number to proper scientific notation\n         * @param {string} stringNumber the string representation of the base ten number to be converted\n         * @returns {string} the number converted to scientific notation\n         */\n        function convertNumberToScientificNotation(stringNumber) {\n            const splitNumber = stringNumber.replace(\"E\", \"e\").split(\"e\");\n            const originalCoefficient = splitNumber[0];\n            const normalizedNumber = stringNumber.includes(\".\") ? normalizeFloat(originalCoefficient)\n                : normalizeInteger(originalCoefficient);\n            const normalizedCoefficient = normalizedNumber.coefficient;\n            const magnitude = splitNumber.length > 1 ? (parseInt(splitNumber[1], 10) + normalizedNumber.magnitude)\n                : normalizedNumber.magnitude;\n\n            return `${normalizedCoefficient}e${magnitude}`;\n\n        }\n\n        /**\n         * Checks that the user-intended base ten number equals the actual number after is has been converted to the Number type\n         * @param {Node} node the node being evaluated\n         * @returns {boolean} true if they do not match\n         */\n        function baseTenLosesPrecision(node) {\n            const normalizedRawNumber = convertNumberToScientificNotation(getRaw(node));\n            const requestedPrecision = normalizedRawNumber.split(\"e\")[0].replace(\".\", \"\").length;\n\n            if (requestedPrecision > 100) {\n                return true;\n            }\n            const storedNumber = node.value.toPrecision(requestedPrecision);\n            const normalizedStoredNumber = convertNumberToScientificNotation(storedNumber);\n\n            return normalizedRawNumber !== normalizedStoredNumber;\n        }\n\n\n        /**\n         * Checks that the user-intended number equals the actual number after is has been converted to the Number type\n         * @param {Node} node the node being evaluated\n         * @returns {boolean} true if they do not match\n         */\n        function losesPrecision(node) {\n            return isBaseTen(node) ? baseTenLosesPrecision(node) : notBaseTenLosesPrecision(node);\n        }\n\n\n        return {\n            Literal(node) {\n                if (node.value && isNumber(node) && losesPrecision(node)) {\n                    context.report({\n                        messageId: \"noLossOfPrecision\",\n                        node\n                    });\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}