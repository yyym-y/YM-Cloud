{"ast":null,"code":"/**\n * @fileoverview A helper that translates context.report() calls from the rule API into generic problem objects\n * @author Teddy Katz\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst assert = require(\"assert\");\nconst ruleFixer = require(\"./rule-fixer\");\nconst interpolate = require(\"./interpolate\");\n\n//------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/**\n * An error message description\n * @typedef {Object} MessageDescriptor\n * @property {ASTNode} [node] The reported node\n * @property {Location} loc The location of the problem.\n * @property {string} message The problem message.\n * @property {Object} [data] Optional data to use to fill in placeholders in the\n *      message.\n * @property {Function} [fix] The function to call that creates a fix command.\n * @property {Array<{desc?: string, messageId?: string, fix: Function}>} suggest Suggestion descriptions and functions to create a the associated fixes.\n */\n\n/**\n * Information about the report\n * @typedef {Object} ReportInfo\n * @property {string} ruleId\n * @property {(0|1|2)} severity\n * @property {(string|undefined)} message\n * @property {(string|undefined)} [messageId]\n * @property {number} line\n * @property {number} column\n * @property {(number|undefined)} [endLine]\n * @property {(number|undefined)} [endColumn]\n * @property {(string|null)} nodeType\n * @property {string} source\n * @property {({text: string, range: (number[]|null)}|null)} [fix]\n * @property {Array<{text: string, range: (number[]|null)}|null>} [suggestions]\n */\n\n//------------------------------------------------------------------------------\n// Module Definition\n//------------------------------------------------------------------------------\n\n/**\n * Translates a multi-argument context.report() call into a single object argument call\n * @param {...*} args A list of arguments passed to `context.report`\n * @returns {MessageDescriptor} A normalized object containing report information\n */\nfunction normalizeMultiArgReportCall(...args) {\n  // If there is one argument, it is considered to be a new-style call already.\n  if (args.length === 1) {\n    // Shallow clone the object to avoid surprises if reusing the descriptor\n    return Object.assign({}, args[0]);\n  }\n\n  // If the second argument is a string, the arguments are interpreted as [node, message, data, fix].\n  if (typeof args[1] === \"string\") {\n    return {\n      node: args[0],\n      message: args[1],\n      data: args[2],\n      fix: args[3]\n    };\n  }\n\n  // Otherwise, the arguments are interpreted as [node, loc, message, data, fix].\n  return {\n    node: args[0],\n    loc: args[1],\n    message: args[2],\n    data: args[3],\n    fix: args[4]\n  };\n}\n\n/**\n * Asserts that either a loc or a node was provided, and the node is valid if it was provided.\n * @param {MessageDescriptor} descriptor A descriptor to validate\n * @returns {void}\n * @throws AssertionError if neither a node nor a loc was provided, or if the node is not an object\n */\nfunction assertValidNodeInfo(descriptor) {\n  if (descriptor.node) {\n    assert(typeof descriptor.node === \"object\", \"Node must be an object\");\n  } else {\n    assert(descriptor.loc, \"Node must be provided when reporting error if location is not provided\");\n  }\n}\n\n/**\n * Normalizes a MessageDescriptor to always have a `loc` with `start` and `end` properties\n * @param {MessageDescriptor} descriptor A descriptor for the report from a rule.\n * @returns {{start: Location, end: (Location|null)}} An updated location that infers the `start` and `end` properties\n * from the `node` of the original descriptor, or infers the `start` from the `loc` of the original descriptor.\n */\nfunction normalizeReportLoc(descriptor) {\n  if (descriptor.loc) {\n    if (descriptor.loc.start) {\n      return descriptor.loc;\n    }\n    return {\n      start: descriptor.loc,\n      end: null\n    };\n  }\n  return descriptor.node.loc;\n}\n\n/**\n * Check that a fix has a valid range.\n * @param {Fix|null} fix The fix to validate.\n * @returns {void}\n */\nfunction assertValidFix(fix) {\n  if (fix) {\n    assert(fix.range && typeof fix.range[0] === \"number\" && typeof fix.range[1] === \"number\", `Fix has invalid range: ${JSON.stringify(fix, null, 2)}`);\n  }\n}\n\n/**\n * Compares items in a fixes array by range.\n * @param {Fix} a The first message.\n * @param {Fix} b The second message.\n * @returns {int} -1 if a comes before b, 1 if a comes after b, 0 if equal.\n * @private\n */\nfunction compareFixesByRange(a, b) {\n  return a.range[0] - b.range[0] || a.range[1] - b.range[1];\n}\n\n/**\n * Merges the given fixes array into one.\n * @param {Fix[]} fixes The fixes to merge.\n * @param {SourceCode} sourceCode The source code object to get the text between fixes.\n * @returns {{text: string, range: number[]}} The merged fixes\n */\nfunction mergeFixes(fixes, sourceCode) {\n  for (const fix of fixes) {\n    assertValidFix(fix);\n  }\n  if (fixes.length === 0) {\n    return null;\n  }\n  if (fixes.length === 1) {\n    return fixes[0];\n  }\n  fixes.sort(compareFixesByRange);\n  const originalText = sourceCode.text;\n  const start = fixes[0].range[0];\n  const end = fixes[fixes.length - 1].range[1];\n  let text = \"\";\n  let lastPos = Number.MIN_SAFE_INTEGER;\n  for (const fix of fixes) {\n    assert(fix.range[0] >= lastPos, \"Fix objects must not be overlapped in a report.\");\n    if (fix.range[0] >= 0) {\n      text += originalText.slice(Math.max(0, start, lastPos), fix.range[0]);\n    }\n    text += fix.text;\n    lastPos = fix.range[1];\n  }\n  text += originalText.slice(Math.max(0, start, lastPos), end);\n  return {\n    range: [start, end],\n    text\n  };\n}\n\n/**\n * Gets one fix object from the given descriptor.\n * If the descriptor retrieves multiple fixes, this merges those to one.\n * @param {MessageDescriptor} descriptor The report descriptor.\n * @param {SourceCode} sourceCode The source code object to get text between fixes.\n * @returns {({text: string, range: number[]}|null)} The fix for the descriptor\n */\nfunction normalizeFixes(descriptor, sourceCode) {\n  if (typeof descriptor.fix !== \"function\") {\n    return null;\n  }\n\n  // @type {null | Fix | Fix[] | IterableIterator<Fix>}\n  const fix = descriptor.fix(ruleFixer);\n\n  // Merge to one.\n  if (fix && Symbol.iterator in fix) {\n    return mergeFixes(Array.from(fix), sourceCode);\n  }\n  assertValidFix(fix);\n  return fix;\n}\n\n/**\n * Gets an array of suggestion objects from the given descriptor.\n * @param {MessageDescriptor} descriptor The report descriptor.\n * @param {SourceCode} sourceCode The source code object to get text between fixes.\n * @param {Object} messages Object of meta messages for the rule.\n * @returns {Array<SuggestionResult>} The suggestions for the descriptor\n */\nfunction mapSuggestions(descriptor, sourceCode, messages) {\n  if (!descriptor.suggest || !Array.isArray(descriptor.suggest)) {\n    return [];\n  }\n  return descriptor.suggest.map(suggestInfo => {\n    const computedDesc = suggestInfo.desc || messages[suggestInfo.messageId];\n    return {\n      ...suggestInfo,\n      desc: interpolate(computedDesc, suggestInfo.data),\n      fix: normalizeFixes(suggestInfo, sourceCode)\n    };\n  })\n\n  // Remove suggestions that didn't provide a fix\n  .filter(({\n    fix\n  }) => fix);\n}\n\n/**\n * Creates information about the report from a descriptor\n * @param {Object} options Information about the problem\n * @param {string} options.ruleId Rule ID\n * @param {(0|1|2)} options.severity Rule severity\n * @param {(ASTNode|null)} options.node Node\n * @param {string} options.message Error message\n * @param {string} [options.messageId] The error message ID.\n * @param {{start: SourceLocation, end: (SourceLocation|null)}} options.loc Start and end location\n * @param {{text: string, range: (number[]|null)}} options.fix The fix object\n * @param {Array<{text: string, range: (number[]|null)}>} options.suggestions The array of suggestions objects\n * @returns {function(...args): ReportInfo} Function that returns information about the report\n */\nfunction createProblem(options) {\n  const problem = {\n    ruleId: options.ruleId,\n    severity: options.severity,\n    message: options.message,\n    line: options.loc.start.line,\n    column: options.loc.start.column + 1,\n    nodeType: options.node && options.node.type || null\n  };\n\n  /*\n   * If this isnâ€™t in the conditional, some of the tests fail\n   * because `messageId` is present in the problem object\n   */\n  if (options.messageId) {\n    problem.messageId = options.messageId;\n  }\n  if (options.loc.end) {\n    problem.endLine = options.loc.end.line;\n    problem.endColumn = options.loc.end.column + 1;\n  }\n  if (options.fix) {\n    problem.fix = options.fix;\n  }\n  if (options.suggestions && options.suggestions.length > 0) {\n    problem.suggestions = options.suggestions;\n  }\n  return problem;\n}\n\n/**\n * Validates that suggestions are properly defined. Throws if an error is detected.\n * @param {Array<{ desc?: string, messageId?: string }>} suggest The incoming suggest data.\n * @param {Object} messages Object of meta messages for the rule.\n * @returns {void}\n */\nfunction validateSuggestions(suggest, messages) {\n  if (suggest && Array.isArray(suggest)) {\n    suggest.forEach(suggestion => {\n      if (suggestion.messageId) {\n        const {\n          messageId\n        } = suggestion;\n        if (!messages) {\n          throw new TypeError(`context.report() called with a suggest option with a messageId '${messageId}', but no messages were present in the rule metadata.`);\n        }\n        if (!messages[messageId]) {\n          throw new TypeError(`context.report() called with a suggest option with a messageId '${messageId}' which is not present in the 'messages' config: ${JSON.stringify(messages, null, 2)}`);\n        }\n        if (suggestion.desc) {\n          throw new TypeError(\"context.report() called with a suggest option that defines both a 'messageId' and an 'desc'. Please only pass one.\");\n        }\n      } else if (!suggestion.desc) {\n        throw new TypeError(\"context.report() called with a suggest option that doesn't have either a `desc` or `messageId`\");\n      }\n      if (typeof suggestion.fix !== \"function\") {\n        throw new TypeError(`context.report() called with a suggest option without a fix function. See: ${suggestion}`);\n      }\n    });\n  }\n}\n\n/**\n * Returns a function that converts the arguments of a `context.report` call from a rule into a reported\n * problem for the Node.js API.\n * @param {{ruleId: string, severity: number, sourceCode: SourceCode, messageIds: Object, disableFixes: boolean}} metadata Metadata for the reported problem\n * @param {SourceCode} sourceCode The `SourceCode` instance for the text being linted\n * @returns {function(...args): ReportInfo} Function that returns information about the report\n */\n\nmodule.exports = function createReportTranslator(metadata) {\n  /*\n   * `createReportTranslator` gets called once per enabled rule per file. It needs to be very performant.\n   * The report translator itself (i.e. the function that `createReportTranslator` returns) gets\n   * called every time a rule reports a problem, which happens much less frequently (usually, the vast\n   * majority of rules don't report any problems for a given file).\n   */\n  return (...args) => {\n    const descriptor = normalizeMultiArgReportCall(...args);\n    const messages = metadata.messageIds;\n    assertValidNodeInfo(descriptor);\n    let computedMessage;\n    if (descriptor.messageId) {\n      if (!messages) {\n        throw new TypeError(\"context.report() called with a messageId, but no messages were present in the rule metadata.\");\n      }\n      const id = descriptor.messageId;\n      if (descriptor.message) {\n        throw new TypeError(\"context.report() called with a message and a messageId. Please only pass one.\");\n      }\n      if (!messages || !Object.prototype.hasOwnProperty.call(messages, id)) {\n        throw new TypeError(`context.report() called with a messageId of '${id}' which is not present in the 'messages' config: ${JSON.stringify(messages, null, 2)}`);\n      }\n      computedMessage = messages[id];\n    } else if (descriptor.message) {\n      computedMessage = descriptor.message;\n    } else {\n      throw new TypeError(\"Missing `message` property in report() call; add a message that describes the linting problem.\");\n    }\n    validateSuggestions(descriptor.suggest, messages);\n    return createProblem({\n      ruleId: metadata.ruleId,\n      severity: metadata.severity,\n      node: descriptor.node,\n      message: interpolate(computedMessage, descriptor.data),\n      messageId: descriptor.messageId,\n      loc: normalizeReportLoc(descriptor),\n      fix: metadata.disableFixes ? null : normalizeFixes(descriptor, metadata.sourceCode),\n      suggestions: metadata.disableFixes ? [] : mapSuggestions(descriptor, metadata.sourceCode, messages)\n    });\n  };\n};","map":{"version":3,"names":["assert","require","ruleFixer","interpolate","normalizeMultiArgReportCall","args","length","Object","assign","node","message","data","fix","loc","assertValidNodeInfo","descriptor","normalizeReportLoc","start","end","assertValidFix","range","JSON","stringify","compareFixesByRange","a","b","mergeFixes","fixes","sourceCode","sort","originalText","text","lastPos","Number","MIN_SAFE_INTEGER","slice","Math","max","normalizeFixes","Symbol","iterator","Array","from","mapSuggestions","messages","suggest","isArray","map","suggestInfo","computedDesc","desc","messageId","filter","createProblem","options","problem","ruleId","severity","line","column","nodeType","type","endLine","endColumn","suggestions","validateSuggestions","forEach","suggestion","TypeError","module","exports","createReportTranslator","metadata","messageIds","computedMessage","id","prototype","hasOwnProperty","call","disableFixes"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/linter/report-translator.js"],"sourcesContent":["/**\n * @fileoverview A helper that translates context.report() calls from the rule API into generic problem objects\n * @author Teddy Katz\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst assert = require(\"assert\");\nconst ruleFixer = require(\"./rule-fixer\");\nconst interpolate = require(\"./interpolate\");\n\n//------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/**\n * An error message description\n * @typedef {Object} MessageDescriptor\n * @property {ASTNode} [node] The reported node\n * @property {Location} loc The location of the problem.\n * @property {string} message The problem message.\n * @property {Object} [data] Optional data to use to fill in placeholders in the\n *      message.\n * @property {Function} [fix] The function to call that creates a fix command.\n * @property {Array<{desc?: string, messageId?: string, fix: Function}>} suggest Suggestion descriptions and functions to create a the associated fixes.\n */\n\n/**\n * Information about the report\n * @typedef {Object} ReportInfo\n * @property {string} ruleId\n * @property {(0|1|2)} severity\n * @property {(string|undefined)} message\n * @property {(string|undefined)} [messageId]\n * @property {number} line\n * @property {number} column\n * @property {(number|undefined)} [endLine]\n * @property {(number|undefined)} [endColumn]\n * @property {(string|null)} nodeType\n * @property {string} source\n * @property {({text: string, range: (number[]|null)}|null)} [fix]\n * @property {Array<{text: string, range: (number[]|null)}|null>} [suggestions]\n */\n\n//------------------------------------------------------------------------------\n// Module Definition\n//------------------------------------------------------------------------------\n\n\n/**\n * Translates a multi-argument context.report() call into a single object argument call\n * @param {...*} args A list of arguments passed to `context.report`\n * @returns {MessageDescriptor} A normalized object containing report information\n */\nfunction normalizeMultiArgReportCall(...args) {\n\n    // If there is one argument, it is considered to be a new-style call already.\n    if (args.length === 1) {\n\n        // Shallow clone the object to avoid surprises if reusing the descriptor\n        return Object.assign({}, args[0]);\n    }\n\n    // If the second argument is a string, the arguments are interpreted as [node, message, data, fix].\n    if (typeof args[1] === \"string\") {\n        return {\n            node: args[0],\n            message: args[1],\n            data: args[2],\n            fix: args[3]\n        };\n    }\n\n    // Otherwise, the arguments are interpreted as [node, loc, message, data, fix].\n    return {\n        node: args[0],\n        loc: args[1],\n        message: args[2],\n        data: args[3],\n        fix: args[4]\n    };\n}\n\n/**\n * Asserts that either a loc or a node was provided, and the node is valid if it was provided.\n * @param {MessageDescriptor} descriptor A descriptor to validate\n * @returns {void}\n * @throws AssertionError if neither a node nor a loc was provided, or if the node is not an object\n */\nfunction assertValidNodeInfo(descriptor) {\n    if (descriptor.node) {\n        assert(typeof descriptor.node === \"object\", \"Node must be an object\");\n    } else {\n        assert(descriptor.loc, \"Node must be provided when reporting error if location is not provided\");\n    }\n}\n\n/**\n * Normalizes a MessageDescriptor to always have a `loc` with `start` and `end` properties\n * @param {MessageDescriptor} descriptor A descriptor for the report from a rule.\n * @returns {{start: Location, end: (Location|null)}} An updated location that infers the `start` and `end` properties\n * from the `node` of the original descriptor, or infers the `start` from the `loc` of the original descriptor.\n */\nfunction normalizeReportLoc(descriptor) {\n    if (descriptor.loc) {\n        if (descriptor.loc.start) {\n            return descriptor.loc;\n        }\n        return { start: descriptor.loc, end: null };\n    }\n    return descriptor.node.loc;\n}\n\n/**\n * Check that a fix has a valid range.\n * @param {Fix|null} fix The fix to validate.\n * @returns {void}\n */\nfunction assertValidFix(fix) {\n    if (fix) {\n        assert(fix.range && typeof fix.range[0] === \"number\" && typeof fix.range[1] === \"number\", `Fix has invalid range: ${JSON.stringify(fix, null, 2)}`);\n    }\n}\n\n/**\n * Compares items in a fixes array by range.\n * @param {Fix} a The first message.\n * @param {Fix} b The second message.\n * @returns {int} -1 if a comes before b, 1 if a comes after b, 0 if equal.\n * @private\n */\nfunction compareFixesByRange(a, b) {\n    return a.range[0] - b.range[0] || a.range[1] - b.range[1];\n}\n\n/**\n * Merges the given fixes array into one.\n * @param {Fix[]} fixes The fixes to merge.\n * @param {SourceCode} sourceCode The source code object to get the text between fixes.\n * @returns {{text: string, range: number[]}} The merged fixes\n */\nfunction mergeFixes(fixes, sourceCode) {\n    for (const fix of fixes) {\n        assertValidFix(fix);\n    }\n\n    if (fixes.length === 0) {\n        return null;\n    }\n    if (fixes.length === 1) {\n        return fixes[0];\n    }\n\n    fixes.sort(compareFixesByRange);\n\n    const originalText = sourceCode.text;\n    const start = fixes[0].range[0];\n    const end = fixes[fixes.length - 1].range[1];\n    let text = \"\";\n    let lastPos = Number.MIN_SAFE_INTEGER;\n\n    for (const fix of fixes) {\n        assert(fix.range[0] >= lastPos, \"Fix objects must not be overlapped in a report.\");\n\n        if (fix.range[0] >= 0) {\n            text += originalText.slice(Math.max(0, start, lastPos), fix.range[0]);\n        }\n        text += fix.text;\n        lastPos = fix.range[1];\n    }\n    text += originalText.slice(Math.max(0, start, lastPos), end);\n\n    return { range: [start, end], text };\n}\n\n/**\n * Gets one fix object from the given descriptor.\n * If the descriptor retrieves multiple fixes, this merges those to one.\n * @param {MessageDescriptor} descriptor The report descriptor.\n * @param {SourceCode} sourceCode The source code object to get text between fixes.\n * @returns {({text: string, range: number[]}|null)} The fix for the descriptor\n */\nfunction normalizeFixes(descriptor, sourceCode) {\n    if (typeof descriptor.fix !== \"function\") {\n        return null;\n    }\n\n    // @type {null | Fix | Fix[] | IterableIterator<Fix>}\n    const fix = descriptor.fix(ruleFixer);\n\n    // Merge to one.\n    if (fix && Symbol.iterator in fix) {\n        return mergeFixes(Array.from(fix), sourceCode);\n    }\n\n    assertValidFix(fix);\n    return fix;\n}\n\n/**\n * Gets an array of suggestion objects from the given descriptor.\n * @param {MessageDescriptor} descriptor The report descriptor.\n * @param {SourceCode} sourceCode The source code object to get text between fixes.\n * @param {Object} messages Object of meta messages for the rule.\n * @returns {Array<SuggestionResult>} The suggestions for the descriptor\n */\nfunction mapSuggestions(descriptor, sourceCode, messages) {\n    if (!descriptor.suggest || !Array.isArray(descriptor.suggest)) {\n        return [];\n    }\n\n    return descriptor.suggest\n        .map(suggestInfo => {\n            const computedDesc = suggestInfo.desc || messages[suggestInfo.messageId];\n\n            return {\n                ...suggestInfo,\n                desc: interpolate(computedDesc, suggestInfo.data),\n                fix: normalizeFixes(suggestInfo, sourceCode)\n            };\n        })\n\n        // Remove suggestions that didn't provide a fix\n        .filter(({ fix }) => fix);\n}\n\n/**\n * Creates information about the report from a descriptor\n * @param {Object} options Information about the problem\n * @param {string} options.ruleId Rule ID\n * @param {(0|1|2)} options.severity Rule severity\n * @param {(ASTNode|null)} options.node Node\n * @param {string} options.message Error message\n * @param {string} [options.messageId] The error message ID.\n * @param {{start: SourceLocation, end: (SourceLocation|null)}} options.loc Start and end location\n * @param {{text: string, range: (number[]|null)}} options.fix The fix object\n * @param {Array<{text: string, range: (number[]|null)}>} options.suggestions The array of suggestions objects\n * @returns {function(...args): ReportInfo} Function that returns information about the report\n */\nfunction createProblem(options) {\n    const problem = {\n        ruleId: options.ruleId,\n        severity: options.severity,\n        message: options.message,\n        line: options.loc.start.line,\n        column: options.loc.start.column + 1,\n        nodeType: options.node && options.node.type || null\n    };\n\n    /*\n     * If this isnâ€™t in the conditional, some of the tests fail\n     * because `messageId` is present in the problem object\n     */\n    if (options.messageId) {\n        problem.messageId = options.messageId;\n    }\n\n    if (options.loc.end) {\n        problem.endLine = options.loc.end.line;\n        problem.endColumn = options.loc.end.column + 1;\n    }\n\n    if (options.fix) {\n        problem.fix = options.fix;\n    }\n\n    if (options.suggestions && options.suggestions.length > 0) {\n        problem.suggestions = options.suggestions;\n    }\n\n    return problem;\n}\n\n/**\n * Validates that suggestions are properly defined. Throws if an error is detected.\n * @param {Array<{ desc?: string, messageId?: string }>} suggest The incoming suggest data.\n * @param {Object} messages Object of meta messages for the rule.\n * @returns {void}\n */\nfunction validateSuggestions(suggest, messages) {\n    if (suggest && Array.isArray(suggest)) {\n        suggest.forEach(suggestion => {\n            if (suggestion.messageId) {\n                const { messageId } = suggestion;\n\n                if (!messages) {\n                    throw new TypeError(`context.report() called with a suggest option with a messageId '${messageId}', but no messages were present in the rule metadata.`);\n                }\n\n                if (!messages[messageId]) {\n                    throw new TypeError(`context.report() called with a suggest option with a messageId '${messageId}' which is not present in the 'messages' config: ${JSON.stringify(messages, null, 2)}`);\n                }\n\n                if (suggestion.desc) {\n                    throw new TypeError(\"context.report() called with a suggest option that defines both a 'messageId' and an 'desc'. Please only pass one.\");\n                }\n            } else if (!suggestion.desc) {\n                throw new TypeError(\"context.report() called with a suggest option that doesn't have either a `desc` or `messageId`\");\n            }\n\n            if (typeof suggestion.fix !== \"function\") {\n                throw new TypeError(`context.report() called with a suggest option without a fix function. See: ${suggestion}`);\n            }\n        });\n    }\n}\n\n/**\n * Returns a function that converts the arguments of a `context.report` call from a rule into a reported\n * problem for the Node.js API.\n * @param {{ruleId: string, severity: number, sourceCode: SourceCode, messageIds: Object, disableFixes: boolean}} metadata Metadata for the reported problem\n * @param {SourceCode} sourceCode The `SourceCode` instance for the text being linted\n * @returns {function(...args): ReportInfo} Function that returns information about the report\n */\n\nmodule.exports = function createReportTranslator(metadata) {\n\n    /*\n     * `createReportTranslator` gets called once per enabled rule per file. It needs to be very performant.\n     * The report translator itself (i.e. the function that `createReportTranslator` returns) gets\n     * called every time a rule reports a problem, which happens much less frequently (usually, the vast\n     * majority of rules don't report any problems for a given file).\n     */\n    return (...args) => {\n        const descriptor = normalizeMultiArgReportCall(...args);\n        const messages = metadata.messageIds;\n\n        assertValidNodeInfo(descriptor);\n\n        let computedMessage;\n\n        if (descriptor.messageId) {\n            if (!messages) {\n                throw new TypeError(\"context.report() called with a messageId, but no messages were present in the rule metadata.\");\n            }\n            const id = descriptor.messageId;\n\n            if (descriptor.message) {\n                throw new TypeError(\"context.report() called with a message and a messageId. Please only pass one.\");\n            }\n            if (!messages || !Object.prototype.hasOwnProperty.call(messages, id)) {\n                throw new TypeError(`context.report() called with a messageId of '${id}' which is not present in the 'messages' config: ${JSON.stringify(messages, null, 2)}`);\n            }\n            computedMessage = messages[id];\n        } else if (descriptor.message) {\n            computedMessage = descriptor.message;\n        } else {\n            throw new TypeError(\"Missing `message` property in report() call; add a message that describes the linting problem.\");\n        }\n\n        validateSuggestions(descriptor.suggest, messages);\n\n        return createProblem({\n            ruleId: metadata.ruleId,\n            severity: metadata.severity,\n            node: descriptor.node,\n            message: interpolate(computedMessage, descriptor.data),\n            messageId: descriptor.messageId,\n            loc: normalizeReportLoc(descriptor),\n            fix: metadata.disableFixes ? null : normalizeFixes(descriptor, metadata.sourceCode),\n            suggestions: metadata.disableFixes ? [] : mapSuggestions(descriptor, metadata.sourceCode, messages)\n        });\n    };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}