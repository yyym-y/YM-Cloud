{"ast":null,"code":"/**\n * @fileoverview Rule to check the spacing around the * in generator functions.\n * @author Jamund Ferguson\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\nconst OVERRIDE_SCHEMA = {\n  oneOf: [{\n    enum: [\"before\", \"after\", \"both\", \"neither\"]\n  }, {\n    type: \"object\",\n    properties: {\n      before: {\n        type: \"boolean\"\n      },\n      after: {\n        type: \"boolean\"\n      }\n    },\n    additionalProperties: false\n  }]\n};\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce consistent spacing around `*` operators in generator functions\",\n      category: \"ECMAScript 6\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/generator-star-spacing\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      oneOf: [{\n        enum: [\"before\", \"after\", \"both\", \"neither\"]\n      }, {\n        type: \"object\",\n        properties: {\n          before: {\n            type: \"boolean\"\n          },\n          after: {\n            type: \"boolean\"\n          },\n          named: OVERRIDE_SCHEMA,\n          anonymous: OVERRIDE_SCHEMA,\n          method: OVERRIDE_SCHEMA\n        },\n        additionalProperties: false\n      }]\n    }],\n    messages: {\n      missingBefore: \"Missing space before *.\",\n      missingAfter: \"Missing space after *.\",\n      unexpectedBefore: \"Unexpected space before *.\",\n      unexpectedAfter: \"Unexpected space after *.\"\n    }\n  },\n  create(context) {\n    const optionDefinitions = {\n      before: {\n        before: true,\n        after: false\n      },\n      after: {\n        before: false,\n        after: true\n      },\n      both: {\n        before: true,\n        after: true\n      },\n      neither: {\n        before: false,\n        after: false\n      }\n    };\n\n    /**\n     * Returns resolved option definitions based on an option and defaults\n     * @param {any} option The option object or string value\n     * @param {Object} defaults The defaults to use if options are not present\n     * @returns {Object} the resolved object definition\n     */\n    function optionToDefinition(option, defaults) {\n      if (!option) {\n        return defaults;\n      }\n      return typeof option === \"string\" ? optionDefinitions[option] : Object.assign({}, defaults, option);\n    }\n    const modes = function (option) {\n      const defaults = optionToDefinition(option, optionDefinitions.before);\n      return {\n        named: optionToDefinition(option.named, defaults),\n        anonymous: optionToDefinition(option.anonymous, defaults),\n        method: optionToDefinition(option.method, defaults)\n      };\n    }(context.options[0] || {});\n    const sourceCode = context.getSourceCode();\n\n    /**\n     * Checks if the given token is a star token or not.\n     * @param {Token} token The token to check.\n     * @returns {boolean} `true` if the token is a star token.\n     */\n    function isStarToken(token) {\n      return token.value === \"*\" && token.type === \"Punctuator\";\n    }\n\n    /**\n     * Gets the generator star token of the given function node.\n     * @param {ASTNode} node The function node to get.\n     * @returns {Token} Found star token.\n     */\n    function getStarToken(node) {\n      return sourceCode.getFirstToken(node.parent.method || node.parent.type === \"MethodDefinition\" ? node.parent : node, isStarToken);\n    }\n\n    /**\n     * capitalize a given string.\n     * @param {string} str the given string.\n     * @returns {string} the capitalized string.\n     */\n    function capitalize(str) {\n      return str[0].toUpperCase() + str.slice(1);\n    }\n\n    /**\n     * Checks the spacing between two tokens before or after the star token.\n     * @param {string} kind Either \"named\", \"anonymous\", or \"method\"\n     * @param {string} side Either \"before\" or \"after\".\n     * @param {Token} leftToken `function` keyword token if side is \"before\", or\n     *     star token if side is \"after\".\n     * @param {Token} rightToken Star token if side is \"before\", or identifier\n     *     token if side is \"after\".\n     * @returns {void}\n     */\n    function checkSpacing(kind, side, leftToken, rightToken) {\n      if (!!(rightToken.range[0] - leftToken.range[1]) !== modes[kind][side]) {\n        const after = leftToken.value === \"*\";\n        const spaceRequired = modes[kind][side];\n        const node = after ? leftToken : rightToken;\n        const messageId = `${spaceRequired ? \"missing\" : \"unexpected\"}${capitalize(side)}`;\n        context.report({\n          node,\n          messageId,\n          fix(fixer) {\n            if (spaceRequired) {\n              if (after) {\n                return fixer.insertTextAfter(node, \" \");\n              }\n              return fixer.insertTextBefore(node, \" \");\n            }\n            return fixer.removeRange([leftToken.range[1], rightToken.range[0]]);\n          }\n        });\n      }\n    }\n\n    /**\n     * Enforces the spacing around the star if node is a generator function.\n     * @param {ASTNode} node A function expression or declaration node.\n     * @returns {void}\n     */\n    function checkFunction(node) {\n      if (!node.generator) {\n        return;\n      }\n      const starToken = getStarToken(node);\n      const prevToken = sourceCode.getTokenBefore(starToken);\n      const nextToken = sourceCode.getTokenAfter(starToken);\n      let kind = \"named\";\n      if (node.parent.type === \"MethodDefinition\" || node.parent.type === \"Property\" && node.parent.method) {\n        kind = \"method\";\n      } else if (!node.id) {\n        kind = \"anonymous\";\n      }\n\n      // Only check before when preceded by `function`|`static` keyword\n      if (!(kind === \"method\" && starToken === sourceCode.getFirstToken(node.parent))) {\n        checkSpacing(kind, \"before\", prevToken, starToken);\n      }\n      checkSpacing(kind, \"after\", starToken, nextToken);\n    }\n    return {\n      FunctionDeclaration: checkFunction,\n      FunctionExpression: checkFunction\n    };\n  }\n};","map":{"version":3,"names":["OVERRIDE_SCHEMA","oneOf","enum","type","properties","before","after","additionalProperties","module","exports","meta","docs","description","category","recommended","url","fixable","schema","named","anonymous","method","messages","missingBefore","missingAfter","unexpectedBefore","unexpectedAfter","create","context","optionDefinitions","both","neither","optionToDefinition","option","defaults","Object","assign","modes","options","sourceCode","getSourceCode","isStarToken","token","value","getStarToken","node","getFirstToken","parent","capitalize","str","toUpperCase","slice","checkSpacing","kind","side","leftToken","rightToken","range","spaceRequired","messageId","report","fix","fixer","insertTextAfter","insertTextBefore","removeRange","checkFunction","generator","starToken","prevToken","getTokenBefore","nextToken","getTokenAfter","id","FunctionDeclaration","FunctionExpression"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/generator-star-spacing.js"],"sourcesContent":["/**\n * @fileoverview Rule to check the spacing around the * in generator functions.\n * @author Jamund Ferguson\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst OVERRIDE_SCHEMA = {\n    oneOf: [\n        {\n            enum: [\"before\", \"after\", \"both\", \"neither\"]\n        },\n        {\n            type: \"object\",\n            properties: {\n                before: { type: \"boolean\" },\n                after: { type: \"boolean\" }\n            },\n            additionalProperties: false\n        }\n    ]\n};\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce consistent spacing around `*` operators in generator functions\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/generator-star-spacing\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"before\", \"after\", \"both\", \"neither\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            before: { type: \"boolean\" },\n                            after: { type: \"boolean\" },\n                            named: OVERRIDE_SCHEMA,\n                            anonymous: OVERRIDE_SCHEMA,\n                            method: OVERRIDE_SCHEMA\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ],\n\n        messages: {\n            missingBefore: \"Missing space before *.\",\n            missingAfter: \"Missing space after *.\",\n            unexpectedBefore: \"Unexpected space before *.\",\n            unexpectedAfter: \"Unexpected space after *.\"\n        }\n    },\n\n    create(context) {\n\n        const optionDefinitions = {\n            before: { before: true, after: false },\n            after: { before: false, after: true },\n            both: { before: true, after: true },\n            neither: { before: false, after: false }\n        };\n\n        /**\n         * Returns resolved option definitions based on an option and defaults\n         * @param {any} option The option object or string value\n         * @param {Object} defaults The defaults to use if options are not present\n         * @returns {Object} the resolved object definition\n         */\n        function optionToDefinition(option, defaults) {\n            if (!option) {\n                return defaults;\n            }\n\n            return typeof option === \"string\"\n                ? optionDefinitions[option]\n                : Object.assign({}, defaults, option);\n        }\n\n        const modes = (function(option) {\n            const defaults = optionToDefinition(option, optionDefinitions.before);\n\n            return {\n                named: optionToDefinition(option.named, defaults),\n                anonymous: optionToDefinition(option.anonymous, defaults),\n                method: optionToDefinition(option.method, defaults)\n            };\n        }(context.options[0] || {}));\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Checks if the given token is a star token or not.\n         * @param {Token} token The token to check.\n         * @returns {boolean} `true` if the token is a star token.\n         */\n        function isStarToken(token) {\n            return token.value === \"*\" && token.type === \"Punctuator\";\n        }\n\n        /**\n         * Gets the generator star token of the given function node.\n         * @param {ASTNode} node The function node to get.\n         * @returns {Token} Found star token.\n         */\n        function getStarToken(node) {\n            return sourceCode.getFirstToken(\n                (node.parent.method || node.parent.type === \"MethodDefinition\") ? node.parent : node,\n                isStarToken\n            );\n        }\n\n        /**\n         * capitalize a given string.\n         * @param {string} str the given string.\n         * @returns {string} the capitalized string.\n         */\n        function capitalize(str) {\n            return str[0].toUpperCase() + str.slice(1);\n        }\n\n        /**\n         * Checks the spacing between two tokens before or after the star token.\n         * @param {string} kind Either \"named\", \"anonymous\", or \"method\"\n         * @param {string} side Either \"before\" or \"after\".\n         * @param {Token} leftToken `function` keyword token if side is \"before\", or\n         *     star token if side is \"after\".\n         * @param {Token} rightToken Star token if side is \"before\", or identifier\n         *     token if side is \"after\".\n         * @returns {void}\n         */\n        function checkSpacing(kind, side, leftToken, rightToken) {\n            if (!!(rightToken.range[0] - leftToken.range[1]) !== modes[kind][side]) {\n                const after = leftToken.value === \"*\";\n                const spaceRequired = modes[kind][side];\n                const node = after ? leftToken : rightToken;\n                const messageId = `${spaceRequired ? \"missing\" : \"unexpected\"}${capitalize(side)}`;\n\n                context.report({\n                    node,\n                    messageId,\n                    fix(fixer) {\n                        if (spaceRequired) {\n                            if (after) {\n                                return fixer.insertTextAfter(node, \" \");\n                            }\n                            return fixer.insertTextBefore(node, \" \");\n                        }\n                        return fixer.removeRange([leftToken.range[1], rightToken.range[0]]);\n                    }\n                });\n            }\n        }\n\n        /**\n         * Enforces the spacing around the star if node is a generator function.\n         * @param {ASTNode} node A function expression or declaration node.\n         * @returns {void}\n         */\n        function checkFunction(node) {\n            if (!node.generator) {\n                return;\n            }\n\n            const starToken = getStarToken(node);\n            const prevToken = sourceCode.getTokenBefore(starToken);\n            const nextToken = sourceCode.getTokenAfter(starToken);\n\n            let kind = \"named\";\n\n            if (node.parent.type === \"MethodDefinition\" || (node.parent.type === \"Property\" && node.parent.method)) {\n                kind = \"method\";\n            } else if (!node.id) {\n                kind = \"anonymous\";\n            }\n\n            // Only check before when preceded by `function`|`static` keyword\n            if (!(kind === \"method\" && starToken === sourceCode.getFirstToken(node.parent))) {\n                checkSpacing(kind, \"before\", prevToken, starToken);\n            }\n\n            checkSpacing(kind, \"after\", starToken, nextToken);\n        }\n\n        return {\n            FunctionDeclaration: checkFunction,\n            FunctionExpression: checkFunction\n        };\n\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}