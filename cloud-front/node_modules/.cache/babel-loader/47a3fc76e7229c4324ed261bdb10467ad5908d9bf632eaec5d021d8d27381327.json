{"ast":null,"code":"/**\n * @fileoverview Enforces or disallows inline comments.\n * @author Greg Cochard\n */\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow inline comments after code\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-inline-comments\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        ignorePattern: {\n          type: \"string\"\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unexpectedInlineComment: \"Unexpected comment inline with code.\"\n    }\n  },\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const options = context.options[0];\n    let customIgnoreRegExp;\n    if (options && options.ignorePattern) {\n      customIgnoreRegExp = new RegExp(options.ignorePattern, \"u\");\n    }\n\n    /**\n     * Will check that comments are not on lines starting with or ending with code\n     * @param {ASTNode} node The comment node to check\n     * @private\n     * @returns {void}\n     */\n    function testCodeAroundComment(node) {\n      const startLine = String(sourceCode.lines[node.loc.start.line - 1]),\n        endLine = String(sourceCode.lines[node.loc.end.line - 1]),\n        preamble = startLine.slice(0, node.loc.start.column).trim(),\n        postamble = endLine.slice(node.loc.end.column).trim(),\n        isPreambleEmpty = !preamble,\n        isPostambleEmpty = !postamble;\n\n      // Nothing on both sides\n      if (isPreambleEmpty && isPostambleEmpty) {\n        return;\n      }\n\n      // Matches the ignore pattern\n      if (customIgnoreRegExp && customIgnoreRegExp.test(node.value)) {\n        return;\n      }\n\n      // JSX Exception\n      if ((isPreambleEmpty || preamble === \"{\") && (isPostambleEmpty || postamble === \"}\")) {\n        const enclosingNode = sourceCode.getNodeByRangeIndex(node.range[0]);\n        if (enclosingNode && enclosingNode.type === \"JSXEmptyExpression\") {\n          return;\n        }\n      }\n\n      // Don't report ESLint directive comments\n      if (astUtils.isDirectiveComment(node)) {\n        return;\n      }\n      context.report({\n        node,\n        messageId: \"unexpectedInlineComment\"\n      });\n    }\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    return {\n      Program() {\n        sourceCode.getAllComments().filter(token => token.type !== \"Shebang\").forEach(testCodeAroundComment);\n      }\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","module","exports","meta","type","docs","description","category","recommended","url","schema","properties","ignorePattern","additionalProperties","messages","unexpectedInlineComment","create","context","sourceCode","getSourceCode","options","customIgnoreRegExp","RegExp","testCodeAroundComment","node","startLine","String","lines","loc","start","line","endLine","end","preamble","slice","column","trim","postamble","isPreambleEmpty","isPostambleEmpty","test","value","enclosingNode","getNodeByRangeIndex","range","isDirectiveComment","report","messageId","Program","getAllComments","filter","token","forEach"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/no-inline-comments.js"],"sourcesContent":["/**\n * @fileoverview Enforces or disallows inline comments.\n * @author Greg Cochard\n */\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow inline comments after code\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-inline-comments\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    ignorePattern: {\n                        type: \"string\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            unexpectedInlineComment: \"Unexpected comment inline with code.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const options = context.options[0];\n        let customIgnoreRegExp;\n\n        if (options && options.ignorePattern) {\n            customIgnoreRegExp = new RegExp(options.ignorePattern, \"u\");\n        }\n\n        /**\n         * Will check that comments are not on lines starting with or ending with code\n         * @param {ASTNode} node The comment node to check\n         * @private\n         * @returns {void}\n         */\n        function testCodeAroundComment(node) {\n\n            const startLine = String(sourceCode.lines[node.loc.start.line - 1]),\n                endLine = String(sourceCode.lines[node.loc.end.line - 1]),\n                preamble = startLine.slice(0, node.loc.start.column).trim(),\n                postamble = endLine.slice(node.loc.end.column).trim(),\n                isPreambleEmpty = !preamble,\n                isPostambleEmpty = !postamble;\n\n            // Nothing on both sides\n            if (isPreambleEmpty && isPostambleEmpty) {\n                return;\n            }\n\n            // Matches the ignore pattern\n            if (customIgnoreRegExp && customIgnoreRegExp.test(node.value)) {\n                return;\n            }\n\n            // JSX Exception\n            if (\n                (isPreambleEmpty || preamble === \"{\") &&\n                (isPostambleEmpty || postamble === \"}\")\n            ) {\n                const enclosingNode = sourceCode.getNodeByRangeIndex(node.range[0]);\n\n                if (enclosingNode && enclosingNode.type === \"JSXEmptyExpression\") {\n                    return;\n                }\n            }\n\n            // Don't report ESLint directive comments\n            if (astUtils.isDirectiveComment(node)) {\n                return;\n            }\n\n            context.report({\n                node,\n                messageId: \"unexpectedInlineComment\"\n            });\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            Program() {\n                sourceCode.getAllComments()\n                    .filter(token => token.type !== \"Shebang\")\n                    .forEach(testCodeAroundComment);\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}