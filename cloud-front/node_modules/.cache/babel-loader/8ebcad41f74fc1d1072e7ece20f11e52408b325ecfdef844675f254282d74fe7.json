{"ast":null,"code":"/**\n * @fileoverview Rule to require braces in arrow function body.\n * @author Alberto Rodríguez\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nrequire(\"core-js/modules/es.array.push.js\");\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require braces around arrow function bodies\",\n      category: \"ECMAScript 6\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/arrow-body-style\"\n    },\n    schema: {\n      anyOf: [{\n        type: \"array\",\n        items: [{\n          enum: [\"always\", \"never\"]\n        }],\n        minItems: 0,\n        maxItems: 1\n      }, {\n        type: \"array\",\n        items: [{\n          enum: [\"as-needed\"]\n        }, {\n          type: \"object\",\n          properties: {\n            requireReturnForObjectLiteral: {\n              type: \"boolean\"\n            }\n          },\n          additionalProperties: false\n        }],\n        minItems: 0,\n        maxItems: 2\n      }]\n    },\n    fixable: \"code\",\n    messages: {\n      unexpectedOtherBlock: \"Unexpected block statement surrounding arrow body.\",\n      unexpectedEmptyBlock: \"Unexpected block statement surrounding arrow body; put a value of `undefined` immediately after the `=>`.\",\n      unexpectedObjectBlock: \"Unexpected block statement surrounding arrow body; parenthesize the returned value and move it immediately after the `=>`.\",\n      unexpectedSingleBlock: \"Unexpected block statement surrounding arrow body; move the returned value immediately after the `=>`.\",\n      expectedBlock: \"Expected block statement surrounding arrow body.\"\n    }\n  },\n  create(context) {\n    const options = context.options;\n    const always = options[0] === \"always\";\n    const asNeeded = !options[0] || options[0] === \"as-needed\";\n    const never = options[0] === \"never\";\n    const requireReturnForObjectLiteral = options[1] && options[1].requireReturnForObjectLiteral;\n    const sourceCode = context.getSourceCode();\n    let funcInfo = null;\n\n    /**\n     * Checks whether the given node has ASI problem or not.\n     * @param {Token} token The token to check.\n     * @returns {boolean} `true` if it changes semantics if `;` or `}` followed by the token are removed.\n     */\n    function hasASIProblem(token) {\n      return token && token.type === \"Punctuator\" && /^[([/`+-]/u.test(token.value);\n    }\n\n    /**\n     * Gets the closing parenthesis by the given node.\n     * @param {ASTNode} node first node after an opening parenthesis.\n     * @returns {Token} The found closing parenthesis token.\n     */\n    function findClosingParen(node) {\n      let nodeToCheck = node;\n      while (!astUtils.isParenthesised(sourceCode, nodeToCheck)) {\n        nodeToCheck = nodeToCheck.parent;\n      }\n      return sourceCode.getTokenAfter(nodeToCheck);\n    }\n\n    /**\n     * Check whether the node is inside of a for loop's init\n     * @param {ASTNode} node node is inside for loop\n     * @returns {boolean} `true` if the node is inside of a for loop, else `false`\n     */\n    function isInsideForLoopInitializer(node) {\n      if (node && node.parent) {\n        if (node.parent.type === \"ForStatement\" && node.parent.init === node) {\n          return true;\n        }\n        return isInsideForLoopInitializer(node.parent);\n      }\n      return false;\n    }\n\n    /**\n     * Determines whether a arrow function body needs braces\n     * @param {ASTNode} node The arrow function node.\n     * @returns {void}\n     */\n    function validate(node) {\n      const arrowBody = node.body;\n      if (arrowBody.type === \"BlockStatement\") {\n        const blockBody = arrowBody.body;\n        if (blockBody.length !== 1 && !never) {\n          return;\n        }\n        if (asNeeded && requireReturnForObjectLiteral && blockBody[0].type === \"ReturnStatement\" && blockBody[0].argument && blockBody[0].argument.type === \"ObjectExpression\") {\n          return;\n        }\n        if (never || asNeeded && blockBody[0].type === \"ReturnStatement\") {\n          let messageId;\n          if (blockBody.length === 0) {\n            messageId = \"unexpectedEmptyBlock\";\n          } else if (blockBody.length > 1) {\n            messageId = \"unexpectedOtherBlock\";\n          } else if (blockBody[0].argument === null) {\n            messageId = \"unexpectedSingleBlock\";\n          } else if (astUtils.isOpeningBraceToken(sourceCode.getFirstToken(blockBody[0], {\n            skip: 1\n          }))) {\n            messageId = \"unexpectedObjectBlock\";\n          } else {\n            messageId = \"unexpectedSingleBlock\";\n          }\n          context.report({\n            node,\n            loc: arrowBody.loc,\n            messageId,\n            fix(fixer) {\n              const fixes = [];\n              if (blockBody.length !== 1 || blockBody[0].type !== \"ReturnStatement\" || !blockBody[0].argument || hasASIProblem(sourceCode.getTokenAfter(arrowBody))) {\n                return fixes;\n              }\n              const openingBrace = sourceCode.getFirstToken(arrowBody);\n              const closingBrace = sourceCode.getLastToken(arrowBody);\n              const firstValueToken = sourceCode.getFirstToken(blockBody[0], 1);\n              const lastValueToken = sourceCode.getLastToken(blockBody[0]);\n              const commentsExist = sourceCode.commentsExistBetween(openingBrace, firstValueToken) || sourceCode.commentsExistBetween(lastValueToken, closingBrace);\n\n              /*\n               * Remove tokens around the return value.\n               * If comments don't exist, remove extra spaces as well.\n               */\n              if (commentsExist) {\n                fixes.push(fixer.remove(openingBrace), fixer.remove(closingBrace), fixer.remove(sourceCode.getTokenAfter(openingBrace)) // return keyword\n                );\n              } else {\n                fixes.push(fixer.removeRange([openingBrace.range[0], firstValueToken.range[0]]), fixer.removeRange([lastValueToken.range[1], closingBrace.range[1]]));\n              }\n\n              /*\n               * If the first token of the return value is `{` or the return value is a sequence expression,\n               * enclose the return value by parentheses to avoid syntax error.\n               */\n              if (astUtils.isOpeningBraceToken(firstValueToken) || blockBody[0].argument.type === \"SequenceExpression\" || funcInfo.hasInOperator && isInsideForLoopInitializer(node)) {\n                if (!astUtils.isParenthesised(sourceCode, blockBody[0].argument)) {\n                  fixes.push(fixer.insertTextBefore(firstValueToken, \"(\"), fixer.insertTextAfter(lastValueToken, \")\"));\n                }\n              }\n\n              /*\n               * If the last token of the return statement is semicolon, remove it.\n               * Non-block arrow body is an expression, not a statement.\n               */\n              if (astUtils.isSemicolonToken(lastValueToken)) {\n                fixes.push(fixer.remove(lastValueToken));\n              }\n              return fixes;\n            }\n          });\n        }\n      } else {\n        if (always || asNeeded && requireReturnForObjectLiteral && arrowBody.type === \"ObjectExpression\") {\n          context.report({\n            node,\n            loc: arrowBody.loc,\n            messageId: \"expectedBlock\",\n            fix(fixer) {\n              const fixes = [];\n              const arrowToken = sourceCode.getTokenBefore(arrowBody, astUtils.isArrowToken);\n              const [firstTokenAfterArrow, secondTokenAfterArrow] = sourceCode.getTokensAfter(arrowToken, {\n                count: 2\n              });\n              const lastToken = sourceCode.getLastToken(node);\n              let parenthesisedObjectLiteral = null;\n              if (astUtils.isOpeningParenToken(firstTokenAfterArrow) && astUtils.isOpeningBraceToken(secondTokenAfterArrow)) {\n                const braceNode = sourceCode.getNodeByRangeIndex(secondTokenAfterArrow.range[0]);\n                if (braceNode.type === \"ObjectExpression\") {\n                  parenthesisedObjectLiteral = braceNode;\n                }\n              }\n\n              // If the value is object literal, remove parentheses which were forced by syntax.\n              if (parenthesisedObjectLiteral) {\n                const openingParenToken = firstTokenAfterArrow;\n                const openingBraceToken = secondTokenAfterArrow;\n                if (astUtils.isTokenOnSameLine(openingParenToken, openingBraceToken)) {\n                  fixes.push(fixer.replaceText(openingParenToken, \"{return \"));\n                } else {\n                  // Avoid ASI\n                  fixes.push(fixer.replaceText(openingParenToken, \"{\"), fixer.insertTextBefore(openingBraceToken, \"return \"));\n                }\n\n                // Closing paren for the object doesn't have to be lastToken, e.g.: () => ({}).foo()\n                fixes.push(fixer.remove(findClosingParen(parenthesisedObjectLiteral)));\n                fixes.push(fixer.insertTextAfter(lastToken, \"}\"));\n              } else {\n                fixes.push(fixer.insertTextBefore(firstTokenAfterArrow, \"{return \"));\n                fixes.push(fixer.insertTextAfter(lastToken, \"}\"));\n              }\n              return fixes;\n            }\n          });\n        }\n      }\n    }\n    return {\n      \"BinaryExpression[operator='in']\"() {\n        let info = funcInfo;\n        while (info) {\n          info.hasInOperator = true;\n          info = info.upper;\n        }\n      },\n      ArrowFunctionExpression() {\n        funcInfo = {\n          upper: funcInfo,\n          hasInOperator: false\n        };\n      },\n      \"ArrowFunctionExpression:exit\"(node) {\n        validate(node);\n        funcInfo = funcInfo.upper;\n      }\n    };\n  }\n};","map":{"version":3,"names":["require","astUtils","module","exports","meta","type","docs","description","category","recommended","url","schema","anyOf","items","enum","minItems","maxItems","properties","requireReturnForObjectLiteral","additionalProperties","fixable","messages","unexpectedOtherBlock","unexpectedEmptyBlock","unexpectedObjectBlock","unexpectedSingleBlock","expectedBlock","create","context","options","always","asNeeded","never","sourceCode","getSourceCode","funcInfo","hasASIProblem","token","test","value","findClosingParen","node","nodeToCheck","isParenthesised","parent","getTokenAfter","isInsideForLoopInitializer","init","validate","arrowBody","body","blockBody","length","argument","messageId","isOpeningBraceToken","getFirstToken","skip","report","loc","fix","fixer","fixes","openingBrace","closingBrace","getLastToken","firstValueToken","lastValueToken","commentsExist","commentsExistBetween","push","remove","removeRange","range","hasInOperator","insertTextBefore","insertTextAfter","isSemicolonToken","arrowToken","getTokenBefore","isArrowToken","firstTokenAfterArrow","secondTokenAfterArrow","getTokensAfter","count","lastToken","parenthesisedObjectLiteral","isOpeningParenToken","braceNode","getNodeByRangeIndex","openingParenToken","openingBraceToken","isTokenOnSameLine","replaceText","BinaryExpression[operator='in']","info","upper","ArrowFunctionExpression","ArrowFunctionExpression:exit"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/arrow-body-style.js"],"sourcesContent":["/**\n * @fileoverview Rule to require braces in arrow function body.\n * @author Alberto Rodríguez\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require braces around arrow function bodies\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/arrow-body-style\"\n        },\n\n        schema: {\n            anyOf: [\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"always\", \"never\"]\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 1\n                },\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"as-needed\"]\n                        },\n                        {\n                            type: \"object\",\n                            properties: {\n                                requireReturnForObjectLiteral: { type: \"boolean\" }\n                            },\n                            additionalProperties: false\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 2\n                }\n            ]\n        },\n\n        fixable: \"code\",\n\n        messages: {\n            unexpectedOtherBlock: \"Unexpected block statement surrounding arrow body.\",\n            unexpectedEmptyBlock: \"Unexpected block statement surrounding arrow body; put a value of `undefined` immediately after the `=>`.\",\n            unexpectedObjectBlock: \"Unexpected block statement surrounding arrow body; parenthesize the returned value and move it immediately after the `=>`.\",\n            unexpectedSingleBlock: \"Unexpected block statement surrounding arrow body; move the returned value immediately after the `=>`.\",\n            expectedBlock: \"Expected block statement surrounding arrow body.\"\n        }\n    },\n\n    create(context) {\n        const options = context.options;\n        const always = options[0] === \"always\";\n        const asNeeded = !options[0] || options[0] === \"as-needed\";\n        const never = options[0] === \"never\";\n        const requireReturnForObjectLiteral = options[1] && options[1].requireReturnForObjectLiteral;\n        const sourceCode = context.getSourceCode();\n        let funcInfo = null;\n\n        /**\n         * Checks whether the given node has ASI problem or not.\n         * @param {Token} token The token to check.\n         * @returns {boolean} `true` if it changes semantics if `;` or `}` followed by the token are removed.\n         */\n        function hasASIProblem(token) {\n            return token && token.type === \"Punctuator\" && /^[([/`+-]/u.test(token.value);\n        }\n\n        /**\n         * Gets the closing parenthesis by the given node.\n         * @param {ASTNode} node first node after an opening parenthesis.\n         * @returns {Token} The found closing parenthesis token.\n         */\n        function findClosingParen(node) {\n            let nodeToCheck = node;\n\n            while (!astUtils.isParenthesised(sourceCode, nodeToCheck)) {\n                nodeToCheck = nodeToCheck.parent;\n            }\n            return sourceCode.getTokenAfter(nodeToCheck);\n        }\n\n        /**\n         * Check whether the node is inside of a for loop's init\n         * @param {ASTNode} node node is inside for loop\n         * @returns {boolean} `true` if the node is inside of a for loop, else `false`\n         */\n        function isInsideForLoopInitializer(node) {\n            if (node && node.parent) {\n                if (node.parent.type === \"ForStatement\" && node.parent.init === node) {\n                    return true;\n                }\n                return isInsideForLoopInitializer(node.parent);\n            }\n            return false;\n        }\n\n        /**\n         * Determines whether a arrow function body needs braces\n         * @param {ASTNode} node The arrow function node.\n         * @returns {void}\n         */\n        function validate(node) {\n            const arrowBody = node.body;\n\n            if (arrowBody.type === \"BlockStatement\") {\n                const blockBody = arrowBody.body;\n\n                if (blockBody.length !== 1 && !never) {\n                    return;\n                }\n\n                if (asNeeded && requireReturnForObjectLiteral && blockBody[0].type === \"ReturnStatement\" &&\n                    blockBody[0].argument && blockBody[0].argument.type === \"ObjectExpression\") {\n                    return;\n                }\n\n                if (never || asNeeded && blockBody[0].type === \"ReturnStatement\") {\n                    let messageId;\n\n                    if (blockBody.length === 0) {\n                        messageId = \"unexpectedEmptyBlock\";\n                    } else if (blockBody.length > 1) {\n                        messageId = \"unexpectedOtherBlock\";\n                    } else if (blockBody[0].argument === null) {\n                        messageId = \"unexpectedSingleBlock\";\n                    } else if (astUtils.isOpeningBraceToken(sourceCode.getFirstToken(blockBody[0], { skip: 1 }))) {\n                        messageId = \"unexpectedObjectBlock\";\n                    } else {\n                        messageId = \"unexpectedSingleBlock\";\n                    }\n\n                    context.report({\n                        node,\n                        loc: arrowBody.loc,\n                        messageId,\n                        fix(fixer) {\n                            const fixes = [];\n\n                            if (blockBody.length !== 1 ||\n                                blockBody[0].type !== \"ReturnStatement\" ||\n                                !blockBody[0].argument ||\n                                hasASIProblem(sourceCode.getTokenAfter(arrowBody))\n                            ) {\n                                return fixes;\n                            }\n\n                            const openingBrace = sourceCode.getFirstToken(arrowBody);\n                            const closingBrace = sourceCode.getLastToken(arrowBody);\n                            const firstValueToken = sourceCode.getFirstToken(blockBody[0], 1);\n                            const lastValueToken = sourceCode.getLastToken(blockBody[0]);\n                            const commentsExist =\n                                sourceCode.commentsExistBetween(openingBrace, firstValueToken) ||\n                                sourceCode.commentsExistBetween(lastValueToken, closingBrace);\n\n                            /*\n                             * Remove tokens around the return value.\n                             * If comments don't exist, remove extra spaces as well.\n                             */\n                            if (commentsExist) {\n                                fixes.push(\n                                    fixer.remove(openingBrace),\n                                    fixer.remove(closingBrace),\n                                    fixer.remove(sourceCode.getTokenAfter(openingBrace)) // return keyword\n                                );\n                            } else {\n                                fixes.push(\n                                    fixer.removeRange([openingBrace.range[0], firstValueToken.range[0]]),\n                                    fixer.removeRange([lastValueToken.range[1], closingBrace.range[1]])\n                                );\n                            }\n\n                            /*\n                             * If the first token of the return value is `{` or the return value is a sequence expression,\n                             * enclose the return value by parentheses to avoid syntax error.\n                             */\n                            if (astUtils.isOpeningBraceToken(firstValueToken) || blockBody[0].argument.type === \"SequenceExpression\" || (funcInfo.hasInOperator && isInsideForLoopInitializer(node))) {\n                                if (!astUtils.isParenthesised(sourceCode, blockBody[0].argument)) {\n                                    fixes.push(\n                                        fixer.insertTextBefore(firstValueToken, \"(\"),\n                                        fixer.insertTextAfter(lastValueToken, \")\")\n                                    );\n                                }\n                            }\n\n                            /*\n                             * If the last token of the return statement is semicolon, remove it.\n                             * Non-block arrow body is an expression, not a statement.\n                             */\n                            if (astUtils.isSemicolonToken(lastValueToken)) {\n                                fixes.push(fixer.remove(lastValueToken));\n                            }\n\n                            return fixes;\n                        }\n                    });\n                }\n            } else {\n                if (always || (asNeeded && requireReturnForObjectLiteral && arrowBody.type === \"ObjectExpression\")) {\n                    context.report({\n                        node,\n                        loc: arrowBody.loc,\n                        messageId: \"expectedBlock\",\n                        fix(fixer) {\n                            const fixes = [];\n                            const arrowToken = sourceCode.getTokenBefore(arrowBody, astUtils.isArrowToken);\n                            const [firstTokenAfterArrow, secondTokenAfterArrow] = sourceCode.getTokensAfter(arrowToken, { count: 2 });\n                            const lastToken = sourceCode.getLastToken(node);\n\n                            let parenthesisedObjectLiteral = null;\n\n                            if (\n                                astUtils.isOpeningParenToken(firstTokenAfterArrow) &&\n                                astUtils.isOpeningBraceToken(secondTokenAfterArrow)\n                            ) {\n                                const braceNode = sourceCode.getNodeByRangeIndex(secondTokenAfterArrow.range[0]);\n\n                                if (braceNode.type === \"ObjectExpression\") {\n                                    parenthesisedObjectLiteral = braceNode;\n                                }\n                            }\n\n                            // If the value is object literal, remove parentheses which were forced by syntax.\n                            if (parenthesisedObjectLiteral) {\n                                const openingParenToken = firstTokenAfterArrow;\n                                const openingBraceToken = secondTokenAfterArrow;\n\n                                if (astUtils.isTokenOnSameLine(openingParenToken, openingBraceToken)) {\n                                    fixes.push(fixer.replaceText(openingParenToken, \"{return \"));\n                                } else {\n\n                                    // Avoid ASI\n                                    fixes.push(\n                                        fixer.replaceText(openingParenToken, \"{\"),\n                                        fixer.insertTextBefore(openingBraceToken, \"return \")\n                                    );\n                                }\n\n                                // Closing paren for the object doesn't have to be lastToken, e.g.: () => ({}).foo()\n                                fixes.push(fixer.remove(findClosingParen(parenthesisedObjectLiteral)));\n                                fixes.push(fixer.insertTextAfter(lastToken, \"}\"));\n\n                            } else {\n                                fixes.push(fixer.insertTextBefore(firstTokenAfterArrow, \"{return \"));\n                                fixes.push(fixer.insertTextAfter(lastToken, \"}\"));\n                            }\n\n                            return fixes;\n                        }\n                    });\n                }\n            }\n        }\n\n        return {\n            \"BinaryExpression[operator='in']\"() {\n                let info = funcInfo;\n\n                while (info) {\n                    info.hasInOperator = true;\n                    info = info.upper;\n                }\n            },\n            ArrowFunctionExpression() {\n                funcInfo = {\n                    upper: funcInfo,\n                    hasInOperator: false\n                };\n            },\n            \"ArrowFunctionExpression:exit\"(node) {\n                validate(node);\n                funcInfo = funcInfo.upper;\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}