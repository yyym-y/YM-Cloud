{"ast":null,"code":"/**\n * @fileoverview enforce the location of arrow function bodies\n * @author Sharmila Jesupaul\n */\n\"use strict\";\n\nconst {\n  isCommentToken,\n  isNotOpeningParenToken\n} = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce the location of arrow function bodies\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/implicit-arrow-linebreak\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      enum: [\"beside\", \"below\"]\n    }],\n    messages: {\n      expected: \"Expected a linebreak before this expression.\",\n      unexpected: \"Expected no linebreak before this expression.\"\n    }\n  },\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const option = context.options[0] || \"beside\";\n\n    /**\n     * Validates the location of an arrow function body\n     * @param {ASTNode} node The arrow function body\n     * @returns {void}\n     */\n    function validateExpression(node) {\n      if (node.body.type === \"BlockStatement\") {\n        return;\n      }\n      const arrowToken = sourceCode.getTokenBefore(node.body, isNotOpeningParenToken);\n      const firstTokenOfBody = sourceCode.getTokenAfter(arrowToken);\n      if (arrowToken.loc.end.line === firstTokenOfBody.loc.start.line && option === \"below\") {\n        context.report({\n          node: firstTokenOfBody,\n          messageId: \"expected\",\n          fix: fixer => fixer.insertTextBefore(firstTokenOfBody, \"\\n\")\n        });\n      } else if (arrowToken.loc.end.line !== firstTokenOfBody.loc.start.line && option === \"beside\") {\n        context.report({\n          node: firstTokenOfBody,\n          messageId: \"unexpected\",\n          fix(fixer) {\n            if (sourceCode.getFirstTokenBetween(arrowToken, firstTokenOfBody, {\n              includeComments: true,\n              filter: isCommentToken\n            })) {\n              return null;\n            }\n            return fixer.replaceTextRange([arrowToken.range[1], firstTokenOfBody.range[0]], \" \");\n          }\n        });\n      }\n    }\n\n    //----------------------------------------------------------------------\n    // Public\n    //----------------------------------------------------------------------\n    return {\n      ArrowFunctionExpression: node => validateExpression(node)\n    };\n  }\n};","map":{"version":3,"names":["isCommentToken","isNotOpeningParenToken","require","module","exports","meta","type","docs","description","category","recommended","url","fixable","schema","enum","messages","expected","unexpected","create","context","sourceCode","getSourceCode","option","options","validateExpression","node","body","arrowToken","getTokenBefore","firstTokenOfBody","getTokenAfter","loc","end","line","start","report","messageId","fix","fixer","insertTextBefore","getFirstTokenBetween","includeComments","filter","replaceTextRange","range","ArrowFunctionExpression"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/implicit-arrow-linebreak.js"],"sourcesContent":["/**\n * @fileoverview enforce the location of arrow function bodies\n * @author Sharmila Jesupaul\n */\n\"use strict\";\n\nconst { isCommentToken, isNotOpeningParenToken } = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce the location of arrow function bodies\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/implicit-arrow-linebreak\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                enum: [\"beside\", \"below\"]\n            }\n        ],\n        messages: {\n            expected: \"Expected a linebreak before this expression.\",\n            unexpected: \"Expected no linebreak before this expression.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const option = context.options[0] || \"beside\";\n\n        /**\n         * Validates the location of an arrow function body\n         * @param {ASTNode} node The arrow function body\n         * @returns {void}\n         */\n        function validateExpression(node) {\n            if (node.body.type === \"BlockStatement\") {\n                return;\n            }\n\n            const arrowToken = sourceCode.getTokenBefore(node.body, isNotOpeningParenToken);\n            const firstTokenOfBody = sourceCode.getTokenAfter(arrowToken);\n\n            if (arrowToken.loc.end.line === firstTokenOfBody.loc.start.line && option === \"below\") {\n                context.report({\n                    node: firstTokenOfBody,\n                    messageId: \"expected\",\n                    fix: fixer => fixer.insertTextBefore(firstTokenOfBody, \"\\n\")\n                });\n            } else if (arrowToken.loc.end.line !== firstTokenOfBody.loc.start.line && option === \"beside\") {\n                context.report({\n                    node: firstTokenOfBody,\n                    messageId: \"unexpected\",\n                    fix(fixer) {\n                        if (sourceCode.getFirstTokenBetween(arrowToken, firstTokenOfBody, { includeComments: true, filter: isCommentToken })) {\n                            return null;\n                        }\n\n                        return fixer.replaceTextRange([arrowToken.range[1], firstTokenOfBody.range[0]], \" \");\n                    }\n                });\n            }\n        }\n\n        //----------------------------------------------------------------------\n        // Public\n        //----------------------------------------------------------------------\n        return {\n            ArrowFunctionExpression: node => validateExpression(node)\n        };\n    }\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,YAAY;;AAEZ,MAAM;EAAEA,cAAc;EAAEC;AAAuB,CAAC,GAAGC,OAAO,CAAC,mBAAmB,CAAC;;AAE/E;AACA;AACA;AACAC,MAAM,CAACC,OAAO,GAAG;EACbC,IAAI,EAAE;IACFC,IAAI,EAAE,QAAQ;IAEdC,IAAI,EAAE;MACFC,WAAW,EAAE,+CAA+C;MAC5DC,QAAQ,EAAE,kBAAkB;MAC5BC,WAAW,EAAE,KAAK;MAClBC,GAAG,EAAE;IACT,CAAC;IAEDC,OAAO,EAAE,YAAY;IAErBC,MAAM,EAAE,CACJ;MACIC,IAAI,EAAE,CAAC,QAAQ,EAAE,OAAO;IAC5B,CAAC,CACJ;IACDC,QAAQ,EAAE;MACNC,QAAQ,EAAE,8CAA8C;MACxDC,UAAU,EAAE;IAChB;EACJ,CAAC;EAEDC,MAAMA,CAACC,OAAO,EAAE;IACZ,MAAMC,UAAU,GAAGD,OAAO,CAACE,aAAa,CAAC,CAAC;IAC1C,MAAMC,MAAM,GAAGH,OAAO,CAACI,OAAO,CAAC,CAAC,CAAC,IAAI,QAAQ;;IAE7C;AACR;AACA;AACA;AACA;IACQ,SAASC,kBAAkBA,CAACC,IAAI,EAAE;MAC9B,IAAIA,IAAI,CAACC,IAAI,CAACpB,IAAI,KAAK,gBAAgB,EAAE;QACrC;MACJ;MAEA,MAAMqB,UAAU,GAAGP,UAAU,CAACQ,cAAc,CAACH,IAAI,CAACC,IAAI,EAAEzB,sBAAsB,CAAC;MAC/E,MAAM4B,gBAAgB,GAAGT,UAAU,CAACU,aAAa,CAACH,UAAU,CAAC;MAE7D,IAAIA,UAAU,CAACI,GAAG,CAACC,GAAG,CAACC,IAAI,KAAKJ,gBAAgB,CAACE,GAAG,CAACG,KAAK,CAACD,IAAI,IAAIX,MAAM,KAAK,OAAO,EAAE;QACnFH,OAAO,CAACgB,MAAM,CAAC;UACXV,IAAI,EAAEI,gBAAgB;UACtBO,SAAS,EAAE,UAAU;UACrBC,GAAG,EAAEC,KAAK,IAAIA,KAAK,CAACC,gBAAgB,CAACV,gBAAgB,EAAE,IAAI;QAC/D,CAAC,CAAC;MACN,CAAC,MAAM,IAAIF,UAAU,CAACI,GAAG,CAACC,GAAG,CAACC,IAAI,KAAKJ,gBAAgB,CAACE,GAAG,CAACG,KAAK,CAACD,IAAI,IAAIX,MAAM,KAAK,QAAQ,EAAE;QAC3FH,OAAO,CAACgB,MAAM,CAAC;UACXV,IAAI,EAAEI,gBAAgB;UACtBO,SAAS,EAAE,YAAY;UACvBC,GAAGA,CAACC,KAAK,EAAE;YACP,IAAIlB,UAAU,CAACoB,oBAAoB,CAACb,UAAU,EAAEE,gBAAgB,EAAE;cAAEY,eAAe,EAAE,IAAI;cAAEC,MAAM,EAAE1C;YAAe,CAAC,CAAC,EAAE;cAClH,OAAO,IAAI;YACf;YAEA,OAAOsC,KAAK,CAACK,gBAAgB,CAAC,CAAChB,UAAU,CAACiB,KAAK,CAAC,CAAC,CAAC,EAAEf,gBAAgB,CAACe,KAAK,CAAC,CAAC,CAAC,CAAC,EAAE,GAAG,CAAC;UACxF;QACJ,CAAC,CAAC;MACN;IACJ;;IAEA;IACA;IACA;IACA,OAAO;MACHC,uBAAuB,EAAEpB,IAAI,IAAID,kBAAkB,CAACC,IAAI;IAC5D,CAAC;EACL;AACJ,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}