{"ast":null,"code":"/**\n * @fileoverview Rule to flag `else` after a `return` in `if`\n * @author Ian Christian Myers\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nrequire(\"core-js/modules/es.array.push.js\");\nconst astUtils = require(\"./utils/ast-utils\");\nconst FixTracker = require(\"./utils/fix-tracker\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow `else` blocks after `return` statements in `if` statements\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-else-return\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        allowElseIf: {\n          type: \"boolean\",\n          default: true\n        }\n      },\n      additionalProperties: false\n    }],\n    fixable: \"code\",\n    messages: {\n      unexpected: \"Unnecessary 'else' after 'return'.\"\n    }\n  },\n  create(context) {\n    //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    /**\n     * Checks whether the given names can be safely used to declare block-scoped variables\n     * in the given scope. Name collisions can produce redeclaration syntax errors,\n     * or silently change references and modify behavior of the original code.\n     *\n     * This is not a generic function. In particular, it is assumed that the scope is a function scope or\n     * a function's inner scope, and that the names can be valid identifiers in the given scope.\n     * @param {string[]} names Array of variable names.\n     * @param {eslint-scope.Scope} scope Function scope or a function's inner scope.\n     * @returns {boolean} True if all names can be safely declared, false otherwise.\n     */\n    function isSafeToDeclare(names, scope) {\n      if (names.length === 0) {\n        return true;\n      }\n      const functionScope = scope.variableScope;\n\n      /*\n       * If this is a function scope, scope.variables will contain parameters, implicit variables such as \"arguments\",\n       * all function-scoped variables ('var'), and block-scoped variables defined in the scope.\n       * If this is an inner scope, scope.variables will contain block-scoped variables defined in the scope.\n       *\n       * Redeclaring any of these would cause a syntax error, except for the implicit variables.\n       */\n      const declaredVariables = scope.variables.filter(({\n        defs\n      }) => defs.length > 0);\n      if (declaredVariables.some(({\n        name\n      }) => names.includes(name))) {\n        return false;\n      }\n\n      // Redeclaring a catch variable would also cause a syntax error.\n      if (scope !== functionScope && scope.upper.type === \"catch\") {\n        if (scope.upper.variables.some(({\n          name\n        }) => names.includes(name))) {\n          return false;\n        }\n      }\n\n      /*\n       * Redeclaring an implicit variable, such as \"arguments\", would not cause a syntax error.\n       * However, if the variable was used, declaring a new one with the same name would change references\n       * and modify behavior.\n       */\n      const usedImplicitVariables = scope.variables.filter(({\n        defs,\n        references\n      }) => defs.length === 0 && references.length > 0);\n      if (usedImplicitVariables.some(({\n        name\n      }) => names.includes(name))) {\n        return false;\n      }\n\n      /*\n       * Declaring a variable with a name that was already used to reference a variable from an upper scope\n       * would change references and modify behavior.\n       */\n      if (scope.through.some(t => names.includes(t.identifier.name))) {\n        return false;\n      }\n\n      /*\n       * If the scope is an inner scope (not the function scope), an uninitialized `var` variable declared inside\n       * the scope node (directly or in one of its descendants) is neither declared nor 'through' in the scope.\n       *\n       * For example, this would be a syntax error \"Identifier 'a' has already been declared\":\n       * function foo() { if (bar) { let a; if (baz) { var a; } } }\n       */\n      if (scope !== functionScope) {\n        const scopeNodeRange = scope.block.range;\n        const variablesToCheck = functionScope.variables.filter(({\n          name\n        }) => names.includes(name));\n        if (variablesToCheck.some(v => v.defs.some(({\n          node: {\n            range\n          }\n        }) => scopeNodeRange[0] <= range[0] && range[1] <= scopeNodeRange[1]))) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    /**\n     * Checks whether the removal of `else` and its braces is safe from variable name collisions.\n     * @param {Node} node The 'else' node.\n     * @param {eslint-scope.Scope} scope The scope in which the node and the whole 'if' statement is.\n     * @returns {boolean} True if it is safe, false otherwise.\n     */\n    function isSafeFromNameCollisions(node, scope) {\n      if (node.type === \"FunctionDeclaration\") {\n        // Conditional function declaration. Scope and hoisting are unpredictable, different engines work differently.\n        return false;\n      }\n      if (node.type !== \"BlockStatement\") {\n        return true;\n      }\n      const elseBlockScope = scope.childScopes.find(({\n        block\n      }) => block === node);\n      if (!elseBlockScope) {\n        // ecmaVersion < 6, `else` block statement cannot have its own scope, no possible collisions.\n        return true;\n      }\n\n      /*\n       * elseBlockScope is supposed to merge into its upper scope. elseBlockScope.variables array contains\n       * only block-scoped variables (such as let and const variables or class and function declarations)\n       * defined directly in the elseBlockScope. These are exactly the only names that could cause collisions.\n       */\n      const namesToCheck = elseBlockScope.variables.map(({\n        name\n      }) => name);\n      return isSafeToDeclare(namesToCheck, scope);\n    }\n\n    /**\n     * Display the context report if rule is violated\n     * @param {Node} node The 'else' node\n     * @returns {void}\n     */\n    function displayReport(node) {\n      const currentScope = context.getScope();\n      context.report({\n        node,\n        messageId: \"unexpected\",\n        fix: fixer => {\n          if (!isSafeFromNameCollisions(node, currentScope)) {\n            return null;\n          }\n          const sourceCode = context.getSourceCode();\n          const startToken = sourceCode.getFirstToken(node);\n          const elseToken = sourceCode.getTokenBefore(startToken);\n          const source = sourceCode.getText(node);\n          const lastIfToken = sourceCode.getTokenBefore(elseToken);\n          let fixedSource, firstTokenOfElseBlock;\n          if (startToken.type === \"Punctuator\" && startToken.value === \"{\") {\n            firstTokenOfElseBlock = sourceCode.getTokenAfter(startToken);\n          } else {\n            firstTokenOfElseBlock = startToken;\n          }\n\n          /*\n           * If the if block does not have curly braces and does not end in a semicolon\n           * and the else block starts with (, [, /, +, ` or -, then it is not\n           * safe to remove the else keyword, because ASI will not add a semicolon\n           * after the if block\n           */\n          const ifBlockMaybeUnsafe = node.parent.consequent.type !== \"BlockStatement\" && lastIfToken.value !== \";\";\n          const elseBlockUnsafe = /^[([/+`-]/u.test(firstTokenOfElseBlock.value);\n          if (ifBlockMaybeUnsafe && elseBlockUnsafe) {\n            return null;\n          }\n          const endToken = sourceCode.getLastToken(node);\n          const lastTokenOfElseBlock = sourceCode.getTokenBefore(endToken);\n          if (lastTokenOfElseBlock.value !== \";\") {\n            const nextToken = sourceCode.getTokenAfter(endToken);\n            const nextTokenUnsafe = nextToken && /^[([/+`-]/u.test(nextToken.value);\n            const nextTokenOnSameLine = nextToken && nextToken.loc.start.line === lastTokenOfElseBlock.loc.start.line;\n\n            /*\n             * If the else block contents does not end in a semicolon,\n             * and the else block starts with (, [, /, +, ` or -, then it is not\n             * safe to remove the else block, because ASI will not add a semicolon\n             * after the remaining else block contents\n             */\n            if (nextTokenUnsafe || nextTokenOnSameLine && nextToken.value !== \"}\") {\n              return null;\n            }\n          }\n          if (startToken.type === \"Punctuator\" && startToken.value === \"{\") {\n            fixedSource = source.slice(1, -1);\n          } else {\n            fixedSource = source;\n          }\n\n          /*\n           * Extend the replacement range to include the entire\n           * function to avoid conflicting with no-useless-return.\n           * https://github.com/eslint/eslint/issues/8026\n           *\n           * Also, to avoid name collisions between two else blocks.\n           */\n          return new FixTracker(fixer, sourceCode).retainEnclosingFunction(node).replaceTextRange([elseToken.range[0], node.range[1]], fixedSource);\n        }\n      });\n    }\n\n    /**\n     * Check to see if the node is a ReturnStatement\n     * @param {Node} node The node being evaluated\n     * @returns {boolean} True if node is a return\n     */\n    function checkForReturn(node) {\n      return node.type === \"ReturnStatement\";\n    }\n\n    /**\n     * Naive return checking, does not iterate through the whole\n     * BlockStatement because we make the assumption that the ReturnStatement\n     * will be the last node in the body of the BlockStatement.\n     * @param {Node} node The consequent/alternate node\n     * @returns {boolean} True if it has a return\n     */\n    function naiveHasReturn(node) {\n      if (node.type === \"BlockStatement\") {\n        const body = node.body,\n          lastChildNode = body[body.length - 1];\n        return lastChildNode && checkForReturn(lastChildNode);\n      }\n      return checkForReturn(node);\n    }\n\n    /**\n     * Check to see if the node is valid for evaluation,\n     * meaning it has an else.\n     * @param {Node} node The node being evaluated\n     * @returns {boolean} True if the node is valid\n     */\n    function hasElse(node) {\n      return node.alternate && node.consequent;\n    }\n\n    /**\n     * If the consequent is an IfStatement, check to see if it has an else\n     * and both its consequent and alternate path return, meaning this is\n     * a nested case of rule violation.  If-Else not considered currently.\n     * @param {Node} node The consequent node\n     * @returns {boolean} True if this is a nested rule violation\n     */\n    function checkForIf(node) {\n      return node.type === \"IfStatement\" && hasElse(node) && naiveHasReturn(node.alternate) && naiveHasReturn(node.consequent);\n    }\n\n    /**\n     * Check the consequent/body node to make sure it is not\n     * a ReturnStatement or an IfStatement that returns on both\n     * code paths.\n     * @param {Node} node The consequent or body node\n     * @returns {boolean} `true` if it is a Return/If node that always returns.\n     */\n    function checkForReturnOrIf(node) {\n      return checkForReturn(node) || checkForIf(node);\n    }\n\n    /**\n     * Check whether a node returns in every codepath.\n     * @param {Node} node The node to be checked\n     * @returns {boolean} `true` if it returns on every codepath.\n     */\n    function alwaysReturns(node) {\n      if (node.type === \"BlockStatement\") {\n        // If we have a BlockStatement, check each consequent body node.\n        return node.body.some(checkForReturnOrIf);\n      }\n\n      /*\n       * If not a block statement, make sure the consequent isn't a\n       * ReturnStatement or an IfStatement with returns on both paths.\n       */\n      return checkForReturnOrIf(node);\n    }\n\n    /**\n     * Check the if statement, but don't catch else-if blocks.\n     * @returns {void}\n     * @param {Node} node The node for the if statement to check\n     * @private\n     */\n    function checkIfWithoutElse(node) {\n      const parent = node.parent;\n\n      /*\n       * Fixing this would require splitting one statement into two, so no error should\n       * be reported if this node is in a position where only one statement is allowed.\n       */\n      if (!astUtils.STATEMENT_LIST_PARENTS.has(parent.type)) {\n        return;\n      }\n      const consequents = [];\n      let alternate;\n      for (let currentNode = node; currentNode.type === \"IfStatement\"; currentNode = currentNode.alternate) {\n        if (!currentNode.alternate) {\n          return;\n        }\n        consequents.push(currentNode.consequent);\n        alternate = currentNode.alternate;\n      }\n      if (consequents.every(alwaysReturns)) {\n        displayReport(alternate);\n      }\n    }\n\n    /**\n     * Check the if statement\n     * @returns {void}\n     * @param {Node} node The node for the if statement to check\n     * @private\n     */\n    function checkIfWithElse(node) {\n      const parent = node.parent;\n\n      /*\n       * Fixing this would require splitting one statement into two, so no error should\n       * be reported if this node is in a position where only one statement is allowed.\n       */\n      if (!astUtils.STATEMENT_LIST_PARENTS.has(parent.type)) {\n        return;\n      }\n      const alternate = node.alternate;\n      if (alternate && alwaysReturns(node.consequent)) {\n        displayReport(alternate);\n      }\n    }\n    const allowElseIf = !(context.options[0] && context.options[0].allowElseIf === false);\n\n    //--------------------------------------------------------------------------\n    // Public API\n    //--------------------------------------------------------------------------\n\n    return {\n      \"IfStatement:exit\": allowElseIf ? checkIfWithoutElse : checkIfWithElse\n    };\n  }\n};","map":{"version":3,"names":["require","astUtils","FixTracker","module","exports","meta","type","docs","description","category","recommended","url","schema","properties","allowElseIf","default","additionalProperties","fixable","messages","unexpected","create","context","isSafeToDeclare","names","scope","length","functionScope","variableScope","declaredVariables","variables","filter","defs","some","name","includes","upper","usedImplicitVariables","references","through","t","identifier","scopeNodeRange","block","range","variablesToCheck","v","node","isSafeFromNameCollisions","elseBlockScope","childScopes","find","namesToCheck","map","displayReport","currentScope","getScope","report","messageId","fix","fixer","sourceCode","getSourceCode","startToken","getFirstToken","elseToken","getTokenBefore","source","getText","lastIfToken","fixedSource","firstTokenOfElseBlock","value","getTokenAfter","ifBlockMaybeUnsafe","parent","consequent","elseBlockUnsafe","test","endToken","getLastToken","lastTokenOfElseBlock","nextToken","nextTokenUnsafe","nextTokenOnSameLine","loc","start","line","slice","retainEnclosingFunction","replaceTextRange","checkForReturn","naiveHasReturn","body","lastChildNode","hasElse","alternate","checkForIf","checkForReturnOrIf","alwaysReturns","checkIfWithoutElse","STATEMENT_LIST_PARENTS","has","consequents","currentNode","push","every","checkIfWithElse","options"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/no-else-return.js"],"sourcesContent":["/**\n * @fileoverview Rule to flag `else` after a `return` in `if`\n * @author Ian Christian Myers\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\nconst FixTracker = require(\"./utils/fix-tracker\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow `else` blocks after `return` statements in `if` statements\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-else-return\"\n        },\n\n        schema: [{\n            type: \"object\",\n            properties: {\n                allowElseIf: {\n                    type: \"boolean\",\n                    default: true\n                }\n            },\n            additionalProperties: false\n        }],\n\n        fixable: \"code\",\n\n        messages: {\n            unexpected: \"Unnecessary 'else' after 'return'.\"\n        }\n    },\n\n    create(context) {\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Checks whether the given names can be safely used to declare block-scoped variables\n         * in the given scope. Name collisions can produce redeclaration syntax errors,\n         * or silently change references and modify behavior of the original code.\n         *\n         * This is not a generic function. In particular, it is assumed that the scope is a function scope or\n         * a function's inner scope, and that the names can be valid identifiers in the given scope.\n         * @param {string[]} names Array of variable names.\n         * @param {eslint-scope.Scope} scope Function scope or a function's inner scope.\n         * @returns {boolean} True if all names can be safely declared, false otherwise.\n         */\n        function isSafeToDeclare(names, scope) {\n\n            if (names.length === 0) {\n                return true;\n            }\n\n            const functionScope = scope.variableScope;\n\n            /*\n             * If this is a function scope, scope.variables will contain parameters, implicit variables such as \"arguments\",\n             * all function-scoped variables ('var'), and block-scoped variables defined in the scope.\n             * If this is an inner scope, scope.variables will contain block-scoped variables defined in the scope.\n             *\n             * Redeclaring any of these would cause a syntax error, except for the implicit variables.\n             */\n            const declaredVariables = scope.variables.filter(({ defs }) => defs.length > 0);\n\n            if (declaredVariables.some(({ name }) => names.includes(name))) {\n                return false;\n            }\n\n            // Redeclaring a catch variable would also cause a syntax error.\n            if (scope !== functionScope && scope.upper.type === \"catch\") {\n                if (scope.upper.variables.some(({ name }) => names.includes(name))) {\n                    return false;\n                }\n            }\n\n            /*\n             * Redeclaring an implicit variable, such as \"arguments\", would not cause a syntax error.\n             * However, if the variable was used, declaring a new one with the same name would change references\n             * and modify behavior.\n             */\n            const usedImplicitVariables = scope.variables.filter(({ defs, references }) =>\n                defs.length === 0 && references.length > 0);\n\n            if (usedImplicitVariables.some(({ name }) => names.includes(name))) {\n                return false;\n            }\n\n            /*\n             * Declaring a variable with a name that was already used to reference a variable from an upper scope\n             * would change references and modify behavior.\n             */\n            if (scope.through.some(t => names.includes(t.identifier.name))) {\n                return false;\n            }\n\n            /*\n             * If the scope is an inner scope (not the function scope), an uninitialized `var` variable declared inside\n             * the scope node (directly or in one of its descendants) is neither declared nor 'through' in the scope.\n             *\n             * For example, this would be a syntax error \"Identifier 'a' has already been declared\":\n             * function foo() { if (bar) { let a; if (baz) { var a; } } }\n             */\n            if (scope !== functionScope) {\n                const scopeNodeRange = scope.block.range;\n                const variablesToCheck = functionScope.variables.filter(({ name }) => names.includes(name));\n\n                if (variablesToCheck.some(v => v.defs.some(({ node: { range } }) =>\n                    scopeNodeRange[0] <= range[0] && range[1] <= scopeNodeRange[1]))) {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n\n        /**\n         * Checks whether the removal of `else` and its braces is safe from variable name collisions.\n         * @param {Node} node The 'else' node.\n         * @param {eslint-scope.Scope} scope The scope in which the node and the whole 'if' statement is.\n         * @returns {boolean} True if it is safe, false otherwise.\n         */\n        function isSafeFromNameCollisions(node, scope) {\n\n            if (node.type === \"FunctionDeclaration\") {\n\n                // Conditional function declaration. Scope and hoisting are unpredictable, different engines work differently.\n                return false;\n            }\n\n            if (node.type !== \"BlockStatement\") {\n                return true;\n            }\n\n            const elseBlockScope = scope.childScopes.find(({ block }) => block === node);\n\n            if (!elseBlockScope) {\n\n                // ecmaVersion < 6, `else` block statement cannot have its own scope, no possible collisions.\n                return true;\n            }\n\n            /*\n             * elseBlockScope is supposed to merge into its upper scope. elseBlockScope.variables array contains\n             * only block-scoped variables (such as let and const variables or class and function declarations)\n             * defined directly in the elseBlockScope. These are exactly the only names that could cause collisions.\n             */\n            const namesToCheck = elseBlockScope.variables.map(({ name }) => name);\n\n            return isSafeToDeclare(namesToCheck, scope);\n        }\n\n        /**\n         * Display the context report if rule is violated\n         * @param {Node} node The 'else' node\n         * @returns {void}\n         */\n        function displayReport(node) {\n            const currentScope = context.getScope();\n\n            context.report({\n                node,\n                messageId: \"unexpected\",\n                fix: fixer => {\n\n                    if (!isSafeFromNameCollisions(node, currentScope)) {\n                        return null;\n                    }\n\n                    const sourceCode = context.getSourceCode();\n                    const startToken = sourceCode.getFirstToken(node);\n                    const elseToken = sourceCode.getTokenBefore(startToken);\n                    const source = sourceCode.getText(node);\n                    const lastIfToken = sourceCode.getTokenBefore(elseToken);\n                    let fixedSource, firstTokenOfElseBlock;\n\n                    if (startToken.type === \"Punctuator\" && startToken.value === \"{\") {\n                        firstTokenOfElseBlock = sourceCode.getTokenAfter(startToken);\n                    } else {\n                        firstTokenOfElseBlock = startToken;\n                    }\n\n                    /*\n                     * If the if block does not have curly braces and does not end in a semicolon\n                     * and the else block starts with (, [, /, +, ` or -, then it is not\n                     * safe to remove the else keyword, because ASI will not add a semicolon\n                     * after the if block\n                     */\n                    const ifBlockMaybeUnsafe = node.parent.consequent.type !== \"BlockStatement\" && lastIfToken.value !== \";\";\n                    const elseBlockUnsafe = /^[([/+`-]/u.test(firstTokenOfElseBlock.value);\n\n                    if (ifBlockMaybeUnsafe && elseBlockUnsafe) {\n                        return null;\n                    }\n\n                    const endToken = sourceCode.getLastToken(node);\n                    const lastTokenOfElseBlock = sourceCode.getTokenBefore(endToken);\n\n                    if (lastTokenOfElseBlock.value !== \";\") {\n                        const nextToken = sourceCode.getTokenAfter(endToken);\n\n                        const nextTokenUnsafe = nextToken && /^[([/+`-]/u.test(nextToken.value);\n                        const nextTokenOnSameLine = nextToken && nextToken.loc.start.line === lastTokenOfElseBlock.loc.start.line;\n\n                        /*\n                         * If the else block contents does not end in a semicolon,\n                         * and the else block starts with (, [, /, +, ` or -, then it is not\n                         * safe to remove the else block, because ASI will not add a semicolon\n                         * after the remaining else block contents\n                         */\n                        if (nextTokenUnsafe || (nextTokenOnSameLine && nextToken.value !== \"}\")) {\n                            return null;\n                        }\n                    }\n\n                    if (startToken.type === \"Punctuator\" && startToken.value === \"{\") {\n                        fixedSource = source.slice(1, -1);\n                    } else {\n                        fixedSource = source;\n                    }\n\n                    /*\n                     * Extend the replacement range to include the entire\n                     * function to avoid conflicting with no-useless-return.\n                     * https://github.com/eslint/eslint/issues/8026\n                     *\n                     * Also, to avoid name collisions between two else blocks.\n                     */\n                    return new FixTracker(fixer, sourceCode)\n                        .retainEnclosingFunction(node)\n                        .replaceTextRange([elseToken.range[0], node.range[1]], fixedSource);\n                }\n            });\n        }\n\n        /**\n         * Check to see if the node is a ReturnStatement\n         * @param {Node} node The node being evaluated\n         * @returns {boolean} True if node is a return\n         */\n        function checkForReturn(node) {\n            return node.type === \"ReturnStatement\";\n        }\n\n        /**\n         * Naive return checking, does not iterate through the whole\n         * BlockStatement because we make the assumption that the ReturnStatement\n         * will be the last node in the body of the BlockStatement.\n         * @param {Node} node The consequent/alternate node\n         * @returns {boolean} True if it has a return\n         */\n        function naiveHasReturn(node) {\n            if (node.type === \"BlockStatement\") {\n                const body = node.body,\n                    lastChildNode = body[body.length - 1];\n\n                return lastChildNode && checkForReturn(lastChildNode);\n            }\n            return checkForReturn(node);\n        }\n\n        /**\n         * Check to see if the node is valid for evaluation,\n         * meaning it has an else.\n         * @param {Node} node The node being evaluated\n         * @returns {boolean} True if the node is valid\n         */\n        function hasElse(node) {\n            return node.alternate && node.consequent;\n        }\n\n        /**\n         * If the consequent is an IfStatement, check to see if it has an else\n         * and both its consequent and alternate path return, meaning this is\n         * a nested case of rule violation.  If-Else not considered currently.\n         * @param {Node} node The consequent node\n         * @returns {boolean} True if this is a nested rule violation\n         */\n        function checkForIf(node) {\n            return node.type === \"IfStatement\" && hasElse(node) &&\n                naiveHasReturn(node.alternate) && naiveHasReturn(node.consequent);\n        }\n\n        /**\n         * Check the consequent/body node to make sure it is not\n         * a ReturnStatement or an IfStatement that returns on both\n         * code paths.\n         * @param {Node} node The consequent or body node\n         * @returns {boolean} `true` if it is a Return/If node that always returns.\n         */\n        function checkForReturnOrIf(node) {\n            return checkForReturn(node) || checkForIf(node);\n        }\n\n\n        /**\n         * Check whether a node returns in every codepath.\n         * @param {Node} node The node to be checked\n         * @returns {boolean} `true` if it returns on every codepath.\n         */\n        function alwaysReturns(node) {\n            if (node.type === \"BlockStatement\") {\n\n                // If we have a BlockStatement, check each consequent body node.\n                return node.body.some(checkForReturnOrIf);\n            }\n\n            /*\n             * If not a block statement, make sure the consequent isn't a\n             * ReturnStatement or an IfStatement with returns on both paths.\n             */\n            return checkForReturnOrIf(node);\n        }\n\n\n        /**\n         * Check the if statement, but don't catch else-if blocks.\n         * @returns {void}\n         * @param {Node} node The node for the if statement to check\n         * @private\n         */\n        function checkIfWithoutElse(node) {\n            const parent = node.parent;\n\n            /*\n             * Fixing this would require splitting one statement into two, so no error should\n             * be reported if this node is in a position where only one statement is allowed.\n             */\n            if (!astUtils.STATEMENT_LIST_PARENTS.has(parent.type)) {\n                return;\n            }\n\n            const consequents = [];\n            let alternate;\n\n            for (let currentNode = node; currentNode.type === \"IfStatement\"; currentNode = currentNode.alternate) {\n                if (!currentNode.alternate) {\n                    return;\n                }\n                consequents.push(currentNode.consequent);\n                alternate = currentNode.alternate;\n            }\n\n            if (consequents.every(alwaysReturns)) {\n                displayReport(alternate);\n            }\n        }\n\n        /**\n         * Check the if statement\n         * @returns {void}\n         * @param {Node} node The node for the if statement to check\n         * @private\n         */\n        function checkIfWithElse(node) {\n            const parent = node.parent;\n\n\n            /*\n             * Fixing this would require splitting one statement into two, so no error should\n             * be reported if this node is in a position where only one statement is allowed.\n             */\n            if (!astUtils.STATEMENT_LIST_PARENTS.has(parent.type)) {\n                return;\n            }\n\n            const alternate = node.alternate;\n\n            if (alternate && alwaysReturns(node.consequent)) {\n                displayReport(alternate);\n            }\n        }\n\n        const allowElseIf = !(context.options[0] && context.options[0].allowElseIf === false);\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n\n            \"IfStatement:exit\": allowElseIf ? checkIfWithoutElse : checkIfWithElse\n\n        };\n\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}