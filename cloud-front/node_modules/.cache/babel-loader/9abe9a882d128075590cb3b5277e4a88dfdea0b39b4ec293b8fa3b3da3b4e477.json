{"ast":null,"code":"'use strict';\n\n/*eslint-disable no-bitwise*/\nrequire(\"core-js/modules/es.array.push.js\");\nvar NodeBuffer;\ntry {\n  // A trick for browserified version, to not include `Buffer` shim\n  var _require = require;\n  NodeBuffer = _require('buffer').Buffer;\n} catch (__) {}\nvar Type = require('../type');\n\n// [ 64, 65, 66 ] -> [ padding, CR, LF ]\nvar BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\\n\\r';\nfunction resolveYamlBinary(data) {\n  if (data === null) return false;\n  var code,\n    idx,\n    bitlen = 0,\n    max = data.length,\n    map = BASE64_MAP;\n\n  // Convert one by one.\n  for (idx = 0; idx < max; idx++) {\n    code = map.indexOf(data.charAt(idx));\n\n    // Skip CR/LF\n    if (code > 64) continue;\n\n    // Fail on illegal characters\n    if (code < 0) return false;\n    bitlen += 6;\n  }\n\n  // If there are any bits left, source was corrupted\n  return bitlen % 8 === 0;\n}\nfunction constructYamlBinary(data) {\n  var idx,\n    tailbits,\n    input = data.replace(/[\\r\\n=]/g, ''),\n    // remove CR/LF & padding to simplify scan\n    max = input.length,\n    map = BASE64_MAP,\n    bits = 0,\n    result = [];\n\n  // Collect by 6*4 bits (3 bytes)\n\n  for (idx = 0; idx < max; idx++) {\n    if (idx % 4 === 0 && idx) {\n      result.push(bits >> 16 & 0xFF);\n      result.push(bits >> 8 & 0xFF);\n      result.push(bits & 0xFF);\n    }\n    bits = bits << 6 | map.indexOf(input.charAt(idx));\n  }\n\n  // Dump tail\n\n  tailbits = max % 4 * 6;\n  if (tailbits === 0) {\n    result.push(bits >> 16 & 0xFF);\n    result.push(bits >> 8 & 0xFF);\n    result.push(bits & 0xFF);\n  } else if (tailbits === 18) {\n    result.push(bits >> 10 & 0xFF);\n    result.push(bits >> 2 & 0xFF);\n  } else if (tailbits === 12) {\n    result.push(bits >> 4 & 0xFF);\n  }\n\n  // Wrap into Buffer for NodeJS and leave Array for browser\n  if (NodeBuffer) {\n    // Support node 6.+ Buffer API when available\n    return NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result);\n  }\n  return result;\n}\nfunction representYamlBinary(object /*, style*/) {\n  var result = '',\n    bits = 0,\n    idx,\n    tail,\n    max = object.length,\n    map = BASE64_MAP;\n\n  // Convert every three bytes to 4 ASCII characters.\n\n  for (idx = 0; idx < max; idx++) {\n    if (idx % 3 === 0 && idx) {\n      result += map[bits >> 18 & 0x3F];\n      result += map[bits >> 12 & 0x3F];\n      result += map[bits >> 6 & 0x3F];\n      result += map[bits & 0x3F];\n    }\n    bits = (bits << 8) + object[idx];\n  }\n\n  // Dump tail\n\n  tail = max % 3;\n  if (tail === 0) {\n    result += map[bits >> 18 & 0x3F];\n    result += map[bits >> 12 & 0x3F];\n    result += map[bits >> 6 & 0x3F];\n    result += map[bits & 0x3F];\n  } else if (tail === 2) {\n    result += map[bits >> 10 & 0x3F];\n    result += map[bits >> 4 & 0x3F];\n    result += map[bits << 2 & 0x3F];\n    result += map[64];\n  } else if (tail === 1) {\n    result += map[bits >> 2 & 0x3F];\n    result += map[bits << 4 & 0x3F];\n    result += map[64];\n    result += map[64];\n  }\n  return result;\n}\nfunction isBinary(object) {\n  return NodeBuffer && NodeBuffer.isBuffer(object);\n}\nmodule.exports = new Type('tag:yaml.org,2002:binary', {\n  kind: 'scalar',\n  resolve: resolveYamlBinary,\n  construct: constructYamlBinary,\n  predicate: isBinary,\n  represent: representYamlBinary\n});","map":{"version":3,"names":["require","NodeBuffer","_require","Buffer","__","Type","BASE64_MAP","resolveYamlBinary","data","code","idx","bitlen","max","length","map","indexOf","charAt","constructYamlBinary","tailbits","input","replace","bits","result","push","from","representYamlBinary","object","tail","isBinary","isBuffer","module","exports","kind","resolve","construct","predicate","represent"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/js-yaml/lib/js-yaml/type/binary.js"],"sourcesContent":["'use strict';\n\n/*eslint-disable no-bitwise*/\n\nvar NodeBuffer;\n\ntry {\n  // A trick for browserified version, to not include `Buffer` shim\n  var _require = require;\n  NodeBuffer = _require('buffer').Buffer;\n} catch (__) {}\n\nvar Type       = require('../type');\n\n\n// [ 64, 65, 66 ] -> [ padding, CR, LF ]\nvar BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\\n\\r';\n\n\nfunction resolveYamlBinary(data) {\n  if (data === null) return false;\n\n  var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;\n\n  // Convert one by one.\n  for (idx = 0; idx < max; idx++) {\n    code = map.indexOf(data.charAt(idx));\n\n    // Skip CR/LF\n    if (code > 64) continue;\n\n    // Fail on illegal characters\n    if (code < 0) return false;\n\n    bitlen += 6;\n  }\n\n  // If there are any bits left, source was corrupted\n  return (bitlen % 8) === 0;\n}\n\nfunction constructYamlBinary(data) {\n  var idx, tailbits,\n      input = data.replace(/[\\r\\n=]/g, ''), // remove CR/LF & padding to simplify scan\n      max = input.length,\n      map = BASE64_MAP,\n      bits = 0,\n      result = [];\n\n  // Collect by 6*4 bits (3 bytes)\n\n  for (idx = 0; idx < max; idx++) {\n    if ((idx % 4 === 0) && idx) {\n      result.push((bits >> 16) & 0xFF);\n      result.push((bits >> 8) & 0xFF);\n      result.push(bits & 0xFF);\n    }\n\n    bits = (bits << 6) | map.indexOf(input.charAt(idx));\n  }\n\n  // Dump tail\n\n  tailbits = (max % 4) * 6;\n\n  if (tailbits === 0) {\n    result.push((bits >> 16) & 0xFF);\n    result.push((bits >> 8) & 0xFF);\n    result.push(bits & 0xFF);\n  } else if (tailbits === 18) {\n    result.push((bits >> 10) & 0xFF);\n    result.push((bits >> 2) & 0xFF);\n  } else if (tailbits === 12) {\n    result.push((bits >> 4) & 0xFF);\n  }\n\n  // Wrap into Buffer for NodeJS and leave Array for browser\n  if (NodeBuffer) {\n    // Support node 6.+ Buffer API when available\n    return NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result);\n  }\n\n  return result;\n}\n\nfunction representYamlBinary(object /*, style*/) {\n  var result = '', bits = 0, idx, tail,\n      max = object.length,\n      map = BASE64_MAP;\n\n  // Convert every three bytes to 4 ASCII characters.\n\n  for (idx = 0; idx < max; idx++) {\n    if ((idx % 3 === 0) && idx) {\n      result += map[(bits >> 18) & 0x3F];\n      result += map[(bits >> 12) & 0x3F];\n      result += map[(bits >> 6) & 0x3F];\n      result += map[bits & 0x3F];\n    }\n\n    bits = (bits << 8) + object[idx];\n  }\n\n  // Dump tail\n\n  tail = max % 3;\n\n  if (tail === 0) {\n    result += map[(bits >> 18) & 0x3F];\n    result += map[(bits >> 12) & 0x3F];\n    result += map[(bits >> 6) & 0x3F];\n    result += map[bits & 0x3F];\n  } else if (tail === 2) {\n    result += map[(bits >> 10) & 0x3F];\n    result += map[(bits >> 4) & 0x3F];\n    result += map[(bits << 2) & 0x3F];\n    result += map[64];\n  } else if (tail === 1) {\n    result += map[(bits >> 2) & 0x3F];\n    result += map[(bits << 4) & 0x3F];\n    result += map[64];\n    result += map[64];\n  }\n\n  return result;\n}\n\nfunction isBinary(object) {\n  return NodeBuffer && NodeBuffer.isBuffer(object);\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:binary', {\n  kind: 'scalar',\n  resolve: resolveYamlBinary,\n  construct: constructYamlBinary,\n  predicate: isBinary,\n  represent: representYamlBinary\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}