{"ast":null,"code":"require(\"core-js/modules/es.array.push.js\");\n/*\n * @fileoverview Main Doctrine object\n * @author Yusuke Suzuki <utatane.tea@gmail.com>\n * @author Dan Tao <daniel.tao@gmail.com>\n * @author Andrew Eisenberg <andrew@eisenberg.as>\n */\n\n(function () {\n  'use strict';\n\n  var typed, utility, jsdoc, esutils, hasOwnProperty;\n  esutils = require('esutils');\n  typed = require('./typed');\n  utility = require('./utility');\n  function sliceSource(source, index, last) {\n    return source.slice(index, last);\n  }\n  hasOwnProperty = function () {\n    var func = Object.prototype.hasOwnProperty;\n    return function hasOwnProperty(obj, name) {\n      return func.call(obj, name);\n    };\n  }();\n  function shallowCopy(obj) {\n    var ret = {},\n      key;\n    for (key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        ret[key] = obj[key];\n      }\n    }\n    return ret;\n  }\n  function isASCIIAlphanumeric(ch) {\n    return ch >= 0x61 /* 'a' */ && ch <= 0x7A /* 'z' */ || ch >= 0x41 /* 'A' */ && ch <= 0x5A /* 'Z' */ || ch >= 0x30 /* '0' */ && ch <= 0x39 /* '9' */;\n  }\n\n  function isParamTitle(title) {\n    return title === 'param' || title === 'argument' || title === 'arg';\n  }\n  function isReturnTitle(title) {\n    return title === 'return' || title === 'returns';\n  }\n  function isProperty(title) {\n    return title === 'property' || title === 'prop';\n  }\n  function isNameParameterRequired(title) {\n    return isParamTitle(title) || isProperty(title) || title === 'alias' || title === 'this' || title === 'mixes' || title === 'requires';\n  }\n  function isAllowedName(title) {\n    return isNameParameterRequired(title) || title === 'const' || title === 'constant';\n  }\n  function isAllowedNested(title) {\n    return isProperty(title) || isParamTitle(title);\n  }\n  function isAllowedOptional(title) {\n    return isProperty(title) || isParamTitle(title);\n  }\n  function isTypeParameterRequired(title) {\n    return isParamTitle(title) || isReturnTitle(title) || title === 'define' || title === 'enum' || title === 'implements' || title === 'this' || title === 'type' || title === 'typedef' || isProperty(title);\n  }\n\n  // Consider deprecation instead using 'isTypeParameterRequired' and 'Rules' declaration to pick when a type is optional/required\n  // This would require changes to 'parseType'\n  function isAllowedType(title) {\n    return isTypeParameterRequired(title) || title === 'throws' || title === 'const' || title === 'constant' || title === 'namespace' || title === 'member' || title === 'var' || title === 'module' || title === 'constructor' || title === 'class' || title === 'extends' || title === 'augments' || title === 'public' || title === 'private' || title === 'protected';\n  }\n\n  // A regex character class that contains all whitespace except linebreak characters (\\r, \\n, \\u2028, \\u2029)\n  var WHITESPACE = '[ \\\\f\\\\t\\\\v\\\\u00a0\\\\u1680\\\\u180e\\\\u2000-\\\\u200a\\\\u202f\\\\u205f\\\\u3000\\\\ufeff]';\n  var STAR_MATCHER = '(' + WHITESPACE + '*(?:\\\\*' + WHITESPACE + '?)?)(.+|[\\r\\n\\u2028\\u2029])';\n  function unwrapComment(doc) {\n    // JSDoc comment is following form\n    //   /**\n    //    * .......\n    //    */\n\n    return doc.\n    // remove /**\n    replace(/^\\/\\*\\*?/, '').\n    // remove */\n    replace(/\\*\\/$/, '').\n    // remove ' * ' at the beginning of a line\n    replace(new RegExp(STAR_MATCHER, 'g'), '$2').\n    // remove trailing whitespace\n    replace(/\\s*$/, '');\n  }\n\n  /**\n   * Converts an index in an \"unwrapped\" JSDoc comment to the corresponding index in the original \"wrapped\" version\n   * @param {string} originalSource The original wrapped comment\n   * @param {number} unwrappedIndex The index of a character in the unwrapped string\n   * @returns {number} The index of the corresponding character in the original wrapped string\n   */\n  function convertUnwrappedCommentIndex(originalSource, unwrappedIndex) {\n    var replacedSource = originalSource.replace(/^\\/\\*\\*?/, '');\n    var numSkippedChars = 0;\n    var matcher = new RegExp(STAR_MATCHER, 'g');\n    var match;\n    while (match = matcher.exec(replacedSource)) {\n      numSkippedChars += match[1].length;\n      if (match.index + match[0].length > unwrappedIndex + numSkippedChars) {\n        return unwrappedIndex + numSkippedChars + originalSource.length - replacedSource.length;\n      }\n    }\n    return originalSource.replace(/\\*\\/$/, '').replace(/\\s*$/, '').length;\n  }\n\n  // JSDoc Tag Parser\n\n  (function (exports) {\n    var Rules, index, lineNumber, length, source, originalSource, recoverable, sloppy, strict;\n    function advance() {\n      var ch = source.charCodeAt(index);\n      index += 1;\n      if (esutils.code.isLineTerminator(ch) && !(ch === 0x0D /* '\\r' */ && source.charCodeAt(index) === 0x0A /* '\\n' */)) {\n        lineNumber += 1;\n      }\n      return String.fromCharCode(ch);\n    }\n    function scanTitle() {\n      var title = '';\n      // waste '@'\n      advance();\n      while (index < length && isASCIIAlphanumeric(source.charCodeAt(index))) {\n        title += advance();\n      }\n      return title;\n    }\n    function seekContent() {\n      var ch,\n        waiting,\n        last = index;\n      waiting = false;\n      while (last < length) {\n        ch = source.charCodeAt(last);\n        if (esutils.code.isLineTerminator(ch) && !(ch === 0x0D /* '\\r' */ && source.charCodeAt(last + 1) === 0x0A /* '\\n' */)) {\n          waiting = true;\n        } else if (waiting) {\n          if (ch === 0x40 /* '@' */) {\n            break;\n          }\n          if (!esutils.code.isWhiteSpace(ch)) {\n            waiting = false;\n          }\n        }\n        last += 1;\n      }\n      return last;\n    }\n\n    // type expression may have nest brace, such as,\n    // { { ok: string } }\n    //\n    // therefore, scanning type expression with balancing braces.\n    function parseType(title, last, addRange) {\n      var ch,\n        brace,\n        type,\n        startIndex,\n        direct = false;\n\n      // search '{'\n      while (index < last) {\n        ch = source.charCodeAt(index);\n        if (esutils.code.isWhiteSpace(ch)) {\n          advance();\n        } else if (ch === 0x7B /* '{' */) {\n          advance();\n          break;\n        } else {\n          // this is direct pattern\n          direct = true;\n          break;\n        }\n      }\n      if (direct) {\n        return null;\n      }\n\n      // type expression { is found\n      brace = 1;\n      type = '';\n      while (index < last) {\n        ch = source.charCodeAt(index);\n        if (esutils.code.isLineTerminator(ch)) {\n          advance();\n        } else {\n          if (ch === 0x7D /* '}' */) {\n            brace -= 1;\n            if (brace === 0) {\n              advance();\n              break;\n            }\n          } else if (ch === 0x7B /* '{' */) {\n            brace += 1;\n          }\n          if (type === '') {\n            startIndex = index;\n          }\n          type += advance();\n        }\n      }\n      if (brace !== 0) {\n        // braces is not balanced\n        return utility.throwError('Braces are not balanced');\n      }\n      if (isAllowedOptional(title)) {\n        return typed.parseParamType(type, {\n          startIndex: convertIndex(startIndex),\n          range: addRange\n        });\n      }\n      return typed.parseType(type, {\n        startIndex: convertIndex(startIndex),\n        range: addRange\n      });\n    }\n    function scanIdentifier(last) {\n      var identifier;\n      if (!esutils.code.isIdentifierStartES5(source.charCodeAt(index)) && !source[index].match(/[0-9]/)) {\n        return null;\n      }\n      identifier = advance();\n      while (index < last && esutils.code.isIdentifierPartES5(source.charCodeAt(index))) {\n        identifier += advance();\n      }\n      return identifier;\n    }\n    function skipWhiteSpace(last) {\n      while (index < last && (esutils.code.isWhiteSpace(source.charCodeAt(index)) || esutils.code.isLineTerminator(source.charCodeAt(index)))) {\n        advance();\n      }\n    }\n    function parseName(last, allowBrackets, allowNestedParams) {\n      var name = '',\n        useBrackets,\n        insideString;\n      skipWhiteSpace(last);\n      if (index >= last) {\n        return null;\n      }\n      if (source.charCodeAt(index) === 0x5B /* '[' */) {\n        if (allowBrackets) {\n          useBrackets = true;\n          name = advance();\n        } else {\n          return null;\n        }\n      }\n      name += scanIdentifier(last);\n      if (allowNestedParams) {\n        if (source.charCodeAt(index) === 0x3A /* ':' */ && (name === 'module' || name === 'external' || name === 'event')) {\n          name += advance();\n          name += scanIdentifier(last);\n        }\n        if (source.charCodeAt(index) === 0x5B /* '[' */ && source.charCodeAt(index + 1) === 0x5D /* ']' */) {\n          name += advance();\n          name += advance();\n        }\n        while (source.charCodeAt(index) === 0x2E /* '.' */ || source.charCodeAt(index) === 0x2F /* '/' */ || source.charCodeAt(index) === 0x23 /* '#' */ || source.charCodeAt(index) === 0x2D /* '-' */ || source.charCodeAt(index) === 0x7E /* '~' */) {\n          name += advance();\n          name += scanIdentifier(last);\n        }\n      }\n      if (useBrackets) {\n        skipWhiteSpace(last);\n        // do we have a default value for this?\n        if (source.charCodeAt(index) === 0x3D /* '=' */) {\n          // consume the '='' symbol\n          name += advance();\n          skipWhiteSpace(last);\n          var ch;\n          var bracketDepth = 1;\n\n          // scan in the default value\n          while (index < last) {\n            ch = source.charCodeAt(index);\n            if (esutils.code.isWhiteSpace(ch)) {\n              if (!insideString) {\n                skipWhiteSpace(last);\n                ch = source.charCodeAt(index);\n              }\n            }\n            if (ch === 0x27 /* ''' */) {\n              if (!insideString) {\n                insideString = '\\'';\n              } else {\n                if (insideString === '\\'') {\n                  insideString = '';\n                }\n              }\n            }\n            if (ch === 0x22 /* '\"' */) {\n              if (!insideString) {\n                insideString = '\"';\n              } else {\n                if (insideString === '\"') {\n                  insideString = '';\n                }\n              }\n            }\n            if (ch === 0x5B /* '[' */) {\n              bracketDepth++;\n            } else if (ch === 0x5D /* ']' */ && --bracketDepth === 0) {\n              break;\n            }\n            name += advance();\n          }\n        }\n        skipWhiteSpace(last);\n        if (index >= last || source.charCodeAt(index) !== 0x5D /* ']' */) {\n          // we never found a closing ']'\n          return null;\n        }\n\n        // collect the last ']'\n        name += advance();\n      }\n      return name;\n    }\n    function skipToTag() {\n      while (index < length && source.charCodeAt(index) !== 0x40 /* '@' */) {\n        advance();\n      }\n      if (index >= length) {\n        return false;\n      }\n      utility.assert(source.charCodeAt(index) === 0x40 /* '@' */);\n      return true;\n    }\n    function convertIndex(rangeIndex) {\n      if (source === originalSource) {\n        return rangeIndex;\n      }\n      return convertUnwrappedCommentIndex(originalSource, rangeIndex);\n    }\n    function TagParser(options, title) {\n      this._options = options;\n      this._title = title.toLowerCase();\n      this._tag = {\n        title: title,\n        description: null\n      };\n      if (this._options.lineNumbers) {\n        this._tag.lineNumber = lineNumber;\n      }\n      this._first = index - title.length - 1;\n      this._last = 0;\n      // space to save special information for title parsers.\n      this._extra = {};\n    }\n\n    // addError(err, ...)\n    TagParser.prototype.addError = function addError(errorText) {\n      var args = Array.prototype.slice.call(arguments, 1),\n        msg = errorText.replace(/%(\\d)/g, function (whole, index) {\n          utility.assert(index < args.length, 'Message reference must be in range');\n          return args[index];\n        });\n      if (!this._tag.errors) {\n        this._tag.errors = [];\n      }\n      if (strict) {\n        utility.throwError(msg);\n      }\n      this._tag.errors.push(msg);\n      return recoverable;\n    };\n    TagParser.prototype.parseType = function () {\n      // type required titles\n      if (isTypeParameterRequired(this._title)) {\n        try {\n          this._tag.type = parseType(this._title, this._last, this._options.range);\n          if (!this._tag.type) {\n            if (!isParamTitle(this._title) && !isReturnTitle(this._title)) {\n              if (!this.addError('Missing or invalid tag type')) {\n                return false;\n              }\n            }\n          }\n        } catch (error) {\n          this._tag.type = null;\n          if (!this.addError(error.message)) {\n            return false;\n          }\n        }\n      } else if (isAllowedType(this._title)) {\n        // optional types\n        try {\n          this._tag.type = parseType(this._title, this._last, this._options.range);\n        } catch (e) {\n          //For optional types, lets drop the thrown error when we hit the end of the file\n        }\n      }\n      return true;\n    };\n    TagParser.prototype._parseNamePath = function (optional) {\n      var name;\n      name = parseName(this._last, sloppy && isAllowedOptional(this._title), true);\n      if (!name) {\n        if (!optional) {\n          if (!this.addError('Missing or invalid tag name')) {\n            return false;\n          }\n        }\n      }\n      this._tag.name = name;\n      return true;\n    };\n    TagParser.prototype.parseNamePath = function () {\n      return this._parseNamePath(false);\n    };\n    TagParser.prototype.parseNamePathOptional = function () {\n      return this._parseNamePath(true);\n    };\n    TagParser.prototype.parseName = function () {\n      var assign, name;\n\n      // param, property requires name\n      if (isAllowedName(this._title)) {\n        this._tag.name = parseName(this._last, sloppy && isAllowedOptional(this._title), isAllowedNested(this._title));\n        if (!this._tag.name) {\n          if (!isNameParameterRequired(this._title)) {\n            return true;\n          }\n\n          // it's possible the name has already been parsed but interpreted as a type\n          // it's also possible this is a sloppy declaration, in which case it will be\n          // fixed at the end\n          if (isParamTitle(this._title) && this._tag.type && this._tag.type.name) {\n            this._extra.name = this._tag.type;\n            this._tag.name = this._tag.type.name;\n            this._tag.type = null;\n          } else {\n            if (!this.addError('Missing or invalid tag name')) {\n              return false;\n            }\n          }\n        } else {\n          name = this._tag.name;\n          if (name.charAt(0) === '[' && name.charAt(name.length - 1) === ']') {\n            // extract the default value if there is one\n            // example: @param {string} [somebody=John Doe] description\n            assign = name.substring(1, name.length - 1).split('=');\n            if (assign.length > 1) {\n              this._tag['default'] = assign.slice(1).join('=');\n            }\n            this._tag.name = assign[0];\n\n            // convert to an optional type\n            if (this._tag.type && this._tag.type.type !== 'OptionalType') {\n              this._tag.type = {\n                type: 'OptionalType',\n                expression: this._tag.type\n              };\n            }\n          }\n        }\n      }\n      return true;\n    };\n    TagParser.prototype.parseDescription = function parseDescription() {\n      var description = sliceSource(source, index, this._last).trim();\n      if (description) {\n        if (/^-\\s+/.test(description)) {\n          description = description.substring(2);\n        }\n        this._tag.description = description;\n      }\n      return true;\n    };\n    TagParser.prototype.parseCaption = function parseDescription() {\n      var description = sliceSource(source, index, this._last).trim();\n      var captionStartTag = '<caption>';\n      var captionEndTag = '</caption>';\n      var captionStart = description.indexOf(captionStartTag);\n      var captionEnd = description.indexOf(captionEndTag);\n      if (captionStart >= 0 && captionEnd >= 0) {\n        this._tag.caption = description.substring(captionStart + captionStartTag.length, captionEnd).trim();\n        this._tag.description = description.substring(captionEnd + captionEndTag.length).trim();\n      } else {\n        this._tag.description = description;\n      }\n      return true;\n    };\n    TagParser.prototype.parseKind = function parseKind() {\n      var kind, kinds;\n      kinds = {\n        'class': true,\n        'constant': true,\n        'event': true,\n        'external': true,\n        'file': true,\n        'function': true,\n        'member': true,\n        'mixin': true,\n        'module': true,\n        'namespace': true,\n        'typedef': true\n      };\n      kind = sliceSource(source, index, this._last).trim();\n      this._tag.kind = kind;\n      if (!hasOwnProperty(kinds, kind)) {\n        if (!this.addError('Invalid kind name \\'%0\\'', kind)) {\n          return false;\n        }\n      }\n      return true;\n    };\n    TagParser.prototype.parseAccess = function parseAccess() {\n      var access;\n      access = sliceSource(source, index, this._last).trim();\n      this._tag.access = access;\n      if (access !== 'private' && access !== 'protected' && access !== 'public') {\n        if (!this.addError('Invalid access name \\'%0\\'', access)) {\n          return false;\n        }\n      }\n      return true;\n    };\n    TagParser.prototype.parseThis = function parseThis() {\n      // this name may be a name expression (e.g. {foo.bar}),\n      // an union (e.g. {foo.bar|foo.baz}) or a name path (e.g. foo.bar)\n      var value = sliceSource(source, index, this._last).trim();\n      if (value && value.charAt(0) === '{') {\n        var gotType = this.parseType();\n        if (gotType && this._tag.type.type === 'NameExpression' || this._tag.type.type === 'UnionType') {\n          this._tag.name = this._tag.type.name;\n          return true;\n        } else {\n          return this.addError('Invalid name for this');\n        }\n      } else {\n        return this.parseNamePath();\n      }\n    };\n    TagParser.prototype.parseVariation = function parseVariation() {\n      var variation, text;\n      text = sliceSource(source, index, this._last).trim();\n      variation = parseFloat(text, 10);\n      this._tag.variation = variation;\n      if (isNaN(variation)) {\n        if (!this.addError('Invalid variation \\'%0\\'', text)) {\n          return false;\n        }\n      }\n      return true;\n    };\n    TagParser.prototype.ensureEnd = function () {\n      var shouldBeEmpty = sliceSource(source, index, this._last).trim();\n      if (shouldBeEmpty) {\n        if (!this.addError('Unknown content \\'%0\\'', shouldBeEmpty)) {\n          return false;\n        }\n      }\n      return true;\n    };\n    TagParser.prototype.epilogue = function epilogue() {\n      var description;\n      description = this._tag.description;\n      // un-fix potentially sloppy declaration\n      if (isAllowedOptional(this._title) && !this._tag.type && description && description.charAt(0) === '[') {\n        this._tag.type = this._extra.name;\n        if (!this._tag.name) {\n          this._tag.name = undefined;\n        }\n        if (!sloppy) {\n          if (!this.addError('Missing or invalid tag name')) {\n            return false;\n          }\n        }\n      }\n      return true;\n    };\n    Rules = {\n      // http://usejsdoc.org/tags-access.html\n      'access': ['parseAccess'],\n      // http://usejsdoc.org/tags-alias.html\n      'alias': ['parseNamePath', 'ensureEnd'],\n      // http://usejsdoc.org/tags-augments.html\n      'augments': ['parseType', 'parseNamePathOptional', 'ensureEnd'],\n      // http://usejsdoc.org/tags-constructor.html\n      'constructor': ['parseType', 'parseNamePathOptional', 'ensureEnd'],\n      // Synonym: http://usejsdoc.org/tags-constructor.html\n      'class': ['parseType', 'parseNamePathOptional', 'ensureEnd'],\n      // Synonym: http://usejsdoc.org/tags-extends.html\n      'extends': ['parseType', 'parseNamePathOptional', 'ensureEnd'],\n      // http://usejsdoc.org/tags-example.html\n      'example': ['parseCaption'],\n      // http://usejsdoc.org/tags-deprecated.html\n      'deprecated': ['parseDescription'],\n      // http://usejsdoc.org/tags-global.html\n      'global': ['ensureEnd'],\n      // http://usejsdoc.org/tags-inner.html\n      'inner': ['ensureEnd'],\n      // http://usejsdoc.org/tags-instance.html\n      'instance': ['ensureEnd'],\n      // http://usejsdoc.org/tags-kind.html\n      'kind': ['parseKind'],\n      // http://usejsdoc.org/tags-mixes.html\n      'mixes': ['parseNamePath', 'ensureEnd'],\n      // http://usejsdoc.org/tags-mixin.html\n      'mixin': ['parseNamePathOptional', 'ensureEnd'],\n      // http://usejsdoc.org/tags-member.html\n      'member': ['parseType', 'parseNamePathOptional', 'ensureEnd'],\n      // http://usejsdoc.org/tags-method.html\n      'method': ['parseNamePathOptional', 'ensureEnd'],\n      // http://usejsdoc.org/tags-module.html\n      'module': ['parseType', 'parseNamePathOptional', 'ensureEnd'],\n      // Synonym: http://usejsdoc.org/tags-method.html\n      'func': ['parseNamePathOptional', 'ensureEnd'],\n      // Synonym: http://usejsdoc.org/tags-method.html\n      'function': ['parseNamePathOptional', 'ensureEnd'],\n      // Synonym: http://usejsdoc.org/tags-member.html\n      'var': ['parseType', 'parseNamePathOptional', 'ensureEnd'],\n      // http://usejsdoc.org/tags-name.html\n      'name': ['parseNamePath', 'ensureEnd'],\n      // http://usejsdoc.org/tags-namespace.html\n      'namespace': ['parseType', 'parseNamePathOptional', 'ensureEnd'],\n      // http://usejsdoc.org/tags-private.html\n      'private': ['parseType', 'parseDescription'],\n      // http://usejsdoc.org/tags-protected.html\n      'protected': ['parseType', 'parseDescription'],\n      // http://usejsdoc.org/tags-public.html\n      'public': ['parseType', 'parseDescription'],\n      // http://usejsdoc.org/tags-readonly.html\n      'readonly': ['ensureEnd'],\n      // http://usejsdoc.org/tags-requires.html\n      'requires': ['parseNamePath', 'ensureEnd'],\n      // http://usejsdoc.org/tags-since.html\n      'since': ['parseDescription'],\n      // http://usejsdoc.org/tags-static.html\n      'static': ['ensureEnd'],\n      // http://usejsdoc.org/tags-summary.html\n      'summary': ['parseDescription'],\n      // http://usejsdoc.org/tags-this.html\n      'this': ['parseThis', 'ensureEnd'],\n      // http://usejsdoc.org/tags-todo.html\n      'todo': ['parseDescription'],\n      // http://usejsdoc.org/tags-typedef.html\n      'typedef': ['parseType', 'parseNamePathOptional'],\n      // http://usejsdoc.org/tags-variation.html\n      'variation': ['parseVariation'],\n      // http://usejsdoc.org/tags-version.html\n      'version': ['parseDescription']\n    };\n    TagParser.prototype.parse = function parse() {\n      var i, iz, sequences, method;\n\n      // empty title\n      if (!this._title) {\n        if (!this.addError('Missing or invalid title')) {\n          return null;\n        }\n      }\n\n      // Seek to content last index.\n      this._last = seekContent(this._title);\n      if (this._options.range) {\n        this._tag.range = [this._first, source.slice(0, this._last).replace(/\\s*$/, '').length].map(convertIndex);\n      }\n      if (hasOwnProperty(Rules, this._title)) {\n        sequences = Rules[this._title];\n      } else {\n        // default sequences\n        sequences = ['parseType', 'parseName', 'parseDescription', 'epilogue'];\n      }\n      for (i = 0, iz = sequences.length; i < iz; ++i) {\n        method = sequences[i];\n        if (!this[method]()) {\n          return null;\n        }\n      }\n      return this._tag;\n    };\n    function parseTag(options) {\n      var title, parser, tag;\n\n      // skip to tag\n      if (!skipToTag()) {\n        return null;\n      }\n\n      // scan title\n      title = scanTitle();\n\n      // construct tag parser\n      parser = new TagParser(options, title);\n      tag = parser.parse();\n\n      // Seek global index to end of this tag.\n      while (index < parser._last) {\n        advance();\n      }\n      return tag;\n    }\n\n    //\n    // Parse JSDoc\n    //\n\n    function scanJSDocDescription(preserveWhitespace) {\n      var description = '',\n        ch,\n        atAllowed;\n      atAllowed = true;\n      while (index < length) {\n        ch = source.charCodeAt(index);\n        if (atAllowed && ch === 0x40 /* '@' */) {\n          break;\n        }\n        if (esutils.code.isLineTerminator(ch)) {\n          atAllowed = true;\n        } else if (atAllowed && !esutils.code.isWhiteSpace(ch)) {\n          atAllowed = false;\n        }\n        description += advance();\n      }\n      return preserveWhitespace ? description : description.trim();\n    }\n    function parse(comment, options) {\n      var tags = [],\n        tag,\n        description,\n        interestingTags,\n        i,\n        iz;\n      if (options === undefined) {\n        options = {};\n      }\n      if (typeof options.unwrap === 'boolean' && options.unwrap) {\n        source = unwrapComment(comment);\n      } else {\n        source = comment;\n      }\n      originalSource = comment;\n\n      // array of relevant tags\n      if (options.tags) {\n        if (Array.isArray(options.tags)) {\n          interestingTags = {};\n          for (i = 0, iz = options.tags.length; i < iz; i++) {\n            if (typeof options.tags[i] === 'string') {\n              interestingTags[options.tags[i]] = true;\n            } else {\n              utility.throwError('Invalid \"tags\" parameter: ' + options.tags);\n            }\n          }\n        } else {\n          utility.throwError('Invalid \"tags\" parameter: ' + options.tags);\n        }\n      }\n      length = source.length;\n      index = 0;\n      lineNumber = 0;\n      recoverable = options.recoverable;\n      sloppy = options.sloppy;\n      strict = options.strict;\n      description = scanJSDocDescription(options.preserveWhitespace);\n      while (true) {\n        tag = parseTag(options);\n        if (!tag) {\n          break;\n        }\n        if (!interestingTags || interestingTags.hasOwnProperty(tag.title)) {\n          tags.push(tag);\n        }\n      }\n      return {\n        description: description,\n        tags: tags\n      };\n    }\n    exports.parse = parse;\n  })(jsdoc = {});\n  exports.version = utility.VERSION;\n  exports.parse = jsdoc.parse;\n  exports.parseType = typed.parseType;\n  exports.parseParamType = typed.parseParamType;\n  exports.unwrapComment = unwrapComment;\n  exports.Syntax = shallowCopy(typed.Syntax);\n  exports.Error = utility.DoctrineError;\n  exports.type = {\n    Syntax: exports.Syntax,\n    parseType: typed.parseType,\n    parseParamType: typed.parseParamType,\n    stringify: typed.stringify\n  };\n})();\n/* vim: set sw=4 ts=4 et tw=80 : */","map":{"version":3,"names":["typed","utility","jsdoc","esutils","hasOwnProperty","require","sliceSource","source","index","last","slice","func","Object","prototype","obj","name","call","shallowCopy","ret","key","isASCIIAlphanumeric","ch","isParamTitle","title","isReturnTitle","isProperty","isNameParameterRequired","isAllowedName","isAllowedNested","isAllowedOptional","isTypeParameterRequired","isAllowedType","WHITESPACE","STAR_MATCHER","unwrapComment","doc","replace","RegExp","convertUnwrappedCommentIndex","originalSource","unwrappedIndex","replacedSource","numSkippedChars","matcher","match","exec","length","exports","Rules","lineNumber","recoverable","sloppy","strict","advance","charCodeAt","code","isLineTerminator","String","fromCharCode","scanTitle","seekContent","waiting","isWhiteSpace","parseType","addRange","brace","type","startIndex","direct","throwError","parseParamType","convertIndex","range","scanIdentifier","identifier","isIdentifierStartES5","isIdentifierPartES5","skipWhiteSpace","parseName","allowBrackets","allowNestedParams","useBrackets","insideString","bracketDepth","skipToTag","assert","rangeIndex","TagParser","options","_options","_title","toLowerCase","_tag","description","lineNumbers","_first","_last","_extra","addError","errorText","args","Array","arguments","msg","whole","errors","push","error","message","e","_parseNamePath","optional","parseNamePath","parseNamePathOptional","assign","charAt","substring","split","join","expression","parseDescription","trim","test","parseCaption","captionStartTag","captionEndTag","captionStart","indexOf","captionEnd","caption","parseKind","kind","kinds","parseAccess","access","parseThis","value","gotType","parseVariation","variation","text","parseFloat","isNaN","ensureEnd","shouldBeEmpty","epilogue","undefined","parse","i","iz","sequences","method","map","parseTag","parser","tag","scanJSDocDescription","preserveWhitespace","atAllowed","comment","tags","interestingTags","unwrap","isArray","version","VERSION","Syntax","Error","DoctrineError","stringify"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/doctrine/lib/doctrine.js"],"sourcesContent":["/*\n * @fileoverview Main Doctrine object\n * @author Yusuke Suzuki <utatane.tea@gmail.com>\n * @author Dan Tao <daniel.tao@gmail.com>\n * @author Andrew Eisenberg <andrew@eisenberg.as>\n */\n\n(function () {\n    'use strict';\n\n    var typed,\n        utility,\n        jsdoc,\n        esutils,\n        hasOwnProperty;\n\n    esutils = require('esutils');\n    typed = require('./typed');\n    utility = require('./utility');\n\n    function sliceSource(source, index, last) {\n        return source.slice(index, last);\n    }\n\n    hasOwnProperty = (function () {\n        var func = Object.prototype.hasOwnProperty;\n        return function hasOwnProperty(obj, name) {\n            return func.call(obj, name);\n        };\n    }());\n    function shallowCopy(obj) {\n        var ret = {}, key;\n        for (key in obj) {\n            if (obj.hasOwnProperty(key)) {\n                ret[key] = obj[key];\n            }\n        }\n        return ret;\n    }\n\n    function isASCIIAlphanumeric(ch) {\n        return (ch >= 0x61  /* 'a' */ && ch <= 0x7A  /* 'z' */) ||\n            (ch >= 0x41  /* 'A' */ && ch <= 0x5A  /* 'Z' */) ||\n            (ch >= 0x30  /* '0' */ && ch <= 0x39  /* '9' */);\n    }\n\n    function isParamTitle(title) {\n        return title === 'param' || title === 'argument' || title === 'arg';\n    }\n\n    function isReturnTitle(title) {\n        return title === 'return' || title === 'returns';\n    }\n\n    function isProperty(title) {\n        return title === 'property' || title === 'prop';\n    }\n\n    function isNameParameterRequired(title) {\n        return isParamTitle(title) || isProperty(title) ||\n            title === 'alias' || title === 'this' || title === 'mixes' || title === 'requires';\n    }\n\n    function isAllowedName(title) {\n        return isNameParameterRequired(title) || title === 'const' || title === 'constant';\n    }\n\n    function isAllowedNested(title) {\n        return isProperty(title) || isParamTitle(title);\n    }\n\n    function isAllowedOptional(title) {\n        return isProperty(title) || isParamTitle(title);\n    }\n\n    function isTypeParameterRequired(title) {\n        return isParamTitle(title) || isReturnTitle(title) ||\n            title === 'define' || title === 'enum' ||\n            title === 'implements' || title === 'this' ||\n            title === 'type' || title === 'typedef' || isProperty(title);\n    }\n\n    // Consider deprecation instead using 'isTypeParameterRequired' and 'Rules' declaration to pick when a type is optional/required\n    // This would require changes to 'parseType'\n    function isAllowedType(title) {\n        return isTypeParameterRequired(title) || title === 'throws' || title === 'const' || title === 'constant' ||\n            title === 'namespace' || title === 'member' || title === 'var' || title === 'module' ||\n            title === 'constructor' || title === 'class' || title === 'extends' || title === 'augments' ||\n            title === 'public' || title === 'private' || title === 'protected';\n    }\n\n    // A regex character class that contains all whitespace except linebreak characters (\\r, \\n, \\u2028, \\u2029)\n    var WHITESPACE = '[ \\\\f\\\\t\\\\v\\\\u00a0\\\\u1680\\\\u180e\\\\u2000-\\\\u200a\\\\u202f\\\\u205f\\\\u3000\\\\ufeff]';\n\n    var STAR_MATCHER = '(' + WHITESPACE + '*(?:\\\\*' + WHITESPACE + '?)?)(.+|[\\r\\n\\u2028\\u2029])';\n\n    function unwrapComment(doc) {\n        // JSDoc comment is following form\n        //   /**\n        //    * .......\n        //    */\n\n        return doc.\n            // remove /**\n            replace(/^\\/\\*\\*?/, '').\n            // remove */\n            replace(/\\*\\/$/, '').\n            // remove ' * ' at the beginning of a line\n            replace(new RegExp(STAR_MATCHER, 'g'), '$2').\n            // remove trailing whitespace\n            replace(/\\s*$/, '');\n    }\n\n    /**\n     * Converts an index in an \"unwrapped\" JSDoc comment to the corresponding index in the original \"wrapped\" version\n     * @param {string} originalSource The original wrapped comment\n     * @param {number} unwrappedIndex The index of a character in the unwrapped string\n     * @returns {number} The index of the corresponding character in the original wrapped string\n     */\n    function convertUnwrappedCommentIndex(originalSource, unwrappedIndex) {\n        var replacedSource = originalSource.replace(/^\\/\\*\\*?/, '');\n        var numSkippedChars = 0;\n        var matcher = new RegExp(STAR_MATCHER, 'g');\n        var match;\n\n        while ((match = matcher.exec(replacedSource))) {\n            numSkippedChars += match[1].length;\n\n            if (match.index + match[0].length > unwrappedIndex + numSkippedChars) {\n                return unwrappedIndex + numSkippedChars + originalSource.length - replacedSource.length;\n            }\n        }\n\n        return originalSource.replace(/\\*\\/$/, '').replace(/\\s*$/, '').length;\n    }\n\n    // JSDoc Tag Parser\n\n    (function (exports) {\n        var Rules,\n            index,\n            lineNumber,\n            length,\n            source,\n            originalSource,\n            recoverable,\n            sloppy,\n            strict;\n\n        function advance() {\n            var ch = source.charCodeAt(index);\n            index += 1;\n            if (esutils.code.isLineTerminator(ch) && !(ch === 0x0D  /* '\\r' */ && source.charCodeAt(index) === 0x0A  /* '\\n' */)) {\n                lineNumber += 1;\n            }\n            return String.fromCharCode(ch);\n        }\n\n        function scanTitle() {\n            var title = '';\n            // waste '@'\n            advance();\n\n            while (index < length && isASCIIAlphanumeric(source.charCodeAt(index))) {\n                title += advance();\n            }\n\n            return title;\n        }\n\n        function seekContent() {\n            var ch, waiting, last = index;\n\n            waiting = false;\n            while (last < length) {\n                ch = source.charCodeAt(last);\n                if (esutils.code.isLineTerminator(ch) && !(ch === 0x0D  /* '\\r' */ && source.charCodeAt(last + 1) === 0x0A  /* '\\n' */)) {\n                    waiting = true;\n                } else if (waiting) {\n                    if (ch === 0x40  /* '@' */) {\n                        break;\n                    }\n                    if (!esutils.code.isWhiteSpace(ch)) {\n                        waiting = false;\n                    }\n                }\n                last += 1;\n            }\n            return last;\n        }\n\n        // type expression may have nest brace, such as,\n        // { { ok: string } }\n        //\n        // therefore, scanning type expression with balancing braces.\n        function parseType(title, last, addRange) {\n            var ch, brace, type, startIndex, direct = false;\n\n\n            // search '{'\n            while (index < last) {\n                ch = source.charCodeAt(index);\n                if (esutils.code.isWhiteSpace(ch)) {\n                    advance();\n                } else if (ch === 0x7B  /* '{' */) {\n                    advance();\n                    break;\n                } else {\n                    // this is direct pattern\n                    direct = true;\n                    break;\n                }\n            }\n\n\n            if (direct) {\n                return null;\n            }\n\n            // type expression { is found\n            brace = 1;\n            type = '';\n            while (index < last) {\n                ch = source.charCodeAt(index);\n                if (esutils.code.isLineTerminator(ch)) {\n                    advance();\n                } else {\n                    if (ch === 0x7D  /* '}' */) {\n                        brace -= 1;\n                        if (brace === 0) {\n                            advance();\n                            break;\n                        }\n                    } else if (ch === 0x7B  /* '{' */) {\n                        brace += 1;\n                    }\n                    if (type === '') {\n                        startIndex = index;\n                    }\n                    type += advance();\n                }\n            }\n\n            if (brace !== 0) {\n                // braces is not balanced\n                return utility.throwError('Braces are not balanced');\n            }\n\n            if (isAllowedOptional(title)) {\n                return typed.parseParamType(type, {startIndex: convertIndex(startIndex), range: addRange});\n            }\n\n            return typed.parseType(type, {startIndex: convertIndex(startIndex), range: addRange});\n        }\n\n        function scanIdentifier(last) {\n            var identifier;\n            if (!esutils.code.isIdentifierStartES5(source.charCodeAt(index)) && !source[index].match(/[0-9]/)) {\n                return null;\n            }\n            identifier = advance();\n            while (index < last && esutils.code.isIdentifierPartES5(source.charCodeAt(index))) {\n                identifier += advance();\n            }\n            return identifier;\n        }\n\n        function skipWhiteSpace(last) {\n            while (index < last && (esutils.code.isWhiteSpace(source.charCodeAt(index)) || esutils.code.isLineTerminator(source.charCodeAt(index)))) {\n                advance();\n            }\n        }\n\n        function parseName(last, allowBrackets, allowNestedParams) {\n            var name = '',\n                useBrackets,\n                insideString;\n\n\n            skipWhiteSpace(last);\n\n            if (index >= last) {\n                return null;\n            }\n\n            if (source.charCodeAt(index) === 0x5B  /* '[' */) {\n                if (allowBrackets) {\n                    useBrackets = true;\n                    name = advance();\n                } else {\n                    return null;\n                }\n            }\n\n            name += scanIdentifier(last);\n\n            if (allowNestedParams) {\n                if (source.charCodeAt(index) === 0x3A /* ':' */ && (\n                        name === 'module' ||\n                        name === 'external' ||\n                        name === 'event')) {\n                    name += advance();\n                    name += scanIdentifier(last);\n\n                }\n                if(source.charCodeAt(index) === 0x5B  /* '[' */ && source.charCodeAt(index + 1) === 0x5D  /* ']' */){\n                    name += advance();\n                    name += advance();\n                }\n                while (source.charCodeAt(index) === 0x2E  /* '.' */ ||\n                        source.charCodeAt(index) === 0x2F  /* '/' */ ||\n                        source.charCodeAt(index) === 0x23  /* '#' */ ||\n                        source.charCodeAt(index) === 0x2D  /* '-' */ ||\n                        source.charCodeAt(index) === 0x7E  /* '~' */) {\n                    name += advance();\n                    name += scanIdentifier(last);\n                }\n            }\n\n            if (useBrackets) {\n                skipWhiteSpace(last);\n                // do we have a default value for this?\n                if (source.charCodeAt(index) === 0x3D  /* '=' */) {\n                    // consume the '='' symbol\n                    name += advance();\n                    skipWhiteSpace(last);\n\n                    var ch;\n                    var bracketDepth = 1;\n\n                    // scan in the default value\n                    while (index < last) {\n                        ch = source.charCodeAt(index);\n\n                        if (esutils.code.isWhiteSpace(ch)) {\n                            if (!insideString) {\n                                skipWhiteSpace(last);\n                                ch = source.charCodeAt(index);\n                            }\n                        }\n\n                        if (ch === 0x27 /* ''' */) {\n                            if (!insideString) {\n                                insideString = '\\'';\n                            } else {\n                                if (insideString === '\\'') {\n                                    insideString = '';\n                                }\n                            }\n                        }\n\n                        if (ch === 0x22 /* '\"' */) {\n                            if (!insideString) {\n                                insideString = '\"';\n                            } else {\n                                if (insideString === '\"') {\n                                    insideString = '';\n                                }\n                            }\n                        }\n\n                        if (ch === 0x5B /* '[' */) {\n                            bracketDepth++;\n                        } else if (ch === 0x5D  /* ']' */ &&\n                            --bracketDepth === 0) {\n                            break;\n                        }\n\n                        name += advance();\n                    }\n                }\n\n                skipWhiteSpace(last);\n\n                if (index >= last || source.charCodeAt(index) !== 0x5D  /* ']' */) {\n                    // we never found a closing ']'\n                    return null;\n                }\n\n                // collect the last ']'\n                name += advance();\n            }\n\n            return name;\n        }\n\n        function skipToTag() {\n            while (index < length && source.charCodeAt(index) !== 0x40  /* '@' */) {\n                advance();\n            }\n            if (index >= length) {\n                return false;\n            }\n            utility.assert(source.charCodeAt(index) === 0x40  /* '@' */);\n            return true;\n        }\n\n        function convertIndex(rangeIndex) {\n            if (source === originalSource) {\n                return rangeIndex;\n            }\n            return convertUnwrappedCommentIndex(originalSource, rangeIndex);\n        }\n\n        function TagParser(options, title) {\n            this._options = options;\n            this._title = title.toLowerCase();\n            this._tag = {\n                title: title,\n                description: null\n            };\n            if (this._options.lineNumbers) {\n                this._tag.lineNumber = lineNumber;\n            }\n            this._first = index - title.length - 1;\n            this._last = 0;\n            // space to save special information for title parsers.\n            this._extra = { };\n        }\n\n        // addError(err, ...)\n        TagParser.prototype.addError = function addError(errorText) {\n            var args = Array.prototype.slice.call(arguments, 1),\n                msg = errorText.replace(\n                    /%(\\d)/g,\n                    function (whole, index) {\n                        utility.assert(index < args.length, 'Message reference must be in range');\n                        return args[index];\n                    }\n                );\n\n            if (!this._tag.errors) {\n                this._tag.errors = [];\n            }\n            if (strict) {\n                utility.throwError(msg);\n            }\n            this._tag.errors.push(msg);\n            return recoverable;\n        };\n\n        TagParser.prototype.parseType = function () {\n            // type required titles\n            if (isTypeParameterRequired(this._title)) {\n                try {\n                    this._tag.type = parseType(this._title, this._last, this._options.range);\n                    if (!this._tag.type) {\n                        if (!isParamTitle(this._title) && !isReturnTitle(this._title)) {\n                            if (!this.addError('Missing or invalid tag type')) {\n                                return false;\n                            }\n                        }\n                    }\n                } catch (error) {\n                    this._tag.type = null;\n                    if (!this.addError(error.message)) {\n                        return false;\n                    }\n                }\n            } else if (isAllowedType(this._title)) {\n                // optional types\n                try {\n                    this._tag.type = parseType(this._title, this._last, this._options.range);\n                } catch (e) {\n                    //For optional types, lets drop the thrown error when we hit the end of the file\n                }\n            }\n            return true;\n        };\n\n        TagParser.prototype._parseNamePath = function (optional) {\n            var name;\n            name = parseName(this._last, sloppy && isAllowedOptional(this._title), true);\n            if (!name) {\n                if (!optional) {\n                    if (!this.addError('Missing or invalid tag name')) {\n                        return false;\n                    }\n                }\n            }\n            this._tag.name = name;\n            return true;\n        };\n\n        TagParser.prototype.parseNamePath = function () {\n            return this._parseNamePath(false);\n        };\n\n        TagParser.prototype.parseNamePathOptional = function () {\n            return this._parseNamePath(true);\n        };\n\n\n        TagParser.prototype.parseName = function () {\n            var assign, name;\n\n            // param, property requires name\n            if (isAllowedName(this._title)) {\n                this._tag.name = parseName(this._last, sloppy && isAllowedOptional(this._title), isAllowedNested(this._title));\n                if (!this._tag.name) {\n                    if (!isNameParameterRequired(this._title)) {\n                        return true;\n                    }\n\n                    // it's possible the name has already been parsed but interpreted as a type\n                    // it's also possible this is a sloppy declaration, in which case it will be\n                    // fixed at the end\n                    if (isParamTitle(this._title) && this._tag.type && this._tag.type.name) {\n                        this._extra.name = this._tag.type;\n                        this._tag.name = this._tag.type.name;\n                        this._tag.type = null;\n                    } else {\n                        if (!this.addError('Missing or invalid tag name')) {\n                            return false;\n                        }\n                    }\n                } else {\n                    name = this._tag.name;\n                    if (name.charAt(0) === '[' && name.charAt(name.length - 1) === ']') {\n                        // extract the default value if there is one\n                        // example: @param {string} [somebody=John Doe] description\n                        assign = name.substring(1, name.length - 1).split('=');\n                        if (assign.length > 1) {\n                            this._tag['default'] = assign.slice(1).join('=');\n                        }\n                        this._tag.name = assign[0];\n\n                        // convert to an optional type\n                        if (this._tag.type && this._tag.type.type !== 'OptionalType') {\n                            this._tag.type = {\n                                type: 'OptionalType',\n                                expression: this._tag.type\n                            };\n                        }\n                    }\n                }\n            }\n\n\n            return true;\n        };\n\n        TagParser.prototype.parseDescription = function parseDescription() {\n            var description = sliceSource(source, index, this._last).trim();\n            if (description) {\n                if ((/^-\\s+/).test(description)) {\n                    description = description.substring(2);\n                }\n                this._tag.description = description;\n            }\n            return true;\n        };\n\n        TagParser.prototype.parseCaption = function parseDescription() {\n            var description = sliceSource(source, index, this._last).trim();\n            var captionStartTag = '<caption>';\n            var captionEndTag = '</caption>';\n            var captionStart = description.indexOf(captionStartTag);\n            var captionEnd = description.indexOf(captionEndTag);\n            if (captionStart >= 0 && captionEnd >= 0) {\n                this._tag.caption = description.substring(\n                    captionStart + captionStartTag.length, captionEnd).trim();\n                this._tag.description = description.substring(captionEnd + captionEndTag.length).trim();\n            } else {\n                this._tag.description = description;\n            }\n            return true;\n        };\n\n        TagParser.prototype.parseKind = function parseKind() {\n            var kind, kinds;\n            kinds = {\n                'class': true,\n                'constant': true,\n                'event': true,\n                'external': true,\n                'file': true,\n                'function': true,\n                'member': true,\n                'mixin': true,\n                'module': true,\n                'namespace': true,\n                'typedef': true\n            };\n            kind = sliceSource(source, index, this._last).trim();\n            this._tag.kind = kind;\n            if (!hasOwnProperty(kinds, kind)) {\n                if (!this.addError('Invalid kind name \\'%0\\'', kind)) {\n                    return false;\n                }\n            }\n            return true;\n        };\n\n        TagParser.prototype.parseAccess = function parseAccess() {\n            var access;\n            access = sliceSource(source, index, this._last).trim();\n            this._tag.access = access;\n            if (access !== 'private' && access !== 'protected' && access !== 'public') {\n                if (!this.addError('Invalid access name \\'%0\\'', access)) {\n                    return false;\n                }\n            }\n            return true;\n        };\n\n        TagParser.prototype.parseThis = function parseThis() {\n            // this name may be a name expression (e.g. {foo.bar}),\n            // an union (e.g. {foo.bar|foo.baz}) or a name path (e.g. foo.bar)\n            var value = sliceSource(source, index, this._last).trim();\n            if (value && value.charAt(0) === '{') {\n                var gotType = this.parseType();\n                if (gotType && this._tag.type.type === 'NameExpression' || this._tag.type.type === 'UnionType') {\n                    this._tag.name = this._tag.type.name;\n                    return true;\n                } else {\n                    return this.addError('Invalid name for this');\n                }\n            } else {\n                return this.parseNamePath();\n            }\n        };\n\n        TagParser.prototype.parseVariation = function parseVariation() {\n            var variation, text;\n            text = sliceSource(source, index, this._last).trim();\n            variation = parseFloat(text, 10);\n            this._tag.variation = variation;\n            if (isNaN(variation)) {\n                if (!this.addError('Invalid variation \\'%0\\'', text)) {\n                    return false;\n                }\n            }\n            return true;\n        };\n\n        TagParser.prototype.ensureEnd = function () {\n            var shouldBeEmpty = sliceSource(source, index, this._last).trim();\n            if (shouldBeEmpty) {\n                if (!this.addError('Unknown content \\'%0\\'', shouldBeEmpty)) {\n                    return false;\n                }\n            }\n            return true;\n        };\n\n        TagParser.prototype.epilogue = function epilogue() {\n            var description;\n\n            description = this._tag.description;\n            // un-fix potentially sloppy declaration\n            if (isAllowedOptional(this._title) && !this._tag.type && description && description.charAt(0) === '[') {\n                this._tag.type = this._extra.name;\n                if (!this._tag.name) {\n                    this._tag.name = undefined;\n                }\n\n                if (!sloppy) {\n                    if (!this.addError('Missing or invalid tag name')) {\n                        return false;\n                    }\n                }\n            }\n\n            return true;\n        };\n\n        Rules = {\n            // http://usejsdoc.org/tags-access.html\n            'access': ['parseAccess'],\n            // http://usejsdoc.org/tags-alias.html\n            'alias': ['parseNamePath', 'ensureEnd'],\n            // http://usejsdoc.org/tags-augments.html\n            'augments': ['parseType', 'parseNamePathOptional', 'ensureEnd'],\n            // http://usejsdoc.org/tags-constructor.html\n            'constructor': ['parseType', 'parseNamePathOptional', 'ensureEnd'],\n            // Synonym: http://usejsdoc.org/tags-constructor.html\n            'class': ['parseType', 'parseNamePathOptional', 'ensureEnd'],\n            // Synonym: http://usejsdoc.org/tags-extends.html\n            'extends': ['parseType', 'parseNamePathOptional', 'ensureEnd'],\n            // http://usejsdoc.org/tags-example.html\n            'example': ['parseCaption'],\n            // http://usejsdoc.org/tags-deprecated.html\n            'deprecated': ['parseDescription'],\n            // http://usejsdoc.org/tags-global.html\n            'global': ['ensureEnd'],\n            // http://usejsdoc.org/tags-inner.html\n            'inner': ['ensureEnd'],\n            // http://usejsdoc.org/tags-instance.html\n            'instance': ['ensureEnd'],\n            // http://usejsdoc.org/tags-kind.html\n            'kind': ['parseKind'],\n            // http://usejsdoc.org/tags-mixes.html\n            'mixes': ['parseNamePath', 'ensureEnd'],\n            // http://usejsdoc.org/tags-mixin.html\n            'mixin': ['parseNamePathOptional', 'ensureEnd'],\n            // http://usejsdoc.org/tags-member.html\n            'member': ['parseType', 'parseNamePathOptional', 'ensureEnd'],\n            // http://usejsdoc.org/tags-method.html\n            'method': ['parseNamePathOptional', 'ensureEnd'],\n            // http://usejsdoc.org/tags-module.html\n            'module': ['parseType', 'parseNamePathOptional', 'ensureEnd'],\n            // Synonym: http://usejsdoc.org/tags-method.html\n            'func': ['parseNamePathOptional', 'ensureEnd'],\n            // Synonym: http://usejsdoc.org/tags-method.html\n            'function': ['parseNamePathOptional', 'ensureEnd'],\n            // Synonym: http://usejsdoc.org/tags-member.html\n            'var': ['parseType', 'parseNamePathOptional', 'ensureEnd'],\n            // http://usejsdoc.org/tags-name.html\n            'name': ['parseNamePath', 'ensureEnd'],\n            // http://usejsdoc.org/tags-namespace.html\n            'namespace': ['parseType', 'parseNamePathOptional', 'ensureEnd'],\n            // http://usejsdoc.org/tags-private.html\n            'private': ['parseType', 'parseDescription'],\n            // http://usejsdoc.org/tags-protected.html\n            'protected': ['parseType', 'parseDescription'],\n            // http://usejsdoc.org/tags-public.html\n            'public': ['parseType', 'parseDescription'],\n            // http://usejsdoc.org/tags-readonly.html\n            'readonly': ['ensureEnd'],\n            // http://usejsdoc.org/tags-requires.html\n            'requires': ['parseNamePath', 'ensureEnd'],\n            // http://usejsdoc.org/tags-since.html\n            'since': ['parseDescription'],\n            // http://usejsdoc.org/tags-static.html\n            'static': ['ensureEnd'],\n            // http://usejsdoc.org/tags-summary.html\n            'summary': ['parseDescription'],\n            // http://usejsdoc.org/tags-this.html\n            'this': ['parseThis', 'ensureEnd'],\n            // http://usejsdoc.org/tags-todo.html\n            'todo': ['parseDescription'],\n            // http://usejsdoc.org/tags-typedef.html\n            'typedef': ['parseType', 'parseNamePathOptional'],\n            // http://usejsdoc.org/tags-variation.html\n            'variation': ['parseVariation'],\n            // http://usejsdoc.org/tags-version.html\n            'version': ['parseDescription']\n        };\n\n        TagParser.prototype.parse = function parse() {\n            var i, iz, sequences, method;\n\n\n            // empty title\n            if (!this._title) {\n                if (!this.addError('Missing or invalid title')) {\n                    return null;\n                }\n            }\n\n            // Seek to content last index.\n            this._last = seekContent(this._title);\n\n            if (this._options.range) {\n                this._tag.range = [this._first, source.slice(0, this._last).replace(/\\s*$/, '').length].map(convertIndex);\n            }\n\n            if (hasOwnProperty(Rules, this._title)) {\n                sequences = Rules[this._title];\n            } else {\n                // default sequences\n                sequences = ['parseType', 'parseName', 'parseDescription', 'epilogue'];\n            }\n\n            for (i = 0, iz = sequences.length; i < iz; ++i) {\n                method = sequences[i];\n                if (!this[method]()) {\n                    return null;\n                }\n            }\n\n            return this._tag;\n        };\n\n        function parseTag(options) {\n            var title, parser, tag;\n\n            // skip to tag\n            if (!skipToTag()) {\n                return null;\n            }\n\n            // scan title\n            title = scanTitle();\n\n            // construct tag parser\n            parser = new TagParser(options, title);\n            tag = parser.parse();\n\n            // Seek global index to end of this tag.\n            while (index < parser._last) {\n                advance();\n            }\n\n            return tag;\n        }\n\n        //\n        // Parse JSDoc\n        //\n\n        function scanJSDocDescription(preserveWhitespace) {\n            var description = '', ch, atAllowed;\n\n            atAllowed = true;\n            while (index < length) {\n                ch = source.charCodeAt(index);\n\n                if (atAllowed && ch === 0x40  /* '@' */) {\n                    break;\n                }\n\n                if (esutils.code.isLineTerminator(ch)) {\n                    atAllowed = true;\n                } else if (atAllowed && !esutils.code.isWhiteSpace(ch)) {\n                    atAllowed = false;\n                }\n\n                description += advance();\n            }\n\n            return preserveWhitespace ? description : description.trim();\n        }\n\n        function parse(comment, options) {\n            var tags = [], tag, description, interestingTags, i, iz;\n\n            if (options === undefined) {\n                options = {};\n            }\n\n            if (typeof options.unwrap === 'boolean' && options.unwrap) {\n                source = unwrapComment(comment);\n            } else {\n                source = comment;\n            }\n\n            originalSource = comment;\n\n            // array of relevant tags\n            if (options.tags) {\n                if (Array.isArray(options.tags)) {\n                    interestingTags = { };\n                    for (i = 0, iz = options.tags.length; i < iz; i++) {\n                        if (typeof options.tags[i] === 'string') {\n                            interestingTags[options.tags[i]] = true;\n                        } else {\n                            utility.throwError('Invalid \"tags\" parameter: ' + options.tags);\n                        }\n                    }\n                } else {\n                    utility.throwError('Invalid \"tags\" parameter: ' + options.tags);\n                }\n            }\n\n            length = source.length;\n            index = 0;\n            lineNumber = 0;\n            recoverable = options.recoverable;\n            sloppy = options.sloppy;\n            strict = options.strict;\n\n            description = scanJSDocDescription(options.preserveWhitespace);\n\n            while (true) {\n                tag = parseTag(options);\n                if (!tag) {\n                    break;\n                }\n                if (!interestingTags || interestingTags.hasOwnProperty(tag.title)) {\n                    tags.push(tag);\n                }\n            }\n\n            return {\n                description: description,\n                tags: tags\n            };\n        }\n        exports.parse = parse;\n    }(jsdoc = {}));\n\n    exports.version = utility.VERSION;\n    exports.parse = jsdoc.parse;\n    exports.parseType = typed.parseType;\n    exports.parseParamType = typed.parseParamType;\n    exports.unwrapComment = unwrapComment;\n    exports.Syntax = shallowCopy(typed.Syntax);\n    exports.Error = utility.DoctrineError;\n    exports.type = {\n        Syntax: exports.Syntax,\n        parseType: typed.parseType,\n        parseParamType: typed.parseParamType,\n        stringify: typed.stringify\n    };\n}());\n/* vim: set sw=4 ts=4 et tw=80 : */\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}