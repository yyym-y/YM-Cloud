{"ast":null,"code":"/**\n * @fileoverview Require or disallow newlines around directives.\n * @author Kai Cataldo\n * @deprecated\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"require or disallow newlines around directives\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/lines-around-directive\"\n    },\n    schema: [{\n      oneOf: [{\n        enum: [\"always\", \"never\"]\n      }, {\n        type: \"object\",\n        properties: {\n          before: {\n            enum: [\"always\", \"never\"]\n          },\n          after: {\n            enum: [\"always\", \"never\"]\n          }\n        },\n        additionalProperties: false,\n        minProperties: 2\n      }]\n    }],\n    fixable: \"whitespace\",\n    messages: {\n      expected: \"Expected newline {{location}} \\\"{{value}}\\\" directive.\",\n      unexpected: \"Unexpected newline {{location}} \\\"{{value}}\\\" directive.\"\n    },\n    deprecated: true,\n    replacedBy: [\"padding-line-between-statements\"]\n  },\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const config = context.options[0] || \"always\";\n    const expectLineBefore = typeof config === \"string\" ? config : config.before;\n    const expectLineAfter = typeof config === \"string\" ? config : config.after;\n\n    //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    /**\n     * Check if node is preceded by a blank newline.\n     * @param {ASTNode} node Node to check.\n     * @returns {boolean} Whether or not the passed in node is preceded by a blank newline.\n     */\n    function hasNewlineBefore(node) {\n      const tokenBefore = sourceCode.getTokenBefore(node, {\n        includeComments: true\n      });\n      const tokenLineBefore = tokenBefore ? tokenBefore.loc.end.line : 0;\n      return node.loc.start.line - tokenLineBefore >= 2;\n    }\n\n    /**\n     * Gets the last token of a node that is on the same line as the rest of the node.\n     * This will usually be the last token of the node, but it will be the second-to-last token if the node has a trailing\n     * semicolon on a different line.\n     * @param {ASTNode} node A directive node\n     * @returns {Token} The last token of the node on the line\n     */\n    function getLastTokenOnLine(node) {\n      const lastToken = sourceCode.getLastToken(node);\n      const secondToLastToken = sourceCode.getTokenBefore(lastToken);\n      return astUtils.isSemicolonToken(lastToken) && lastToken.loc.start.line > secondToLastToken.loc.end.line ? secondToLastToken : lastToken;\n    }\n\n    /**\n     * Check if node is followed by a blank newline.\n     * @param {ASTNode} node Node to check.\n     * @returns {boolean} Whether or not the passed in node is followed by a blank newline.\n     */\n    function hasNewlineAfter(node) {\n      const lastToken = getLastTokenOnLine(node);\n      const tokenAfter = sourceCode.getTokenAfter(lastToken, {\n        includeComments: true\n      });\n      return tokenAfter.loc.start.line - lastToken.loc.end.line >= 2;\n    }\n\n    /**\n     * Report errors for newlines around directives.\n     * @param {ASTNode} node Node to check.\n     * @param {string} location Whether the error was found before or after the directive.\n     * @param {boolean} expected Whether or not a newline was expected or unexpected.\n     * @returns {void}\n     */\n    function reportError(node, location, expected) {\n      context.report({\n        node,\n        messageId: expected ? \"expected\" : \"unexpected\",\n        data: {\n          value: node.expression.value,\n          location\n        },\n        fix(fixer) {\n          const lastToken = getLastTokenOnLine(node);\n          if (expected) {\n            return location === \"before\" ? fixer.insertTextBefore(node, \"\\n\") : fixer.insertTextAfter(lastToken, \"\\n\");\n          }\n          return fixer.removeRange(location === \"before\" ? [node.range[0] - 1, node.range[0]] : [lastToken.range[1], lastToken.range[1] + 1]);\n        }\n      });\n    }\n\n    /**\n     * Check lines around directives in node\n     * @param {ASTNode} node node to check\n     * @returns {void}\n     */\n    function checkDirectives(node) {\n      const directives = astUtils.getDirectivePrologue(node);\n      if (!directives.length) {\n        return;\n      }\n      const firstDirective = directives[0];\n      const leadingComments = sourceCode.getCommentsBefore(firstDirective);\n\n      /*\n       * Only check before the first directive if it is preceded by a comment or if it is at the top of\n       * the file and expectLineBefore is set to \"never\". This is to not force a newline at the top of\n       * the file if there are no comments as well as for compatibility with padded-blocks.\n       */\n      if (leadingComments.length) {\n        if (expectLineBefore === \"always\" && !hasNewlineBefore(firstDirective)) {\n          reportError(firstDirective, \"before\", true);\n        }\n        if (expectLineBefore === \"never\" && hasNewlineBefore(firstDirective)) {\n          reportError(firstDirective, \"before\", false);\n        }\n      } else if (node.type === \"Program\" && expectLineBefore === \"never\" && !leadingComments.length && hasNewlineBefore(firstDirective)) {\n        reportError(firstDirective, \"before\", false);\n      }\n      const lastDirective = directives[directives.length - 1];\n      const statements = node.type === \"Program\" ? node.body : node.body.body;\n\n      /*\n       * Do not check after the last directive if the body only\n       * contains a directive prologue and isn't followed by a comment to ensure\n       * this rule behaves well with padded-blocks.\n       */\n      if (lastDirective === statements[statements.length - 1] && !lastDirective.trailingComments) {\n        return;\n      }\n      if (expectLineAfter === \"always\" && !hasNewlineAfter(lastDirective)) {\n        reportError(lastDirective, \"after\", true);\n      }\n      if (expectLineAfter === \"never\" && hasNewlineAfter(lastDirective)) {\n        reportError(lastDirective, \"after\", false);\n      }\n    }\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    return {\n      Program: checkDirectives,\n      FunctionDeclaration: checkDirectives,\n      FunctionExpression: checkDirectives,\n      ArrowFunctionExpression: checkDirectives\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","module","exports","meta","type","docs","description","category","recommended","url","schema","oneOf","enum","properties","before","after","additionalProperties","minProperties","fixable","messages","expected","unexpected","deprecated","replacedBy","create","context","sourceCode","getSourceCode","config","options","expectLineBefore","expectLineAfter","hasNewlineBefore","node","tokenBefore","getTokenBefore","includeComments","tokenLineBefore","loc","end","line","start","getLastTokenOnLine","lastToken","getLastToken","secondToLastToken","isSemicolonToken","hasNewlineAfter","tokenAfter","getTokenAfter","reportError","location","report","messageId","data","value","expression","fix","fixer","insertTextBefore","insertTextAfter","removeRange","range","checkDirectives","directives","getDirectivePrologue","length","firstDirective","leadingComments","getCommentsBefore","lastDirective","statements","body","trailingComments","Program","FunctionDeclaration","FunctionExpression","ArrowFunctionExpression"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/lines-around-directive.js"],"sourcesContent":["/**\n * @fileoverview Require or disallow newlines around directives.\n * @author Kai Cataldo\n * @deprecated\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"require or disallow newlines around directives\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/lines-around-directive\"\n        },\n\n        schema: [{\n            oneOf: [\n                {\n                    enum: [\"always\", \"never\"]\n                },\n                {\n                    type: \"object\",\n                    properties: {\n                        before: {\n                            enum: [\"always\", \"never\"]\n                        },\n                        after: {\n                            enum: [\"always\", \"never\"]\n                        }\n                    },\n                    additionalProperties: false,\n                    minProperties: 2\n                }\n            ]\n        }],\n\n        fixable: \"whitespace\",\n        messages: {\n            expected: \"Expected newline {{location}} \\\"{{value}}\\\" directive.\",\n            unexpected: \"Unexpected newline {{location}} \\\"{{value}}\\\" directive.\"\n        },\n        deprecated: true,\n        replacedBy: [\"padding-line-between-statements\"]\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const config = context.options[0] || \"always\";\n        const expectLineBefore = typeof config === \"string\" ? config : config.before;\n        const expectLineAfter = typeof config === \"string\" ? config : config.after;\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Check if node is preceded by a blank newline.\n         * @param {ASTNode} node Node to check.\n         * @returns {boolean} Whether or not the passed in node is preceded by a blank newline.\n         */\n        function hasNewlineBefore(node) {\n            const tokenBefore = sourceCode.getTokenBefore(node, { includeComments: true });\n            const tokenLineBefore = tokenBefore ? tokenBefore.loc.end.line : 0;\n\n            return node.loc.start.line - tokenLineBefore >= 2;\n        }\n\n        /**\n         * Gets the last token of a node that is on the same line as the rest of the node.\n         * This will usually be the last token of the node, but it will be the second-to-last token if the node has a trailing\n         * semicolon on a different line.\n         * @param {ASTNode} node A directive node\n         * @returns {Token} The last token of the node on the line\n         */\n        function getLastTokenOnLine(node) {\n            const lastToken = sourceCode.getLastToken(node);\n            const secondToLastToken = sourceCode.getTokenBefore(lastToken);\n\n            return astUtils.isSemicolonToken(lastToken) && lastToken.loc.start.line > secondToLastToken.loc.end.line\n                ? secondToLastToken\n                : lastToken;\n        }\n\n        /**\n         * Check if node is followed by a blank newline.\n         * @param {ASTNode} node Node to check.\n         * @returns {boolean} Whether or not the passed in node is followed by a blank newline.\n         */\n        function hasNewlineAfter(node) {\n            const lastToken = getLastTokenOnLine(node);\n            const tokenAfter = sourceCode.getTokenAfter(lastToken, { includeComments: true });\n\n            return tokenAfter.loc.start.line - lastToken.loc.end.line >= 2;\n        }\n\n        /**\n         * Report errors for newlines around directives.\n         * @param {ASTNode} node Node to check.\n         * @param {string} location Whether the error was found before or after the directive.\n         * @param {boolean} expected Whether or not a newline was expected or unexpected.\n         * @returns {void}\n         */\n        function reportError(node, location, expected) {\n            context.report({\n                node,\n                messageId: expected ? \"expected\" : \"unexpected\",\n                data: {\n                    value: node.expression.value,\n                    location\n                },\n                fix(fixer) {\n                    const lastToken = getLastTokenOnLine(node);\n\n                    if (expected) {\n                        return location === \"before\" ? fixer.insertTextBefore(node, \"\\n\") : fixer.insertTextAfter(lastToken, \"\\n\");\n                    }\n                    return fixer.removeRange(location === \"before\" ? [node.range[0] - 1, node.range[0]] : [lastToken.range[1], lastToken.range[1] + 1]);\n                }\n            });\n        }\n\n        /**\n         * Check lines around directives in node\n         * @param {ASTNode} node node to check\n         * @returns {void}\n         */\n        function checkDirectives(node) {\n            const directives = astUtils.getDirectivePrologue(node);\n\n            if (!directives.length) {\n                return;\n            }\n\n            const firstDirective = directives[0];\n            const leadingComments = sourceCode.getCommentsBefore(firstDirective);\n\n            /*\n             * Only check before the first directive if it is preceded by a comment or if it is at the top of\n             * the file and expectLineBefore is set to \"never\". This is to not force a newline at the top of\n             * the file if there are no comments as well as for compatibility with padded-blocks.\n             */\n            if (leadingComments.length) {\n                if (expectLineBefore === \"always\" && !hasNewlineBefore(firstDirective)) {\n                    reportError(firstDirective, \"before\", true);\n                }\n\n                if (expectLineBefore === \"never\" && hasNewlineBefore(firstDirective)) {\n                    reportError(firstDirective, \"before\", false);\n                }\n            } else if (\n                node.type === \"Program\" &&\n                expectLineBefore === \"never\" &&\n                !leadingComments.length &&\n                hasNewlineBefore(firstDirective)\n            ) {\n                reportError(firstDirective, \"before\", false);\n            }\n\n            const lastDirective = directives[directives.length - 1];\n            const statements = node.type === \"Program\" ? node.body : node.body.body;\n\n            /*\n             * Do not check after the last directive if the body only\n             * contains a directive prologue and isn't followed by a comment to ensure\n             * this rule behaves well with padded-blocks.\n             */\n            if (lastDirective === statements[statements.length - 1] && !lastDirective.trailingComments) {\n                return;\n            }\n\n            if (expectLineAfter === \"always\" && !hasNewlineAfter(lastDirective)) {\n                reportError(lastDirective, \"after\", true);\n            }\n\n            if (expectLineAfter === \"never\" && hasNewlineAfter(lastDirective)) {\n                reportError(lastDirective, \"after\", false);\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            Program: checkDirectives,\n            FunctionDeclaration: checkDirectives,\n            FunctionExpression: checkDirectives,\n            ArrowFunctionExpression: checkDirectives\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}