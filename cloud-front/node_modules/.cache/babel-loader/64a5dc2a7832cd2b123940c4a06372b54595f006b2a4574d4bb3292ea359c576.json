{"ast":null,"code":"'use strict';\n\nconst singleComment = Symbol('singleComment');\nconst multiComment = Symbol('multiComment');\nconst stripWithoutWhitespace = () => '';\nconst stripWithWhitespace = (string, start, end) => string.slice(start, end).replace(/\\S/g, ' ');\nconst isEscaped = (jsonString, quotePosition) => {\n  let index = quotePosition - 1;\n  let backslashCount = 0;\n  while (jsonString[index] === '\\\\') {\n    index -= 1;\n    backslashCount += 1;\n  }\n  return Boolean(backslashCount % 2);\n};\nmodule.exports = (jsonString, options = {}) => {\n  if (typeof jsonString !== 'string') {\n    throw new TypeError(`Expected argument \\`jsonString\\` to be a \\`string\\`, got \\`${typeof jsonString}\\``);\n  }\n  const strip = options.whitespace === false ? stripWithoutWhitespace : stripWithWhitespace;\n  let insideString = false;\n  let insideComment = false;\n  let offset = 0;\n  let result = '';\n  for (let i = 0; i < jsonString.length; i++) {\n    const currentCharacter = jsonString[i];\n    const nextCharacter = jsonString[i + 1];\n    if (!insideComment && currentCharacter === '\"') {\n      const escaped = isEscaped(jsonString, i);\n      if (!escaped) {\n        insideString = !insideString;\n      }\n    }\n    if (insideString) {\n      continue;\n    }\n    if (!insideComment && currentCharacter + nextCharacter === '//') {\n      result += jsonString.slice(offset, i);\n      offset = i;\n      insideComment = singleComment;\n      i++;\n    } else if (insideComment === singleComment && currentCharacter + nextCharacter === '\\r\\n') {\n      i++;\n      insideComment = false;\n      result += strip(jsonString, offset, i);\n      offset = i;\n      continue;\n    } else if (insideComment === singleComment && currentCharacter === '\\n') {\n      insideComment = false;\n      result += strip(jsonString, offset, i);\n      offset = i;\n    } else if (!insideComment && currentCharacter + nextCharacter === '/*') {\n      result += jsonString.slice(offset, i);\n      offset = i;\n      insideComment = multiComment;\n      i++;\n      continue;\n    } else if (insideComment === multiComment && currentCharacter + nextCharacter === '*/') {\n      i++;\n      insideComment = false;\n      result += strip(jsonString, offset, i + 1);\n      offset = i + 1;\n      continue;\n    }\n  }\n  return result + (insideComment ? strip(jsonString.slice(offset)) : jsonString.slice(offset));\n};","map":{"version":3,"names":["singleComment","Symbol","multiComment","stripWithoutWhitespace","stripWithWhitespace","string","start","end","slice","replace","isEscaped","jsonString","quotePosition","index","backslashCount","Boolean","module","exports","options","TypeError","strip","whitespace","insideString","insideComment","offset","result","i","length","currentCharacter","nextCharacter","escaped"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/strip-json-comments/index.js"],"sourcesContent":["'use strict';\nconst singleComment = Symbol('singleComment');\nconst multiComment = Symbol('multiComment');\nconst stripWithoutWhitespace = () => '';\nconst stripWithWhitespace = (string, start, end) => string.slice(start, end).replace(/\\S/g, ' ');\n\nconst isEscaped = (jsonString, quotePosition) => {\n\tlet index = quotePosition - 1;\n\tlet backslashCount = 0;\n\n\twhile (jsonString[index] === '\\\\') {\n\t\tindex -= 1;\n\t\tbackslashCount += 1;\n\t}\n\n\treturn Boolean(backslashCount % 2);\n};\n\nmodule.exports = (jsonString, options = {}) => {\n\tif (typeof jsonString !== 'string') {\n\t\tthrow new TypeError(`Expected argument \\`jsonString\\` to be a \\`string\\`, got \\`${typeof jsonString}\\``);\n\t}\n\n\tconst strip = options.whitespace === false ? stripWithoutWhitespace : stripWithWhitespace;\n\n\tlet insideString = false;\n\tlet insideComment = false;\n\tlet offset = 0;\n\tlet result = '';\n\n\tfor (let i = 0; i < jsonString.length; i++) {\n\t\tconst currentCharacter = jsonString[i];\n\t\tconst nextCharacter = jsonString[i + 1];\n\n\t\tif (!insideComment && currentCharacter === '\"') {\n\t\t\tconst escaped = isEscaped(jsonString, i);\n\t\t\tif (!escaped) {\n\t\t\t\tinsideString = !insideString;\n\t\t\t}\n\t\t}\n\n\t\tif (insideString) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!insideComment && currentCharacter + nextCharacter === '//') {\n\t\t\tresult += jsonString.slice(offset, i);\n\t\t\toffset = i;\n\t\t\tinsideComment = singleComment;\n\t\t\ti++;\n\t\t} else if (insideComment === singleComment && currentCharacter + nextCharacter === '\\r\\n') {\n\t\t\ti++;\n\t\t\tinsideComment = false;\n\t\t\tresult += strip(jsonString, offset, i);\n\t\t\toffset = i;\n\t\t\tcontinue;\n\t\t} else if (insideComment === singleComment && currentCharacter === '\\n') {\n\t\t\tinsideComment = false;\n\t\t\tresult += strip(jsonString, offset, i);\n\t\t\toffset = i;\n\t\t} else if (!insideComment && currentCharacter + nextCharacter === '/*') {\n\t\t\tresult += jsonString.slice(offset, i);\n\t\t\toffset = i;\n\t\t\tinsideComment = multiComment;\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t} else if (insideComment === multiComment && currentCharacter + nextCharacter === '*/') {\n\t\t\ti++;\n\t\t\tinsideComment = false;\n\t\t\tresult += strip(jsonString, offset, i + 1);\n\t\t\toffset = i + 1;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\treturn result + (insideComment ? strip(jsonString.slice(offset)) : jsonString.slice(offset));\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}