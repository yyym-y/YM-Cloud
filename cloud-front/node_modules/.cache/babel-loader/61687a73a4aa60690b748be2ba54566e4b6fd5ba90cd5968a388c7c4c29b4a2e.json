{"ast":null,"code":"/**\n * @fileoverview Utility for caching lint results.\n * @author Kevin Partington\n */\n\"use strict\";\n\n//-----------------------------------------------------------------------------\n// Requirements\n//-----------------------------------------------------------------------------\nconst assert = require(\"assert\");\nconst fs = require(\"fs\");\nconst fileEntryCache = require(\"file-entry-cache\");\nconst stringify = require(\"json-stable-stringify-without-jsonify\");\nconst pkg = require(\"../../package.json\");\nconst hash = require(\"./hash\");\nconst debug = require(\"debug\")(\"eslint:lint-result-cache\");\n\n//-----------------------------------------------------------------------------\n// Helpers\n//-----------------------------------------------------------------------------\n\nconst configHashCache = new WeakMap();\nconst nodeVersion = process && process.version;\nconst validCacheStrategies = [\"metadata\", \"content\"];\nconst invalidCacheStrategyErrorMessage = `Cache strategy must be one of: ${validCacheStrategies.map(strategy => `\"${strategy}\"`).join(\", \")}`;\n\n/**\n * Tests whether a provided cacheStrategy is valid\n * @param {string} cacheStrategy The cache strategy to use\n * @returns {boolean} true if `cacheStrategy` is one of `validCacheStrategies`; false otherwise\n */\nfunction isValidCacheStrategy(cacheStrategy) {\n  return validCacheStrategies.indexOf(cacheStrategy) !== -1;\n}\n\n/**\n * Calculates the hash of the config\n * @param {ConfigArray} config The config.\n * @returns {string} The hash of the config\n */\nfunction hashOfConfigFor(config) {\n  if (!configHashCache.has(config)) {\n    configHashCache.set(config, hash(`${pkg.version}_${nodeVersion}_${stringify(config)}`));\n  }\n  return configHashCache.get(config);\n}\n\n//-----------------------------------------------------------------------------\n// Public Interface\n//-----------------------------------------------------------------------------\n\n/**\n * Lint result cache. This wraps around the file-entry-cache module,\n * transparently removing properties that are difficult or expensive to\n * serialize and adding them back in on retrieval.\n */\nclass LintResultCache {\n  /**\n   * Creates a new LintResultCache instance.\n   * @param {string} cacheFileLocation The cache file location.\n   * @param {\"metadata\" | \"content\"} cacheStrategy The cache strategy to use.\n   */\n  constructor(cacheFileLocation, cacheStrategy) {\n    assert(cacheFileLocation, \"Cache file location is required\");\n    assert(cacheStrategy, \"Cache strategy is required\");\n    assert(isValidCacheStrategy(cacheStrategy), invalidCacheStrategyErrorMessage);\n    debug(`Caching results to ${cacheFileLocation}`);\n    const useChecksum = cacheStrategy === \"content\";\n    debug(`Using \"${cacheStrategy}\" strategy to detect changes`);\n    this.fileEntryCache = fileEntryCache.create(cacheFileLocation, void 0, useChecksum);\n    this.cacheFileLocation = cacheFileLocation;\n  }\n\n  /**\n   * Retrieve cached lint results for a given file path, if present in the\n   * cache. If the file is present and has not been changed, rebuild any\n   * missing result information.\n   * @param {string} filePath The file for which to retrieve lint results.\n   * @param {ConfigArray} config The config of the file.\n   * @returns {Object|null} The rebuilt lint results, or null if the file is\n   *   changed or not in the filesystem.\n   */\n  getCachedLintResults(filePath, config) {\n    /*\n     * Cached lint results are valid if and only if:\n     * 1. The file is present in the filesystem\n     * 2. The file has not changed since the time it was previously linted\n     * 3. The ESLint configuration has not changed since the time the file\n     *    was previously linted\n     * If any of these are not true, we will not reuse the lint results.\n     */\n    const fileDescriptor = this.fileEntryCache.getFileDescriptor(filePath);\n    const hashOfConfig = hashOfConfigFor(config);\n    const changed = fileDescriptor.changed || fileDescriptor.meta.hashOfConfig !== hashOfConfig;\n    if (fileDescriptor.notFound) {\n      debug(`File not found on the file system: ${filePath}`);\n      return null;\n    }\n    if (changed) {\n      debug(`Cache entry not found or no longer valid: ${filePath}`);\n      return null;\n    }\n\n    // If source is present but null, need to reread the file from the filesystem.\n    if (fileDescriptor.meta.results && fileDescriptor.meta.results.source === null) {\n      debug(`Rereading cached result source from filesystem: ${filePath}`);\n      fileDescriptor.meta.results.source = fs.readFileSync(filePath, \"utf-8\");\n    }\n    return fileDescriptor.meta.results;\n  }\n\n  /**\n   * Set the cached lint results for a given file path, after removing any\n   * information that will be both unnecessary and difficult to serialize.\n   * Avoids caching results with an \"output\" property (meaning fixes were\n   * applied), to prevent potentially incorrect results if fixes are not\n   * written to disk.\n   * @param {string} filePath The file for which to set lint results.\n   * @param {ConfigArray} config The config of the file.\n   * @param {Object} result The lint result to be set for the file.\n   * @returns {void}\n   */\n  setCachedLintResults(filePath, config, result) {\n    if (result && Object.prototype.hasOwnProperty.call(result, \"output\")) {\n      return;\n    }\n    const fileDescriptor = this.fileEntryCache.getFileDescriptor(filePath);\n    if (fileDescriptor && !fileDescriptor.notFound) {\n      debug(`Updating cached result: ${filePath}`);\n\n      // Serialize the result, except that we want to remove the file source if present.\n      const resultToSerialize = Object.assign({}, result);\n\n      /*\n       * Set result.source to null.\n       * In `getCachedLintResults`, if source is explicitly null, we will\n       * read the file from the filesystem to set the value again.\n       */\n      if (Object.prototype.hasOwnProperty.call(resultToSerialize, \"source\")) {\n        resultToSerialize.source = null;\n      }\n      fileDescriptor.meta.results = resultToSerialize;\n      fileDescriptor.meta.hashOfConfig = hashOfConfigFor(config);\n    }\n  }\n\n  /**\n   * Persists the in-memory cache to disk.\n   * @returns {void}\n   */\n  reconcile() {\n    debug(`Persisting cached results: ${this.cacheFileLocation}`);\n    this.fileEntryCache.reconcile();\n  }\n}\nmodule.exports = LintResultCache;","map":{"version":3,"names":["assert","require","fs","fileEntryCache","stringify","pkg","hash","debug","configHashCache","WeakMap","nodeVersion","process","version","validCacheStrategies","invalidCacheStrategyErrorMessage","map","strategy","join","isValidCacheStrategy","cacheStrategy","indexOf","hashOfConfigFor","config","has","set","get","LintResultCache","constructor","cacheFileLocation","useChecksum","create","getCachedLintResults","filePath","fileDescriptor","getFileDescriptor","hashOfConfig","changed","meta","notFound","results","source","readFileSync","setCachedLintResults","result","Object","prototype","hasOwnProperty","call","resultToSerialize","assign","reconcile","module","exports"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/cli-engine/lint-result-cache.js"],"sourcesContent":["/**\n * @fileoverview Utility for caching lint results.\n * @author Kevin Partington\n */\n\"use strict\";\n\n//-----------------------------------------------------------------------------\n// Requirements\n//-----------------------------------------------------------------------------\n\nconst assert = require(\"assert\");\nconst fs = require(\"fs\");\nconst fileEntryCache = require(\"file-entry-cache\");\nconst stringify = require(\"json-stable-stringify-without-jsonify\");\nconst pkg = require(\"../../package.json\");\nconst hash = require(\"./hash\");\n\nconst debug = require(\"debug\")(\"eslint:lint-result-cache\");\n\n//-----------------------------------------------------------------------------\n// Helpers\n//-----------------------------------------------------------------------------\n\nconst configHashCache = new WeakMap();\nconst nodeVersion = process && process.version;\n\nconst validCacheStrategies = [\"metadata\", \"content\"];\nconst invalidCacheStrategyErrorMessage = `Cache strategy must be one of: ${validCacheStrategies\n    .map(strategy => `\"${strategy}\"`)\n    .join(\", \")}`;\n\n/**\n * Tests whether a provided cacheStrategy is valid\n * @param {string} cacheStrategy The cache strategy to use\n * @returns {boolean} true if `cacheStrategy` is one of `validCacheStrategies`; false otherwise\n */\nfunction isValidCacheStrategy(cacheStrategy) {\n    return (\n        validCacheStrategies.indexOf(cacheStrategy) !== -1\n    );\n}\n\n/**\n * Calculates the hash of the config\n * @param {ConfigArray} config The config.\n * @returns {string} The hash of the config\n */\nfunction hashOfConfigFor(config) {\n    if (!configHashCache.has(config)) {\n        configHashCache.set(config, hash(`${pkg.version}_${nodeVersion}_${stringify(config)}`));\n    }\n\n    return configHashCache.get(config);\n}\n\n//-----------------------------------------------------------------------------\n// Public Interface\n//-----------------------------------------------------------------------------\n\n/**\n * Lint result cache. This wraps around the file-entry-cache module,\n * transparently removing properties that are difficult or expensive to\n * serialize and adding them back in on retrieval.\n */\nclass LintResultCache {\n\n    /**\n     * Creates a new LintResultCache instance.\n     * @param {string} cacheFileLocation The cache file location.\n     * @param {\"metadata\" | \"content\"} cacheStrategy The cache strategy to use.\n     */\n    constructor(cacheFileLocation, cacheStrategy) {\n        assert(cacheFileLocation, \"Cache file location is required\");\n        assert(cacheStrategy, \"Cache strategy is required\");\n        assert(\n            isValidCacheStrategy(cacheStrategy),\n            invalidCacheStrategyErrorMessage\n        );\n\n        debug(`Caching results to ${cacheFileLocation}`);\n\n        const useChecksum = cacheStrategy === \"content\";\n\n        debug(\n            `Using \"${cacheStrategy}\" strategy to detect changes`\n        );\n\n        this.fileEntryCache = fileEntryCache.create(\n            cacheFileLocation,\n            void 0,\n            useChecksum\n        );\n        this.cacheFileLocation = cacheFileLocation;\n    }\n\n    /**\n     * Retrieve cached lint results for a given file path, if present in the\n     * cache. If the file is present and has not been changed, rebuild any\n     * missing result information.\n     * @param {string} filePath The file for which to retrieve lint results.\n     * @param {ConfigArray} config The config of the file.\n     * @returns {Object|null} The rebuilt lint results, or null if the file is\n     *   changed or not in the filesystem.\n     */\n    getCachedLintResults(filePath, config) {\n\n        /*\n         * Cached lint results are valid if and only if:\n         * 1. The file is present in the filesystem\n         * 2. The file has not changed since the time it was previously linted\n         * 3. The ESLint configuration has not changed since the time the file\n         *    was previously linted\n         * If any of these are not true, we will not reuse the lint results.\n         */\n        const fileDescriptor = this.fileEntryCache.getFileDescriptor(filePath);\n        const hashOfConfig = hashOfConfigFor(config);\n        const changed =\n            fileDescriptor.changed ||\n            fileDescriptor.meta.hashOfConfig !== hashOfConfig;\n\n        if (fileDescriptor.notFound) {\n            debug(`File not found on the file system: ${filePath}`);\n            return null;\n        }\n\n        if (changed) {\n            debug(`Cache entry not found or no longer valid: ${filePath}`);\n            return null;\n        }\n\n        // If source is present but null, need to reread the file from the filesystem.\n        if (\n            fileDescriptor.meta.results &&\n            fileDescriptor.meta.results.source === null\n        ) {\n            debug(`Rereading cached result source from filesystem: ${filePath}`);\n            fileDescriptor.meta.results.source = fs.readFileSync(filePath, \"utf-8\");\n        }\n\n        return fileDescriptor.meta.results;\n    }\n\n    /**\n     * Set the cached lint results for a given file path, after removing any\n     * information that will be both unnecessary and difficult to serialize.\n     * Avoids caching results with an \"output\" property (meaning fixes were\n     * applied), to prevent potentially incorrect results if fixes are not\n     * written to disk.\n     * @param {string} filePath The file for which to set lint results.\n     * @param {ConfigArray} config The config of the file.\n     * @param {Object} result The lint result to be set for the file.\n     * @returns {void}\n     */\n    setCachedLintResults(filePath, config, result) {\n        if (result && Object.prototype.hasOwnProperty.call(result, \"output\")) {\n            return;\n        }\n\n        const fileDescriptor = this.fileEntryCache.getFileDescriptor(filePath);\n\n        if (fileDescriptor && !fileDescriptor.notFound) {\n            debug(`Updating cached result: ${filePath}`);\n\n            // Serialize the result, except that we want to remove the file source if present.\n            const resultToSerialize = Object.assign({}, result);\n\n            /*\n             * Set result.source to null.\n             * In `getCachedLintResults`, if source is explicitly null, we will\n             * read the file from the filesystem to set the value again.\n             */\n            if (Object.prototype.hasOwnProperty.call(resultToSerialize, \"source\")) {\n                resultToSerialize.source = null;\n            }\n\n            fileDescriptor.meta.results = resultToSerialize;\n            fileDescriptor.meta.hashOfConfig = hashOfConfigFor(config);\n        }\n    }\n\n    /**\n     * Persists the in-memory cache to disk.\n     * @returns {void}\n     */\n    reconcile() {\n        debug(`Persisting cached results: ${this.cacheFileLocation}`);\n        this.fileEntryCache.reconcile();\n    }\n}\n\nmodule.exports = LintResultCache;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}