{"ast":null,"code":"require(\"core-js/modules/es.array.push.js\");\n// A simple implementation of make-array\nfunction make_array(subject) {\n  return Array.isArray(subject) ? subject : [subject];\n}\nconst REGEX_BLANK_LINE = /^\\s+$/;\nconst REGEX_LEADING_EXCAPED_EXCLAMATION = /^\\\\!/;\nconst REGEX_LEADING_EXCAPED_HASH = /^\\\\#/;\nconst SLASH = '/';\nconst KEY_IGNORE = typeof Symbol !== 'undefined' ? Symbol.for('node-ignore')\n/* istanbul ignore next */ : 'node-ignore';\nconst define = (object, key, value) => Object.defineProperty(object, key, {\n  value\n});\nconst REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g;\n\n// Sanitize the range of a regular expression\n// The cases are complicated, see test cases for details\nconst sanitizeRange = range => range.replace(REGEX_REGEXP_RANGE, (match, from, to) => from.charCodeAt(0) <= to.charCodeAt(0) ? match\n// Invalid range (out of order) which is ok for gitignore rules but\n//   fatal for JavaScript regular expression, so eliminate it.\n: '');\n\n// > If the pattern ends with a slash,\n// > it is removed for the purpose of the following description,\n// > but it would only find a match with a directory.\n// > In other words, foo/ will match a directory foo and paths underneath it,\n// > but will not match a regular file or a symbolic link foo\n// >  (this is consistent with the way how pathspec works in general in Git).\n// '`foo/`' will not match regular file '`foo`' or symbolic link '`foo`'\n// -> ignore-rules will not deal with it, because it costs extra `fs.stat` call\n//      you could use option `mark: true` with `glob`\n\n// '`foo/`' should not continue with the '`..`'\nconst DEFAULT_REPLACER_PREFIX = [\n// > Trailing spaces are ignored unless they are quoted with backslash (\"\\\")\n[\n// (a\\ ) -> (a )\n// (a  ) -> (a)\n// (a \\ ) -> (a  )\n/\\\\?\\s+$/, match => match.indexOf('\\\\') === 0 ? ' ' : ''],\n// replace (\\ ) with ' '\n[/\\\\\\s/g, () => ' '],\n// Escape metacharacters\n// which is written down by users but means special for regular expressions.\n\n// > There are 12 characters with special meanings:\n// > - the backslash \\,\n// > - the caret ^,\n// > - the dollar sign $,\n// > - the period or dot .,\n// > - the vertical bar or pipe symbol |,\n// > - the question mark ?,\n// > - the asterisk or star *,\n// > - the plus sign +,\n// > - the opening parenthesis (,\n// > - the closing parenthesis ),\n// > - and the opening square bracket [,\n// > - the opening curly brace {,\n// > These special characters are often called \"metacharacters\".\n[/[\\\\^$.|*+(){]/g, match => `\\\\${match}`], [\n// > [abc] matches any character inside the brackets\n// >    (in this case a, b, or c);\n/\\[([^\\]/]*)($|\\])/g, (match, p1, p2) => p2 === ']' ? `[${sanitizeRange(p1)}]` : `\\\\${match}`], [\n// > a question mark (?) matches a single character\n/(?!\\\\)\\?/g, () => '[^/]'],\n// leading slash\n[\n// > A leading slash matches the beginning of the pathname.\n// > For example, \"/*.c\" matches \"cat-file.c\" but not \"mozilla-sha1/sha1.c\".\n// A leading slash matches the beginning of the pathname\n/^\\//, () => '^'],\n// replace special metacharacter slash after the leading slash\n[/\\//g, () => '\\\\/'], [\n// > A leading \"**\" followed by a slash means match in all directories.\n// > For example, \"**/foo\" matches file or directory \"foo\" anywhere,\n// > the same as pattern \"foo\".\n// > \"**/foo/bar\" matches file or directory \"bar\" anywhere that is directly\n// >   under directory \"foo\".\n// Notice that the '*'s have been replaced as '\\\\*'\n/^\\^*\\\\\\*\\\\\\*\\\\\\//,\n// '**/foo' <-> 'foo'\n() => '^(?:.*\\\\/)?']];\nconst DEFAULT_REPLACER_SUFFIX = [\n// starting\n[\n// there will be no leading '/'\n//   (which has been replaced by section \"leading slash\")\n// If starts with '**', adding a '^' to the regular expression also works\n/^(?=[^^])/, function startingReplacer() {\n  return !/\\/(?!$)/.test(this)\n  // > If the pattern does not contain a slash /,\n  // >   Git treats it as a shell glob pattern\n  // Actually, if there is only a trailing slash,\n  //   git also treats it as a shell glob pattern\n  ? '(?:^|\\\\/)'\n\n  // > Otherwise, Git treats the pattern as a shell glob suitable for\n  // >   consumption by fnmatch(3)\n  : '^';\n}],\n// two globstars\n[\n// Use lookahead assertions so that we could match more than one `'/**'`\n/\\\\\\/\\\\\\*\\\\\\*(?=\\\\\\/|$)/g,\n// Zero, one or several directories\n// should not use '*', or it will be replaced by the next replacer\n\n// Check if it is not the last `'/**'`\n(match, index, str) => index + 6 < str.length\n\n// case: /**/\n// > A slash followed by two consecutive asterisks then a slash matches\n// >   zero or more directories.\n// > For example, \"a/**/b\" matches \"a/b\", \"a/x/b\", \"a/x/y/b\" and so on.\n// '/**/'\n? '(?:\\\\/[^\\\\/]+)*'\n\n// case: /**\n// > A trailing `\"/**\"` matches everything inside.\n\n// #21: everything inside but it should not include the current folder\n: '\\\\/.+'],\n// intermediate wildcards\n[\n// Never replace escaped '*'\n// ignore rule '\\*' will match the path '*'\n\n// 'abc.*/' -> go\n// 'abc.*'  -> skip this rule\n/(^|[^\\\\]+)\\\\\\*(?=.+)/g,\n// '*.js' matches '.js'\n// '*.js' doesn't match 'abc'\n(match, p1) => `${p1}[^\\\\/]*`],\n// trailing wildcard\n[/(\\^|\\\\\\/)?\\\\\\*$/, (match, p1) => {\n  const prefix = p1\n  // '\\^':\n  // '/*' does not match ''\n  // '/*' does not match everything\n\n  // '\\\\\\/':\n  // 'abc/*' does not match 'abc/'\n  ? `${p1}[^/]+`\n\n  // 'a*' matches 'a'\n  // 'a*' matches 'aa'\n  : '[^/]*';\n  return `${prefix}(?=$|\\\\/$)`;\n}], [\n// unescape\n/\\\\\\\\\\\\/g, () => '\\\\']];\nconst POSITIVE_REPLACERS = [...DEFAULT_REPLACER_PREFIX,\n// 'f'\n// matches\n// - /f(end)\n// - /f/\n// - (start)f(end)\n// - (start)f/\n// doesn't match\n// - oof\n// - foo\n// pseudo:\n// -> (^|/)f(/|$)\n\n// ending\n[\n// 'js' will not match 'js.'\n// 'ab' will not match 'abc'\n/(?:[^*/])$/,\n// 'js*' will not match 'a.js'\n// 'js/' will not match 'a.js'\n// 'js' will match 'a.js' and 'a.js/'\nmatch => `${match}(?=$|\\\\/)`], ...DEFAULT_REPLACER_SUFFIX];\nconst NEGATIVE_REPLACERS = [...DEFAULT_REPLACER_PREFIX,\n// #24, #38\n// The MISSING rule of [gitignore docs](https://git-scm.com/docs/gitignore)\n// A negative pattern without a trailing wildcard should not\n// re-include the things inside that directory.\n\n// eg:\n// ['node_modules/*', '!node_modules']\n// should ignore `node_modules/a.js`\n[/(?:[^*])$/, match => `${match}(?=$|\\\\/$)`], ...DEFAULT_REPLACER_SUFFIX];\n\n// A simple cache, because an ignore rule only has only one certain meaning\nconst cache = Object.create(null);\n\n// @param {pattern}\nconst make_regex = (pattern, negative, ignorecase) => {\n  const r = cache[pattern];\n  if (r) {\n    return r;\n  }\n  const replacers = negative ? NEGATIVE_REPLACERS : POSITIVE_REPLACERS;\n  const source = replacers.reduce((prev, current) => prev.replace(current[0], current[1].bind(pattern)), pattern);\n  return cache[pattern] = ignorecase ? new RegExp(source, 'i') : new RegExp(source);\n};\n\n// > A blank line matches no files, so it can serve as a separator for readability.\nconst checkPattern = pattern => pattern && typeof pattern === 'string' && !REGEX_BLANK_LINE.test(pattern)\n\n// > A line starting with # serves as a comment.\n&& pattern.indexOf('#') !== 0;\nconst createRule = (pattern, ignorecase) => {\n  const origin = pattern;\n  let negative = false;\n\n  // > An optional prefix \"!\" which negates the pattern;\n  if (pattern.indexOf('!') === 0) {\n    negative = true;\n    pattern = pattern.substr(1);\n  }\n  pattern = pattern\n  // > Put a backslash (\"\\\") in front of the first \"!\" for patterns that\n  // >   begin with a literal \"!\", for example, `\"\\!important!.txt\"`.\n  .replace(REGEX_LEADING_EXCAPED_EXCLAMATION, '!')\n  // > Put a backslash (\"\\\") in front of the first hash for patterns that\n  // >   begin with a hash.\n  .replace(REGEX_LEADING_EXCAPED_HASH, '#');\n  const regex = make_regex(pattern, negative, ignorecase);\n  return {\n    origin,\n    pattern,\n    negative,\n    regex\n  };\n};\nclass IgnoreBase {\n  constructor({\n    ignorecase = true\n  } = {}) {\n    this._rules = [];\n    this._ignorecase = ignorecase;\n    define(this, KEY_IGNORE, true);\n    this._initCache();\n  }\n  _initCache() {\n    this._cache = Object.create(null);\n  }\n\n  // @param {Array.<string>|string|Ignore} pattern\n  add(pattern) {\n    this._added = false;\n    if (typeof pattern === 'string') {\n      pattern = pattern.split(/\\r?\\n/g);\n    }\n    make_array(pattern).forEach(this._addPattern, this);\n\n    // Some rules have just added to the ignore,\n    // making the behavior changed.\n    if (this._added) {\n      this._initCache();\n    }\n    return this;\n  }\n\n  // legacy\n  addPattern(pattern) {\n    return this.add(pattern);\n  }\n  _addPattern(pattern) {\n    // #32\n    if (pattern && pattern[KEY_IGNORE]) {\n      this._rules = this._rules.concat(pattern._rules);\n      this._added = true;\n      return;\n    }\n    if (checkPattern(pattern)) {\n      const rule = createRule(pattern, this._ignorecase);\n      this._added = true;\n      this._rules.push(rule);\n    }\n  }\n  filter(paths) {\n    return make_array(paths).filter(path => this._filter(path));\n  }\n  createFilter() {\n    return path => this._filter(path);\n  }\n  ignores(path) {\n    return !this._filter(path);\n  }\n\n  // @returns `Boolean` true if the `path` is NOT ignored\n  _filter(path, slices) {\n    if (!path) {\n      return false;\n    }\n    if (path in this._cache) {\n      return this._cache[path];\n    }\n    if (!slices) {\n      // path/to/a.js\n      // ['path', 'to', 'a.js']\n      slices = path.split(SLASH);\n    }\n    slices.pop();\n    return this._cache[path] = slices.length\n    // > It is not possible to re-include a file if a parent directory of\n    // >   that file is excluded.\n    // If the path contains a parent directory, check the parent first\n    ? this._filter(slices.join(SLASH) + SLASH, slices) && this._test(path)\n\n    // Or only test the path\n    : this._test(path);\n  }\n\n  // @returns {Boolean} true if a file is NOT ignored\n  _test(path) {\n    // Explicitly define variable type by setting matched to `0`\n    let matched = 0;\n    this._rules.forEach(rule => {\n      // if matched = true, then we only test negative rules\n      // if matched = false, then we test non-negative rules\n      if (!(matched ^ rule.negative)) {\n        matched = rule.negative ^ rule.regex.test(path);\n      }\n    });\n    return !matched;\n  }\n}\n\n// Windows\n// --------------------------------------------------------------\n/* istanbul ignore if  */\nif (\n// Detect `process` so that it can run in browsers.\ntypeof process !== 'undefined' && (process.env && process.env.IGNORE_TEST_WIN32 || process.platform === 'win32')) {\n  const filter = IgnoreBase.prototype._filter;\n\n  /* eslint no-control-regex: \"off\" */\n  const make_posix = str => /^\\\\\\\\\\?\\\\/.test(str) || /[^\\x00-\\x80]+/.test(str) ? str : str.replace(/\\\\/g, '/');\n  IgnoreBase.prototype._filter = function filterWin32(path, slices) {\n    path = make_posix(path);\n    return filter.call(this, path, slices);\n  };\n}\nmodule.exports = options => new IgnoreBase(options);","map":{"version":3,"names":["make_array","subject","Array","isArray","REGEX_BLANK_LINE","REGEX_LEADING_EXCAPED_EXCLAMATION","REGEX_LEADING_EXCAPED_HASH","SLASH","KEY_IGNORE","Symbol","for","define","object","key","value","Object","defineProperty","REGEX_REGEXP_RANGE","sanitizeRange","range","replace","match","from","to","charCodeAt","DEFAULT_REPLACER_PREFIX","indexOf","p1","p2","DEFAULT_REPLACER_SUFFIX","startingReplacer","test","index","str","length","prefix","POSITIVE_REPLACERS","NEGATIVE_REPLACERS","cache","create","make_regex","pattern","negative","ignorecase","r","replacers","source","reduce","prev","current","bind","RegExp","checkPattern","createRule","origin","substr","regex","IgnoreBase","constructor","_rules","_ignorecase","_initCache","_cache","add","_added","split","forEach","_addPattern","addPattern","concat","rule","push","filter","paths","path","_filter","createFilter","ignores","slices","pop","join","_test","matched","process","env","IGNORE_TEST_WIN32","platform","prototype","make_posix","filterWin32","call","module","exports","options"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/node_modules/ignore/index.js"],"sourcesContent":["// A simple implementation of make-array\nfunction make_array (subject) {\n  return Array.isArray(subject)\n    ? subject\n    : [subject]\n}\n\nconst REGEX_BLANK_LINE = /^\\s+$/\nconst REGEX_LEADING_EXCAPED_EXCLAMATION = /^\\\\!/\nconst REGEX_LEADING_EXCAPED_HASH = /^\\\\#/\nconst SLASH = '/'\nconst KEY_IGNORE = typeof Symbol !== 'undefined'\n  ? Symbol.for('node-ignore')\n  /* istanbul ignore next */\n  : 'node-ignore'\n\nconst define = (object, key, value) =>\n  Object.defineProperty(object, key, {value})\n\nconst REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g\n\n// Sanitize the range of a regular expression\n// The cases are complicated, see test cases for details\nconst sanitizeRange = range => range.replace(\n  REGEX_REGEXP_RANGE,\n  (match, from, to) => from.charCodeAt(0) <= to.charCodeAt(0)\n    ? match\n    // Invalid range (out of order) which is ok for gitignore rules but\n    //   fatal for JavaScript regular expression, so eliminate it.\n    : ''\n)\n\n// > If the pattern ends with a slash,\n// > it is removed for the purpose of the following description,\n// > but it would only find a match with a directory.\n// > In other words, foo/ will match a directory foo and paths underneath it,\n// > but will not match a regular file or a symbolic link foo\n// >  (this is consistent with the way how pathspec works in general in Git).\n// '`foo/`' will not match regular file '`foo`' or symbolic link '`foo`'\n// -> ignore-rules will not deal with it, because it costs extra `fs.stat` call\n//      you could use option `mark: true` with `glob`\n\n// '`foo/`' should not continue with the '`..`'\nconst DEFAULT_REPLACER_PREFIX = [\n\n  // > Trailing spaces are ignored unless they are quoted with backslash (\"\\\")\n  [\n    // (a\\ ) -> (a )\n    // (a  ) -> (a)\n    // (a \\ ) -> (a  )\n    /\\\\?\\s+$/,\n    match => match.indexOf('\\\\') === 0\n      ? ' '\n      : ''\n  ],\n\n  // replace (\\ ) with ' '\n  [\n    /\\\\\\s/g,\n    () => ' '\n  ],\n\n  // Escape metacharacters\n  // which is written down by users but means special for regular expressions.\n\n  // > There are 12 characters with special meanings:\n  // > - the backslash \\,\n  // > - the caret ^,\n  // > - the dollar sign $,\n  // > - the period or dot .,\n  // > - the vertical bar or pipe symbol |,\n  // > - the question mark ?,\n  // > - the asterisk or star *,\n  // > - the plus sign +,\n  // > - the opening parenthesis (,\n  // > - the closing parenthesis ),\n  // > - and the opening square bracket [,\n  // > - the opening curly brace {,\n  // > These special characters are often called \"metacharacters\".\n  [\n    /[\\\\^$.|*+(){]/g,\n    match => `\\\\${match}`\n  ],\n\n  [\n    // > [abc] matches any character inside the brackets\n    // >    (in this case a, b, or c);\n    /\\[([^\\]/]*)($|\\])/g,\n    (match, p1, p2) => p2 === ']'\n      ? `[${sanitizeRange(p1)}]`\n      : `\\\\${match}`\n  ],\n\n  [\n    // > a question mark (?) matches a single character\n    /(?!\\\\)\\?/g,\n    () => '[^/]'\n  ],\n\n  // leading slash\n  [\n\n    // > A leading slash matches the beginning of the pathname.\n    // > For example, \"/*.c\" matches \"cat-file.c\" but not \"mozilla-sha1/sha1.c\".\n    // A leading slash matches the beginning of the pathname\n    /^\\//,\n    () => '^'\n  ],\n\n  // replace special metacharacter slash after the leading slash\n  [\n    /\\//g,\n    () => '\\\\/'\n  ],\n\n  [\n    // > A leading \"**\" followed by a slash means match in all directories.\n    // > For example, \"**/foo\" matches file or directory \"foo\" anywhere,\n    // > the same as pattern \"foo\".\n    // > \"**/foo/bar\" matches file or directory \"bar\" anywhere that is directly\n    // >   under directory \"foo\".\n    // Notice that the '*'s have been replaced as '\\\\*'\n    /^\\^*\\\\\\*\\\\\\*\\\\\\//,\n\n    // '**/foo' <-> 'foo'\n    () => '^(?:.*\\\\/)?'\n  ]\n]\n\nconst DEFAULT_REPLACER_SUFFIX = [\n  // starting\n  [\n    // there will be no leading '/'\n    //   (which has been replaced by section \"leading slash\")\n    // If starts with '**', adding a '^' to the regular expression also works\n    /^(?=[^^])/,\n    function startingReplacer () {\n      return !/\\/(?!$)/.test(this)\n        // > If the pattern does not contain a slash /,\n        // >   Git treats it as a shell glob pattern\n        // Actually, if there is only a trailing slash,\n        //   git also treats it as a shell glob pattern\n        ? '(?:^|\\\\/)'\n\n        // > Otherwise, Git treats the pattern as a shell glob suitable for\n        // >   consumption by fnmatch(3)\n        : '^'\n    }\n  ],\n\n  // two globstars\n  [\n    // Use lookahead assertions so that we could match more than one `'/**'`\n    /\\\\\\/\\\\\\*\\\\\\*(?=\\\\\\/|$)/g,\n\n    // Zero, one or several directories\n    // should not use '*', or it will be replaced by the next replacer\n\n    // Check if it is not the last `'/**'`\n    (match, index, str) => index + 6 < str.length\n\n      // case: /**/\n      // > A slash followed by two consecutive asterisks then a slash matches\n      // >   zero or more directories.\n      // > For example, \"a/**/b\" matches \"a/b\", \"a/x/b\", \"a/x/y/b\" and so on.\n      // '/**/'\n      ? '(?:\\\\/[^\\\\/]+)*'\n\n      // case: /**\n      // > A trailing `\"/**\"` matches everything inside.\n\n      // #21: everything inside but it should not include the current folder\n      : '\\\\/.+'\n  ],\n\n  // intermediate wildcards\n  [\n    // Never replace escaped '*'\n    // ignore rule '\\*' will match the path '*'\n\n    // 'abc.*/' -> go\n    // 'abc.*'  -> skip this rule\n    /(^|[^\\\\]+)\\\\\\*(?=.+)/g,\n\n    // '*.js' matches '.js'\n    // '*.js' doesn't match 'abc'\n    (match, p1) => `${p1}[^\\\\/]*`\n  ],\n\n  // trailing wildcard\n  [\n    /(\\^|\\\\\\/)?\\\\\\*$/,\n    (match, p1) => {\n      const prefix = p1\n        // '\\^':\n        // '/*' does not match ''\n        // '/*' does not match everything\n\n        // '\\\\\\/':\n        // 'abc/*' does not match 'abc/'\n        ? `${p1}[^/]+`\n\n        // 'a*' matches 'a'\n        // 'a*' matches 'aa'\n        : '[^/]*'\n\n      return `${prefix}(?=$|\\\\/$)`\n    }\n  ],\n\n  [\n    // unescape\n    /\\\\\\\\\\\\/g,\n    () => '\\\\'\n  ]\n]\n\nconst POSITIVE_REPLACERS = [\n  ...DEFAULT_REPLACER_PREFIX,\n\n  // 'f'\n  // matches\n  // - /f(end)\n  // - /f/\n  // - (start)f(end)\n  // - (start)f/\n  // doesn't match\n  // - oof\n  // - foo\n  // pseudo:\n  // -> (^|/)f(/|$)\n\n  // ending\n  [\n    // 'js' will not match 'js.'\n    // 'ab' will not match 'abc'\n    /(?:[^*/])$/,\n\n    // 'js*' will not match 'a.js'\n    // 'js/' will not match 'a.js'\n    // 'js' will match 'a.js' and 'a.js/'\n    match => `${match}(?=$|\\\\/)`\n  ],\n\n  ...DEFAULT_REPLACER_SUFFIX\n]\n\nconst NEGATIVE_REPLACERS = [\n  ...DEFAULT_REPLACER_PREFIX,\n\n  // #24, #38\n  // The MISSING rule of [gitignore docs](https://git-scm.com/docs/gitignore)\n  // A negative pattern without a trailing wildcard should not\n  // re-include the things inside that directory.\n\n  // eg:\n  // ['node_modules/*', '!node_modules']\n  // should ignore `node_modules/a.js`\n  [\n    /(?:[^*])$/,\n    match => `${match}(?=$|\\\\/$)`\n  ],\n\n  ...DEFAULT_REPLACER_SUFFIX\n]\n\n// A simple cache, because an ignore rule only has only one certain meaning\nconst cache = Object.create(null)\n\n// @param {pattern}\nconst make_regex = (pattern, negative, ignorecase) => {\n  const r = cache[pattern]\n  if (r) {\n    return r\n  }\n\n  const replacers = negative\n    ? NEGATIVE_REPLACERS\n    : POSITIVE_REPLACERS\n\n  const source = replacers.reduce(\n    (prev, current) => prev.replace(current[0], current[1].bind(pattern)),\n    pattern\n  )\n\n  return cache[pattern] = ignorecase\n    ? new RegExp(source, 'i')\n    : new RegExp(source)\n}\n\n// > A blank line matches no files, so it can serve as a separator for readability.\nconst checkPattern = pattern => pattern\n  && typeof pattern === 'string'\n  && !REGEX_BLANK_LINE.test(pattern)\n\n  // > A line starting with # serves as a comment.\n  && pattern.indexOf('#') !== 0\n\nconst createRule = (pattern, ignorecase) => {\n  const origin = pattern\n  let negative = false\n\n  // > An optional prefix \"!\" which negates the pattern;\n  if (pattern.indexOf('!') === 0) {\n    negative = true\n    pattern = pattern.substr(1)\n  }\n\n  pattern = pattern\n  // > Put a backslash (\"\\\") in front of the first \"!\" for patterns that\n  // >   begin with a literal \"!\", for example, `\"\\!important!.txt\"`.\n  .replace(REGEX_LEADING_EXCAPED_EXCLAMATION, '!')\n  // > Put a backslash (\"\\\") in front of the first hash for patterns that\n  // >   begin with a hash.\n  .replace(REGEX_LEADING_EXCAPED_HASH, '#')\n\n  const regex = make_regex(pattern, negative, ignorecase)\n\n  return {\n    origin,\n    pattern,\n    negative,\n    regex\n  }\n}\n\nclass IgnoreBase {\n  constructor ({\n    ignorecase = true\n  } = {}) {\n    this._rules = []\n    this._ignorecase = ignorecase\n    define(this, KEY_IGNORE, true)\n    this._initCache()\n  }\n\n  _initCache () {\n    this._cache = Object.create(null)\n  }\n\n  // @param {Array.<string>|string|Ignore} pattern\n  add (pattern) {\n    this._added = false\n\n    if (typeof pattern === 'string') {\n      pattern = pattern.split(/\\r?\\n/g)\n    }\n\n    make_array(pattern).forEach(this._addPattern, this)\n\n    // Some rules have just added to the ignore,\n    // making the behavior changed.\n    if (this._added) {\n      this._initCache()\n    }\n\n    return this\n  }\n\n  // legacy\n  addPattern (pattern) {\n    return this.add(pattern)\n  }\n\n  _addPattern (pattern) {\n    // #32\n    if (pattern && pattern[KEY_IGNORE]) {\n      this._rules = this._rules.concat(pattern._rules)\n      this._added = true\n      return\n    }\n\n    if (checkPattern(pattern)) {\n      const rule = createRule(pattern, this._ignorecase)\n      this._added = true\n      this._rules.push(rule)\n    }\n  }\n\n  filter (paths) {\n    return make_array(paths).filter(path => this._filter(path))\n  }\n\n  createFilter () {\n    return path => this._filter(path)\n  }\n\n  ignores (path) {\n    return !this._filter(path)\n  }\n\n  // @returns `Boolean` true if the `path` is NOT ignored\n  _filter (path, slices) {\n    if (!path) {\n      return false\n    }\n\n    if (path in this._cache) {\n      return this._cache[path]\n    }\n\n    if (!slices) {\n      // path/to/a.js\n      // ['path', 'to', 'a.js']\n      slices = path.split(SLASH)\n    }\n\n    slices.pop()\n\n    return this._cache[path] = slices.length\n      // > It is not possible to re-include a file if a parent directory of\n      // >   that file is excluded.\n      // If the path contains a parent directory, check the parent first\n      ? this._filter(slices.join(SLASH) + SLASH, slices)\n        && this._test(path)\n\n      // Or only test the path\n      : this._test(path)\n  }\n\n  // @returns {Boolean} true if a file is NOT ignored\n  _test (path) {\n    // Explicitly define variable type by setting matched to `0`\n    let matched = 0\n\n    this._rules.forEach(rule => {\n      // if matched = true, then we only test negative rules\n      // if matched = false, then we test non-negative rules\n      if (!(matched ^ rule.negative)) {\n        matched = rule.negative ^ rule.regex.test(path)\n      }\n    })\n\n    return !matched\n  }\n}\n\n// Windows\n// --------------------------------------------------------------\n/* istanbul ignore if  */\nif (\n  // Detect `process` so that it can run in browsers.\n  typeof process !== 'undefined'\n  && (\n    process.env && process.env.IGNORE_TEST_WIN32\n    || process.platform === 'win32'\n  )\n) {\n  const filter = IgnoreBase.prototype._filter\n\n  /* eslint no-control-regex: \"off\" */\n  const make_posix = str => /^\\\\\\\\\\?\\\\/.test(str)\n  || /[^\\x00-\\x80]+/.test(str)\n    ? str\n    : str.replace(/\\\\/g, '/')\n\n  IgnoreBase.prototype._filter = function filterWin32 (path, slices) {\n    path = make_posix(path)\n    return filter.call(this, path, slices)\n  }\n}\n\nmodule.exports = options => new IgnoreBase(options)\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}