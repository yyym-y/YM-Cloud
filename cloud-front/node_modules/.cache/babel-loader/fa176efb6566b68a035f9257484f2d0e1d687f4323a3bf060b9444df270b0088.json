{"ast":null,"code":"/**\n * @fileoverview Rule to disallow Math.pow in favor of the ** operator\n * @author Milos Djermanovic\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils\");\nconst {\n  CALL,\n  ReferenceTracker\n} = require(\"eslint-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst PRECEDENCE_OF_EXPONENTIATION_EXPR = astUtils.getPrecedence({\n  type: \"BinaryExpression\",\n  operator: \"**\"\n});\n\n/**\n * Determines whether the given node needs parens if used as the base in an exponentiation binary expression.\n * @param {ASTNode} base The node to check.\n * @returns {boolean} `true` if the node needs to be parenthesised.\n */\nfunction doesBaseNeedParens(base) {\n  return (\n    // '**' is right-associative, parens are needed when Math.pow(a ** b, c) is converted to (a ** b) ** c\n    astUtils.getPrecedence(base) <= PRECEDENCE_OF_EXPONENTIATION_EXPR ||\n    // An unary operator cannot be used immediately before an exponentiation expression\n    base.type === \"AwaitExpression\" || base.type === \"UnaryExpression\"\n  );\n}\n\n/**\n * Determines whether the given node needs parens if used as the exponent in an exponentiation binary expression.\n * @param {ASTNode} exponent The node to check.\n * @returns {boolean} `true` if the node needs to be parenthesised.\n */\nfunction doesExponentNeedParens(exponent) {\n  // '**' is right-associative, there is no need for parens when Math.pow(a, b ** c) is converted to a ** b ** c\n  return astUtils.getPrecedence(exponent) < PRECEDENCE_OF_EXPONENTIATION_EXPR;\n}\n\n/**\n * Determines whether an exponentiation binary expression at the place of the given node would need parens.\n * @param {ASTNode} node A node that would be replaced by an exponentiation binary expression.\n * @param {SourceCode} sourceCode A SourceCode object.\n * @returns {boolean} `true` if the expression needs to be parenthesised.\n */\nfunction doesExponentiationExpressionNeedParens(node, sourceCode) {\n  const parent = node.parent.type === \"ChainExpression\" ? node.parent.parent : node.parent;\n  const needsParens = parent.type === \"ClassDeclaration\" || parent.type.endsWith(\"Expression\") && astUtils.getPrecedence(parent) >= PRECEDENCE_OF_EXPONENTIATION_EXPR && !(parent.type === \"BinaryExpression\" && parent.operator === \"**\" && parent.right === node) && !((parent.type === \"CallExpression\" || parent.type === \"NewExpression\") && parent.arguments.includes(node)) && !(parent.type === \"MemberExpression\" && parent.computed && parent.property === node) && !(parent.type === \"ArrayExpression\");\n  return needsParens && !astUtils.isParenthesised(sourceCode, node);\n}\n\n/**\n * Optionally parenthesizes given text.\n * @param {string} text The text to parenthesize.\n * @param {boolean} shouldParenthesize If `true`, the text will be parenthesised.\n * @returns {string} parenthesised or unchanged text.\n */\nfunction parenthesizeIfShould(text, shouldParenthesize) {\n  return shouldParenthesize ? `(${text})` : text;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow the use of `Math.pow` in favor of the `**` operator\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/prefer-exponentiation-operator\"\n    },\n    schema: [],\n    fixable: \"code\",\n    messages: {\n      useExponentiation: \"Use the '**' operator instead of 'Math.pow'.\"\n    }\n  },\n  create(context) {\n    const sourceCode = context.getSourceCode();\n\n    /**\n     * Reports the given node.\n     * @param {ASTNode} node 'Math.pow()' node to report.\n     * @returns {void}\n     */\n    function report(node) {\n      context.report({\n        node,\n        messageId: \"useExponentiation\",\n        fix(fixer) {\n          if (node.arguments.length !== 2 || node.arguments.some(arg => arg.type === \"SpreadElement\") || sourceCode.getCommentsInside(node).length > 0) {\n            return null;\n          }\n          const base = node.arguments[0],\n            exponent = node.arguments[1],\n            baseText = sourceCode.getText(base),\n            exponentText = sourceCode.getText(exponent),\n            shouldParenthesizeBase = doesBaseNeedParens(base),\n            shouldParenthesizeExponent = doesExponentNeedParens(exponent),\n            shouldParenthesizeAll = doesExponentiationExpressionNeedParens(node, sourceCode);\n          let prefix = \"\",\n            suffix = \"\";\n          if (!shouldParenthesizeAll) {\n            if (!shouldParenthesizeBase) {\n              const firstReplacementToken = sourceCode.getFirstToken(base),\n                tokenBefore = sourceCode.getTokenBefore(node);\n              if (tokenBefore && tokenBefore.range[1] === node.range[0] && !astUtils.canTokensBeAdjacent(tokenBefore, firstReplacementToken)) {\n                prefix = \" \"; // a+Math.pow(++b, c) -> a+ ++b**c\n              }\n            }\n\n            if (!shouldParenthesizeExponent) {\n              const lastReplacementToken = sourceCode.getLastToken(exponent),\n                tokenAfter = sourceCode.getTokenAfter(node);\n              if (tokenAfter && node.range[1] === tokenAfter.range[0] && !astUtils.canTokensBeAdjacent(lastReplacementToken, tokenAfter)) {\n                suffix = \" \"; // Math.pow(a, b)in c -> a**b in c\n              }\n            }\n          }\n\n          const baseReplacement = parenthesizeIfShould(baseText, shouldParenthesizeBase),\n            exponentReplacement = parenthesizeIfShould(exponentText, shouldParenthesizeExponent),\n            replacement = parenthesizeIfShould(`${baseReplacement}**${exponentReplacement}`, shouldParenthesizeAll);\n          return fixer.replaceText(node, `${prefix}${replacement}${suffix}`);\n        }\n      });\n    }\n    return {\n      Program() {\n        const scope = context.getScope();\n        const tracker = new ReferenceTracker(scope);\n        const trackMap = {\n          Math: {\n            pow: {\n              [CALL]: true\n            }\n          }\n        };\n        for (const {\n          node\n        } of tracker.iterateGlobalReferences(trackMap)) {\n          report(node);\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","CALL","ReferenceTracker","PRECEDENCE_OF_EXPONENTIATION_EXPR","getPrecedence","type","operator","doesBaseNeedParens","base","doesExponentNeedParens","exponent","doesExponentiationExpressionNeedParens","node","sourceCode","parent","needsParens","endsWith","right","arguments","includes","computed","property","isParenthesised","parenthesizeIfShould","text","shouldParenthesize","module","exports","meta","docs","description","category","recommended","url","schema","fixable","messages","useExponentiation","create","context","getSourceCode","report","messageId","fix","fixer","length","some","arg","getCommentsInside","baseText","getText","exponentText","shouldParenthesizeBase","shouldParenthesizeExponent","shouldParenthesizeAll","prefix","suffix","firstReplacementToken","getFirstToken","tokenBefore","getTokenBefore","range","canTokensBeAdjacent","lastReplacementToken","getLastToken","tokenAfter","getTokenAfter","baseReplacement","exponentReplacement","replacement","replaceText","Program","scope","getScope","tracker","trackMap","Math","pow","iterateGlobalReferences"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/prefer-exponentiation-operator.js"],"sourcesContent":["/**\n * @fileoverview Rule to disallow Math.pow in favor of the ** operator\n * @author Milos Djermanovic\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\nconst { CALL, ReferenceTracker } = require(\"eslint-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst PRECEDENCE_OF_EXPONENTIATION_EXPR = astUtils.getPrecedence({ type: \"BinaryExpression\", operator: \"**\" });\n\n/**\n * Determines whether the given node needs parens if used as the base in an exponentiation binary expression.\n * @param {ASTNode} base The node to check.\n * @returns {boolean} `true` if the node needs to be parenthesised.\n */\nfunction doesBaseNeedParens(base) {\n    return (\n\n        // '**' is right-associative, parens are needed when Math.pow(a ** b, c) is converted to (a ** b) ** c\n        astUtils.getPrecedence(base) <= PRECEDENCE_OF_EXPONENTIATION_EXPR ||\n\n        // An unary operator cannot be used immediately before an exponentiation expression\n        base.type === \"AwaitExpression\" ||\n        base.type === \"UnaryExpression\"\n    );\n}\n\n/**\n * Determines whether the given node needs parens if used as the exponent in an exponentiation binary expression.\n * @param {ASTNode} exponent The node to check.\n * @returns {boolean} `true` if the node needs to be parenthesised.\n */\nfunction doesExponentNeedParens(exponent) {\n\n    // '**' is right-associative, there is no need for parens when Math.pow(a, b ** c) is converted to a ** b ** c\n    return astUtils.getPrecedence(exponent) < PRECEDENCE_OF_EXPONENTIATION_EXPR;\n}\n\n/**\n * Determines whether an exponentiation binary expression at the place of the given node would need parens.\n * @param {ASTNode} node A node that would be replaced by an exponentiation binary expression.\n * @param {SourceCode} sourceCode A SourceCode object.\n * @returns {boolean} `true` if the expression needs to be parenthesised.\n */\nfunction doesExponentiationExpressionNeedParens(node, sourceCode) {\n    const parent = node.parent.type === \"ChainExpression\" ? node.parent.parent : node.parent;\n\n    const needsParens = (\n        parent.type === \"ClassDeclaration\" ||\n        (\n            parent.type.endsWith(\"Expression\") &&\n            astUtils.getPrecedence(parent) >= PRECEDENCE_OF_EXPONENTIATION_EXPR &&\n            !(parent.type === \"BinaryExpression\" && parent.operator === \"**\" && parent.right === node) &&\n            !((parent.type === \"CallExpression\" || parent.type === \"NewExpression\") && parent.arguments.includes(node)) &&\n            !(parent.type === \"MemberExpression\" && parent.computed && parent.property === node) &&\n            !(parent.type === \"ArrayExpression\")\n        )\n    );\n\n    return needsParens && !astUtils.isParenthesised(sourceCode, node);\n}\n\n/**\n * Optionally parenthesizes given text.\n * @param {string} text The text to parenthesize.\n * @param {boolean} shouldParenthesize If `true`, the text will be parenthesised.\n * @returns {string} parenthesised or unchanged text.\n */\nfunction parenthesizeIfShould(text, shouldParenthesize) {\n    return shouldParenthesize ? `(${text})` : text;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow the use of `Math.pow` in favor of the `**` operator\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/prefer-exponentiation-operator\"\n        },\n\n        schema: [],\n        fixable: \"code\",\n\n        messages: {\n            useExponentiation: \"Use the '**' operator instead of 'Math.pow'.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Reports the given node.\n         * @param {ASTNode} node 'Math.pow()' node to report.\n         * @returns {void}\n         */\n        function report(node) {\n            context.report({\n                node,\n                messageId: \"useExponentiation\",\n                fix(fixer) {\n                    if (\n                        node.arguments.length !== 2 ||\n                        node.arguments.some(arg => arg.type === \"SpreadElement\") ||\n                        sourceCode.getCommentsInside(node).length > 0\n                    ) {\n                        return null;\n                    }\n\n                    const base = node.arguments[0],\n                        exponent = node.arguments[1],\n                        baseText = sourceCode.getText(base),\n                        exponentText = sourceCode.getText(exponent),\n                        shouldParenthesizeBase = doesBaseNeedParens(base),\n                        shouldParenthesizeExponent = doesExponentNeedParens(exponent),\n                        shouldParenthesizeAll = doesExponentiationExpressionNeedParens(node, sourceCode);\n\n                    let prefix = \"\",\n                        suffix = \"\";\n\n                    if (!shouldParenthesizeAll) {\n                        if (!shouldParenthesizeBase) {\n                            const firstReplacementToken = sourceCode.getFirstToken(base),\n                                tokenBefore = sourceCode.getTokenBefore(node);\n\n                            if (\n                                tokenBefore &&\n                                tokenBefore.range[1] === node.range[0] &&\n                                !astUtils.canTokensBeAdjacent(tokenBefore, firstReplacementToken)\n                            ) {\n                                prefix = \" \"; // a+Math.pow(++b, c) -> a+ ++b**c\n                            }\n                        }\n                        if (!shouldParenthesizeExponent) {\n                            const lastReplacementToken = sourceCode.getLastToken(exponent),\n                                tokenAfter = sourceCode.getTokenAfter(node);\n\n                            if (\n                                tokenAfter &&\n                                node.range[1] === tokenAfter.range[0] &&\n                                !astUtils.canTokensBeAdjacent(lastReplacementToken, tokenAfter)\n                            ) {\n                                suffix = \" \"; // Math.pow(a, b)in c -> a**b in c\n                            }\n                        }\n                    }\n\n                    const baseReplacement = parenthesizeIfShould(baseText, shouldParenthesizeBase),\n                        exponentReplacement = parenthesizeIfShould(exponentText, shouldParenthesizeExponent),\n                        replacement = parenthesizeIfShould(`${baseReplacement}**${exponentReplacement}`, shouldParenthesizeAll);\n\n                    return fixer.replaceText(node, `${prefix}${replacement}${suffix}`);\n                }\n            });\n        }\n\n        return {\n            Program() {\n                const scope = context.getScope();\n                const tracker = new ReferenceTracker(scope);\n                const trackMap = {\n                    Math: {\n                        pow: { [CALL]: true }\n                    }\n                };\n\n                for (const { node } of tracker.iterateGlobalReferences(trackMap)) {\n                    report(node);\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}