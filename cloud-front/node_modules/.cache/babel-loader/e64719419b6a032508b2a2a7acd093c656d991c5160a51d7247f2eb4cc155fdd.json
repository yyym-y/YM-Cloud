{"ast":null,"code":"/**\n * @fileoverview Rule to require sorting of import declarations\n * @author Christian Schuller\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"enforce sorted import declarations within modules\",\n      category: \"ECMAScript 6\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/sort-imports\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        ignoreCase: {\n          type: \"boolean\",\n          default: false\n        },\n        memberSyntaxSortOrder: {\n          type: \"array\",\n          items: {\n            enum: [\"none\", \"all\", \"multiple\", \"single\"]\n          },\n          uniqueItems: true,\n          minItems: 4,\n          maxItems: 4\n        },\n        ignoreDeclarationSort: {\n          type: \"boolean\",\n          default: false\n        },\n        ignoreMemberSort: {\n          type: \"boolean\",\n          default: false\n        },\n        allowSeparatedGroups: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    fixable: \"code\",\n    messages: {\n      sortImportsAlphabetically: \"Imports should be sorted alphabetically.\",\n      sortMembersAlphabetically: \"Member '{{memberName}}' of the import declaration should be sorted alphabetically.\",\n      unexpectedSyntaxOrder: \"Expected '{{syntaxA}}' syntax before '{{syntaxB}}' syntax.\"\n    }\n  },\n  create(context) {\n    const configuration = context.options[0] || {},\n      ignoreCase = configuration.ignoreCase || false,\n      ignoreDeclarationSort = configuration.ignoreDeclarationSort || false,\n      ignoreMemberSort = configuration.ignoreMemberSort || false,\n      memberSyntaxSortOrder = configuration.memberSyntaxSortOrder || [\"none\", \"all\", \"multiple\", \"single\"],\n      allowSeparatedGroups = configuration.allowSeparatedGroups || false,\n      sourceCode = context.getSourceCode();\n    let previousDeclaration = null;\n\n    /**\n     * Gets the used member syntax style.\n     *\n     * import \"my-module.js\" --> none\n     * import * as myModule from \"my-module.js\" --> all\n     * import {myMember} from \"my-module.js\" --> single\n     * import {foo, bar} from  \"my-module.js\" --> multiple\n     * @param {ASTNode} node the ImportDeclaration node.\n     * @returns {string} used member parameter style, [\"all\", \"multiple\", \"single\"]\n     */\n    function usedMemberSyntax(node) {\n      if (node.specifiers.length === 0) {\n        return \"none\";\n      }\n      if (node.specifiers[0].type === \"ImportNamespaceSpecifier\") {\n        return \"all\";\n      }\n      if (node.specifiers.length === 1) {\n        return \"single\";\n      }\n      return \"multiple\";\n    }\n\n    /**\n     * Gets the group by member parameter index for given declaration.\n     * @param {ASTNode} node the ImportDeclaration node.\n     * @returns {number} the declaration group by member index.\n     */\n    function getMemberParameterGroupIndex(node) {\n      return memberSyntaxSortOrder.indexOf(usedMemberSyntax(node));\n    }\n\n    /**\n     * Gets the local name of the first imported module.\n     * @param {ASTNode} node the ImportDeclaration node.\n     * @returns {?string} the local name of the first imported module.\n     */\n    function getFirstLocalMemberName(node) {\n      if (node.specifiers[0]) {\n        return node.specifiers[0].local.name;\n      }\n      return null;\n    }\n\n    /**\n     * Calculates number of lines between two nodes. It is assumed that the given `left` node appears before\n     * the given `right` node in the source code. Lines are counted from the end of the `left` node till the\n     * start of the `right` node. If the given nodes are on the same line, it returns `0`, same as if they were\n     * on two consecutive lines.\n     * @param {ASTNode} left node that appears before the given `right` node.\n     * @param {ASTNode} right node that appears after the given `left` node.\n     * @returns {number} number of lines between nodes.\n     */\n    function getNumberOfLinesBetween(left, right) {\n      return Math.max(right.loc.start.line - left.loc.end.line - 1, 0);\n    }\n    return {\n      ImportDeclaration(node) {\n        if (!ignoreDeclarationSort) {\n          if (previousDeclaration && allowSeparatedGroups && getNumberOfLinesBetween(previousDeclaration, node) > 0) {\n            // reset declaration sort\n            previousDeclaration = null;\n          }\n          if (previousDeclaration) {\n            const currentMemberSyntaxGroupIndex = getMemberParameterGroupIndex(node),\n              previousMemberSyntaxGroupIndex = getMemberParameterGroupIndex(previousDeclaration);\n            let currentLocalMemberName = getFirstLocalMemberName(node),\n              previousLocalMemberName = getFirstLocalMemberName(previousDeclaration);\n            if (ignoreCase) {\n              previousLocalMemberName = previousLocalMemberName && previousLocalMemberName.toLowerCase();\n              currentLocalMemberName = currentLocalMemberName && currentLocalMemberName.toLowerCase();\n            }\n\n            /*\n             * When the current declaration uses a different member syntax,\n             * then check if the ordering is correct.\n             * Otherwise, make a default string compare (like rule sort-vars to be consistent) of the first used local member name.\n             */\n            if (currentMemberSyntaxGroupIndex !== previousMemberSyntaxGroupIndex) {\n              if (currentMemberSyntaxGroupIndex < previousMemberSyntaxGroupIndex) {\n                context.report({\n                  node,\n                  messageId: \"unexpectedSyntaxOrder\",\n                  data: {\n                    syntaxA: memberSyntaxSortOrder[currentMemberSyntaxGroupIndex],\n                    syntaxB: memberSyntaxSortOrder[previousMemberSyntaxGroupIndex]\n                  }\n                });\n              }\n            } else {\n              if (previousLocalMemberName && currentLocalMemberName && currentLocalMemberName < previousLocalMemberName) {\n                context.report({\n                  node,\n                  messageId: \"sortImportsAlphabetically\"\n                });\n              }\n            }\n          }\n          previousDeclaration = node;\n        }\n        if (!ignoreMemberSort) {\n          const importSpecifiers = node.specifiers.filter(specifier => specifier.type === \"ImportSpecifier\");\n          const getSortableName = ignoreCase ? specifier => specifier.local.name.toLowerCase() : specifier => specifier.local.name;\n          const firstUnsortedIndex = importSpecifiers.map(getSortableName).findIndex((name, index, array) => array[index - 1] > name);\n          if (firstUnsortedIndex !== -1) {\n            context.report({\n              node: importSpecifiers[firstUnsortedIndex],\n              messageId: \"sortMembersAlphabetically\",\n              data: {\n                memberName: importSpecifiers[firstUnsortedIndex].local.name\n              },\n              fix(fixer) {\n                if (importSpecifiers.some(specifier => sourceCode.getCommentsBefore(specifier).length || sourceCode.getCommentsAfter(specifier).length)) {\n                  // If there are comments in the ImportSpecifier list, don't rearrange the specifiers.\n                  return null;\n                }\n                return fixer.replaceTextRange([importSpecifiers[0].range[0], importSpecifiers[importSpecifiers.length - 1].range[1]], importSpecifiers\n\n                // Clone the importSpecifiers array to avoid mutating it\n                .slice()\n\n                // Sort the array into the desired order\n                .sort((specifierA, specifierB) => {\n                  const aName = getSortableName(specifierA);\n                  const bName = getSortableName(specifierB);\n                  return aName > bName ? 1 : -1;\n                })\n\n                // Build a string out of the sorted list of import specifiers and the text between the originals\n                .reduce((sourceText, specifier, index) => {\n                  const textAfterSpecifier = index === importSpecifiers.length - 1 ? \"\" : sourceCode.getText().slice(importSpecifiers[index].range[1], importSpecifiers[index + 1].range[0]);\n                  return sourceText + sourceCode.getText(specifier) + textAfterSpecifier;\n                }, \"\"));\n              }\n            });\n          }\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["module","exports","meta","type","docs","description","category","recommended","url","schema","properties","ignoreCase","default","memberSyntaxSortOrder","items","enum","uniqueItems","minItems","maxItems","ignoreDeclarationSort","ignoreMemberSort","allowSeparatedGroups","additionalProperties","fixable","messages","sortImportsAlphabetically","sortMembersAlphabetically","unexpectedSyntaxOrder","create","context","configuration","options","sourceCode","getSourceCode","previousDeclaration","usedMemberSyntax","node","specifiers","length","getMemberParameterGroupIndex","indexOf","getFirstLocalMemberName","local","name","getNumberOfLinesBetween","left","right","Math","max","loc","start","line","end","ImportDeclaration","currentMemberSyntaxGroupIndex","previousMemberSyntaxGroupIndex","currentLocalMemberName","previousLocalMemberName","toLowerCase","report","messageId","data","syntaxA","syntaxB","importSpecifiers","filter","specifier","getSortableName","firstUnsortedIndex","map","findIndex","index","array","memberName","fix","fixer","some","getCommentsBefore","getCommentsAfter","replaceTextRange","range","slice","sort","specifierA","specifierB","aName","bName","reduce","sourceText","textAfterSpecifier","getText"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/sort-imports.js"],"sourcesContent":["/**\n * @fileoverview Rule to require sorting of import declarations\n * @author Christian Schuller\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce sorted import declarations within modules\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/sort-imports\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    ignoreCase: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    memberSyntaxSortOrder: {\n                        type: \"array\",\n                        items: {\n                            enum: [\"none\", \"all\", \"multiple\", \"single\"]\n                        },\n                        uniqueItems: true,\n                        minItems: 4,\n                        maxItems: 4\n                    },\n                    ignoreDeclarationSort: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    ignoreMemberSort: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    allowSeparatedGroups: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: \"code\",\n\n        messages: {\n            sortImportsAlphabetically: \"Imports should be sorted alphabetically.\",\n            sortMembersAlphabetically: \"Member '{{memberName}}' of the import declaration should be sorted alphabetically.\",\n            unexpectedSyntaxOrder: \"Expected '{{syntaxA}}' syntax before '{{syntaxB}}' syntax.\"\n        }\n    },\n\n    create(context) {\n\n        const configuration = context.options[0] || {},\n            ignoreCase = configuration.ignoreCase || false,\n            ignoreDeclarationSort = configuration.ignoreDeclarationSort || false,\n            ignoreMemberSort = configuration.ignoreMemberSort || false,\n            memberSyntaxSortOrder = configuration.memberSyntaxSortOrder || [\"none\", \"all\", \"multiple\", \"single\"],\n            allowSeparatedGroups = configuration.allowSeparatedGroups || false,\n            sourceCode = context.getSourceCode();\n        let previousDeclaration = null;\n\n        /**\n         * Gets the used member syntax style.\n         *\n         * import \"my-module.js\" --> none\n         * import * as myModule from \"my-module.js\" --> all\n         * import {myMember} from \"my-module.js\" --> single\n         * import {foo, bar} from  \"my-module.js\" --> multiple\n         * @param {ASTNode} node the ImportDeclaration node.\n         * @returns {string} used member parameter style, [\"all\", \"multiple\", \"single\"]\n         */\n        function usedMemberSyntax(node) {\n            if (node.specifiers.length === 0) {\n                return \"none\";\n            }\n            if (node.specifiers[0].type === \"ImportNamespaceSpecifier\") {\n                return \"all\";\n            }\n            if (node.specifiers.length === 1) {\n                return \"single\";\n            }\n            return \"multiple\";\n\n        }\n\n        /**\n         * Gets the group by member parameter index for given declaration.\n         * @param {ASTNode} node the ImportDeclaration node.\n         * @returns {number} the declaration group by member index.\n         */\n        function getMemberParameterGroupIndex(node) {\n            return memberSyntaxSortOrder.indexOf(usedMemberSyntax(node));\n        }\n\n        /**\n         * Gets the local name of the first imported module.\n         * @param {ASTNode} node the ImportDeclaration node.\n         * @returns {?string} the local name of the first imported module.\n         */\n        function getFirstLocalMemberName(node) {\n            if (node.specifiers[0]) {\n                return node.specifiers[0].local.name;\n            }\n            return null;\n\n        }\n\n        /**\n         * Calculates number of lines between two nodes. It is assumed that the given `left` node appears before\n         * the given `right` node in the source code. Lines are counted from the end of the `left` node till the\n         * start of the `right` node. If the given nodes are on the same line, it returns `0`, same as if they were\n         * on two consecutive lines.\n         * @param {ASTNode} left node that appears before the given `right` node.\n         * @param {ASTNode} right node that appears after the given `left` node.\n         * @returns {number} number of lines between nodes.\n         */\n        function getNumberOfLinesBetween(left, right) {\n            return Math.max(right.loc.start.line - left.loc.end.line - 1, 0);\n        }\n\n        return {\n            ImportDeclaration(node) {\n                if (!ignoreDeclarationSort) {\n                    if (\n                        previousDeclaration &&\n                        allowSeparatedGroups &&\n                        getNumberOfLinesBetween(previousDeclaration, node) > 0\n                    ) {\n\n                        // reset declaration sort\n                        previousDeclaration = null;\n                    }\n\n                    if (previousDeclaration) {\n                        const currentMemberSyntaxGroupIndex = getMemberParameterGroupIndex(node),\n                            previousMemberSyntaxGroupIndex = getMemberParameterGroupIndex(previousDeclaration);\n                        let currentLocalMemberName = getFirstLocalMemberName(node),\n                            previousLocalMemberName = getFirstLocalMemberName(previousDeclaration);\n\n                        if (ignoreCase) {\n                            previousLocalMemberName = previousLocalMemberName && previousLocalMemberName.toLowerCase();\n                            currentLocalMemberName = currentLocalMemberName && currentLocalMemberName.toLowerCase();\n                        }\n\n                        /*\n                         * When the current declaration uses a different member syntax,\n                         * then check if the ordering is correct.\n                         * Otherwise, make a default string compare (like rule sort-vars to be consistent) of the first used local member name.\n                         */\n                        if (currentMemberSyntaxGroupIndex !== previousMemberSyntaxGroupIndex) {\n                            if (currentMemberSyntaxGroupIndex < previousMemberSyntaxGroupIndex) {\n                                context.report({\n                                    node,\n                                    messageId: \"unexpectedSyntaxOrder\",\n                                    data: {\n                                        syntaxA: memberSyntaxSortOrder[currentMemberSyntaxGroupIndex],\n                                        syntaxB: memberSyntaxSortOrder[previousMemberSyntaxGroupIndex]\n                                    }\n                                });\n                            }\n                        } else {\n                            if (previousLocalMemberName &&\n                                currentLocalMemberName &&\n                                currentLocalMemberName < previousLocalMemberName\n                            ) {\n                                context.report({\n                                    node,\n                                    messageId: \"sortImportsAlphabetically\"\n                                });\n                            }\n                        }\n                    }\n\n                    previousDeclaration = node;\n                }\n\n                if (!ignoreMemberSort) {\n                    const importSpecifiers = node.specifiers.filter(specifier => specifier.type === \"ImportSpecifier\");\n                    const getSortableName = ignoreCase ? specifier => specifier.local.name.toLowerCase() : specifier => specifier.local.name;\n                    const firstUnsortedIndex = importSpecifiers.map(getSortableName).findIndex((name, index, array) => array[index - 1] > name);\n\n                    if (firstUnsortedIndex !== -1) {\n                        context.report({\n                            node: importSpecifiers[firstUnsortedIndex],\n                            messageId: \"sortMembersAlphabetically\",\n                            data: { memberName: importSpecifiers[firstUnsortedIndex].local.name },\n                            fix(fixer) {\n                                if (importSpecifiers.some(specifier =>\n                                    sourceCode.getCommentsBefore(specifier).length || sourceCode.getCommentsAfter(specifier).length)) {\n\n                                    // If there are comments in the ImportSpecifier list, don't rearrange the specifiers.\n                                    return null;\n                                }\n\n                                return fixer.replaceTextRange(\n                                    [importSpecifiers[0].range[0], importSpecifiers[importSpecifiers.length - 1].range[1]],\n                                    importSpecifiers\n\n                                        // Clone the importSpecifiers array to avoid mutating it\n                                        .slice()\n\n                                        // Sort the array into the desired order\n                                        .sort((specifierA, specifierB) => {\n                                            const aName = getSortableName(specifierA);\n                                            const bName = getSortableName(specifierB);\n\n                                            return aName > bName ? 1 : -1;\n                                        })\n\n                                        // Build a string out of the sorted list of import specifiers and the text between the originals\n                                        .reduce((sourceText, specifier, index) => {\n                                            const textAfterSpecifier = index === importSpecifiers.length - 1\n                                                ? \"\"\n                                                : sourceCode.getText().slice(importSpecifiers[index].range[1], importSpecifiers[index + 1].range[0]);\n\n                                            return sourceText + sourceCode.getText(specifier) + textAfterSpecifier;\n                                        }, \"\")\n                                );\n                            }\n                        });\n                    }\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}