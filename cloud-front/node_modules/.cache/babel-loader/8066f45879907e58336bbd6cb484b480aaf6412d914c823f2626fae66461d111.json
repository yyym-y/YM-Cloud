{"ast":null,"code":"/*\n * STOP!!! DO NOT MODIFY.\n *\n * This file is part of the ongoing work to move the eslintrc-style config\n * system into the @eslint/eslintrc package. This file needs to remain\n * unchanged in order for this work to proceed.\n *\n * If you think you need to change this file, please contact @nzakas first.\n *\n * Thanks in advance for your cooperation.\n */\n\n/**\n * @fileoverview Validates configs.\n * @author Brandon Mills\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst util = require(\"util\"),\n  configSchema = require(\"../../conf/config-schema\"),\n  BuiltInEnvironments = require(\"@eslint/eslintrc/conf/environments\"),\n  BuiltInRules = require(\"../rules\"),\n  ConfigOps = require(\"@eslint/eslintrc/lib/shared/config-ops\"),\n  {\n    emitDeprecationWarning\n  } = require(\"./deprecation-warnings\");\nconst ajv = require(\"./ajv\")();\nconst ruleValidators = new WeakMap();\nconst noop = Function.prototype;\n\n//------------------------------------------------------------------------------\n// Private\n//------------------------------------------------------------------------------\nlet validateSchema;\nconst severityMap = {\n  error: 2,\n  warn: 1,\n  off: 0\n};\n\n/**\n * Gets a complete options schema for a rule.\n * @param {{create: Function, schema: (Array|null)}} rule A new-style rule object\n * @returns {Object} JSON Schema for the rule's options.\n */\nfunction getRuleOptionsSchema(rule) {\n  if (!rule) {\n    return null;\n  }\n  const schema = rule.schema || rule.meta && rule.meta.schema;\n\n  // Given a tuple of schemas, insert warning level at the beginning\n  if (Array.isArray(schema)) {\n    if (schema.length) {\n      return {\n        type: \"array\",\n        items: schema,\n        minItems: 0,\n        maxItems: schema.length\n      };\n    }\n    return {\n      type: \"array\",\n      minItems: 0,\n      maxItems: 0\n    };\n  }\n\n  // Given a full schema, leave it alone\n  return schema || null;\n}\n\n/**\n * Validates a rule's severity and returns the severity value. Throws an error if the severity is invalid.\n * @param {options} options The given options for the rule.\n * @returns {number|string} The rule's severity value\n */\nfunction validateRuleSeverity(options) {\n  const severity = Array.isArray(options) ? options[0] : options;\n  const normSeverity = typeof severity === \"string\" ? severityMap[severity.toLowerCase()] : severity;\n  if (normSeverity === 0 || normSeverity === 1 || normSeverity === 2) {\n    return normSeverity;\n  }\n  throw new Error(`\\tSeverity should be one of the following: 0 = off, 1 = warn, 2 = error (you passed '${util.inspect(severity).replace(/'/gu, \"\\\"\").replace(/\\n/gu, \"\")}').\\n`);\n}\n\n/**\n * Validates the non-severity options passed to a rule, based on its schema.\n * @param {{create: Function}} rule The rule to validate\n * @param {Array} localOptions The options for the rule, excluding severity\n * @returns {void}\n */\nfunction validateRuleSchema(rule, localOptions) {\n  if (!ruleValidators.has(rule)) {\n    const schema = getRuleOptionsSchema(rule);\n    if (schema) {\n      ruleValidators.set(rule, ajv.compile(schema));\n    }\n  }\n  const validateRule = ruleValidators.get(rule);\n  if (validateRule) {\n    validateRule(localOptions);\n    if (validateRule.errors) {\n      throw new Error(validateRule.errors.map(error => `\\tValue ${JSON.stringify(error.data)} ${error.message}.\\n`).join(\"\"));\n    }\n  }\n}\n\n/**\n * Validates a rule's options against its schema.\n * @param {{create: Function}|null} rule The rule that the config is being validated for\n * @param {string} ruleId The rule's unique name.\n * @param {Array|number} options The given options for the rule.\n * @param {string|null} source The name of the configuration source to report in any errors. If null or undefined,\n * no source is prepended to the message.\n * @returns {void}\n */\nfunction validateRuleOptions(rule, ruleId, options, source = null) {\n  try {\n    const severity = validateRuleSeverity(options);\n    if (severity !== 0) {\n      validateRuleSchema(rule, Array.isArray(options) ? options.slice(1) : []);\n    }\n  } catch (err) {\n    const enhancedMessage = `Configuration for rule \"${ruleId}\" is invalid:\\n${err.message}`;\n    if (typeof source === \"string\") {\n      throw new Error(`${source}:\\n\\t${enhancedMessage}`);\n    } else {\n      throw new Error(enhancedMessage);\n    }\n  }\n}\n\n/**\n * Validates an environment object\n * @param {Object} environment The environment config object to validate.\n * @param {string} source The name of the configuration source to report in any errors.\n * @param {function(envId:string): Object} [getAdditionalEnv] A map from strings to loaded environments.\n * @returns {void}\n */\nfunction validateEnvironment(environment, source, getAdditionalEnv = noop) {\n  // not having an environment is ok\n  if (!environment) {\n    return;\n  }\n  Object.keys(environment).forEach(id => {\n    const env = getAdditionalEnv(id) || BuiltInEnvironments.get(id) || null;\n    if (!env) {\n      const message = `${source}:\\n\\tEnvironment key \"${id}\" is unknown\\n`;\n      throw new Error(message);\n    }\n  });\n}\n\n/**\n * Validates a rules config object\n * @param {Object} rulesConfig The rules config object to validate.\n * @param {string} source The name of the configuration source to report in any errors.\n * @param {function(ruleId:string): Object} getAdditionalRule A map from strings to loaded rules\n * @returns {void}\n */\nfunction validateRules(rulesConfig, source, getAdditionalRule = noop) {\n  if (!rulesConfig) {\n    return;\n  }\n  Object.keys(rulesConfig).forEach(id => {\n    const rule = getAdditionalRule(id) || BuiltInRules.get(id) || null;\n    validateRuleOptions(rule, id, rulesConfig[id], source);\n  });\n}\n\n/**\n * Validates a `globals` section of a config file\n * @param {Object} globalsConfig The `globals` section\n * @param {string|null} source The name of the configuration source to report in the event of an error.\n * @returns {void}\n */\nfunction validateGlobals(globalsConfig, source = null) {\n  if (!globalsConfig) {\n    return;\n  }\n  Object.entries(globalsConfig).forEach(([configuredGlobal, configuredValue]) => {\n    try {\n      ConfigOps.normalizeConfigGlobal(configuredValue);\n    } catch (err) {\n      throw new Error(`ESLint configuration of global '${configuredGlobal}' in ${source} is invalid:\\n${err.message}`);\n    }\n  });\n}\n\n/**\n * Validate `processor` configuration.\n * @param {string|undefined} processorName The processor name.\n * @param {string} source The name of config file.\n * @param {function(id:string): Processor} getProcessor The getter of defined processors.\n * @returns {void}\n */\nfunction validateProcessor(processorName, source, getProcessor) {\n  if (processorName && !getProcessor(processorName)) {\n    throw new Error(`ESLint configuration of processor in '${source}' is invalid: '${processorName}' was not found.`);\n  }\n}\n\n/**\n * Formats an array of schema validation errors.\n * @param {Array} errors An array of error messages to format.\n * @returns {string} Formatted error message\n */\nfunction formatErrors(errors) {\n  return errors.map(error => {\n    if (error.keyword === \"additionalProperties\") {\n      const formattedPropertyPath = error.dataPath.length ? `${error.dataPath.slice(1)}.${error.params.additionalProperty}` : error.params.additionalProperty;\n      return `Unexpected top-level property \"${formattedPropertyPath}\"`;\n    }\n    if (error.keyword === \"type\") {\n      const formattedField = error.dataPath.slice(1);\n      const formattedExpectedType = Array.isArray(error.schema) ? error.schema.join(\"/\") : error.schema;\n      const formattedValue = JSON.stringify(error.data);\n      return `Property \"${formattedField}\" is the wrong type (expected ${formattedExpectedType} but got \\`${formattedValue}\\`)`;\n    }\n    const field = error.dataPath[0] === \".\" ? error.dataPath.slice(1) : error.dataPath;\n    return `\"${field}\" ${error.message}. Value: ${JSON.stringify(error.data)}`;\n  }).map(message => `\\t- ${message}.\\n`).join(\"\");\n}\n\n/**\n * Validates the top level properties of the config object.\n * @param {Object} config The config object to validate.\n * @param {string} source The name of the configuration source to report in any errors.\n * @returns {void}\n */\nfunction validateConfigSchema(config, source = null) {\n  validateSchema = validateSchema || ajv.compile(configSchema);\n  if (!validateSchema(config)) {\n    throw new Error(`ESLint configuration in ${source} is invalid:\\n${formatErrors(validateSchema.errors)}`);\n  }\n  if (Object.hasOwnProperty.call(config, \"ecmaFeatures\")) {\n    emitDeprecationWarning(source, \"ESLINT_LEGACY_ECMAFEATURES\");\n  }\n}\n\n/**\n * Validates an entire config object.\n * @param {Object} config The config object to validate.\n * @param {string} source The name of the configuration source to report in any errors.\n * @param {function(ruleId:string): Object} [getAdditionalRule] A map from strings to loaded rules.\n * @param {function(envId:string): Object} [getAdditionalEnv] A map from strings to loaded envs.\n * @returns {void}\n */\nfunction validate(config, source, getAdditionalRule, getAdditionalEnv) {\n  validateConfigSchema(config, source);\n  validateRules(config.rules, source, getAdditionalRule);\n  validateEnvironment(config.env, source, getAdditionalEnv);\n  validateGlobals(config.globals, source);\n  for (const override of config.overrides || []) {\n    validateRules(override.rules, source, getAdditionalRule);\n    validateEnvironment(override.env, source, getAdditionalEnv);\n    validateGlobals(config.globals, source);\n  }\n}\nconst validated = new WeakSet();\n\n/**\n * Validate config array object.\n * @param {ConfigArray} configArray The config array to validate.\n * @returns {void}\n */\nfunction validateConfigArray(configArray) {\n  const getPluginEnv = Map.prototype.get.bind(configArray.pluginEnvironments);\n  const getPluginProcessor = Map.prototype.get.bind(configArray.pluginProcessors);\n  const getPluginRule = Map.prototype.get.bind(configArray.pluginRules);\n\n  // Validate.\n  for (const element of configArray) {\n    if (validated.has(element)) {\n      continue;\n    }\n    validated.add(element);\n    validateEnvironment(element.env, element.name, getPluginEnv);\n    validateGlobals(element.globals, element.name);\n    validateProcessor(element.processor, element.name, getPluginProcessor);\n    validateRules(element.rules, element.name, getPluginRule);\n  }\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  getRuleOptionsSchema,\n  validate,\n  validateConfigArray,\n  validateConfigSchema,\n  validateRuleOptions\n};","map":{"version":3,"names":["util","require","configSchema","BuiltInEnvironments","BuiltInRules","ConfigOps","emitDeprecationWarning","ajv","ruleValidators","WeakMap","noop","Function","prototype","validateSchema","severityMap","error","warn","off","getRuleOptionsSchema","rule","schema","meta","Array","isArray","length","type","items","minItems","maxItems","validateRuleSeverity","options","severity","normSeverity","toLowerCase","Error","inspect","replace","validateRuleSchema","localOptions","has","set","compile","validateRule","get","errors","map","JSON","stringify","data","message","join","validateRuleOptions","ruleId","source","slice","err","enhancedMessage","validateEnvironment","environment","getAdditionalEnv","Object","keys","forEach","id","env","validateRules","rulesConfig","getAdditionalRule","validateGlobals","globalsConfig","entries","configuredGlobal","configuredValue","normalizeConfigGlobal","validateProcessor","processorName","getProcessor","formatErrors","keyword","formattedPropertyPath","dataPath","params","additionalProperty","formattedField","formattedExpectedType","formattedValue","field","validateConfigSchema","config","hasOwnProperty","call","validate","rules","globals","override","overrides","validated","WeakSet","validateConfigArray","configArray","getPluginEnv","Map","bind","pluginEnvironments","getPluginProcessor","pluginProcessors","getPluginRule","pluginRules","element","add","name","processor","module","exports"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/shared/config-validator.js"],"sourcesContent":["/*\n * STOP!!! DO NOT MODIFY.\n *\n * This file is part of the ongoing work to move the eslintrc-style config\n * system into the @eslint/eslintrc package. This file needs to remain\n * unchanged in order for this work to proceed.\n *\n * If you think you need to change this file, please contact @nzakas first.\n *\n * Thanks in advance for your cooperation.\n */\n\n/**\n * @fileoverview Validates configs.\n * @author Brandon Mills\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst\n    util = require(\"util\"),\n    configSchema = require(\"../../conf/config-schema\"),\n    BuiltInEnvironments = require(\"@eslint/eslintrc/conf/environments\"),\n    BuiltInRules = require(\"../rules\"),\n    ConfigOps = require(\"@eslint/eslintrc/lib/shared/config-ops\"),\n    { emitDeprecationWarning } = require(\"./deprecation-warnings\");\n\nconst ajv = require(\"./ajv\")();\nconst ruleValidators = new WeakMap();\nconst noop = Function.prototype;\n\n//------------------------------------------------------------------------------\n// Private\n//------------------------------------------------------------------------------\nlet validateSchema;\nconst severityMap = {\n    error: 2,\n    warn: 1,\n    off: 0\n};\n\n/**\n * Gets a complete options schema for a rule.\n * @param {{create: Function, schema: (Array|null)}} rule A new-style rule object\n * @returns {Object} JSON Schema for the rule's options.\n */\nfunction getRuleOptionsSchema(rule) {\n    if (!rule) {\n        return null;\n    }\n\n    const schema = rule.schema || rule.meta && rule.meta.schema;\n\n    // Given a tuple of schemas, insert warning level at the beginning\n    if (Array.isArray(schema)) {\n        if (schema.length) {\n            return {\n                type: \"array\",\n                items: schema,\n                minItems: 0,\n                maxItems: schema.length\n            };\n        }\n        return {\n            type: \"array\",\n            minItems: 0,\n            maxItems: 0\n        };\n\n    }\n\n    // Given a full schema, leave it alone\n    return schema || null;\n}\n\n/**\n * Validates a rule's severity and returns the severity value. Throws an error if the severity is invalid.\n * @param {options} options The given options for the rule.\n * @returns {number|string} The rule's severity value\n */\nfunction validateRuleSeverity(options) {\n    const severity = Array.isArray(options) ? options[0] : options;\n    const normSeverity = typeof severity === \"string\" ? severityMap[severity.toLowerCase()] : severity;\n\n    if (normSeverity === 0 || normSeverity === 1 || normSeverity === 2) {\n        return normSeverity;\n    }\n\n    throw new Error(`\\tSeverity should be one of the following: 0 = off, 1 = warn, 2 = error (you passed '${util.inspect(severity).replace(/'/gu, \"\\\"\").replace(/\\n/gu, \"\")}').\\n`);\n\n}\n\n/**\n * Validates the non-severity options passed to a rule, based on its schema.\n * @param {{create: Function}} rule The rule to validate\n * @param {Array} localOptions The options for the rule, excluding severity\n * @returns {void}\n */\nfunction validateRuleSchema(rule, localOptions) {\n    if (!ruleValidators.has(rule)) {\n        const schema = getRuleOptionsSchema(rule);\n\n        if (schema) {\n            ruleValidators.set(rule, ajv.compile(schema));\n        }\n    }\n\n    const validateRule = ruleValidators.get(rule);\n\n    if (validateRule) {\n        validateRule(localOptions);\n        if (validateRule.errors) {\n            throw new Error(validateRule.errors.map(\n                error => `\\tValue ${JSON.stringify(error.data)} ${error.message}.\\n`\n            ).join(\"\"));\n        }\n    }\n}\n\n/**\n * Validates a rule's options against its schema.\n * @param {{create: Function}|null} rule The rule that the config is being validated for\n * @param {string} ruleId The rule's unique name.\n * @param {Array|number} options The given options for the rule.\n * @param {string|null} source The name of the configuration source to report in any errors. If null or undefined,\n * no source is prepended to the message.\n * @returns {void}\n */\nfunction validateRuleOptions(rule, ruleId, options, source = null) {\n    try {\n        const severity = validateRuleSeverity(options);\n\n        if (severity !== 0) {\n            validateRuleSchema(rule, Array.isArray(options) ? options.slice(1) : []);\n        }\n    } catch (err) {\n        const enhancedMessage = `Configuration for rule \"${ruleId}\" is invalid:\\n${err.message}`;\n\n        if (typeof source === \"string\") {\n            throw new Error(`${source}:\\n\\t${enhancedMessage}`);\n        } else {\n            throw new Error(enhancedMessage);\n        }\n    }\n}\n\n/**\n * Validates an environment object\n * @param {Object} environment The environment config object to validate.\n * @param {string} source The name of the configuration source to report in any errors.\n * @param {function(envId:string): Object} [getAdditionalEnv] A map from strings to loaded environments.\n * @returns {void}\n */\nfunction validateEnvironment(\n    environment,\n    source,\n    getAdditionalEnv = noop\n) {\n\n    // not having an environment is ok\n    if (!environment) {\n        return;\n    }\n\n    Object.keys(environment).forEach(id => {\n        const env = getAdditionalEnv(id) || BuiltInEnvironments.get(id) || null;\n\n        if (!env) {\n            const message = `${source}:\\n\\tEnvironment key \"${id}\" is unknown\\n`;\n\n            throw new Error(message);\n        }\n    });\n}\n\n/**\n * Validates a rules config object\n * @param {Object} rulesConfig The rules config object to validate.\n * @param {string} source The name of the configuration source to report in any errors.\n * @param {function(ruleId:string): Object} getAdditionalRule A map from strings to loaded rules\n * @returns {void}\n */\nfunction validateRules(\n    rulesConfig,\n    source,\n    getAdditionalRule = noop\n) {\n    if (!rulesConfig) {\n        return;\n    }\n\n    Object.keys(rulesConfig).forEach(id => {\n        const rule = getAdditionalRule(id) || BuiltInRules.get(id) || null;\n\n        validateRuleOptions(rule, id, rulesConfig[id], source);\n    });\n}\n\n/**\n * Validates a `globals` section of a config file\n * @param {Object} globalsConfig The `globals` section\n * @param {string|null} source The name of the configuration source to report in the event of an error.\n * @returns {void}\n */\nfunction validateGlobals(globalsConfig, source = null) {\n    if (!globalsConfig) {\n        return;\n    }\n\n    Object.entries(globalsConfig)\n        .forEach(([configuredGlobal, configuredValue]) => {\n            try {\n                ConfigOps.normalizeConfigGlobal(configuredValue);\n            } catch (err) {\n                throw new Error(`ESLint configuration of global '${configuredGlobal}' in ${source} is invalid:\\n${err.message}`);\n            }\n        });\n}\n\n/**\n * Validate `processor` configuration.\n * @param {string|undefined} processorName The processor name.\n * @param {string} source The name of config file.\n * @param {function(id:string): Processor} getProcessor The getter of defined processors.\n * @returns {void}\n */\nfunction validateProcessor(processorName, source, getProcessor) {\n    if (processorName && !getProcessor(processorName)) {\n        throw new Error(`ESLint configuration of processor in '${source}' is invalid: '${processorName}' was not found.`);\n    }\n}\n\n/**\n * Formats an array of schema validation errors.\n * @param {Array} errors An array of error messages to format.\n * @returns {string} Formatted error message\n */\nfunction formatErrors(errors) {\n    return errors.map(error => {\n        if (error.keyword === \"additionalProperties\") {\n            const formattedPropertyPath = error.dataPath.length ? `${error.dataPath.slice(1)}.${error.params.additionalProperty}` : error.params.additionalProperty;\n\n            return `Unexpected top-level property \"${formattedPropertyPath}\"`;\n        }\n        if (error.keyword === \"type\") {\n            const formattedField = error.dataPath.slice(1);\n            const formattedExpectedType = Array.isArray(error.schema) ? error.schema.join(\"/\") : error.schema;\n            const formattedValue = JSON.stringify(error.data);\n\n            return `Property \"${formattedField}\" is the wrong type (expected ${formattedExpectedType} but got \\`${formattedValue}\\`)`;\n        }\n\n        const field = error.dataPath[0] === \".\" ? error.dataPath.slice(1) : error.dataPath;\n\n        return `\"${field}\" ${error.message}. Value: ${JSON.stringify(error.data)}`;\n    }).map(message => `\\t- ${message}.\\n`).join(\"\");\n}\n\n/**\n * Validates the top level properties of the config object.\n * @param {Object} config The config object to validate.\n * @param {string} source The name of the configuration source to report in any errors.\n * @returns {void}\n */\nfunction validateConfigSchema(config, source = null) {\n    validateSchema = validateSchema || ajv.compile(configSchema);\n\n    if (!validateSchema(config)) {\n        throw new Error(`ESLint configuration in ${source} is invalid:\\n${formatErrors(validateSchema.errors)}`);\n    }\n\n    if (Object.hasOwnProperty.call(config, \"ecmaFeatures\")) {\n        emitDeprecationWarning(source, \"ESLINT_LEGACY_ECMAFEATURES\");\n    }\n}\n\n/**\n * Validates an entire config object.\n * @param {Object} config The config object to validate.\n * @param {string} source The name of the configuration source to report in any errors.\n * @param {function(ruleId:string): Object} [getAdditionalRule] A map from strings to loaded rules.\n * @param {function(envId:string): Object} [getAdditionalEnv] A map from strings to loaded envs.\n * @returns {void}\n */\nfunction validate(config, source, getAdditionalRule, getAdditionalEnv) {\n    validateConfigSchema(config, source);\n    validateRules(config.rules, source, getAdditionalRule);\n    validateEnvironment(config.env, source, getAdditionalEnv);\n    validateGlobals(config.globals, source);\n\n    for (const override of config.overrides || []) {\n        validateRules(override.rules, source, getAdditionalRule);\n        validateEnvironment(override.env, source, getAdditionalEnv);\n        validateGlobals(config.globals, source);\n    }\n}\n\nconst validated = new WeakSet();\n\n/**\n * Validate config array object.\n * @param {ConfigArray} configArray The config array to validate.\n * @returns {void}\n */\nfunction validateConfigArray(configArray) {\n    const getPluginEnv = Map.prototype.get.bind(configArray.pluginEnvironments);\n    const getPluginProcessor = Map.prototype.get.bind(configArray.pluginProcessors);\n    const getPluginRule = Map.prototype.get.bind(configArray.pluginRules);\n\n    // Validate.\n    for (const element of configArray) {\n        if (validated.has(element)) {\n            continue;\n        }\n        validated.add(element);\n\n        validateEnvironment(element.env, element.name, getPluginEnv);\n        validateGlobals(element.globals, element.name);\n        validateProcessor(element.processor, element.name, getPluginProcessor);\n        validateRules(element.rules, element.name, getPluginRule);\n    }\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    getRuleOptionsSchema,\n    validate,\n    validateConfigArray,\n    validateConfigSchema,\n    validateRuleOptions\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}