{"ast":null,"code":"/**\n * @fileoverview Rule to warn when a function expression does not have a name.\n * @author Kyle T. Nunery\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils\");\n\n/**\n * Checks whether or not a given variable is a function name.\n * @param {eslint-scope.Variable} variable A variable to check.\n * @returns {boolean} `true` if the variable is a function name.\n */\nfunction isFunctionName(variable) {\n  return variable && variable.defs[0].type === \"FunctionName\";\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require or disallow named `function` expressions\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/func-names\"\n    },\n    schema: {\n      definitions: {\n        value: {\n          enum: [\"always\", \"as-needed\", \"never\"]\n        }\n      },\n      items: [{\n        $ref: \"#/definitions/value\"\n      }, {\n        type: \"object\",\n        properties: {\n          generators: {\n            $ref: \"#/definitions/value\"\n          }\n        },\n        additionalProperties: false\n      }]\n    },\n    messages: {\n      unnamed: \"Unexpected unnamed {{name}}.\",\n      named: \"Unexpected named {{name}}.\"\n    }\n  },\n  create(context) {\n    const sourceCode = context.getSourceCode();\n\n    /**\n     * Returns the config option for the given node.\n     * @param {ASTNode} node A node to get the config for.\n     * @returns {string} The config option.\n     */\n    function getConfigForNode(node) {\n      if (node.generator && context.options.length > 1 && context.options[1].generators) {\n        return context.options[1].generators;\n      }\n      return context.options[0] || \"always\";\n    }\n\n    /**\n     * Determines whether the current FunctionExpression node is a get, set, or\n     * shorthand method in an object literal or a class.\n     * @param {ASTNode} node A node to check.\n     * @returns {boolean} True if the node is a get, set, or shorthand method.\n     */\n    function isObjectOrClassMethod(node) {\n      const parent = node.parent;\n      return parent.type === \"MethodDefinition\" || parent.type === \"Property\" && (parent.method || parent.kind === \"get\" || parent.kind === \"set\");\n    }\n\n    /**\n     * Determines whether the current FunctionExpression node has a name that would be\n     * inferred from context in a conforming ES6 environment.\n     * @param {ASTNode} node A node to check.\n     * @returns {boolean} True if the node would have a name assigned automatically.\n     */\n    function hasInferredName(node) {\n      const parent = node.parent;\n      return isObjectOrClassMethod(node) || parent.type === \"VariableDeclarator\" && parent.id.type === \"Identifier\" && parent.init === node || parent.type === \"Property\" && parent.value === node || parent.type === \"AssignmentExpression\" && parent.left.type === \"Identifier\" && parent.right === node || parent.type === \"AssignmentPattern\" && parent.left.type === \"Identifier\" && parent.right === node;\n    }\n\n    /**\n     * Reports that an unnamed function should be named\n     * @param {ASTNode} node The node to report in the event of an error.\n     * @returns {void}\n     */\n    function reportUnexpectedUnnamedFunction(node) {\n      context.report({\n        node,\n        messageId: \"unnamed\",\n        loc: astUtils.getFunctionHeadLoc(node, sourceCode),\n        data: {\n          name: astUtils.getFunctionNameWithKind(node)\n        }\n      });\n    }\n\n    /**\n     * Reports that a named function should be unnamed\n     * @param {ASTNode} node The node to report in the event of an error.\n     * @returns {void}\n     */\n    function reportUnexpectedNamedFunction(node) {\n      context.report({\n        node,\n        messageId: \"named\",\n        loc: astUtils.getFunctionHeadLoc(node, sourceCode),\n        data: {\n          name: astUtils.getFunctionNameWithKind(node)\n        }\n      });\n    }\n\n    /**\n     * The listener for function nodes.\n     * @param {ASTNode} node function node\n     * @returns {void}\n     */\n    function handleFunction(node) {\n      // Skip recursive functions.\n      const nameVar = context.getDeclaredVariables(node)[0];\n      if (isFunctionName(nameVar) && nameVar.references.length > 0) {\n        return;\n      }\n      const hasName = Boolean(node.id && node.id.name);\n      const config = getConfigForNode(node);\n      if (config === \"never\") {\n        if (hasName && node.type !== \"FunctionDeclaration\") {\n          reportUnexpectedNamedFunction(node);\n        }\n      } else if (config === \"as-needed\") {\n        if (!hasName && !hasInferredName(node)) {\n          reportUnexpectedUnnamedFunction(node);\n        }\n      } else {\n        if (!hasName && !isObjectOrClassMethod(node)) {\n          reportUnexpectedUnnamedFunction(node);\n        }\n      }\n    }\n    return {\n      \"FunctionExpression:exit\": handleFunction,\n      \"ExportDefaultDeclaration > FunctionDeclaration\": handleFunction\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","isFunctionName","variable","defs","type","module","exports","meta","docs","description","category","recommended","url","schema","definitions","value","enum","items","$ref","properties","generators","additionalProperties","messages","unnamed","named","create","context","sourceCode","getSourceCode","getConfigForNode","node","generator","options","length","isObjectOrClassMethod","parent","method","kind","hasInferredName","id","init","left","right","reportUnexpectedUnnamedFunction","report","messageId","loc","getFunctionHeadLoc","data","name","getFunctionNameWithKind","reportUnexpectedNamedFunction","handleFunction","nameVar","getDeclaredVariables","references","hasName","Boolean","config"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/func-names.js"],"sourcesContent":["/**\n * @fileoverview Rule to warn when a function expression does not have a name.\n * @author Kyle T. Nunery\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n/**\n * Checks whether or not a given variable is a function name.\n * @param {eslint-scope.Variable} variable A variable to check.\n * @returns {boolean} `true` if the variable is a function name.\n */\nfunction isFunctionName(variable) {\n    return variable && variable.defs[0].type === \"FunctionName\";\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require or disallow named `function` expressions\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/func-names\"\n        },\n\n        schema: {\n            definitions: {\n                value: {\n                    enum: [\n                        \"always\",\n                        \"as-needed\",\n                        \"never\"\n                    ]\n                }\n            },\n            items: [\n                {\n                    $ref: \"#/definitions/value\"\n                },\n                {\n                    type: \"object\",\n                    properties: {\n                        generators: {\n                            $ref: \"#/definitions/value\"\n                        }\n                    },\n                    additionalProperties: false\n                }\n            ]\n        },\n\n        messages: {\n            unnamed: \"Unexpected unnamed {{name}}.\",\n            named: \"Unexpected named {{name}}.\"\n        }\n    },\n\n    create(context) {\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Returns the config option for the given node.\n         * @param {ASTNode} node A node to get the config for.\n         * @returns {string} The config option.\n         */\n        function getConfigForNode(node) {\n            if (\n                node.generator &&\n                context.options.length > 1 &&\n                context.options[1].generators\n            ) {\n                return context.options[1].generators;\n            }\n\n            return context.options[0] || \"always\";\n        }\n\n        /**\n         * Determines whether the current FunctionExpression node is a get, set, or\n         * shorthand method in an object literal or a class.\n         * @param {ASTNode} node A node to check.\n         * @returns {boolean} True if the node is a get, set, or shorthand method.\n         */\n        function isObjectOrClassMethod(node) {\n            const parent = node.parent;\n\n            return (parent.type === \"MethodDefinition\" || (\n                parent.type === \"Property\" && (\n                    parent.method ||\n                    parent.kind === \"get\" ||\n                    parent.kind === \"set\"\n                )\n            ));\n        }\n\n        /**\n         * Determines whether the current FunctionExpression node has a name that would be\n         * inferred from context in a conforming ES6 environment.\n         * @param {ASTNode} node A node to check.\n         * @returns {boolean} True if the node would have a name assigned automatically.\n         */\n        function hasInferredName(node) {\n            const parent = node.parent;\n\n            return isObjectOrClassMethod(node) ||\n                (parent.type === \"VariableDeclarator\" && parent.id.type === \"Identifier\" && parent.init === node) ||\n                (parent.type === \"Property\" && parent.value === node) ||\n                (parent.type === \"AssignmentExpression\" && parent.left.type === \"Identifier\" && parent.right === node) ||\n                (parent.type === \"AssignmentPattern\" && parent.left.type === \"Identifier\" && parent.right === node);\n        }\n\n        /**\n         * Reports that an unnamed function should be named\n         * @param {ASTNode} node The node to report in the event of an error.\n         * @returns {void}\n         */\n        function reportUnexpectedUnnamedFunction(node) {\n            context.report({\n                node,\n                messageId: \"unnamed\",\n                loc: astUtils.getFunctionHeadLoc(node, sourceCode),\n                data: { name: astUtils.getFunctionNameWithKind(node) }\n            });\n        }\n\n        /**\n         * Reports that a named function should be unnamed\n         * @param {ASTNode} node The node to report in the event of an error.\n         * @returns {void}\n         */\n        function reportUnexpectedNamedFunction(node) {\n            context.report({\n                node,\n                messageId: \"named\",\n                loc: astUtils.getFunctionHeadLoc(node, sourceCode),\n                data: { name: astUtils.getFunctionNameWithKind(node) }\n            });\n        }\n\n        /**\n         * The listener for function nodes.\n         * @param {ASTNode} node function node\n         * @returns {void}\n         */\n        function handleFunction(node) {\n\n            // Skip recursive functions.\n            const nameVar = context.getDeclaredVariables(node)[0];\n\n            if (isFunctionName(nameVar) && nameVar.references.length > 0) {\n                return;\n            }\n\n            const hasName = Boolean(node.id && node.id.name);\n            const config = getConfigForNode(node);\n\n            if (config === \"never\") {\n                if (hasName && node.type !== \"FunctionDeclaration\") {\n                    reportUnexpectedNamedFunction(node);\n                }\n            } else if (config === \"as-needed\") {\n                if (!hasName && !hasInferredName(node)) {\n                    reportUnexpectedUnnamedFunction(node);\n                }\n            } else {\n                if (!hasName && !isObjectOrClassMethod(node)) {\n                    reportUnexpectedUnnamedFunction(node);\n                }\n            }\n        }\n\n        return {\n            \"FunctionExpression:exit\": handleFunction,\n            \"ExportDefaultDeclaration > FunctionDeclaration\": handleFunction\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}