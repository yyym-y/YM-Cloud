{"ast":null,"code":"require(\"core-js/modules/es.array.push.js\");\n/*\n * @fileoverview Type expression parser.\n * @author Yusuke Suzuki <utatane.tea@gmail.com>\n * @author Dan Tao <daniel.tao@gmail.com>\n * @author Andrew Eisenberg <andrew@eisenberg.as>\n */\n\n// \"typed\", the Type Expression Parser for doctrine.\n\n(function () {\n  'use strict';\n\n  var Syntax, Token, source, length, index, previous, token, value, esutils, utility, rangeOffset, addRange;\n  esutils = require('esutils');\n  utility = require('./utility');\n  Syntax = {\n    NullableLiteral: 'NullableLiteral',\n    AllLiteral: 'AllLiteral',\n    NullLiteral: 'NullLiteral',\n    UndefinedLiteral: 'UndefinedLiteral',\n    VoidLiteral: 'VoidLiteral',\n    UnionType: 'UnionType',\n    ArrayType: 'ArrayType',\n    RecordType: 'RecordType',\n    FieldType: 'FieldType',\n    FunctionType: 'FunctionType',\n    ParameterType: 'ParameterType',\n    RestType: 'RestType',\n    NonNullableType: 'NonNullableType',\n    OptionalType: 'OptionalType',\n    NullableType: 'NullableType',\n    NameExpression: 'NameExpression',\n    TypeApplication: 'TypeApplication',\n    StringLiteralType: 'StringLiteralType',\n    NumericLiteralType: 'NumericLiteralType',\n    BooleanLiteralType: 'BooleanLiteralType'\n  };\n  Token = {\n    ILLEGAL: 0,\n    // ILLEGAL\n    DOT_LT: 1,\n    // .<\n    REST: 2,\n    // ...\n    LT: 3,\n    // <\n    GT: 4,\n    // >\n    LPAREN: 5,\n    // (\n    RPAREN: 6,\n    // )\n    LBRACE: 7,\n    // {\n    RBRACE: 8,\n    // }\n    LBRACK: 9,\n    // [\n    RBRACK: 10,\n    // ]\n    COMMA: 11,\n    // ,\n    COLON: 12,\n    // :\n    STAR: 13,\n    // *\n    PIPE: 14,\n    // |\n    QUESTION: 15,\n    // ?\n    BANG: 16,\n    // !\n    EQUAL: 17,\n    // =\n    NAME: 18,\n    // name token\n    STRING: 19,\n    // string\n    NUMBER: 20,\n    // number\n    EOF: 21\n  };\n  function isTypeName(ch) {\n    return '><(){}[],:*|?!='.indexOf(String.fromCharCode(ch)) === -1 && !esutils.code.isWhiteSpace(ch) && !esutils.code.isLineTerminator(ch);\n  }\n  function Context(previous, index, token, value) {\n    this._previous = previous;\n    this._index = index;\n    this._token = token;\n    this._value = value;\n  }\n  Context.prototype.restore = function () {\n    previous = this._previous;\n    index = this._index;\n    token = this._token;\n    value = this._value;\n  };\n  Context.save = function () {\n    return new Context(previous, index, token, value);\n  };\n  function maybeAddRange(node, range) {\n    if (addRange) {\n      node.range = [range[0] + rangeOffset, range[1] + rangeOffset];\n    }\n    return node;\n  }\n  function advance() {\n    var ch = source.charAt(index);\n    index += 1;\n    return ch;\n  }\n  function scanHexEscape(prefix) {\n    var i,\n      len,\n      ch,\n      code = 0;\n    len = prefix === 'u' ? 4 : 2;\n    for (i = 0; i < len; ++i) {\n      if (index < length && esutils.code.isHexDigit(source.charCodeAt(index))) {\n        ch = advance();\n        code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n      } else {\n        return '';\n      }\n    }\n    return String.fromCharCode(code);\n  }\n  function scanString() {\n    var str = '',\n      quote,\n      ch,\n      code,\n      unescaped,\n      restore; //TODO review removal octal = false\n    quote = source.charAt(index);\n    ++index;\n    while (index < length) {\n      ch = advance();\n      if (ch === quote) {\n        quote = '';\n        break;\n      } else if (ch === '\\\\') {\n        ch = advance();\n        if (!esutils.code.isLineTerminator(ch.charCodeAt(0))) {\n          switch (ch) {\n            case 'n':\n              str += '\\n';\n              break;\n            case 'r':\n              str += '\\r';\n              break;\n            case 't':\n              str += '\\t';\n              break;\n            case 'u':\n            case 'x':\n              restore = index;\n              unescaped = scanHexEscape(ch);\n              if (unescaped) {\n                str += unescaped;\n              } else {\n                index = restore;\n                str += ch;\n              }\n              break;\n            case 'b':\n              str += '\\b';\n              break;\n            case 'f':\n              str += '\\f';\n              break;\n            case 'v':\n              str += '\\v';\n              break;\n            default:\n              if (esutils.code.isOctalDigit(ch.charCodeAt(0))) {\n                code = '01234567'.indexOf(ch);\n\n                // \\0 is not octal escape sequence\n                // Deprecating unused code. TODO review removal\n                //if (code !== 0) {\n                //    octal = true;\n                //}\n\n                if (index < length && esutils.code.isOctalDigit(source.charCodeAt(index))) {\n                  //TODO Review Removal octal = true;\n                  code = code * 8 + '01234567'.indexOf(advance());\n\n                  // 3 digits are only allowed when string starts\n                  // with 0, 1, 2, 3\n                  if ('0123'.indexOf(ch) >= 0 && index < length && esutils.code.isOctalDigit(source.charCodeAt(index))) {\n                    code = code * 8 + '01234567'.indexOf(advance());\n                  }\n                }\n                str += String.fromCharCode(code);\n              } else {\n                str += ch;\n              }\n              break;\n          }\n        } else {\n          if (ch === '\\r' && source.charCodeAt(index) === 0x0A /* '\\n' */) {\n            ++index;\n          }\n        }\n      } else if (esutils.code.isLineTerminator(ch.charCodeAt(0))) {\n        break;\n      } else {\n        str += ch;\n      }\n    }\n    if (quote !== '') {\n      utility.throwError('unexpected quote');\n    }\n    value = str;\n    return Token.STRING;\n  }\n  function scanNumber() {\n    var number, ch;\n    number = '';\n    ch = source.charCodeAt(index);\n    if (ch !== 0x2E /* '.' */) {\n      number = advance();\n      ch = source.charCodeAt(index);\n      if (number === '0') {\n        if (ch === 0x78 /* 'x' */ || ch === 0x58 /* 'X' */) {\n          number += advance();\n          while (index < length) {\n            ch = source.charCodeAt(index);\n            if (!esutils.code.isHexDigit(ch)) {\n              break;\n            }\n            number += advance();\n          }\n          if (number.length <= 2) {\n            // only 0x\n            utility.throwError('unexpected token');\n          }\n          if (index < length) {\n            ch = source.charCodeAt(index);\n            if (esutils.code.isIdentifierStartES5(ch)) {\n              utility.throwError('unexpected token');\n            }\n          }\n          value = parseInt(number, 16);\n          return Token.NUMBER;\n        }\n        if (esutils.code.isOctalDigit(ch)) {\n          number += advance();\n          while (index < length) {\n            ch = source.charCodeAt(index);\n            if (!esutils.code.isOctalDigit(ch)) {\n              break;\n            }\n            number += advance();\n          }\n          if (index < length) {\n            ch = source.charCodeAt(index);\n            if (esutils.code.isIdentifierStartES5(ch) || esutils.code.isDecimalDigit(ch)) {\n              utility.throwError('unexpected token');\n            }\n          }\n          value = parseInt(number, 8);\n          return Token.NUMBER;\n        }\n        if (esutils.code.isDecimalDigit(ch)) {\n          utility.throwError('unexpected token');\n        }\n      }\n      while (index < length) {\n        ch = source.charCodeAt(index);\n        if (!esutils.code.isDecimalDigit(ch)) {\n          break;\n        }\n        number += advance();\n      }\n    }\n    if (ch === 0x2E /* '.' */) {\n      number += advance();\n      while (index < length) {\n        ch = source.charCodeAt(index);\n        if (!esutils.code.isDecimalDigit(ch)) {\n          break;\n        }\n        number += advance();\n      }\n    }\n    if (ch === 0x65 /* 'e' */ || ch === 0x45 /* 'E' */) {\n      number += advance();\n      ch = source.charCodeAt(index);\n      if (ch === 0x2B /* '+' */ || ch === 0x2D /* '-' */) {\n        number += advance();\n      }\n      ch = source.charCodeAt(index);\n      if (esutils.code.isDecimalDigit(ch)) {\n        number += advance();\n        while (index < length) {\n          ch = source.charCodeAt(index);\n          if (!esutils.code.isDecimalDigit(ch)) {\n            break;\n          }\n          number += advance();\n        }\n      } else {\n        utility.throwError('unexpected token');\n      }\n    }\n    if (index < length) {\n      ch = source.charCodeAt(index);\n      if (esutils.code.isIdentifierStartES5(ch)) {\n        utility.throwError('unexpected token');\n      }\n    }\n    value = parseFloat(number);\n    return Token.NUMBER;\n  }\n  function scanTypeName() {\n    var ch, ch2;\n    value = advance();\n    while (index < length && isTypeName(source.charCodeAt(index))) {\n      ch = source.charCodeAt(index);\n      if (ch === 0x2E /* '.' */) {\n        if (index + 1 >= length) {\n          return Token.ILLEGAL;\n        }\n        ch2 = source.charCodeAt(index + 1);\n        if (ch2 === 0x3C /* '<' */) {\n          break;\n        }\n      }\n      value += advance();\n    }\n    return Token.NAME;\n  }\n  function next() {\n    var ch;\n    previous = index;\n    while (index < length && esutils.code.isWhiteSpace(source.charCodeAt(index))) {\n      advance();\n    }\n    if (index >= length) {\n      token = Token.EOF;\n      return token;\n    }\n    ch = source.charCodeAt(index);\n    switch (ch) {\n      case 0x27: /* ''' */\n      case 0x22:\n        /* '\"' */\n        token = scanString();\n        return token;\n      case 0x3A:\n        /* ':' */\n        advance();\n        token = Token.COLON;\n        return token;\n      case 0x2C:\n        /* ',' */\n        advance();\n        token = Token.COMMA;\n        return token;\n      case 0x28:\n        /* '(' */\n        advance();\n        token = Token.LPAREN;\n        return token;\n      case 0x29:\n        /* ')' */\n        advance();\n        token = Token.RPAREN;\n        return token;\n      case 0x5B:\n        /* '[' */\n        advance();\n        token = Token.LBRACK;\n        return token;\n      case 0x5D:\n        /* ']' */\n        advance();\n        token = Token.RBRACK;\n        return token;\n      case 0x7B:\n        /* '{' */\n        advance();\n        token = Token.LBRACE;\n        return token;\n      case 0x7D:\n        /* '}' */\n        advance();\n        token = Token.RBRACE;\n        return token;\n      case 0x2E:\n        /* '.' */\n        if (index + 1 < length) {\n          ch = source.charCodeAt(index + 1);\n          if (ch === 0x3C /* '<' */) {\n            advance(); // '.'\n            advance(); // '<'\n            token = Token.DOT_LT;\n            return token;\n          }\n          if (ch === 0x2E /* '.' */ && index + 2 < length && source.charCodeAt(index + 2) === 0x2E /* '.' */) {\n            advance(); // '.'\n            advance(); // '.'\n            advance(); // '.'\n            token = Token.REST;\n            return token;\n          }\n          if (esutils.code.isDecimalDigit(ch)) {\n            token = scanNumber();\n            return token;\n          }\n        }\n        token = Token.ILLEGAL;\n        return token;\n      case 0x3C:\n        /* '<' */\n        advance();\n        token = Token.LT;\n        return token;\n      case 0x3E:\n        /* '>' */\n        advance();\n        token = Token.GT;\n        return token;\n      case 0x2A:\n        /* '*' */\n        advance();\n        token = Token.STAR;\n        return token;\n      case 0x7C:\n        /* '|' */\n        advance();\n        token = Token.PIPE;\n        return token;\n      case 0x3F:\n        /* '?' */\n        advance();\n        token = Token.QUESTION;\n        return token;\n      case 0x21:\n        /* '!' */\n        advance();\n        token = Token.BANG;\n        return token;\n      case 0x3D:\n        /* '=' */\n        advance();\n        token = Token.EQUAL;\n        return token;\n      case 0x2D:\n        /* '-' */\n        token = scanNumber();\n        return token;\n      default:\n        if (esutils.code.isDecimalDigit(ch)) {\n          token = scanNumber();\n          return token;\n        }\n\n        // type string permits following case,\n        //\n        // namespace.module.MyClass\n        //\n        // this reduced 1 token TK_NAME\n        utility.assert(isTypeName(ch));\n        token = scanTypeName();\n        return token;\n    }\n  }\n  function consume(target, text) {\n    utility.assert(token === target, text || 'consumed token not matched');\n    next();\n  }\n  function expect(target, message) {\n    if (token !== target) {\n      utility.throwError(message || 'unexpected token');\n    }\n    next();\n  }\n\n  // UnionType := '(' TypeUnionList ')'\n  //\n  // TypeUnionList :=\n  //     <<empty>>\n  //   | NonemptyTypeUnionList\n  //\n  // NonemptyTypeUnionList :=\n  //     TypeExpression\n  //   | TypeExpression '|' NonemptyTypeUnionList\n  function parseUnionType() {\n    var elements,\n      startIndex = index - 1;\n    consume(Token.LPAREN, 'UnionType should start with (');\n    elements = [];\n    if (token !== Token.RPAREN) {\n      while (true) {\n        elements.push(parseTypeExpression());\n        if (token === Token.RPAREN) {\n          break;\n        }\n        expect(Token.PIPE);\n      }\n    }\n    consume(Token.RPAREN, 'UnionType should end with )');\n    return maybeAddRange({\n      type: Syntax.UnionType,\n      elements: elements\n    }, [startIndex, previous]);\n  }\n\n  // ArrayType := '[' ElementTypeList ']'\n  //\n  // ElementTypeList :=\n  //     <<empty>>\n  //  | TypeExpression\n  //  | '...' TypeExpression\n  //  | TypeExpression ',' ElementTypeList\n  function parseArrayType() {\n    var elements,\n      startIndex = index - 1,\n      restStartIndex;\n    consume(Token.LBRACK, 'ArrayType should start with [');\n    elements = [];\n    while (token !== Token.RBRACK) {\n      if (token === Token.REST) {\n        restStartIndex = index - 3;\n        consume(Token.REST);\n        elements.push(maybeAddRange({\n          type: Syntax.RestType,\n          expression: parseTypeExpression()\n        }, [restStartIndex, previous]));\n        break;\n      } else {\n        elements.push(parseTypeExpression());\n      }\n      if (token !== Token.RBRACK) {\n        expect(Token.COMMA);\n      }\n    }\n    expect(Token.RBRACK);\n    return maybeAddRange({\n      type: Syntax.ArrayType,\n      elements: elements\n    }, [startIndex, previous]);\n  }\n  function parseFieldName() {\n    var v = value;\n    if (token === Token.NAME || token === Token.STRING) {\n      next();\n      return v;\n    }\n    if (token === Token.NUMBER) {\n      consume(Token.NUMBER);\n      return String(v);\n    }\n    utility.throwError('unexpected token');\n  }\n\n  // FieldType :=\n  //     FieldName\n  //   | FieldName ':' TypeExpression\n  //\n  // FieldName :=\n  //     NameExpression\n  //   | StringLiteral\n  //   | NumberLiteral\n  //   | ReservedIdentifier\n  function parseFieldType() {\n    var key,\n      rangeStart = previous;\n    key = parseFieldName();\n    if (token === Token.COLON) {\n      consume(Token.COLON);\n      return maybeAddRange({\n        type: Syntax.FieldType,\n        key: key,\n        value: parseTypeExpression()\n      }, [rangeStart, previous]);\n    }\n    return maybeAddRange({\n      type: Syntax.FieldType,\n      key: key,\n      value: null\n    }, [rangeStart, previous]);\n  }\n\n  // RecordType := '{' FieldTypeList '}'\n  //\n  // FieldTypeList :=\n  //     <<empty>>\n  //   | FieldType\n  //   | FieldType ',' FieldTypeList\n  function parseRecordType() {\n    var fields,\n      rangeStart = index - 1,\n      rangeEnd;\n    consume(Token.LBRACE, 'RecordType should start with {');\n    fields = [];\n    if (token === Token.COMMA) {\n      consume(Token.COMMA);\n    } else {\n      while (token !== Token.RBRACE) {\n        fields.push(parseFieldType());\n        if (token !== Token.RBRACE) {\n          expect(Token.COMMA);\n        }\n      }\n    }\n    rangeEnd = index;\n    expect(Token.RBRACE);\n    return maybeAddRange({\n      type: Syntax.RecordType,\n      fields: fields\n    }, [rangeStart, rangeEnd]);\n  }\n\n  // NameExpression :=\n  //    Identifier\n  //  | TagIdentifier ':' Identifier\n  //\n  // Tag identifier is one of \"module\", \"external\" or \"event\"\n  // Identifier is the same as Token.NAME, including any dots, something like\n  // namespace.module.MyClass\n  function parseNameExpression() {\n    var name = value,\n      rangeStart = index - name.length;\n    expect(Token.NAME);\n    if (token === Token.COLON && (name === 'module' || name === 'external' || name === 'event')) {\n      consume(Token.COLON);\n      name += ':' + value;\n      expect(Token.NAME);\n    }\n    return maybeAddRange({\n      type: Syntax.NameExpression,\n      name: name\n    }, [rangeStart, previous]);\n  }\n\n  // TypeExpressionList :=\n  //     TopLevelTypeExpression\n  //   | TopLevelTypeExpression ',' TypeExpressionList\n  function parseTypeExpressionList() {\n    var elements = [];\n    elements.push(parseTop());\n    while (token === Token.COMMA) {\n      consume(Token.COMMA);\n      elements.push(parseTop());\n    }\n    return elements;\n  }\n\n  // TypeName :=\n  //     NameExpression\n  //   | NameExpression TypeApplication\n  //\n  // TypeApplication :=\n  //     '.<' TypeExpressionList '>'\n  //   | '<' TypeExpressionList '>'   // this is extension of doctrine\n  function parseTypeName() {\n    var expr,\n      applications,\n      startIndex = index - value.length;\n    expr = parseNameExpression();\n    if (token === Token.DOT_LT || token === Token.LT) {\n      next();\n      applications = parseTypeExpressionList();\n      expect(Token.GT);\n      return maybeAddRange({\n        type: Syntax.TypeApplication,\n        expression: expr,\n        applications: applications\n      }, [startIndex, previous]);\n    }\n    return expr;\n  }\n\n  // ResultType :=\n  //     <<empty>>\n  //   | ':' void\n  //   | ':' TypeExpression\n  //\n  // BNF is above\n  // but, we remove <<empty>> pattern, so token is always TypeToken::COLON\n  function parseResultType() {\n    consume(Token.COLON, 'ResultType should start with :');\n    if (token === Token.NAME && value === 'void') {\n      consume(Token.NAME);\n      return {\n        type: Syntax.VoidLiteral\n      };\n    }\n    return parseTypeExpression();\n  }\n\n  // ParametersType :=\n  //     RestParameterType\n  //   | NonRestParametersType\n  //   | NonRestParametersType ',' RestParameterType\n  //\n  // RestParameterType :=\n  //     '...'\n  //     '...' Identifier\n  //\n  // NonRestParametersType :=\n  //     ParameterType ',' NonRestParametersType\n  //   | ParameterType\n  //   | OptionalParametersType\n  //\n  // OptionalParametersType :=\n  //     OptionalParameterType\n  //   | OptionalParameterType, OptionalParametersType\n  //\n  // OptionalParameterType := ParameterType=\n  //\n  // ParameterType := TypeExpression | Identifier ':' TypeExpression\n  //\n  // Identifier is \"new\" or \"this\"\n  function parseParametersType() {\n    var params = [],\n      optionalSequence = false,\n      expr,\n      rest = false,\n      startIndex,\n      restStartIndex = index - 3,\n      nameStartIndex;\n    while (token !== Token.RPAREN) {\n      if (token === Token.REST) {\n        // RestParameterType\n        consume(Token.REST);\n        rest = true;\n      }\n      startIndex = previous;\n      expr = parseTypeExpression();\n      if (expr.type === Syntax.NameExpression && token === Token.COLON) {\n        nameStartIndex = previous - expr.name.length;\n        // Identifier ':' TypeExpression\n        consume(Token.COLON);\n        expr = maybeAddRange({\n          type: Syntax.ParameterType,\n          name: expr.name,\n          expression: parseTypeExpression()\n        }, [nameStartIndex, previous]);\n      }\n      if (token === Token.EQUAL) {\n        consume(Token.EQUAL);\n        expr = maybeAddRange({\n          type: Syntax.OptionalType,\n          expression: expr\n        }, [startIndex, previous]);\n        optionalSequence = true;\n      } else {\n        if (optionalSequence) {\n          utility.throwError('unexpected token');\n        }\n      }\n      if (rest) {\n        expr = maybeAddRange({\n          type: Syntax.RestType,\n          expression: expr\n        }, [restStartIndex, previous]);\n      }\n      params.push(expr);\n      if (token !== Token.RPAREN) {\n        expect(Token.COMMA);\n      }\n    }\n    return params;\n  }\n\n  // FunctionType := 'function' FunctionSignatureType\n  //\n  // FunctionSignatureType :=\n  //   | TypeParameters '(' ')' ResultType\n  //   | TypeParameters '(' ParametersType ')' ResultType\n  //   | TypeParameters '(' 'this' ':' TypeName ')' ResultType\n  //   | TypeParameters '(' 'this' ':' TypeName ',' ParametersType ')' ResultType\n  function parseFunctionType() {\n    var isNew,\n      thisBinding,\n      params,\n      result,\n      fnType,\n      startIndex = index - value.length;\n    utility.assert(token === Token.NAME && value === 'function', 'FunctionType should start with \\'function\\'');\n    consume(Token.NAME);\n\n    // Google Closure Compiler is not implementing TypeParameters.\n    // So we do not. if we don't get '(', we see it as error.\n    expect(Token.LPAREN);\n    isNew = false;\n    params = [];\n    thisBinding = null;\n    if (token !== Token.RPAREN) {\n      // ParametersType or 'this'\n      if (token === Token.NAME && (value === 'this' || value === 'new')) {\n        // 'this' or 'new'\n        // 'new' is Closure Compiler extension\n        isNew = value === 'new';\n        consume(Token.NAME);\n        expect(Token.COLON);\n        thisBinding = parseTypeName();\n        if (token === Token.COMMA) {\n          consume(Token.COMMA);\n          params = parseParametersType();\n        }\n      } else {\n        params = parseParametersType();\n      }\n    }\n    expect(Token.RPAREN);\n    result = null;\n    if (token === Token.COLON) {\n      result = parseResultType();\n    }\n    fnType = maybeAddRange({\n      type: Syntax.FunctionType,\n      params: params,\n      result: result\n    }, [startIndex, previous]);\n    if (thisBinding) {\n      // avoid adding null 'new' and 'this' properties\n      fnType['this'] = thisBinding;\n      if (isNew) {\n        fnType['new'] = true;\n      }\n    }\n    return fnType;\n  }\n\n  // BasicTypeExpression :=\n  //     '*'\n  //   | 'null'\n  //   | 'undefined'\n  //   | TypeName\n  //   | FunctionType\n  //   | UnionType\n  //   | RecordType\n  //   | ArrayType\n  function parseBasicTypeExpression() {\n    var context, startIndex;\n    switch (token) {\n      case Token.STAR:\n        consume(Token.STAR);\n        return maybeAddRange({\n          type: Syntax.AllLiteral\n        }, [previous - 1, previous]);\n      case Token.LPAREN:\n        return parseUnionType();\n      case Token.LBRACK:\n        return parseArrayType();\n      case Token.LBRACE:\n        return parseRecordType();\n      case Token.NAME:\n        startIndex = index - value.length;\n        if (value === 'null') {\n          consume(Token.NAME);\n          return maybeAddRange({\n            type: Syntax.NullLiteral\n          }, [startIndex, previous]);\n        }\n        if (value === 'undefined') {\n          consume(Token.NAME);\n          return maybeAddRange({\n            type: Syntax.UndefinedLiteral\n          }, [startIndex, previous]);\n        }\n        if (value === 'true' || value === 'false') {\n          consume(Token.NAME);\n          return maybeAddRange({\n            type: Syntax.BooleanLiteralType,\n            value: value === 'true'\n          }, [startIndex, previous]);\n        }\n        context = Context.save();\n        if (value === 'function') {\n          try {\n            return parseFunctionType();\n          } catch (e) {\n            context.restore();\n          }\n        }\n        return parseTypeName();\n      case Token.STRING:\n        next();\n        return maybeAddRange({\n          type: Syntax.StringLiteralType,\n          value: value\n        }, [previous - value.length - 2, previous]);\n      case Token.NUMBER:\n        next();\n        return maybeAddRange({\n          type: Syntax.NumericLiteralType,\n          value: value\n        }, [previous - String(value).length, previous]);\n      default:\n        utility.throwError('unexpected token');\n    }\n  }\n\n  // TypeExpression :=\n  //     BasicTypeExpression\n  //   | '?' BasicTypeExpression\n  //   | '!' BasicTypeExpression\n  //   | BasicTypeExpression '?'\n  //   | BasicTypeExpression '!'\n  //   | '?'\n  //   | BasicTypeExpression '[]'\n  function parseTypeExpression() {\n    var expr, rangeStart;\n    if (token === Token.QUESTION) {\n      rangeStart = index - 1;\n      consume(Token.QUESTION);\n      if (token === Token.COMMA || token === Token.EQUAL || token === Token.RBRACE || token === Token.RPAREN || token === Token.PIPE || token === Token.EOF || token === Token.RBRACK || token === Token.GT) {\n        return maybeAddRange({\n          type: Syntax.NullableLiteral\n        }, [rangeStart, previous]);\n      }\n      return maybeAddRange({\n        type: Syntax.NullableType,\n        expression: parseBasicTypeExpression(),\n        prefix: true\n      }, [rangeStart, previous]);\n    } else if (token === Token.BANG) {\n      rangeStart = index - 1;\n      consume(Token.BANG);\n      return maybeAddRange({\n        type: Syntax.NonNullableType,\n        expression: parseBasicTypeExpression(),\n        prefix: true\n      }, [rangeStart, previous]);\n    } else {\n      rangeStart = previous;\n    }\n    expr = parseBasicTypeExpression();\n    if (token === Token.BANG) {\n      consume(Token.BANG);\n      return maybeAddRange({\n        type: Syntax.NonNullableType,\n        expression: expr,\n        prefix: false\n      }, [rangeStart, previous]);\n    }\n    if (token === Token.QUESTION) {\n      consume(Token.QUESTION);\n      return maybeAddRange({\n        type: Syntax.NullableType,\n        expression: expr,\n        prefix: false\n      }, [rangeStart, previous]);\n    }\n    if (token === Token.LBRACK) {\n      consume(Token.LBRACK);\n      expect(Token.RBRACK, 'expected an array-style type declaration (' + value + '[])');\n      return maybeAddRange({\n        type: Syntax.TypeApplication,\n        expression: maybeAddRange({\n          type: Syntax.NameExpression,\n          name: 'Array'\n        }, [rangeStart, previous]),\n        applications: [expr]\n      }, [rangeStart, previous]);\n    }\n    return expr;\n  }\n\n  // TopLevelTypeExpression :=\n  //      TypeExpression\n  //    | TypeUnionList\n  //\n  // This rule is Google Closure Compiler extension, not ES4\n  // like,\n  //   { number | string }\n  // If strict to ES4, we should write it as\n  //   { (number|string) }\n  function parseTop() {\n    var expr, elements;\n    expr = parseTypeExpression();\n    if (token !== Token.PIPE) {\n      return expr;\n    }\n    elements = [expr];\n    consume(Token.PIPE);\n    while (true) {\n      elements.push(parseTypeExpression());\n      if (token !== Token.PIPE) {\n        break;\n      }\n      consume(Token.PIPE);\n    }\n    return maybeAddRange({\n      type: Syntax.UnionType,\n      elements: elements\n    }, [0, index]);\n  }\n  function parseTopParamType() {\n    var expr;\n    if (token === Token.REST) {\n      consume(Token.REST);\n      return maybeAddRange({\n        type: Syntax.RestType,\n        expression: parseTop()\n      }, [0, index]);\n    }\n    expr = parseTop();\n    if (token === Token.EQUAL) {\n      consume(Token.EQUAL);\n      return maybeAddRange({\n        type: Syntax.OptionalType,\n        expression: expr\n      }, [0, index]);\n    }\n    return expr;\n  }\n  function parseType(src, opt) {\n    var expr;\n    source = src;\n    length = source.length;\n    index = 0;\n    previous = 0;\n    addRange = opt && opt.range;\n    rangeOffset = opt && opt.startIndex || 0;\n    next();\n    expr = parseTop();\n    if (opt && opt.midstream) {\n      return {\n        expression: expr,\n        index: previous\n      };\n    }\n    if (token !== Token.EOF) {\n      utility.throwError('not reach to EOF');\n    }\n    return expr;\n  }\n  function parseParamType(src, opt) {\n    var expr;\n    source = src;\n    length = source.length;\n    index = 0;\n    previous = 0;\n    addRange = opt && opt.range;\n    rangeOffset = opt && opt.startIndex || 0;\n    next();\n    expr = parseTopParamType();\n    if (opt && opt.midstream) {\n      return {\n        expression: expr,\n        index: previous\n      };\n    }\n    if (token !== Token.EOF) {\n      utility.throwError('not reach to EOF');\n    }\n    return expr;\n  }\n  function stringifyImpl(node, compact, topLevel) {\n    var result, i, iz;\n    switch (node.type) {\n      case Syntax.NullableLiteral:\n        result = '?';\n        break;\n      case Syntax.AllLiteral:\n        result = '*';\n        break;\n      case Syntax.NullLiteral:\n        result = 'null';\n        break;\n      case Syntax.UndefinedLiteral:\n        result = 'undefined';\n        break;\n      case Syntax.VoidLiteral:\n        result = 'void';\n        break;\n      case Syntax.UnionType:\n        if (!topLevel) {\n          result = '(';\n        } else {\n          result = '';\n        }\n        for (i = 0, iz = node.elements.length; i < iz; ++i) {\n          result += stringifyImpl(node.elements[i], compact);\n          if (i + 1 !== iz) {\n            result += compact ? '|' : ' | ';\n          }\n        }\n        if (!topLevel) {\n          result += ')';\n        }\n        break;\n      case Syntax.ArrayType:\n        result = '[';\n        for (i = 0, iz = node.elements.length; i < iz; ++i) {\n          result += stringifyImpl(node.elements[i], compact);\n          if (i + 1 !== iz) {\n            result += compact ? ',' : ', ';\n          }\n        }\n        result += ']';\n        break;\n      case Syntax.RecordType:\n        result = '{';\n        for (i = 0, iz = node.fields.length; i < iz; ++i) {\n          result += stringifyImpl(node.fields[i], compact);\n          if (i + 1 !== iz) {\n            result += compact ? ',' : ', ';\n          }\n        }\n        result += '}';\n        break;\n      case Syntax.FieldType:\n        if (node.value) {\n          result = node.key + (compact ? ':' : ': ') + stringifyImpl(node.value, compact);\n        } else {\n          result = node.key;\n        }\n        break;\n      case Syntax.FunctionType:\n        result = compact ? 'function(' : 'function (';\n        if (node['this']) {\n          if (node['new']) {\n            result += compact ? 'new:' : 'new: ';\n          } else {\n            result += compact ? 'this:' : 'this: ';\n          }\n          result += stringifyImpl(node['this'], compact);\n          if (node.params.length !== 0) {\n            result += compact ? ',' : ', ';\n          }\n        }\n        for (i = 0, iz = node.params.length; i < iz; ++i) {\n          result += stringifyImpl(node.params[i], compact);\n          if (i + 1 !== iz) {\n            result += compact ? ',' : ', ';\n          }\n        }\n        result += ')';\n        if (node.result) {\n          result += (compact ? ':' : ': ') + stringifyImpl(node.result, compact);\n        }\n        break;\n      case Syntax.ParameterType:\n        result = node.name + (compact ? ':' : ': ') + stringifyImpl(node.expression, compact);\n        break;\n      case Syntax.RestType:\n        result = '...';\n        if (node.expression) {\n          result += stringifyImpl(node.expression, compact);\n        }\n        break;\n      case Syntax.NonNullableType:\n        if (node.prefix) {\n          result = '!' + stringifyImpl(node.expression, compact);\n        } else {\n          result = stringifyImpl(node.expression, compact) + '!';\n        }\n        break;\n      case Syntax.OptionalType:\n        result = stringifyImpl(node.expression, compact) + '=';\n        break;\n      case Syntax.NullableType:\n        if (node.prefix) {\n          result = '?' + stringifyImpl(node.expression, compact);\n        } else {\n          result = stringifyImpl(node.expression, compact) + '?';\n        }\n        break;\n      case Syntax.NameExpression:\n        result = node.name;\n        break;\n      case Syntax.TypeApplication:\n        result = stringifyImpl(node.expression, compact) + '.<';\n        for (i = 0, iz = node.applications.length; i < iz; ++i) {\n          result += stringifyImpl(node.applications[i], compact);\n          if (i + 1 !== iz) {\n            result += compact ? ',' : ', ';\n          }\n        }\n        result += '>';\n        break;\n      case Syntax.StringLiteralType:\n        result = '\"' + node.value + '\"';\n        break;\n      case Syntax.NumericLiteralType:\n        result = String(node.value);\n        break;\n      case Syntax.BooleanLiteralType:\n        result = String(node.value);\n        break;\n      default:\n        utility.throwError('Unknown type ' + node.type);\n    }\n    return result;\n  }\n  function stringify(node, options) {\n    if (options == null) {\n      options = {};\n    }\n    return stringifyImpl(node, options.compact, options.topLevel);\n  }\n  exports.parseType = parseType;\n  exports.parseParamType = parseParamType;\n  exports.stringify = stringify;\n  exports.Syntax = Syntax;\n})();\n/* vim: set sw=4 ts=4 et tw=80 : */","map":{"version":3,"names":["Syntax","Token","source","length","index","previous","token","value","esutils","utility","rangeOffset","addRange","require","NullableLiteral","AllLiteral","NullLiteral","UndefinedLiteral","VoidLiteral","UnionType","ArrayType","RecordType","FieldType","FunctionType","ParameterType","RestType","NonNullableType","OptionalType","NullableType","NameExpression","TypeApplication","StringLiteralType","NumericLiteralType","BooleanLiteralType","ILLEGAL","DOT_LT","REST","LT","GT","LPAREN","RPAREN","LBRACE","RBRACE","LBRACK","RBRACK","COMMA","COLON","STAR","PIPE","QUESTION","BANG","EQUAL","NAME","STRING","NUMBER","EOF","isTypeName","ch","indexOf","String","fromCharCode","code","isWhiteSpace","isLineTerminator","Context","_previous","_index","_token","_value","prototype","restore","save","maybeAddRange","node","range","advance","charAt","scanHexEscape","prefix","i","len","isHexDigit","charCodeAt","toLowerCase","scanString","str","quote","unescaped","isOctalDigit","throwError","scanNumber","number","isIdentifierStartES5","parseInt","isDecimalDigit","parseFloat","scanTypeName","ch2","next","assert","consume","target","text","expect","message","parseUnionType","elements","startIndex","push","parseTypeExpression","type","parseArrayType","restStartIndex","expression","parseFieldName","v","parseFieldType","key","rangeStart","parseRecordType","fields","rangeEnd","parseNameExpression","name","parseTypeExpressionList","parseTop","parseTypeName","expr","applications","parseResultType","parseParametersType","params","optionalSequence","rest","nameStartIndex","parseFunctionType","isNew","thisBinding","result","fnType","parseBasicTypeExpression","context","e","parseTopParamType","parseType","src","opt","midstream","parseParamType","stringifyImpl","compact","topLevel","iz","stringify","options","exports"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/doctrine/lib/typed.js"],"sourcesContent":["/*\n * @fileoverview Type expression parser.\n * @author Yusuke Suzuki <utatane.tea@gmail.com>\n * @author Dan Tao <daniel.tao@gmail.com>\n * @author Andrew Eisenberg <andrew@eisenberg.as>\n */\n\n// \"typed\", the Type Expression Parser for doctrine.\n\n(function () {\n    'use strict';\n\n    var Syntax,\n        Token,\n        source,\n        length,\n        index,\n        previous,\n        token,\n        value,\n        esutils,\n        utility,\n        rangeOffset,\n        addRange;\n\n    esutils = require('esutils');\n    utility = require('./utility');\n\n    Syntax = {\n        NullableLiteral: 'NullableLiteral',\n        AllLiteral: 'AllLiteral',\n        NullLiteral: 'NullLiteral',\n        UndefinedLiteral: 'UndefinedLiteral',\n        VoidLiteral: 'VoidLiteral',\n        UnionType: 'UnionType',\n        ArrayType: 'ArrayType',\n        RecordType: 'RecordType',\n        FieldType: 'FieldType',\n        FunctionType: 'FunctionType',\n        ParameterType: 'ParameterType',\n        RestType: 'RestType',\n        NonNullableType: 'NonNullableType',\n        OptionalType: 'OptionalType',\n        NullableType: 'NullableType',\n        NameExpression: 'NameExpression',\n        TypeApplication: 'TypeApplication',\n        StringLiteralType: 'StringLiteralType',\n        NumericLiteralType: 'NumericLiteralType',\n        BooleanLiteralType: 'BooleanLiteralType'\n    };\n\n    Token = {\n        ILLEGAL: 0,    // ILLEGAL\n        DOT_LT: 1,     // .<\n        REST: 2,       // ...\n        LT: 3,         // <\n        GT: 4,         // >\n        LPAREN: 5,     // (\n        RPAREN: 6,     // )\n        LBRACE: 7,     // {\n        RBRACE: 8,     // }\n        LBRACK: 9,    // [\n        RBRACK: 10,    // ]\n        COMMA: 11,     // ,\n        COLON: 12,     // :\n        STAR: 13,      // *\n        PIPE: 14,      // |\n        QUESTION: 15,  // ?\n        BANG: 16,      // !\n        EQUAL: 17,     // =\n        NAME: 18,      // name token\n        STRING: 19,    // string\n        NUMBER: 20,    // number\n        EOF: 21\n    };\n\n    function isTypeName(ch) {\n        return '><(){}[],:*|?!='.indexOf(String.fromCharCode(ch)) === -1 && !esutils.code.isWhiteSpace(ch) && !esutils.code.isLineTerminator(ch);\n    }\n\n    function Context(previous, index, token, value) {\n        this._previous = previous;\n        this._index = index;\n        this._token = token;\n        this._value = value;\n    }\n\n    Context.prototype.restore = function () {\n        previous = this._previous;\n        index = this._index;\n        token = this._token;\n        value = this._value;\n    };\n\n    Context.save = function () {\n        return new Context(previous, index, token, value);\n    };\n\n    function maybeAddRange(node, range) {\n        if (addRange) {\n            node.range = [range[0] + rangeOffset, range[1] + rangeOffset];\n        }\n        return node;\n    }\n\n    function advance() {\n        var ch = source.charAt(index);\n        index += 1;\n        return ch;\n    }\n\n    function scanHexEscape(prefix) {\n        var i, len, ch, code = 0;\n\n        len = (prefix === 'u') ? 4 : 2;\n        for (i = 0; i < len; ++i) {\n            if (index < length && esutils.code.isHexDigit(source.charCodeAt(index))) {\n                ch = advance();\n                code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n            } else {\n                return '';\n            }\n        }\n        return String.fromCharCode(code);\n    }\n\n    function scanString() {\n        var str = '', quote, ch, code, unescaped, restore; //TODO review removal octal = false\n        quote = source.charAt(index);\n        ++index;\n\n        while (index < length) {\n            ch = advance();\n\n            if (ch === quote) {\n                quote = '';\n                break;\n            } else if (ch === '\\\\') {\n                ch = advance();\n                if (!esutils.code.isLineTerminator(ch.charCodeAt(0))) {\n                    switch (ch) {\n                    case 'n':\n                        str += '\\n';\n                        break;\n                    case 'r':\n                        str += '\\r';\n                        break;\n                    case 't':\n                        str += '\\t';\n                        break;\n                    case 'u':\n                    case 'x':\n                        restore = index;\n                        unescaped = scanHexEscape(ch);\n                        if (unescaped) {\n                            str += unescaped;\n                        } else {\n                            index = restore;\n                            str += ch;\n                        }\n                        break;\n                    case 'b':\n                        str += '\\b';\n                        break;\n                    case 'f':\n                        str += '\\f';\n                        break;\n                    case 'v':\n                        str += '\\v';\n                        break;\n\n                    default:\n                        if (esutils.code.isOctalDigit(ch.charCodeAt(0))) {\n                            code = '01234567'.indexOf(ch);\n\n                            // \\0 is not octal escape sequence\n                            // Deprecating unused code. TODO review removal\n                            //if (code !== 0) {\n                            //    octal = true;\n                            //}\n\n                            if (index < length && esutils.code.isOctalDigit(source.charCodeAt(index))) {\n                                //TODO Review Removal octal = true;\n                                code = code * 8 + '01234567'.indexOf(advance());\n\n                                // 3 digits are only allowed when string starts\n                                // with 0, 1, 2, 3\n                                if ('0123'.indexOf(ch) >= 0 &&\n                                        index < length &&\n                                        esutils.code.isOctalDigit(source.charCodeAt(index))) {\n                                    code = code * 8 + '01234567'.indexOf(advance());\n                                }\n                            }\n                            str += String.fromCharCode(code);\n                        } else {\n                            str += ch;\n                        }\n                        break;\n                    }\n                } else {\n                    if (ch ===  '\\r' && source.charCodeAt(index) === 0x0A  /* '\\n' */) {\n                        ++index;\n                    }\n                }\n            } else if (esutils.code.isLineTerminator(ch.charCodeAt(0))) {\n                break;\n            } else {\n                str += ch;\n            }\n        }\n\n        if (quote !== '') {\n            utility.throwError('unexpected quote');\n        }\n\n        value = str;\n        return Token.STRING;\n    }\n\n    function scanNumber() {\n        var number, ch;\n\n        number = '';\n        ch = source.charCodeAt(index);\n\n        if (ch !== 0x2E  /* '.' */) {\n            number = advance();\n            ch = source.charCodeAt(index);\n\n            if (number === '0') {\n                if (ch === 0x78  /* 'x' */ || ch === 0x58  /* 'X' */) {\n                    number += advance();\n                    while (index < length) {\n                        ch = source.charCodeAt(index);\n                        if (!esutils.code.isHexDigit(ch)) {\n                            break;\n                        }\n                        number += advance();\n                    }\n\n                    if (number.length <= 2) {\n                        // only 0x\n                        utility.throwError('unexpected token');\n                    }\n\n                    if (index < length) {\n                        ch = source.charCodeAt(index);\n                        if (esutils.code.isIdentifierStartES5(ch)) {\n                            utility.throwError('unexpected token');\n                        }\n                    }\n                    value = parseInt(number, 16);\n                    return Token.NUMBER;\n                }\n\n                if (esutils.code.isOctalDigit(ch)) {\n                    number += advance();\n                    while (index < length) {\n                        ch = source.charCodeAt(index);\n                        if (!esutils.code.isOctalDigit(ch)) {\n                            break;\n                        }\n                        number += advance();\n                    }\n\n                    if (index < length) {\n                        ch = source.charCodeAt(index);\n                        if (esutils.code.isIdentifierStartES5(ch) || esutils.code.isDecimalDigit(ch)) {\n                            utility.throwError('unexpected token');\n                        }\n                    }\n                    value = parseInt(number, 8);\n                    return Token.NUMBER;\n                }\n\n                if (esutils.code.isDecimalDigit(ch)) {\n                    utility.throwError('unexpected token');\n                }\n            }\n\n            while (index < length) {\n                ch = source.charCodeAt(index);\n                if (!esutils.code.isDecimalDigit(ch)) {\n                    break;\n                }\n                number += advance();\n            }\n        }\n\n        if (ch === 0x2E  /* '.' */) {\n            number += advance();\n            while (index < length) {\n                ch = source.charCodeAt(index);\n                if (!esutils.code.isDecimalDigit(ch)) {\n                    break;\n                }\n                number += advance();\n            }\n        }\n\n        if (ch === 0x65  /* 'e' */ || ch === 0x45  /* 'E' */) {\n            number += advance();\n\n            ch = source.charCodeAt(index);\n            if (ch === 0x2B  /* '+' */ || ch === 0x2D  /* '-' */) {\n                number += advance();\n            }\n\n            ch = source.charCodeAt(index);\n            if (esutils.code.isDecimalDigit(ch)) {\n                number += advance();\n                while (index < length) {\n                    ch = source.charCodeAt(index);\n                    if (!esutils.code.isDecimalDigit(ch)) {\n                        break;\n                    }\n                    number += advance();\n                }\n            } else {\n                utility.throwError('unexpected token');\n            }\n        }\n\n        if (index < length) {\n            ch = source.charCodeAt(index);\n            if (esutils.code.isIdentifierStartES5(ch)) {\n                utility.throwError('unexpected token');\n            }\n        }\n\n        value = parseFloat(number);\n        return Token.NUMBER;\n    }\n\n\n    function scanTypeName() {\n        var ch, ch2;\n\n        value = advance();\n        while (index < length && isTypeName(source.charCodeAt(index))) {\n            ch = source.charCodeAt(index);\n            if (ch === 0x2E  /* '.' */) {\n                if ((index + 1) >= length) {\n                    return Token.ILLEGAL;\n                }\n                ch2 = source.charCodeAt(index + 1);\n                if (ch2 === 0x3C  /* '<' */) {\n                    break;\n                }\n            }\n            value += advance();\n        }\n        return Token.NAME;\n    }\n\n    function next() {\n        var ch;\n\n        previous = index;\n\n        while (index < length && esutils.code.isWhiteSpace(source.charCodeAt(index))) {\n            advance();\n        }\n        if (index >= length) {\n            token = Token.EOF;\n            return token;\n        }\n\n        ch = source.charCodeAt(index);\n        switch (ch) {\n        case 0x27:  /* ''' */\n        case 0x22:  /* '\"' */\n            token = scanString();\n            return token;\n\n        case 0x3A:  /* ':' */\n            advance();\n            token = Token.COLON;\n            return token;\n\n        case 0x2C:  /* ',' */\n            advance();\n            token = Token.COMMA;\n            return token;\n\n        case 0x28:  /* '(' */\n            advance();\n            token = Token.LPAREN;\n            return token;\n\n        case 0x29:  /* ')' */\n            advance();\n            token = Token.RPAREN;\n            return token;\n\n        case 0x5B:  /* '[' */\n            advance();\n            token = Token.LBRACK;\n            return token;\n\n        case 0x5D:  /* ']' */\n            advance();\n            token = Token.RBRACK;\n            return token;\n\n        case 0x7B:  /* '{' */\n            advance();\n            token = Token.LBRACE;\n            return token;\n\n        case 0x7D:  /* '}' */\n            advance();\n            token = Token.RBRACE;\n            return token;\n\n        case 0x2E:  /* '.' */\n            if (index + 1 < length) {\n                ch = source.charCodeAt(index + 1);\n                if (ch === 0x3C  /* '<' */) {\n                    advance();  // '.'\n                    advance();  // '<'\n                    token = Token.DOT_LT;\n                    return token;\n                }\n\n                if (ch === 0x2E  /* '.' */ && index + 2 < length && source.charCodeAt(index + 2) === 0x2E  /* '.' */) {\n                    advance();  // '.'\n                    advance();  // '.'\n                    advance();  // '.'\n                    token = Token.REST;\n                    return token;\n                }\n\n                if (esutils.code.isDecimalDigit(ch)) {\n                    token = scanNumber();\n                    return token;\n                }\n            }\n            token = Token.ILLEGAL;\n            return token;\n\n        case 0x3C:  /* '<' */\n            advance();\n            token = Token.LT;\n            return token;\n\n        case 0x3E:  /* '>' */\n            advance();\n            token = Token.GT;\n            return token;\n\n        case 0x2A:  /* '*' */\n            advance();\n            token = Token.STAR;\n            return token;\n\n        case 0x7C:  /* '|' */\n            advance();\n            token = Token.PIPE;\n            return token;\n\n        case 0x3F:  /* '?' */\n            advance();\n            token = Token.QUESTION;\n            return token;\n\n        case 0x21:  /* '!' */\n            advance();\n            token = Token.BANG;\n            return token;\n\n        case 0x3D:  /* '=' */\n            advance();\n            token = Token.EQUAL;\n            return token;\n\n        case 0x2D: /* '-' */\n            token = scanNumber();\n            return token;\n\n        default:\n            if (esutils.code.isDecimalDigit(ch)) {\n                token = scanNumber();\n                return token;\n            }\n\n            // type string permits following case,\n            //\n            // namespace.module.MyClass\n            //\n            // this reduced 1 token TK_NAME\n            utility.assert(isTypeName(ch));\n            token = scanTypeName();\n            return token;\n        }\n    }\n\n    function consume(target, text) {\n        utility.assert(token === target, text || 'consumed token not matched');\n        next();\n    }\n\n    function expect(target, message) {\n        if (token !== target) {\n            utility.throwError(message || 'unexpected token');\n        }\n        next();\n    }\n\n    // UnionType := '(' TypeUnionList ')'\n    //\n    // TypeUnionList :=\n    //     <<empty>>\n    //   | NonemptyTypeUnionList\n    //\n    // NonemptyTypeUnionList :=\n    //     TypeExpression\n    //   | TypeExpression '|' NonemptyTypeUnionList\n    function parseUnionType() {\n        var elements, startIndex = index - 1;\n        consume(Token.LPAREN, 'UnionType should start with (');\n        elements = [];\n        if (token !== Token.RPAREN) {\n            while (true) {\n                elements.push(parseTypeExpression());\n                if (token === Token.RPAREN) {\n                    break;\n                }\n                expect(Token.PIPE);\n            }\n        }\n        consume(Token.RPAREN, 'UnionType should end with )');\n        return maybeAddRange({\n            type: Syntax.UnionType,\n            elements: elements\n        }, [startIndex, previous]);\n    }\n\n    // ArrayType := '[' ElementTypeList ']'\n    //\n    // ElementTypeList :=\n    //     <<empty>>\n    //  | TypeExpression\n    //  | '...' TypeExpression\n    //  | TypeExpression ',' ElementTypeList\n    function parseArrayType() {\n        var elements, startIndex = index - 1, restStartIndex;\n        consume(Token.LBRACK, 'ArrayType should start with [');\n        elements = [];\n        while (token !== Token.RBRACK) {\n            if (token === Token.REST) {\n                restStartIndex = index - 3;\n                consume(Token.REST);\n                elements.push(maybeAddRange({\n                    type: Syntax.RestType,\n                    expression: parseTypeExpression()\n                }, [restStartIndex, previous]));\n                break;\n            } else {\n                elements.push(parseTypeExpression());\n            }\n            if (token !== Token.RBRACK) {\n                expect(Token.COMMA);\n            }\n        }\n        expect(Token.RBRACK);\n        return maybeAddRange({\n            type: Syntax.ArrayType,\n            elements: elements\n        }, [startIndex, previous]);\n    }\n\n    function parseFieldName() {\n        var v = value;\n        if (token === Token.NAME || token === Token.STRING) {\n            next();\n            return v;\n        }\n\n        if (token === Token.NUMBER) {\n            consume(Token.NUMBER);\n            return String(v);\n        }\n\n        utility.throwError('unexpected token');\n    }\n\n    // FieldType :=\n    //     FieldName\n    //   | FieldName ':' TypeExpression\n    //\n    // FieldName :=\n    //     NameExpression\n    //   | StringLiteral\n    //   | NumberLiteral\n    //   | ReservedIdentifier\n    function parseFieldType() {\n        var key, rangeStart = previous;\n\n        key = parseFieldName();\n        if (token === Token.COLON) {\n            consume(Token.COLON);\n            return maybeAddRange({\n                type: Syntax.FieldType,\n                key: key,\n                value: parseTypeExpression()\n            }, [rangeStart, previous]);\n        }\n        return maybeAddRange({\n            type: Syntax.FieldType,\n            key: key,\n            value: null\n        }, [rangeStart, previous]);\n    }\n\n    // RecordType := '{' FieldTypeList '}'\n    //\n    // FieldTypeList :=\n    //     <<empty>>\n    //   | FieldType\n    //   | FieldType ',' FieldTypeList\n    function parseRecordType() {\n        var fields, rangeStart = index - 1, rangeEnd;\n\n        consume(Token.LBRACE, 'RecordType should start with {');\n        fields = [];\n        if (token === Token.COMMA) {\n            consume(Token.COMMA);\n        } else {\n            while (token !== Token.RBRACE) {\n                fields.push(parseFieldType());\n                if (token !== Token.RBRACE) {\n                    expect(Token.COMMA);\n                }\n            }\n        }\n        rangeEnd = index;\n        expect(Token.RBRACE);\n        return maybeAddRange({\n            type: Syntax.RecordType,\n            fields: fields\n        }, [rangeStart, rangeEnd]);\n    }\n\n    // NameExpression :=\n    //    Identifier\n    //  | TagIdentifier ':' Identifier\n    //\n    // Tag identifier is one of \"module\", \"external\" or \"event\"\n    // Identifier is the same as Token.NAME, including any dots, something like\n    // namespace.module.MyClass\n    function parseNameExpression() {\n        var name = value, rangeStart = index - name.length;\n        expect(Token.NAME);\n\n        if (token === Token.COLON && (\n                name === 'module' ||\n                name === 'external' ||\n                name === 'event')) {\n            consume(Token.COLON);\n            name += ':' + value;\n            expect(Token.NAME);\n        }\n\n        return maybeAddRange({\n            type: Syntax.NameExpression,\n            name: name\n        }, [rangeStart, previous]);\n    }\n\n    // TypeExpressionList :=\n    //     TopLevelTypeExpression\n    //   | TopLevelTypeExpression ',' TypeExpressionList\n    function parseTypeExpressionList() {\n        var elements = [];\n\n        elements.push(parseTop());\n        while (token === Token.COMMA) {\n            consume(Token.COMMA);\n            elements.push(parseTop());\n        }\n        return elements;\n    }\n\n    // TypeName :=\n    //     NameExpression\n    //   | NameExpression TypeApplication\n    //\n    // TypeApplication :=\n    //     '.<' TypeExpressionList '>'\n    //   | '<' TypeExpressionList '>'   // this is extension of doctrine\n    function parseTypeName() {\n        var expr, applications, startIndex = index - value.length;\n\n        expr = parseNameExpression();\n        if (token === Token.DOT_LT || token === Token.LT) {\n            next();\n            applications = parseTypeExpressionList();\n            expect(Token.GT);\n            return maybeAddRange({\n                type: Syntax.TypeApplication,\n                expression: expr,\n                applications: applications\n            }, [startIndex, previous]);\n        }\n        return expr;\n    }\n\n    // ResultType :=\n    //     <<empty>>\n    //   | ':' void\n    //   | ':' TypeExpression\n    //\n    // BNF is above\n    // but, we remove <<empty>> pattern, so token is always TypeToken::COLON\n    function parseResultType() {\n        consume(Token.COLON, 'ResultType should start with :');\n        if (token === Token.NAME && value === 'void') {\n            consume(Token.NAME);\n            return {\n                type: Syntax.VoidLiteral\n            };\n        }\n        return parseTypeExpression();\n    }\n\n    // ParametersType :=\n    //     RestParameterType\n    //   | NonRestParametersType\n    //   | NonRestParametersType ',' RestParameterType\n    //\n    // RestParameterType :=\n    //     '...'\n    //     '...' Identifier\n    //\n    // NonRestParametersType :=\n    //     ParameterType ',' NonRestParametersType\n    //   | ParameterType\n    //   | OptionalParametersType\n    //\n    // OptionalParametersType :=\n    //     OptionalParameterType\n    //   | OptionalParameterType, OptionalParametersType\n    //\n    // OptionalParameterType := ParameterType=\n    //\n    // ParameterType := TypeExpression | Identifier ':' TypeExpression\n    //\n    // Identifier is \"new\" or \"this\"\n    function parseParametersType() {\n        var params = [], optionalSequence = false, expr, rest = false, startIndex, restStartIndex = index - 3, nameStartIndex;\n\n        while (token !== Token.RPAREN) {\n            if (token === Token.REST) {\n                // RestParameterType\n                consume(Token.REST);\n                rest = true;\n            }\n\n            startIndex = previous;\n\n            expr = parseTypeExpression();\n            if (expr.type === Syntax.NameExpression && token === Token.COLON) {\n                nameStartIndex = previous - expr.name.length;\n                // Identifier ':' TypeExpression\n                consume(Token.COLON);\n                expr = maybeAddRange({\n                    type: Syntax.ParameterType,\n                    name: expr.name,\n                    expression: parseTypeExpression()\n                }, [nameStartIndex, previous]);\n            }\n            if (token === Token.EQUAL) {\n                consume(Token.EQUAL);\n                expr = maybeAddRange({\n                    type: Syntax.OptionalType,\n                    expression: expr\n                }, [startIndex, previous]);\n                optionalSequence = true;\n            } else {\n                if (optionalSequence) {\n                    utility.throwError('unexpected token');\n                }\n            }\n            if (rest) {\n                expr = maybeAddRange({\n                    type: Syntax.RestType,\n                    expression: expr\n                }, [restStartIndex, previous]);\n            }\n            params.push(expr);\n            if (token !== Token.RPAREN) {\n                expect(Token.COMMA);\n            }\n        }\n        return params;\n    }\n\n    // FunctionType := 'function' FunctionSignatureType\n    //\n    // FunctionSignatureType :=\n    //   | TypeParameters '(' ')' ResultType\n    //   | TypeParameters '(' ParametersType ')' ResultType\n    //   | TypeParameters '(' 'this' ':' TypeName ')' ResultType\n    //   | TypeParameters '(' 'this' ':' TypeName ',' ParametersType ')' ResultType\n    function parseFunctionType() {\n        var isNew, thisBinding, params, result, fnType, startIndex = index - value.length;\n        utility.assert(token === Token.NAME && value === 'function', 'FunctionType should start with \\'function\\'');\n        consume(Token.NAME);\n\n        // Google Closure Compiler is not implementing TypeParameters.\n        // So we do not. if we don't get '(', we see it as error.\n        expect(Token.LPAREN);\n\n        isNew = false;\n        params = [];\n        thisBinding = null;\n        if (token !== Token.RPAREN) {\n            // ParametersType or 'this'\n            if (token === Token.NAME &&\n                    (value === 'this' || value === 'new')) {\n                // 'this' or 'new'\n                // 'new' is Closure Compiler extension\n                isNew = value === 'new';\n                consume(Token.NAME);\n                expect(Token.COLON);\n                thisBinding = parseTypeName();\n                if (token === Token.COMMA) {\n                    consume(Token.COMMA);\n                    params = parseParametersType();\n                }\n            } else {\n                params = parseParametersType();\n            }\n        }\n\n        expect(Token.RPAREN);\n\n        result = null;\n        if (token === Token.COLON) {\n            result = parseResultType();\n        }\n\n        fnType = maybeAddRange({\n            type: Syntax.FunctionType,\n            params: params,\n            result: result\n        }, [startIndex, previous]);\n        if (thisBinding) {\n            // avoid adding null 'new' and 'this' properties\n            fnType['this'] = thisBinding;\n            if (isNew) {\n                fnType['new'] = true;\n            }\n        }\n        return fnType;\n    }\n\n    // BasicTypeExpression :=\n    //     '*'\n    //   | 'null'\n    //   | 'undefined'\n    //   | TypeName\n    //   | FunctionType\n    //   | UnionType\n    //   | RecordType\n    //   | ArrayType\n    function parseBasicTypeExpression() {\n        var context, startIndex;\n        switch (token) {\n        case Token.STAR:\n            consume(Token.STAR);\n            return maybeAddRange({\n                type: Syntax.AllLiteral\n            }, [previous - 1, previous]);\n\n        case Token.LPAREN:\n            return parseUnionType();\n\n        case Token.LBRACK:\n            return parseArrayType();\n\n        case Token.LBRACE:\n            return parseRecordType();\n\n        case Token.NAME:\n            startIndex = index - value.length;\n\n            if (value === 'null') {\n                consume(Token.NAME);\n                return maybeAddRange({\n                    type: Syntax.NullLiteral\n                }, [startIndex, previous]);\n            }\n\n            if (value === 'undefined') {\n                consume(Token.NAME);\n                return maybeAddRange({\n                    type: Syntax.UndefinedLiteral\n                }, [startIndex, previous]);\n            }\n\n            if (value === 'true' || value === 'false') {\n                consume(Token.NAME);\n                return maybeAddRange({\n                    type: Syntax.BooleanLiteralType,\n                    value: value === 'true'\n                }, [startIndex, previous]);\n            }\n\n            context = Context.save();\n            if (value === 'function') {\n                try {\n                    return parseFunctionType();\n                } catch (e) {\n                    context.restore();\n                }\n            }\n\n            return parseTypeName();\n\n        case Token.STRING:\n            next();\n            return maybeAddRange({\n                type: Syntax.StringLiteralType,\n                value: value\n            }, [previous - value.length - 2, previous]);\n\n        case Token.NUMBER:\n            next();\n            return maybeAddRange({\n                type: Syntax.NumericLiteralType,\n                value: value\n            }, [previous - String(value).length, previous]);\n\n        default:\n            utility.throwError('unexpected token');\n        }\n    }\n\n    // TypeExpression :=\n    //     BasicTypeExpression\n    //   | '?' BasicTypeExpression\n    //   | '!' BasicTypeExpression\n    //   | BasicTypeExpression '?'\n    //   | BasicTypeExpression '!'\n    //   | '?'\n    //   | BasicTypeExpression '[]'\n    function parseTypeExpression() {\n        var expr, rangeStart;\n\n        if (token === Token.QUESTION) {\n            rangeStart = index - 1;\n            consume(Token.QUESTION);\n            if (token === Token.COMMA || token === Token.EQUAL || token === Token.RBRACE ||\n                    token === Token.RPAREN || token === Token.PIPE || token === Token.EOF ||\n                    token === Token.RBRACK || token === Token.GT) {\n                return maybeAddRange({\n                    type: Syntax.NullableLiteral\n                }, [rangeStart, previous]);\n            }\n            return maybeAddRange({\n                type: Syntax.NullableType,\n                expression: parseBasicTypeExpression(),\n                prefix: true\n            }, [rangeStart, previous]);\n        } else if (token === Token.BANG) {\n            rangeStart = index - 1;\n            consume(Token.BANG);\n            return maybeAddRange({\n                type: Syntax.NonNullableType,\n                expression: parseBasicTypeExpression(),\n                prefix: true\n            }, [rangeStart, previous]);\n        } else {\n            rangeStart = previous;\n        }\n\n        expr = parseBasicTypeExpression();\n        if (token === Token.BANG) {\n            consume(Token.BANG);\n            return maybeAddRange({\n                type: Syntax.NonNullableType,\n                expression: expr,\n                prefix: false\n            }, [rangeStart, previous]);\n        }\n\n        if (token === Token.QUESTION) {\n            consume(Token.QUESTION);\n            return maybeAddRange({\n                type: Syntax.NullableType,\n                expression: expr,\n                prefix: false\n            }, [rangeStart, previous]);\n        }\n\n        if (token === Token.LBRACK) {\n            consume(Token.LBRACK);\n            expect(Token.RBRACK, 'expected an array-style type declaration (' + value + '[])');\n            return maybeAddRange({\n                type: Syntax.TypeApplication,\n                expression: maybeAddRange({\n                    type: Syntax.NameExpression,\n                    name: 'Array'\n                }, [rangeStart, previous]),\n                applications: [expr]\n            }, [rangeStart, previous]);\n        }\n\n        return expr;\n    }\n\n    // TopLevelTypeExpression :=\n    //      TypeExpression\n    //    | TypeUnionList\n    //\n    // This rule is Google Closure Compiler extension, not ES4\n    // like,\n    //   { number | string }\n    // If strict to ES4, we should write it as\n    //   { (number|string) }\n    function parseTop() {\n        var expr, elements;\n\n        expr = parseTypeExpression();\n        if (token !== Token.PIPE) {\n            return expr;\n        }\n\n        elements = [expr];\n        consume(Token.PIPE);\n        while (true) {\n            elements.push(parseTypeExpression());\n            if (token !== Token.PIPE) {\n                break;\n            }\n            consume(Token.PIPE);\n        }\n\n        return maybeAddRange({\n            type: Syntax.UnionType,\n            elements: elements\n        }, [0, index]);\n    }\n\n    function parseTopParamType() {\n        var expr;\n\n        if (token === Token.REST) {\n            consume(Token.REST);\n            return maybeAddRange({\n                type: Syntax.RestType,\n                expression: parseTop()\n            }, [0, index]);\n        }\n\n        expr = parseTop();\n        if (token === Token.EQUAL) {\n            consume(Token.EQUAL);\n            return maybeAddRange({\n                type: Syntax.OptionalType,\n                expression: expr\n            }, [0, index]);\n        }\n\n        return expr;\n    }\n\n    function parseType(src, opt) {\n        var expr;\n\n        source = src;\n        length = source.length;\n        index = 0;\n        previous = 0;\n        addRange = opt && opt.range;\n        rangeOffset = opt && opt.startIndex || 0;\n\n        next();\n        expr = parseTop();\n\n        if (opt && opt.midstream) {\n            return {\n                expression: expr,\n                index: previous\n            };\n        }\n\n        if (token !== Token.EOF) {\n            utility.throwError('not reach to EOF');\n        }\n\n        return expr;\n    }\n\n    function parseParamType(src, opt) {\n        var expr;\n\n        source = src;\n        length = source.length;\n        index = 0;\n        previous = 0;\n        addRange = opt && opt.range;\n        rangeOffset = opt && opt.startIndex || 0;\n\n        next();\n        expr = parseTopParamType();\n\n        if (opt && opt.midstream) {\n            return {\n                expression: expr,\n                index: previous\n            };\n        }\n\n        if (token !== Token.EOF) {\n            utility.throwError('not reach to EOF');\n        }\n\n        return expr;\n    }\n\n    function stringifyImpl(node, compact, topLevel) {\n        var result, i, iz;\n\n        switch (node.type) {\n        case Syntax.NullableLiteral:\n            result = '?';\n            break;\n\n        case Syntax.AllLiteral:\n            result = '*';\n            break;\n\n        case Syntax.NullLiteral:\n            result = 'null';\n            break;\n\n        case Syntax.UndefinedLiteral:\n            result = 'undefined';\n            break;\n\n        case Syntax.VoidLiteral:\n            result = 'void';\n            break;\n\n        case Syntax.UnionType:\n            if (!topLevel) {\n                result = '(';\n            } else {\n                result = '';\n            }\n\n            for (i = 0, iz = node.elements.length; i < iz; ++i) {\n                result += stringifyImpl(node.elements[i], compact);\n                if ((i + 1) !== iz) {\n                    result += compact ? '|' : ' | ';\n                }\n            }\n\n            if (!topLevel) {\n                result += ')';\n            }\n            break;\n\n        case Syntax.ArrayType:\n            result = '[';\n            for (i = 0, iz = node.elements.length; i < iz; ++i) {\n                result += stringifyImpl(node.elements[i], compact);\n                if ((i + 1) !== iz) {\n                    result += compact ? ',' : ', ';\n                }\n            }\n            result += ']';\n            break;\n\n        case Syntax.RecordType:\n            result = '{';\n            for (i = 0, iz = node.fields.length; i < iz; ++i) {\n                result += stringifyImpl(node.fields[i], compact);\n                if ((i + 1) !== iz) {\n                    result += compact ? ',' : ', ';\n                }\n            }\n            result += '}';\n            break;\n\n        case Syntax.FieldType:\n            if (node.value) {\n                result = node.key + (compact ? ':' : ': ') + stringifyImpl(node.value, compact);\n            } else {\n                result = node.key;\n            }\n            break;\n\n        case Syntax.FunctionType:\n            result = compact ? 'function(' : 'function (';\n\n            if (node['this']) {\n                if (node['new']) {\n                    result += (compact ? 'new:' : 'new: ');\n                } else {\n                    result += (compact ? 'this:' : 'this: ');\n                }\n\n                result += stringifyImpl(node['this'], compact);\n\n                if (node.params.length !== 0) {\n                    result += compact ? ',' : ', ';\n                }\n            }\n\n            for (i = 0, iz = node.params.length; i < iz; ++i) {\n                result += stringifyImpl(node.params[i], compact);\n                if ((i + 1) !== iz) {\n                    result += compact ? ',' : ', ';\n                }\n            }\n\n            result += ')';\n\n            if (node.result) {\n                result += (compact ? ':' : ': ') + stringifyImpl(node.result, compact);\n            }\n            break;\n\n        case Syntax.ParameterType:\n            result = node.name + (compact ? ':' : ': ') + stringifyImpl(node.expression, compact);\n            break;\n\n        case Syntax.RestType:\n            result = '...';\n            if (node.expression) {\n                result += stringifyImpl(node.expression, compact);\n            }\n            break;\n\n        case Syntax.NonNullableType:\n            if (node.prefix) {\n                result = '!' + stringifyImpl(node.expression, compact);\n            } else {\n                result = stringifyImpl(node.expression, compact) + '!';\n            }\n            break;\n\n        case Syntax.OptionalType:\n            result = stringifyImpl(node.expression, compact) + '=';\n            break;\n\n        case Syntax.NullableType:\n            if (node.prefix) {\n                result = '?' + stringifyImpl(node.expression, compact);\n            } else {\n                result = stringifyImpl(node.expression, compact) + '?';\n            }\n            break;\n\n        case Syntax.NameExpression:\n            result = node.name;\n            break;\n\n        case Syntax.TypeApplication:\n            result = stringifyImpl(node.expression, compact) + '.<';\n            for (i = 0, iz = node.applications.length; i < iz; ++i) {\n                result += stringifyImpl(node.applications[i], compact);\n                if ((i + 1) !== iz) {\n                    result += compact ? ',' : ', ';\n                }\n            }\n            result += '>';\n            break;\n\n        case Syntax.StringLiteralType:\n            result = '\"' + node.value + '\"';\n            break;\n\n        case Syntax.NumericLiteralType:\n            result = String(node.value);\n            break;\n\n        case Syntax.BooleanLiteralType:\n            result = String(node.value);\n            break;\n\n        default:\n            utility.throwError('Unknown type ' + node.type);\n        }\n\n        return result;\n    }\n\n    function stringify(node, options) {\n        if (options == null) {\n            options = {};\n        }\n        return stringifyImpl(node, options.compact, options.topLevel);\n    }\n\n    exports.parseType = parseType;\n    exports.parseParamType = parseParamType;\n    exports.stringify = stringify;\n    exports.Syntax = Syntax;\n}());\n/* vim: set sw=4 ts=4 et tw=80 : */\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}