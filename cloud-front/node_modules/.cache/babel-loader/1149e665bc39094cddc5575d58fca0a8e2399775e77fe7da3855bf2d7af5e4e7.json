{"ast":null,"code":"/**\n * @fileoverview Checks for unreachable code due to return, throws, break, and continue.\n * @author Joel Feenstra\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given variable declarator has the initializer.\n * @param {ASTNode} node A VariableDeclarator node to check.\n * @returns {boolean} `true` if the node has the initializer.\n */\nfunction isInitialized(node) {\n  return Boolean(node.init);\n}\n\n/**\n * Checks whether or not a given code path segment is unreachable.\n * @param {CodePathSegment} segment A CodePathSegment to check.\n * @returns {boolean} `true` if the segment is unreachable.\n */\nfunction isUnreachable(segment) {\n  return !segment.reachable;\n}\n\n/**\n * The class to distinguish consecutive unreachable statements.\n */\nclass ConsecutiveRange {\n  constructor(sourceCode) {\n    this.sourceCode = sourceCode;\n    this.startNode = null;\n    this.endNode = null;\n  }\n\n  /**\n   * The location object of this range.\n   * @type {Object}\n   */\n  get location() {\n    return {\n      start: this.startNode.loc.start,\n      end: this.endNode.loc.end\n    };\n  }\n\n  /**\n   * `true` if this range is empty.\n   * @type {boolean}\n   */\n  get isEmpty() {\n    return !(this.startNode && this.endNode);\n  }\n\n  /**\n   * Checks whether the given node is inside of this range.\n   * @param {ASTNode|Token} node The node to check.\n   * @returns {boolean} `true` if the node is inside of this range.\n   */\n  contains(node) {\n    return node.range[0] >= this.startNode.range[0] && node.range[1] <= this.endNode.range[1];\n  }\n\n  /**\n   * Checks whether the given node is consecutive to this range.\n   * @param {ASTNode} node The node to check.\n   * @returns {boolean} `true` if the node is consecutive to this range.\n   */\n  isConsecutive(node) {\n    return this.contains(this.sourceCode.getTokenBefore(node));\n  }\n\n  /**\n   * Merges the given node to this range.\n   * @param {ASTNode} node The node to merge.\n   * @returns {void}\n   */\n  merge(node) {\n    this.endNode = node;\n  }\n\n  /**\n   * Resets this range by the given node or null.\n   * @param {ASTNode|null} node The node to reset, or null.\n   * @returns {void}\n   */\n  reset(node) {\n    this.startNode = this.endNode = node;\n  }\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow unreachable code after `return`, `throw`, `continue`, and `break` statements\",\n      category: \"Possible Errors\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-unreachable\"\n    },\n    schema: [],\n    messages: {\n      unreachableCode: \"Unreachable code.\"\n    }\n  },\n  create(context) {\n    let currentCodePath = null;\n    const range = new ConsecutiveRange(context.getSourceCode());\n\n    /**\n     * Reports a given node if it's unreachable.\n     * @param {ASTNode} node A statement node to report.\n     * @returns {void}\n     */\n    function reportIfUnreachable(node) {\n      let nextNode = null;\n      if (node && currentCodePath.currentSegments.every(isUnreachable)) {\n        // Store this statement to distinguish consecutive statements.\n        if (range.isEmpty) {\n          range.reset(node);\n          return;\n        }\n\n        // Skip if this statement is inside of the current range.\n        if (range.contains(node)) {\n          return;\n        }\n\n        // Merge if this statement is consecutive to the current range.\n        if (range.isConsecutive(node)) {\n          range.merge(node);\n          return;\n        }\n        nextNode = node;\n      }\n\n      /*\n       * Report the current range since this statement is reachable or is\n       * not consecutive to the current range.\n       */\n      if (!range.isEmpty) {\n        context.report({\n          messageId: \"unreachableCode\",\n          loc: range.location,\n          node: range.startNode\n        });\n      }\n\n      // Update the current range.\n      range.reset(nextNode);\n    }\n    return {\n      // Manages the current code path.\n      onCodePathStart(codePath) {\n        currentCodePath = codePath;\n      },\n      onCodePathEnd() {\n        currentCodePath = currentCodePath.upper;\n      },\n      // Registers for all statement nodes (excludes FunctionDeclaration).\n      BlockStatement: reportIfUnreachable,\n      BreakStatement: reportIfUnreachable,\n      ClassDeclaration: reportIfUnreachable,\n      ContinueStatement: reportIfUnreachable,\n      DebuggerStatement: reportIfUnreachable,\n      DoWhileStatement: reportIfUnreachable,\n      ExpressionStatement: reportIfUnreachable,\n      ForInStatement: reportIfUnreachable,\n      ForOfStatement: reportIfUnreachable,\n      ForStatement: reportIfUnreachable,\n      IfStatement: reportIfUnreachable,\n      ImportDeclaration: reportIfUnreachable,\n      LabeledStatement: reportIfUnreachable,\n      ReturnStatement: reportIfUnreachable,\n      SwitchStatement: reportIfUnreachable,\n      ThrowStatement: reportIfUnreachable,\n      TryStatement: reportIfUnreachable,\n      VariableDeclaration(node) {\n        if (node.kind !== \"var\" || node.declarations.some(isInitialized)) {\n          reportIfUnreachable(node);\n        }\n      },\n      WhileStatement: reportIfUnreachable,\n      WithStatement: reportIfUnreachable,\n      ExportNamedDeclaration: reportIfUnreachable,\n      ExportDefaultDeclaration: reportIfUnreachable,\n      ExportAllDeclaration: reportIfUnreachable,\n      \"Program:exit\"() {\n        reportIfUnreachable();\n      }\n    };\n  }\n};","map":{"version":3,"names":["isInitialized","node","Boolean","init","isUnreachable","segment","reachable","ConsecutiveRange","constructor","sourceCode","startNode","endNode","location","start","loc","end","isEmpty","contains","range","isConsecutive","getTokenBefore","merge","reset","module","exports","meta","type","docs","description","category","recommended","url","schema","messages","unreachableCode","create","context","currentCodePath","getSourceCode","reportIfUnreachable","nextNode","currentSegments","every","report","messageId","onCodePathStart","codePath","onCodePathEnd","upper","BlockStatement","BreakStatement","ClassDeclaration","ContinueStatement","DebuggerStatement","DoWhileStatement","ExpressionStatement","ForInStatement","ForOfStatement","ForStatement","IfStatement","ImportDeclaration","LabeledStatement","ReturnStatement","SwitchStatement","ThrowStatement","TryStatement","VariableDeclaration","kind","declarations","some","WhileStatement","WithStatement","ExportNamedDeclaration","ExportDefaultDeclaration","ExportAllDeclaration","Program:exit"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/no-unreachable.js"],"sourcesContent":["/**\n * @fileoverview Checks for unreachable code due to return, throws, break, and continue.\n * @author Joel Feenstra\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given variable declarator has the initializer.\n * @param {ASTNode} node A VariableDeclarator node to check.\n * @returns {boolean} `true` if the node has the initializer.\n */\nfunction isInitialized(node) {\n    return Boolean(node.init);\n}\n\n/**\n * Checks whether or not a given code path segment is unreachable.\n * @param {CodePathSegment} segment A CodePathSegment to check.\n * @returns {boolean} `true` if the segment is unreachable.\n */\nfunction isUnreachable(segment) {\n    return !segment.reachable;\n}\n\n/**\n * The class to distinguish consecutive unreachable statements.\n */\nclass ConsecutiveRange {\n    constructor(sourceCode) {\n        this.sourceCode = sourceCode;\n        this.startNode = null;\n        this.endNode = null;\n    }\n\n    /**\n     * The location object of this range.\n     * @type {Object}\n     */\n    get location() {\n        return {\n            start: this.startNode.loc.start,\n            end: this.endNode.loc.end\n        };\n    }\n\n    /**\n     * `true` if this range is empty.\n     * @type {boolean}\n     */\n    get isEmpty() {\n        return !(this.startNode && this.endNode);\n    }\n\n    /**\n     * Checks whether the given node is inside of this range.\n     * @param {ASTNode|Token} node The node to check.\n     * @returns {boolean} `true` if the node is inside of this range.\n     */\n    contains(node) {\n        return (\n            node.range[0] >= this.startNode.range[0] &&\n            node.range[1] <= this.endNode.range[1]\n        );\n    }\n\n    /**\n     * Checks whether the given node is consecutive to this range.\n     * @param {ASTNode} node The node to check.\n     * @returns {boolean} `true` if the node is consecutive to this range.\n     */\n    isConsecutive(node) {\n        return this.contains(this.sourceCode.getTokenBefore(node));\n    }\n\n    /**\n     * Merges the given node to this range.\n     * @param {ASTNode} node The node to merge.\n     * @returns {void}\n     */\n    merge(node) {\n        this.endNode = node;\n    }\n\n    /**\n     * Resets this range by the given node or null.\n     * @param {ASTNode|null} node The node to reset, or null.\n     * @returns {void}\n     */\n    reset(node) {\n        this.startNode = this.endNode = node;\n    }\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow unreachable code after `return`, `throw`, `continue`, and `break` statements\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-unreachable\"\n        },\n\n        schema: [],\n\n        messages: {\n            unreachableCode: \"Unreachable code.\"\n        }\n    },\n\n    create(context) {\n        let currentCodePath = null;\n\n        const range = new ConsecutiveRange(context.getSourceCode());\n\n        /**\n         * Reports a given node if it's unreachable.\n         * @param {ASTNode} node A statement node to report.\n         * @returns {void}\n         */\n        function reportIfUnreachable(node) {\n            let nextNode = null;\n\n            if (node && currentCodePath.currentSegments.every(isUnreachable)) {\n\n                // Store this statement to distinguish consecutive statements.\n                if (range.isEmpty) {\n                    range.reset(node);\n                    return;\n                }\n\n                // Skip if this statement is inside of the current range.\n                if (range.contains(node)) {\n                    return;\n                }\n\n                // Merge if this statement is consecutive to the current range.\n                if (range.isConsecutive(node)) {\n                    range.merge(node);\n                    return;\n                }\n\n                nextNode = node;\n            }\n\n            /*\n             * Report the current range since this statement is reachable or is\n             * not consecutive to the current range.\n             */\n            if (!range.isEmpty) {\n                context.report({\n                    messageId: \"unreachableCode\",\n                    loc: range.location,\n                    node: range.startNode\n                });\n            }\n\n            // Update the current range.\n            range.reset(nextNode);\n        }\n\n        return {\n\n            // Manages the current code path.\n            onCodePathStart(codePath) {\n                currentCodePath = codePath;\n            },\n\n            onCodePathEnd() {\n                currentCodePath = currentCodePath.upper;\n            },\n\n            // Registers for all statement nodes (excludes FunctionDeclaration).\n            BlockStatement: reportIfUnreachable,\n            BreakStatement: reportIfUnreachable,\n            ClassDeclaration: reportIfUnreachable,\n            ContinueStatement: reportIfUnreachable,\n            DebuggerStatement: reportIfUnreachable,\n            DoWhileStatement: reportIfUnreachable,\n            ExpressionStatement: reportIfUnreachable,\n            ForInStatement: reportIfUnreachable,\n            ForOfStatement: reportIfUnreachable,\n            ForStatement: reportIfUnreachable,\n            IfStatement: reportIfUnreachable,\n            ImportDeclaration: reportIfUnreachable,\n            LabeledStatement: reportIfUnreachable,\n            ReturnStatement: reportIfUnreachable,\n            SwitchStatement: reportIfUnreachable,\n            ThrowStatement: reportIfUnreachable,\n            TryStatement: reportIfUnreachable,\n\n            VariableDeclaration(node) {\n                if (node.kind !== \"var\" || node.declarations.some(isInitialized)) {\n                    reportIfUnreachable(node);\n                }\n            },\n\n            WhileStatement: reportIfUnreachable,\n            WithStatement: reportIfUnreachable,\n            ExportNamedDeclaration: reportIfUnreachable,\n            ExportDefaultDeclaration: reportIfUnreachable,\n            ExportAllDeclaration: reportIfUnreachable,\n\n            \"Program:exit\"() {\n                reportIfUnreachable();\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}