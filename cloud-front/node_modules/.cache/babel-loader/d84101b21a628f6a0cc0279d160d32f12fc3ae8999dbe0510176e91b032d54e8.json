{"ast":null,"code":"/**\n * @fileoverview Enforce return after a callback.\n * @author Jamund Ferguson\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\nmodule.exports = {\n  meta: {\n    deprecated: true,\n    replacedBy: [],\n    type: \"suggestion\",\n    docs: {\n      description: \"require `return` statements after callbacks\",\n      category: \"Node.js and CommonJS\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/callback-return\"\n    },\n    schema: [{\n      type: \"array\",\n      items: {\n        type: \"string\"\n      }\n    }],\n    messages: {\n      missingReturn: \"Expected return with your callback function.\"\n    }\n  },\n  create(context) {\n    const callbacks = context.options[0] || [\"callback\", \"cb\", \"next\"],\n      sourceCode = context.getSourceCode();\n\n    //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    /**\n     * Find the closest parent matching a list of types.\n     * @param {ASTNode} node The node whose parents we are searching\n     * @param {Array} types The node types to match\n     * @returns {ASTNode} The matched node or undefined.\n     */\n    function findClosestParentOfType(node, types) {\n      if (!node.parent) {\n        return null;\n      }\n      if (types.indexOf(node.parent.type) === -1) {\n        return findClosestParentOfType(node.parent, types);\n      }\n      return node.parent;\n    }\n\n    /**\n     * Check to see if a node contains only identifiers\n     * @param {ASTNode} node The node to check\n     * @returns {boolean} Whether or not the node contains only identifiers\n     */\n    function containsOnlyIdentifiers(node) {\n      if (node.type === \"Identifier\") {\n        return true;\n      }\n      if (node.type === \"MemberExpression\") {\n        if (node.object.type === \"Identifier\") {\n          return true;\n        }\n        if (node.object.type === \"MemberExpression\") {\n          return containsOnlyIdentifiers(node.object);\n        }\n      }\n      return false;\n    }\n\n    /**\n     * Check to see if a CallExpression is in our callback list.\n     * @param {ASTNode} node The node to check against our callback names list.\n     * @returns {boolean} Whether or not this function matches our callback name.\n     */\n    function isCallback(node) {\n      return containsOnlyIdentifiers(node.callee) && callbacks.indexOf(sourceCode.getText(node.callee)) > -1;\n    }\n\n    /**\n     * Determines whether or not the callback is part of a callback expression.\n     * @param {ASTNode} node The callback node\n     * @param {ASTNode} parentNode The expression node\n     * @returns {boolean} Whether or not this is part of a callback expression\n     */\n    function isCallbackExpression(node, parentNode) {\n      // ensure the parent node exists and is an expression\n      if (!parentNode || parentNode.type !== \"ExpressionStatement\") {\n        return false;\n      }\n\n      // cb()\n      if (parentNode.expression === node) {\n        return true;\n      }\n\n      // special case for cb && cb() and similar\n      if (parentNode.expression.type === \"BinaryExpression\" || parentNode.expression.type === \"LogicalExpression\") {\n        if (parentNode.expression.right === node) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    return {\n      CallExpression(node) {\n        // if we're not a callback we can return\n        if (!isCallback(node)) {\n          return;\n        }\n\n        // find the closest block, return or loop\n        const closestBlock = findClosestParentOfType(node, [\"BlockStatement\", \"ReturnStatement\", \"ArrowFunctionExpression\"]) || {};\n\n        // if our parent is a return we know we're ok\n        if (closestBlock.type === \"ReturnStatement\") {\n          return;\n        }\n\n        // arrow functions don't always have blocks and implicitly return\n        if (closestBlock.type === \"ArrowFunctionExpression\") {\n          return;\n        }\n\n        // block statements are part of functions and most if statements\n        if (closestBlock.type === \"BlockStatement\") {\n          // find the last item in the block\n          const lastItem = closestBlock.body[closestBlock.body.length - 1];\n\n          // if the callback is the last thing in a block that might be ok\n          if (isCallbackExpression(node, lastItem)) {\n            const parentType = closestBlock.parent.type;\n\n            // but only if the block is part of a function\n            if (parentType === \"FunctionExpression\" || parentType === \"FunctionDeclaration\" || parentType === \"ArrowFunctionExpression\") {\n              return;\n            }\n          }\n\n          // ending a block with a return is also ok\n          if (lastItem.type === \"ReturnStatement\") {\n            // but only if the callback is immediately before\n            if (isCallbackExpression(node, closestBlock.body[closestBlock.body.length - 2])) {\n              return;\n            }\n          }\n        }\n\n        // as long as you're the child of a function at this point you should be asked to return\n        if (findClosestParentOfType(node, [\"FunctionDeclaration\", \"FunctionExpression\", \"ArrowFunctionExpression\"])) {\n          context.report({\n            node,\n            messageId: \"missingReturn\"\n          });\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["module","exports","meta","deprecated","replacedBy","type","docs","description","category","recommended","url","schema","items","messages","missingReturn","create","context","callbacks","options","sourceCode","getSourceCode","findClosestParentOfType","node","types","parent","indexOf","containsOnlyIdentifiers","object","isCallback","callee","getText","isCallbackExpression","parentNode","expression","right","CallExpression","closestBlock","lastItem","body","length","parentType","report","messageId"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/callback-return.js"],"sourcesContent":["/**\n * @fileoverview Enforce return after a callback.\n * @author Jamund Ferguson\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        deprecated: true,\n\n        replacedBy: [],\n\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require `return` statements after callbacks\",\n            category: \"Node.js and CommonJS\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/callback-return\"\n        },\n\n        schema: [{\n            type: \"array\",\n            items: { type: \"string\" }\n        }],\n\n        messages: {\n            missingReturn: \"Expected return with your callback function.\"\n        }\n    },\n\n    create(context) {\n\n        const callbacks = context.options[0] || [\"callback\", \"cb\", \"next\"],\n            sourceCode = context.getSourceCode();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Find the closest parent matching a list of types.\n         * @param {ASTNode} node The node whose parents we are searching\n         * @param {Array} types The node types to match\n         * @returns {ASTNode} The matched node or undefined.\n         */\n        function findClosestParentOfType(node, types) {\n            if (!node.parent) {\n                return null;\n            }\n            if (types.indexOf(node.parent.type) === -1) {\n                return findClosestParentOfType(node.parent, types);\n            }\n            return node.parent;\n        }\n\n        /**\n         * Check to see if a node contains only identifiers\n         * @param {ASTNode} node The node to check\n         * @returns {boolean} Whether or not the node contains only identifiers\n         */\n        function containsOnlyIdentifiers(node) {\n            if (node.type === \"Identifier\") {\n                return true;\n            }\n\n            if (node.type === \"MemberExpression\") {\n                if (node.object.type === \"Identifier\") {\n                    return true;\n                }\n                if (node.object.type === \"MemberExpression\") {\n                    return containsOnlyIdentifiers(node.object);\n                }\n            }\n\n            return false;\n        }\n\n        /**\n         * Check to see if a CallExpression is in our callback list.\n         * @param {ASTNode} node The node to check against our callback names list.\n         * @returns {boolean} Whether or not this function matches our callback name.\n         */\n        function isCallback(node) {\n            return containsOnlyIdentifiers(node.callee) && callbacks.indexOf(sourceCode.getText(node.callee)) > -1;\n        }\n\n        /**\n         * Determines whether or not the callback is part of a callback expression.\n         * @param {ASTNode} node The callback node\n         * @param {ASTNode} parentNode The expression node\n         * @returns {boolean} Whether or not this is part of a callback expression\n         */\n        function isCallbackExpression(node, parentNode) {\n\n            // ensure the parent node exists and is an expression\n            if (!parentNode || parentNode.type !== \"ExpressionStatement\") {\n                return false;\n            }\n\n            // cb()\n            if (parentNode.expression === node) {\n                return true;\n            }\n\n            // special case for cb && cb() and similar\n            if (parentNode.expression.type === \"BinaryExpression\" || parentNode.expression.type === \"LogicalExpression\") {\n                if (parentNode.expression.right === node) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            CallExpression(node) {\n\n                // if we're not a callback we can return\n                if (!isCallback(node)) {\n                    return;\n                }\n\n                // find the closest block, return or loop\n                const closestBlock = findClosestParentOfType(node, [\"BlockStatement\", \"ReturnStatement\", \"ArrowFunctionExpression\"]) || {};\n\n                // if our parent is a return we know we're ok\n                if (closestBlock.type === \"ReturnStatement\") {\n                    return;\n                }\n\n                // arrow functions don't always have blocks and implicitly return\n                if (closestBlock.type === \"ArrowFunctionExpression\") {\n                    return;\n                }\n\n                // block statements are part of functions and most if statements\n                if (closestBlock.type === \"BlockStatement\") {\n\n                    // find the last item in the block\n                    const lastItem = closestBlock.body[closestBlock.body.length - 1];\n\n                    // if the callback is the last thing in a block that might be ok\n                    if (isCallbackExpression(node, lastItem)) {\n\n                        const parentType = closestBlock.parent.type;\n\n                        // but only if the block is part of a function\n                        if (parentType === \"FunctionExpression\" ||\n                            parentType === \"FunctionDeclaration\" ||\n                            parentType === \"ArrowFunctionExpression\"\n                        ) {\n                            return;\n                        }\n\n                    }\n\n                    // ending a block with a return is also ok\n                    if (lastItem.type === \"ReturnStatement\") {\n\n                        // but only if the callback is immediately before\n                        if (isCallbackExpression(node, closestBlock.body[closestBlock.body.length - 2])) {\n                            return;\n                        }\n                    }\n\n                }\n\n                // as long as you're the child of a function at this point you should be asked to return\n                if (findClosestParentOfType(node, [\"FunctionDeclaration\", \"FunctionExpression\", \"ArrowFunctionExpression\"])) {\n                    context.report({ node, messageId: \"missingReturn\" });\n                }\n\n            }\n\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}