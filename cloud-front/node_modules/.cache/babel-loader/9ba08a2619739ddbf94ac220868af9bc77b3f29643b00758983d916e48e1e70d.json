{"ast":null,"code":"/**\n * @fileoverview Rule to flag assignment in a conditional statement's test expression\n * @author Stephen Murray <spmurrayzzz>\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst TEST_CONDITION_PARENT_TYPES = new Set([\"IfStatement\", \"WhileStatement\", \"DoWhileStatement\", \"ForStatement\", \"ConditionalExpression\"]);\nconst NODE_DESCRIPTIONS = {\n  DoWhileStatement: \"a 'do...while' statement\",\n  ForStatement: \"a 'for' statement\",\n  IfStatement: \"an 'if' statement\",\n  WhileStatement: \"a 'while' statement\"\n};\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow assignment operators in conditional expressions\",\n      category: \"Possible Errors\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-cond-assign\"\n    },\n    schema: [{\n      enum: [\"except-parens\", \"always\"]\n    }],\n    messages: {\n      unexpected: \"Unexpected assignment within {{type}}.\",\n      // must match JSHint's error message\n      missing: \"Expected a conditional expression and instead saw an assignment.\"\n    }\n  },\n  create(context) {\n    const prohibitAssign = context.options[0] || \"except-parens\";\n    const sourceCode = context.getSourceCode();\n\n    /**\n     * Check whether an AST node is the test expression for a conditional statement.\n     * @param {!Object} node The node to test.\n     * @returns {boolean} `true` if the node is the text expression for a conditional statement; otherwise, `false`.\n     */\n    function isConditionalTestExpression(node) {\n      return node.parent && TEST_CONDITION_PARENT_TYPES.has(node.parent.type) && node === node.parent.test;\n    }\n\n    /**\n     * Given an AST node, perform a bottom-up search for the first ancestor that represents a conditional statement.\n     * @param {!Object} node The node to use at the start of the search.\n     * @returns {?Object} The closest ancestor node that represents a conditional statement.\n     */\n    function findConditionalAncestor(node) {\n      let currentAncestor = node;\n      do {\n        if (isConditionalTestExpression(currentAncestor)) {\n          return currentAncestor.parent;\n        }\n      } while ((currentAncestor = currentAncestor.parent) && !astUtils.isFunction(currentAncestor));\n      return null;\n    }\n\n    /**\n     * Check whether the code represented by an AST node is enclosed in two sets of parentheses.\n     * @param {!Object} node The node to test.\n     * @returns {boolean} `true` if the code is enclosed in two sets of parentheses; otherwise, `false`.\n     */\n    function isParenthesisedTwice(node) {\n      const previousToken = sourceCode.getTokenBefore(node, 1),\n        nextToken = sourceCode.getTokenAfter(node, 1);\n      return astUtils.isParenthesised(sourceCode, node) && previousToken && astUtils.isOpeningParenToken(previousToken) && previousToken.range[1] <= node.range[0] && astUtils.isClosingParenToken(nextToken) && nextToken.range[0] >= node.range[1];\n    }\n\n    /**\n     * Check a conditional statement's test expression for top-level assignments that are not enclosed in parentheses.\n     * @param {!Object} node The node for the conditional statement.\n     * @returns {void}\n     */\n    function testForAssign(node) {\n      if (node.test && node.test.type === \"AssignmentExpression\" && (node.type === \"ForStatement\" ? !astUtils.isParenthesised(sourceCode, node.test) : !isParenthesisedTwice(node.test))) {\n        context.report({\n          node: node.test,\n          messageId: \"missing\"\n        });\n      }\n    }\n\n    /**\n     * Check whether an assignment expression is descended from a conditional statement's test expression.\n     * @param {!Object} node The node for the assignment expression.\n     * @returns {void}\n     */\n    function testForConditionalAncestor(node) {\n      const ancestor = findConditionalAncestor(node);\n      if (ancestor) {\n        context.report({\n          node,\n          messageId: \"unexpected\",\n          data: {\n            type: NODE_DESCRIPTIONS[ancestor.type] || ancestor.type\n          }\n        });\n      }\n    }\n    if (prohibitAssign === \"always\") {\n      return {\n        AssignmentExpression: testForConditionalAncestor\n      };\n    }\n    return {\n      DoWhileStatement: testForAssign,\n      ForStatement: testForAssign,\n      IfStatement: testForAssign,\n      WhileStatement: testForAssign,\n      ConditionalExpression: testForAssign\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","TEST_CONDITION_PARENT_TYPES","Set","NODE_DESCRIPTIONS","DoWhileStatement","ForStatement","IfStatement","WhileStatement","module","exports","meta","type","docs","description","category","recommended","url","schema","enum","messages","unexpected","missing","create","context","prohibitAssign","options","sourceCode","getSourceCode","isConditionalTestExpression","node","parent","has","test","findConditionalAncestor","currentAncestor","isFunction","isParenthesisedTwice","previousToken","getTokenBefore","nextToken","getTokenAfter","isParenthesised","isOpeningParenToken","range","isClosingParenToken","testForAssign","report","messageId","testForConditionalAncestor","ancestor","data","AssignmentExpression","ConditionalExpression"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/no-cond-assign.js"],"sourcesContent":["/**\n * @fileoverview Rule to flag assignment in a conditional statement's test expression\n * @author Stephen Murray <spmurrayzzz>\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst TEST_CONDITION_PARENT_TYPES = new Set([\"IfStatement\", \"WhileStatement\", \"DoWhileStatement\", \"ForStatement\", \"ConditionalExpression\"]);\n\nconst NODE_DESCRIPTIONS = {\n    DoWhileStatement: \"a 'do...while' statement\",\n    ForStatement: \"a 'for' statement\",\n    IfStatement: \"an 'if' statement\",\n    WhileStatement: \"a 'while' statement\"\n};\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow assignment operators in conditional expressions\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-cond-assign\"\n        },\n\n        schema: [\n            {\n                enum: [\"except-parens\", \"always\"]\n            }\n        ],\n\n        messages: {\n            unexpected: \"Unexpected assignment within {{type}}.\",\n\n            // must match JSHint's error message\n            missing: \"Expected a conditional expression and instead saw an assignment.\"\n        }\n    },\n\n    create(context) {\n\n        const prohibitAssign = (context.options[0] || \"except-parens\");\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Check whether an AST node is the test expression for a conditional statement.\n         * @param {!Object} node The node to test.\n         * @returns {boolean} `true` if the node is the text expression for a conditional statement; otherwise, `false`.\n         */\n        function isConditionalTestExpression(node) {\n            return node.parent &&\n                TEST_CONDITION_PARENT_TYPES.has(node.parent.type) &&\n                node === node.parent.test;\n        }\n\n        /**\n         * Given an AST node, perform a bottom-up search for the first ancestor that represents a conditional statement.\n         * @param {!Object} node The node to use at the start of the search.\n         * @returns {?Object} The closest ancestor node that represents a conditional statement.\n         */\n        function findConditionalAncestor(node) {\n            let currentAncestor = node;\n\n            do {\n                if (isConditionalTestExpression(currentAncestor)) {\n                    return currentAncestor.parent;\n                }\n            } while ((currentAncestor = currentAncestor.parent) && !astUtils.isFunction(currentAncestor));\n\n            return null;\n        }\n\n        /**\n         * Check whether the code represented by an AST node is enclosed in two sets of parentheses.\n         * @param {!Object} node The node to test.\n         * @returns {boolean} `true` if the code is enclosed in two sets of parentheses; otherwise, `false`.\n         */\n        function isParenthesisedTwice(node) {\n            const previousToken = sourceCode.getTokenBefore(node, 1),\n                nextToken = sourceCode.getTokenAfter(node, 1);\n\n            return astUtils.isParenthesised(sourceCode, node) &&\n                previousToken && astUtils.isOpeningParenToken(previousToken) && previousToken.range[1] <= node.range[0] &&\n                astUtils.isClosingParenToken(nextToken) && nextToken.range[0] >= node.range[1];\n        }\n\n        /**\n         * Check a conditional statement's test expression for top-level assignments that are not enclosed in parentheses.\n         * @param {!Object} node The node for the conditional statement.\n         * @returns {void}\n         */\n        function testForAssign(node) {\n            if (node.test &&\n                (node.test.type === \"AssignmentExpression\") &&\n                (node.type === \"ForStatement\"\n                    ? !astUtils.isParenthesised(sourceCode, node.test)\n                    : !isParenthesisedTwice(node.test)\n                )\n            ) {\n\n                context.report({\n                    node: node.test,\n                    messageId: \"missing\"\n                });\n            }\n        }\n\n        /**\n         * Check whether an assignment expression is descended from a conditional statement's test expression.\n         * @param {!Object} node The node for the assignment expression.\n         * @returns {void}\n         */\n        function testForConditionalAncestor(node) {\n            const ancestor = findConditionalAncestor(node);\n\n            if (ancestor) {\n                context.report({\n                    node,\n                    messageId: \"unexpected\",\n                    data: {\n                        type: NODE_DESCRIPTIONS[ancestor.type] || ancestor.type\n                    }\n                });\n            }\n        }\n\n        if (prohibitAssign === \"always\") {\n            return {\n                AssignmentExpression: testForConditionalAncestor\n            };\n        }\n\n        return {\n            DoWhileStatement: testForAssign,\n            ForStatement: testForAssign,\n            IfStatement: testForAssign,\n            WhileStatement: testForAssign,\n            ConditionalExpression: testForAssign\n        };\n\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}