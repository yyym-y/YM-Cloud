{"ast":null,"code":"/**\n * @fileoverview A rule to suggest using of the spread operator instead of `.apply()`.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a node is a `.apply()` for variadic.\n * @param {ASTNode} node A CallExpression node to check.\n * @returns {boolean} Whether or not the node is a `.apply()` for variadic.\n */\nfunction isVariadicApplyCalling(node) {\n  return astUtils.isSpecificMemberAccess(node.callee, null, \"apply\") && node.arguments.length === 2 && node.arguments[1].type !== \"ArrayExpression\" && node.arguments[1].type !== \"SpreadElement\";\n}\n\n/**\n * Checks whether or not `thisArg` is not changed by `.apply()`.\n * @param {ASTNode|null} expectedThis The node that is the owner of the applied function.\n * @param {ASTNode} thisArg The node that is given to the first argument of the `.apply()`.\n * @param {RuleContext} context The ESLint rule context object.\n * @returns {boolean} Whether or not `thisArg` is not changed by `.apply()`.\n */\nfunction isValidThisArg(expectedThis, thisArg, context) {\n  if (!expectedThis) {\n    return astUtils.isNullOrUndefined(thisArg);\n  }\n  return astUtils.equalTokens(expectedThis, thisArg, context);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require spread operators instead of `.apply()`\",\n      category: \"ECMAScript 6\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/prefer-spread\"\n    },\n    schema: [],\n    fixable: null,\n    messages: {\n      preferSpread: \"Use the spread operator instead of '.apply()'.\"\n    }\n  },\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    return {\n      CallExpression(node) {\n        if (!isVariadicApplyCalling(node)) {\n          return;\n        }\n        const applied = astUtils.skipChainExpression(astUtils.skipChainExpression(node.callee).object);\n        const expectedThis = applied.type === \"MemberExpression\" ? applied.object : null;\n        const thisArg = node.arguments[0];\n        if (isValidThisArg(expectedThis, thisArg, sourceCode)) {\n          context.report({\n            node,\n            messageId: \"preferSpread\"\n          });\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","isVariadicApplyCalling","node","isSpecificMemberAccess","callee","arguments","length","type","isValidThisArg","expectedThis","thisArg","context","isNullOrUndefined","equalTokens","module","exports","meta","docs","description","category","recommended","url","schema","fixable","messages","preferSpread","create","sourceCode","getSourceCode","CallExpression","applied","skipChainExpression","object","report","messageId"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/prefer-spread.js"],"sourcesContent":["/**\n * @fileoverview A rule to suggest using of the spread operator instead of `.apply()`.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a node is a `.apply()` for variadic.\n * @param {ASTNode} node A CallExpression node to check.\n * @returns {boolean} Whether or not the node is a `.apply()` for variadic.\n */\nfunction isVariadicApplyCalling(node) {\n    return (\n        astUtils.isSpecificMemberAccess(node.callee, null, \"apply\") &&\n        node.arguments.length === 2 &&\n        node.arguments[1].type !== \"ArrayExpression\" &&\n        node.arguments[1].type !== \"SpreadElement\"\n    );\n}\n\n/**\n * Checks whether or not `thisArg` is not changed by `.apply()`.\n * @param {ASTNode|null} expectedThis The node that is the owner of the applied function.\n * @param {ASTNode} thisArg The node that is given to the first argument of the `.apply()`.\n * @param {RuleContext} context The ESLint rule context object.\n * @returns {boolean} Whether or not `thisArg` is not changed by `.apply()`.\n */\nfunction isValidThisArg(expectedThis, thisArg, context) {\n    if (!expectedThis) {\n        return astUtils.isNullOrUndefined(thisArg);\n    }\n    return astUtils.equalTokens(expectedThis, thisArg, context);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require spread operators instead of `.apply()`\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/prefer-spread\"\n        },\n\n        schema: [],\n        fixable: null,\n\n        messages: {\n            preferSpread: \"Use the spread operator instead of '.apply()'.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        return {\n            CallExpression(node) {\n                if (!isVariadicApplyCalling(node)) {\n                    return;\n                }\n\n                const applied = astUtils.skipChainExpression(astUtils.skipChainExpression(node.callee).object);\n                const expectedThis = (applied.type === \"MemberExpression\") ? applied.object : null;\n                const thisArg = node.arguments[0];\n\n                if (isValidThisArg(expectedThis, thisArg, sourceCode)) {\n                    context.report({\n                        node,\n                        messageId: \"preferSpread\"\n                    });\n                }\n            }\n        };\n    }\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA,YAAY;;AAEZ,MAAMA,QAAQ,GAAGC,OAAO,CAAC,mBAAmB,CAAC;;AAE7C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASC,sBAAsBA,CAACC,IAAI,EAAE;EAClC,OACIH,QAAQ,CAACI,sBAAsB,CAACD,IAAI,CAACE,MAAM,EAAE,IAAI,EAAE,OAAO,CAAC,IAC3DF,IAAI,CAACG,SAAS,CAACC,MAAM,KAAK,CAAC,IAC3BJ,IAAI,CAACG,SAAS,CAAC,CAAC,CAAC,CAACE,IAAI,KAAK,iBAAiB,IAC5CL,IAAI,CAACG,SAAS,CAAC,CAAC,CAAC,CAACE,IAAI,KAAK,eAAe;AAElD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,cAAcA,CAACC,YAAY,EAAEC,OAAO,EAAEC,OAAO,EAAE;EACpD,IAAI,CAACF,YAAY,EAAE;IACf,OAAOV,QAAQ,CAACa,iBAAiB,CAACF,OAAO,CAAC;EAC9C;EACA,OAAOX,QAAQ,CAACc,WAAW,CAACJ,YAAY,EAAEC,OAAO,EAAEC,OAAO,CAAC;AAC/D;;AAEA;AACA;AACA;;AAEAG,MAAM,CAACC,OAAO,GAAG;EACbC,IAAI,EAAE;IACFT,IAAI,EAAE,YAAY;IAElBU,IAAI,EAAE;MACFC,WAAW,EAAE,gDAAgD;MAC7DC,QAAQ,EAAE,cAAc;MACxBC,WAAW,EAAE,KAAK;MAClBC,GAAG,EAAE;IACT,CAAC;IAEDC,MAAM,EAAE,EAAE;IACVC,OAAO,EAAE,IAAI;IAEbC,QAAQ,EAAE;MACNC,YAAY,EAAE;IAClB;EACJ,CAAC;EAEDC,MAAMA,CAACf,OAAO,EAAE;IACZ,MAAMgB,UAAU,GAAGhB,OAAO,CAACiB,aAAa,CAAC,CAAC;IAE1C,OAAO;MACHC,cAAcA,CAAC3B,IAAI,EAAE;QACjB,IAAI,CAACD,sBAAsB,CAACC,IAAI,CAAC,EAAE;UAC/B;QACJ;QAEA,MAAM4B,OAAO,GAAG/B,QAAQ,CAACgC,mBAAmB,CAAChC,QAAQ,CAACgC,mBAAmB,CAAC7B,IAAI,CAACE,MAAM,CAAC,CAAC4B,MAAM,CAAC;QAC9F,MAAMvB,YAAY,GAAIqB,OAAO,CAACvB,IAAI,KAAK,kBAAkB,GAAIuB,OAAO,CAACE,MAAM,GAAG,IAAI;QAClF,MAAMtB,OAAO,GAAGR,IAAI,CAACG,SAAS,CAAC,CAAC,CAAC;QAEjC,IAAIG,cAAc,CAACC,YAAY,EAAEC,OAAO,EAAEiB,UAAU,CAAC,EAAE;UACnDhB,OAAO,CAACsB,MAAM,CAAC;YACX/B,IAAI;YACJgC,SAAS,EAAE;UACf,CAAC,CAAC;QACN;MACJ;IACJ,CAAC;EACL;AACJ,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}