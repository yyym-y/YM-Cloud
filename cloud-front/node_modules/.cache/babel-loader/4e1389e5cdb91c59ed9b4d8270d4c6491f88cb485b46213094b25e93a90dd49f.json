{"ast":null,"code":"/**\n * @fileoverview Rule to flag use of implied eval via setTimeout and setInterval\n * @author James Allardice\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils\");\nconst {\n  getStaticValue\n} = require(\"eslint-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow the use of `eval()`-like methods\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-implied-eval\"\n    },\n    schema: [],\n    messages: {\n      impliedEval: \"Implied eval. Consider passing a function instead of a string.\"\n    }\n  },\n  create(context) {\n    const GLOBAL_CANDIDATES = Object.freeze([\"global\", \"window\", \"globalThis\"]);\n    const EVAL_LIKE_FUNC_PATTERN = /^(?:set(?:Interval|Timeout)|execScript)$/u;\n\n    /**\n     * Checks whether a node is evaluated as a string or not.\n     * @param {ASTNode} node A node to check.\n     * @returns {boolean} True if the node is evaluated as a string.\n     */\n    function isEvaluatedString(node) {\n      if (node.type === \"Literal\" && typeof node.value === \"string\" || node.type === \"TemplateLiteral\") {\n        return true;\n      }\n      if (node.type === \"BinaryExpression\" && node.operator === \"+\") {\n        return isEvaluatedString(node.left) || isEvaluatedString(node.right);\n      }\n      return false;\n    }\n\n    /**\n     * Reports if the `CallExpression` node has evaluated argument.\n     * @param {ASTNode} node A CallExpression to check.\n     * @returns {void}\n     */\n    function reportImpliedEvalCallExpression(node) {\n      const [firstArgument] = node.arguments;\n      if (firstArgument) {\n        const staticValue = getStaticValue(firstArgument, context.getScope());\n        const isStaticString = staticValue && typeof staticValue.value === \"string\";\n        const isString = isStaticString || isEvaluatedString(firstArgument);\n        if (isString) {\n          context.report({\n            node,\n            messageId: \"impliedEval\"\n          });\n        }\n      }\n    }\n\n    /**\n     * Reports calls of `implied eval` via the global references.\n     * @param {Variable} globalVar A global variable to check.\n     * @returns {void}\n     */\n    function reportImpliedEvalViaGlobal(globalVar) {\n      const {\n        references,\n        name\n      } = globalVar;\n      references.forEach(ref => {\n        const identifier = ref.identifier;\n        let node = identifier.parent;\n        while (astUtils.isSpecificMemberAccess(node, null, name)) {\n          node = node.parent;\n        }\n        if (astUtils.isSpecificMemberAccess(node, null, EVAL_LIKE_FUNC_PATTERN)) {\n          const calleeNode = node.parent.type === \"ChainExpression\" ? node.parent : node;\n          const parent = calleeNode.parent;\n          if (parent.type === \"CallExpression\" && parent.callee === calleeNode) {\n            reportImpliedEvalCallExpression(parent);\n          }\n        }\n      });\n    }\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    return {\n      CallExpression(node) {\n        if (astUtils.isSpecificId(node.callee, EVAL_LIKE_FUNC_PATTERN)) {\n          reportImpliedEvalCallExpression(node);\n        }\n      },\n      \"Program:exit\"() {\n        const globalScope = context.getScope();\n        GLOBAL_CANDIDATES.map(candidate => astUtils.getVariableByName(globalScope, candidate)).filter(globalVar => !!globalVar && globalVar.defs.length === 0).forEach(reportImpliedEvalViaGlobal);\n      }\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","getStaticValue","module","exports","meta","type","docs","description","category","recommended","url","schema","messages","impliedEval","create","context","GLOBAL_CANDIDATES","Object","freeze","EVAL_LIKE_FUNC_PATTERN","isEvaluatedString","node","value","operator","left","right","reportImpliedEvalCallExpression","firstArgument","arguments","staticValue","getScope","isStaticString","isString","report","messageId","reportImpliedEvalViaGlobal","globalVar","references","name","forEach","ref","identifier","parent","isSpecificMemberAccess","calleeNode","callee","CallExpression","isSpecificId","Program:exit","globalScope","map","candidate","getVariableByName","filter","defs","length"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/no-implied-eval.js"],"sourcesContent":["/**\n * @fileoverview Rule to flag use of implied eval via setTimeout and setInterval\n * @author James Allardice\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\nconst { getStaticValue } = require(\"eslint-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow the use of `eval()`-like methods\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-implied-eval\"\n        },\n\n        schema: [],\n\n        messages: {\n            impliedEval: \"Implied eval. Consider passing a function instead of a string.\"\n        }\n    },\n\n    create(context) {\n        const GLOBAL_CANDIDATES = Object.freeze([\"global\", \"window\", \"globalThis\"]);\n        const EVAL_LIKE_FUNC_PATTERN = /^(?:set(?:Interval|Timeout)|execScript)$/u;\n\n        /**\n         * Checks whether a node is evaluated as a string or not.\n         * @param {ASTNode} node A node to check.\n         * @returns {boolean} True if the node is evaluated as a string.\n         */\n        function isEvaluatedString(node) {\n            if (\n                (node.type === \"Literal\" && typeof node.value === \"string\") ||\n                node.type === \"TemplateLiteral\"\n            ) {\n                return true;\n            }\n            if (node.type === \"BinaryExpression\" && node.operator === \"+\") {\n                return isEvaluatedString(node.left) || isEvaluatedString(node.right);\n            }\n            return false;\n        }\n\n        /**\n         * Reports if the `CallExpression` node has evaluated argument.\n         * @param {ASTNode} node A CallExpression to check.\n         * @returns {void}\n         */\n        function reportImpliedEvalCallExpression(node) {\n            const [firstArgument] = node.arguments;\n\n            if (firstArgument) {\n\n                const staticValue = getStaticValue(firstArgument, context.getScope());\n                const isStaticString = staticValue && typeof staticValue.value === \"string\";\n                const isString = isStaticString || isEvaluatedString(firstArgument);\n\n                if (isString) {\n                    context.report({\n                        node,\n                        messageId: \"impliedEval\"\n                    });\n                }\n            }\n\n        }\n\n        /**\n         * Reports calls of `implied eval` via the global references.\n         * @param {Variable} globalVar A global variable to check.\n         * @returns {void}\n         */\n        function reportImpliedEvalViaGlobal(globalVar) {\n            const { references, name } = globalVar;\n\n            references.forEach(ref => {\n                const identifier = ref.identifier;\n                let node = identifier.parent;\n\n                while (astUtils.isSpecificMemberAccess(node, null, name)) {\n                    node = node.parent;\n                }\n\n                if (astUtils.isSpecificMemberAccess(node, null, EVAL_LIKE_FUNC_PATTERN)) {\n                    const calleeNode = node.parent.type === \"ChainExpression\" ? node.parent : node;\n                    const parent = calleeNode.parent;\n\n                    if (parent.type === \"CallExpression\" && parent.callee === calleeNode) {\n                        reportImpliedEvalCallExpression(parent);\n                    }\n                }\n            });\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            CallExpression(node) {\n                if (astUtils.isSpecificId(node.callee, EVAL_LIKE_FUNC_PATTERN)) {\n                    reportImpliedEvalCallExpression(node);\n                }\n            },\n            \"Program:exit\"() {\n                const globalScope = context.getScope();\n\n                GLOBAL_CANDIDATES\n                    .map(candidate => astUtils.getVariableByName(globalScope, candidate))\n                    .filter(globalVar => !!globalVar && globalVar.defs.length === 0)\n                    .forEach(reportImpliedEvalViaGlobal);\n            }\n        };\n\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}