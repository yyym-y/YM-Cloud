{"ast":null,"code":"/**\n * @fileoverview Validate strings passed to the RegExp constructor\n * @author Michael Ficarra\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst RegExpValidator = require(\"regexpp\").RegExpValidator;\nconst validator = new RegExpValidator();\nconst validFlags = /[gimuys]/gu;\nconst undefined1 = void 0;\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow invalid regular expression strings in `RegExp` constructors\",\n      category: \"Possible Errors\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-invalid-regexp\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        allowConstructorFlags: {\n          type: \"array\",\n          items: {\n            type: \"string\"\n          }\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      regexMessage: \"{{message}}.\"\n    }\n  },\n  create(context) {\n    const options = context.options[0];\n    let allowedFlags = null;\n    if (options && options.allowConstructorFlags) {\n      const temp = options.allowConstructorFlags.join(\"\").replace(validFlags, \"\");\n      if (temp) {\n        allowedFlags = new RegExp(`[${temp}]`, \"giu\");\n      }\n    }\n\n    /**\n     * Check if node is a string\n     * @param {ASTNode} node node to evaluate\n     * @returns {boolean} True if its a string\n     * @private\n     */\n    function isString(node) {\n      return node && node.type === \"Literal\" && typeof node.value === \"string\";\n    }\n\n    /**\n     * Gets flags of a regular expression created by the given `RegExp()` or `new RegExp()` call\n     * Examples:\n     *     new RegExp(\".\")         // => \"\"\n     *     new RegExp(\".\", \"gu\")   // => \"gu\"\n     *     new RegExp(\".\", flags)  // => null\n     * @param {ASTNode} node `CallExpression` or `NewExpression` node\n     * @returns {string|null} flags if they can be determined, `null` otherwise\n     * @private\n     */\n    function getFlags(node) {\n      if (node.arguments.length < 2) {\n        return \"\";\n      }\n      if (isString(node.arguments[1])) {\n        return node.arguments[1].value;\n      }\n      return null;\n    }\n\n    /**\n     * Check syntax error in a given pattern.\n     * @param {string} pattern The RegExp pattern to validate.\n     * @param {boolean} uFlag The Unicode flag.\n     * @returns {string|null} The syntax error.\n     */\n    function validateRegExpPattern(pattern, uFlag) {\n      try {\n        validator.validatePattern(pattern, undefined1, undefined1, uFlag);\n        return null;\n      } catch (err) {\n        return err.message;\n      }\n    }\n\n    /**\n     * Check syntax error in a given flags.\n     * @param {string} flags The RegExp flags to validate.\n     * @returns {string|null} The syntax error.\n     */\n    function validateRegExpFlags(flags) {\n      try {\n        validator.validateFlags(flags);\n        return null;\n      } catch {\n        return `Invalid flags supplied to RegExp constructor '${flags}'`;\n      }\n    }\n    return {\n      \"CallExpression, NewExpression\"(node) {\n        if (node.callee.type !== \"Identifier\" || node.callee.name !== \"RegExp\" || !isString(node.arguments[0])) {\n          return;\n        }\n        const pattern = node.arguments[0].value;\n        let flags = getFlags(node);\n        if (flags && allowedFlags) {\n          flags = flags.replace(allowedFlags, \"\");\n        }\n        const message = flags && validateRegExpFlags(flags) || (\n        // If flags are unknown, report the regex only if its pattern is invalid both with and without the \"u\" flag\n        flags === null ? validateRegExpPattern(pattern, true) && validateRegExpPattern(pattern, false) : validateRegExpPattern(pattern, flags.includes(\"u\")));\n        if (message) {\n          context.report({\n            node,\n            messageId: \"regexMessage\",\n            data: {\n              message\n            }\n          });\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["RegExpValidator","require","validator","validFlags","undefined1","module","exports","meta","type","docs","description","category","recommended","url","schema","properties","allowConstructorFlags","items","additionalProperties","messages","regexMessage","create","context","options","allowedFlags","temp","join","replace","RegExp","isString","node","value","getFlags","arguments","length","validateRegExpPattern","pattern","uFlag","validatePattern","err","message","validateRegExpFlags","flags","validateFlags","CallExpression, NewExpression","callee","name","includes","report","messageId","data"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/no-invalid-regexp.js"],"sourcesContent":["/**\n * @fileoverview Validate strings passed to the RegExp constructor\n * @author Michael Ficarra\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst RegExpValidator = require(\"regexpp\").RegExpValidator;\nconst validator = new RegExpValidator();\nconst validFlags = /[gimuys]/gu;\nconst undefined1 = void 0;\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow invalid regular expression strings in `RegExp` constructors\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-invalid-regexp\"\n        },\n\n        schema: [{\n            type: \"object\",\n            properties: {\n                allowConstructorFlags: {\n                    type: \"array\",\n                    items: {\n                        type: \"string\"\n                    }\n                }\n            },\n            additionalProperties: false\n        }],\n\n        messages: {\n            regexMessage: \"{{message}}.\"\n        }\n    },\n\n    create(context) {\n\n        const options = context.options[0];\n        let allowedFlags = null;\n\n        if (options && options.allowConstructorFlags) {\n            const temp = options.allowConstructorFlags.join(\"\").replace(validFlags, \"\");\n\n            if (temp) {\n                allowedFlags = new RegExp(`[${temp}]`, \"giu\");\n            }\n        }\n\n        /**\n         * Check if node is a string\n         * @param {ASTNode} node node to evaluate\n         * @returns {boolean} True if its a string\n         * @private\n         */\n        function isString(node) {\n            return node && node.type === \"Literal\" && typeof node.value === \"string\";\n        }\n\n        /**\n         * Gets flags of a regular expression created by the given `RegExp()` or `new RegExp()` call\n         * Examples:\n         *     new RegExp(\".\")         // => \"\"\n         *     new RegExp(\".\", \"gu\")   // => \"gu\"\n         *     new RegExp(\".\", flags)  // => null\n         * @param {ASTNode} node `CallExpression` or `NewExpression` node\n         * @returns {string|null} flags if they can be determined, `null` otherwise\n         * @private\n         */\n        function getFlags(node) {\n            if (node.arguments.length < 2) {\n                return \"\";\n            }\n\n            if (isString(node.arguments[1])) {\n                return node.arguments[1].value;\n            }\n\n            return null;\n        }\n\n        /**\n         * Check syntax error in a given pattern.\n         * @param {string} pattern The RegExp pattern to validate.\n         * @param {boolean} uFlag The Unicode flag.\n         * @returns {string|null} The syntax error.\n         */\n        function validateRegExpPattern(pattern, uFlag) {\n            try {\n                validator.validatePattern(pattern, undefined1, undefined1, uFlag);\n                return null;\n            } catch (err) {\n                return err.message;\n            }\n        }\n\n        /**\n         * Check syntax error in a given flags.\n         * @param {string} flags The RegExp flags to validate.\n         * @returns {string|null} The syntax error.\n         */\n        function validateRegExpFlags(flags) {\n            try {\n                validator.validateFlags(flags);\n                return null;\n            } catch {\n                return `Invalid flags supplied to RegExp constructor '${flags}'`;\n            }\n        }\n\n        return {\n            \"CallExpression, NewExpression\"(node) {\n                if (node.callee.type !== \"Identifier\" || node.callee.name !== \"RegExp\" || !isString(node.arguments[0])) {\n                    return;\n                }\n                const pattern = node.arguments[0].value;\n                let flags = getFlags(node);\n\n                if (flags && allowedFlags) {\n                    flags = flags.replace(allowedFlags, \"\");\n                }\n\n                const message =\n                    (\n                        flags && validateRegExpFlags(flags)\n                    ) ||\n                    (\n\n                        // If flags are unknown, report the regex only if its pattern is invalid both with and without the \"u\" flag\n                        flags === null\n                            ? validateRegExpPattern(pattern, true) && validateRegExpPattern(pattern, false)\n                            : validateRegExpPattern(pattern, flags.includes(\"u\"))\n                    );\n\n                if (message) {\n                    context.report({\n                        node,\n                        messageId: \"regexMessage\",\n                        data: { message }\n                    });\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}