{"ast":null,"code":"/**\n * @fileoverview Rule to forbid or enforce dangling commas.\n * @author Ian Christian Myers\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst DEFAULT_OPTIONS = Object.freeze({\n  arrays: \"never\",\n  objects: \"never\",\n  imports: \"never\",\n  exports: \"never\",\n  functions: \"never\"\n});\n\n/**\n * Checks whether or not a trailing comma is allowed in a given node.\n * If the `lastItem` is `RestElement` or `RestProperty`, it disallows trailing commas.\n * @param {ASTNode} lastItem The node of the last element in the given node.\n * @returns {boolean} `true` if a trailing comma is allowed.\n */\nfunction isTrailingCommaAllowed(lastItem) {\n  return !(lastItem.type === \"RestElement\" || lastItem.type === \"RestProperty\" || lastItem.type === \"ExperimentalRestProperty\");\n}\n\n/**\n * Normalize option value.\n * @param {string|Object|undefined} optionValue The 1st option value to normalize.\n * @param {number} ecmaVersion The normalized ECMAScript version.\n * @returns {Object} The normalized option value.\n */\nfunction normalizeOptions(optionValue, ecmaVersion) {\n  if (typeof optionValue === \"string\") {\n    return {\n      arrays: optionValue,\n      objects: optionValue,\n      imports: optionValue,\n      exports: optionValue,\n      functions: !ecmaVersion || ecmaVersion < 8 ? \"ignore\" : optionValue\n    };\n  }\n  if (typeof optionValue === \"object\" && optionValue !== null) {\n    return {\n      arrays: optionValue.arrays || DEFAULT_OPTIONS.arrays,\n      objects: optionValue.objects || DEFAULT_OPTIONS.objects,\n      imports: optionValue.imports || DEFAULT_OPTIONS.imports,\n      exports: optionValue.exports || DEFAULT_OPTIONS.exports,\n      functions: optionValue.functions || DEFAULT_OPTIONS.functions\n    };\n  }\n  return DEFAULT_OPTIONS;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"require or disallow trailing commas\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/comma-dangle\"\n    },\n    fixable: \"code\",\n    schema: {\n      definitions: {\n        value: {\n          enum: [\"always-multiline\", \"always\", \"never\", \"only-multiline\"]\n        },\n        valueWithIgnore: {\n          enum: [\"always-multiline\", \"always\", \"ignore\", \"never\", \"only-multiline\"]\n        }\n      },\n      type: \"array\",\n      items: [{\n        oneOf: [{\n          $ref: \"#/definitions/value\"\n        }, {\n          type: \"object\",\n          properties: {\n            arrays: {\n              $ref: \"#/definitions/valueWithIgnore\"\n            },\n            objects: {\n              $ref: \"#/definitions/valueWithIgnore\"\n            },\n            imports: {\n              $ref: \"#/definitions/valueWithIgnore\"\n            },\n            exports: {\n              $ref: \"#/definitions/valueWithIgnore\"\n            },\n            functions: {\n              $ref: \"#/definitions/valueWithIgnore\"\n            }\n          },\n          additionalProperties: false\n        }]\n      }]\n    },\n    messages: {\n      unexpected: \"Unexpected trailing comma.\",\n      missing: \"Missing trailing comma.\"\n    }\n  },\n  create(context) {\n    const options = normalizeOptions(context.options[0], context.parserOptions.ecmaVersion);\n    const sourceCode = context.getSourceCode();\n\n    /**\n     * Gets the last item of the given node.\n     * @param {ASTNode} node The node to get.\n     * @returns {ASTNode|null} The last node or null.\n     */\n    function getLastItem(node) {\n      /**\n       * Returns the last element of an array\n       * @param {any[]} array The input array\n       * @returns {any} The last element\n       */\n      function last(array) {\n        return array[array.length - 1];\n      }\n      switch (node.type) {\n        case \"ObjectExpression\":\n        case \"ObjectPattern\":\n          return last(node.properties);\n        case \"ArrayExpression\":\n        case \"ArrayPattern\":\n          return last(node.elements);\n        case \"ImportDeclaration\":\n        case \"ExportNamedDeclaration\":\n          return last(node.specifiers);\n        case \"FunctionDeclaration\":\n        case \"FunctionExpression\":\n        case \"ArrowFunctionExpression\":\n          return last(node.params);\n        case \"CallExpression\":\n        case \"NewExpression\":\n          return last(node.arguments);\n        default:\n          return null;\n      }\n    }\n\n    /**\n     * Gets the trailing comma token of the given node.\n     * If the trailing comma does not exist, this returns the token which is\n     * the insertion point of the trailing comma token.\n     * @param {ASTNode} node The node to get.\n     * @param {ASTNode} lastItem The last item of the node.\n     * @returns {Token} The trailing comma token or the insertion point.\n     */\n    function getTrailingToken(node, lastItem) {\n      switch (node.type) {\n        case \"ObjectExpression\":\n        case \"ArrayExpression\":\n        case \"CallExpression\":\n        case \"NewExpression\":\n          return sourceCode.getLastToken(node, 1);\n        default:\n          {\n            const nextToken = sourceCode.getTokenAfter(lastItem);\n            if (astUtils.isCommaToken(nextToken)) {\n              return nextToken;\n            }\n            return sourceCode.getLastToken(lastItem);\n          }\n      }\n    }\n\n    /**\n     * Checks whether or not a given node is multiline.\n     * This rule handles a given node as multiline when the closing parenthesis\n     * and the last element are not on the same line.\n     * @param {ASTNode} node A node to check.\n     * @returns {boolean} `true` if the node is multiline.\n     */\n    function isMultiline(node) {\n      const lastItem = getLastItem(node);\n      if (!lastItem) {\n        return false;\n      }\n      const penultimateToken = getTrailingToken(node, lastItem);\n      const lastToken = sourceCode.getTokenAfter(penultimateToken);\n      return lastToken.loc.end.line !== penultimateToken.loc.end.line;\n    }\n\n    /**\n     * Reports a trailing comma if it exists.\n     * @param {ASTNode} node A node to check. Its type is one of\n     *   ObjectExpression, ObjectPattern, ArrayExpression, ArrayPattern,\n     *   ImportDeclaration, and ExportNamedDeclaration.\n     * @returns {void}\n     */\n    function forbidTrailingComma(node) {\n      const lastItem = getLastItem(node);\n      if (!lastItem || node.type === \"ImportDeclaration\" && lastItem.type !== \"ImportSpecifier\") {\n        return;\n      }\n      const trailingToken = getTrailingToken(node, lastItem);\n      if (astUtils.isCommaToken(trailingToken)) {\n        context.report({\n          node: lastItem,\n          loc: trailingToken.loc,\n          messageId: \"unexpected\",\n          fix(fixer) {\n            return fixer.remove(trailingToken);\n          }\n        });\n      }\n    }\n\n    /**\n     * Reports the last element of a given node if it does not have a trailing\n     * comma.\n     *\n     * If a given node is `ArrayPattern` which has `RestElement`, the trailing\n     * comma is disallowed, so report if it exists.\n     * @param {ASTNode} node A node to check. Its type is one of\n     *   ObjectExpression, ObjectPattern, ArrayExpression, ArrayPattern,\n     *   ImportDeclaration, and ExportNamedDeclaration.\n     * @returns {void}\n     */\n    function forceTrailingComma(node) {\n      const lastItem = getLastItem(node);\n      if (!lastItem || node.type === \"ImportDeclaration\" && lastItem.type !== \"ImportSpecifier\") {\n        return;\n      }\n      if (!isTrailingCommaAllowed(lastItem)) {\n        forbidTrailingComma(node);\n        return;\n      }\n      const trailingToken = getTrailingToken(node, lastItem);\n      if (trailingToken.value !== \",\") {\n        context.report({\n          node: lastItem,\n          loc: {\n            start: trailingToken.loc.end,\n            end: astUtils.getNextLocation(sourceCode, trailingToken.loc.end)\n          },\n          messageId: \"missing\",\n          fix(fixer) {\n            return fixer.insertTextAfter(trailingToken, \",\");\n          }\n        });\n      }\n    }\n\n    /**\n     * If a given node is multiline, reports the last element of a given node\n     * when it does not have a trailing comma.\n     * Otherwise, reports a trailing comma if it exists.\n     * @param {ASTNode} node A node to check. Its type is one of\n     *   ObjectExpression, ObjectPattern, ArrayExpression, ArrayPattern,\n     *   ImportDeclaration, and ExportNamedDeclaration.\n     * @returns {void}\n     */\n    function forceTrailingCommaIfMultiline(node) {\n      if (isMultiline(node)) {\n        forceTrailingComma(node);\n      } else {\n        forbidTrailingComma(node);\n      }\n    }\n\n    /**\n     * Only if a given node is not multiline, reports the last element of a given node\n     * when it does not have a trailing comma.\n     * Otherwise, reports a trailing comma if it exists.\n     * @param {ASTNode} node A node to check. Its type is one of\n     *   ObjectExpression, ObjectPattern, ArrayExpression, ArrayPattern,\n     *   ImportDeclaration, and ExportNamedDeclaration.\n     * @returns {void}\n     */\n    function allowTrailingCommaIfMultiline(node) {\n      if (!isMultiline(node)) {\n        forbidTrailingComma(node);\n      }\n    }\n    const predicate = {\n      always: forceTrailingComma,\n      \"always-multiline\": forceTrailingCommaIfMultiline,\n      \"only-multiline\": allowTrailingCommaIfMultiline,\n      never: forbidTrailingComma,\n      ignore: () => {}\n    };\n    return {\n      ObjectExpression: predicate[options.objects],\n      ObjectPattern: predicate[options.objects],\n      ArrayExpression: predicate[options.arrays],\n      ArrayPattern: predicate[options.arrays],\n      ImportDeclaration: predicate[options.imports],\n      ExportNamedDeclaration: predicate[options.exports],\n      FunctionDeclaration: predicate[options.functions],\n      FunctionExpression: predicate[options.functions],\n      ArrowFunctionExpression: predicate[options.functions],\n      CallExpression: predicate[options.functions],\n      NewExpression: predicate[options.functions]\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","DEFAULT_OPTIONS","Object","freeze","arrays","objects","imports","exports","functions","isTrailingCommaAllowed","lastItem","type","normalizeOptions","optionValue","ecmaVersion","module","meta","docs","description","category","recommended","url","fixable","schema","definitions","value","enum","valueWithIgnore","items","oneOf","$ref","properties","additionalProperties","messages","unexpected","missing","create","context","options","parserOptions","sourceCode","getSourceCode","getLastItem","node","last","array","length","elements","specifiers","params","arguments","getTrailingToken","getLastToken","nextToken","getTokenAfter","isCommaToken","isMultiline","penultimateToken","lastToken","loc","end","line","forbidTrailingComma","trailingToken","report","messageId","fix","fixer","remove","forceTrailingComma","start","getNextLocation","insertTextAfter","forceTrailingCommaIfMultiline","allowTrailingCommaIfMultiline","predicate","always","never","ignore","ObjectExpression","ObjectPattern","ArrayExpression","ArrayPattern","ImportDeclaration","ExportNamedDeclaration","FunctionDeclaration","FunctionExpression","ArrowFunctionExpression","CallExpression","NewExpression"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/comma-dangle.js"],"sourcesContent":["/**\n * @fileoverview Rule to forbid or enforce dangling commas.\n * @author Ian Christian Myers\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst DEFAULT_OPTIONS = Object.freeze({\n    arrays: \"never\",\n    objects: \"never\",\n    imports: \"never\",\n    exports: \"never\",\n    functions: \"never\"\n});\n\n/**\n * Checks whether or not a trailing comma is allowed in a given node.\n * If the `lastItem` is `RestElement` or `RestProperty`, it disallows trailing commas.\n * @param {ASTNode} lastItem The node of the last element in the given node.\n * @returns {boolean} `true` if a trailing comma is allowed.\n */\nfunction isTrailingCommaAllowed(lastItem) {\n    return !(\n        lastItem.type === \"RestElement\" ||\n        lastItem.type === \"RestProperty\" ||\n        lastItem.type === \"ExperimentalRestProperty\"\n    );\n}\n\n/**\n * Normalize option value.\n * @param {string|Object|undefined} optionValue The 1st option value to normalize.\n * @param {number} ecmaVersion The normalized ECMAScript version.\n * @returns {Object} The normalized option value.\n */\nfunction normalizeOptions(optionValue, ecmaVersion) {\n    if (typeof optionValue === \"string\") {\n        return {\n            arrays: optionValue,\n            objects: optionValue,\n            imports: optionValue,\n            exports: optionValue,\n            functions: (!ecmaVersion || ecmaVersion < 8) ? \"ignore\" : optionValue\n        };\n    }\n    if (typeof optionValue === \"object\" && optionValue !== null) {\n        return {\n            arrays: optionValue.arrays || DEFAULT_OPTIONS.arrays,\n            objects: optionValue.objects || DEFAULT_OPTIONS.objects,\n            imports: optionValue.imports || DEFAULT_OPTIONS.imports,\n            exports: optionValue.exports || DEFAULT_OPTIONS.exports,\n            functions: optionValue.functions || DEFAULT_OPTIONS.functions\n        };\n    }\n\n    return DEFAULT_OPTIONS;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"require or disallow trailing commas\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/comma-dangle\"\n        },\n\n        fixable: \"code\",\n\n        schema: {\n            definitions: {\n                value: {\n                    enum: [\n                        \"always-multiline\",\n                        \"always\",\n                        \"never\",\n                        \"only-multiline\"\n                    ]\n                },\n                valueWithIgnore: {\n                    enum: [\n                        \"always-multiline\",\n                        \"always\",\n                        \"ignore\",\n                        \"never\",\n                        \"only-multiline\"\n                    ]\n                }\n            },\n            type: \"array\",\n            items: [\n                {\n                    oneOf: [\n                        {\n                            $ref: \"#/definitions/value\"\n                        },\n                        {\n                            type: \"object\",\n                            properties: {\n                                arrays: { $ref: \"#/definitions/valueWithIgnore\" },\n                                objects: { $ref: \"#/definitions/valueWithIgnore\" },\n                                imports: { $ref: \"#/definitions/valueWithIgnore\" },\n                                exports: { $ref: \"#/definitions/valueWithIgnore\" },\n                                functions: { $ref: \"#/definitions/valueWithIgnore\" }\n                            },\n                            additionalProperties: false\n                        }\n                    ]\n                }\n            ]\n        },\n\n        messages: {\n            unexpected: \"Unexpected trailing comma.\",\n            missing: \"Missing trailing comma.\"\n        }\n    },\n\n    create(context) {\n        const options = normalizeOptions(context.options[0], context.parserOptions.ecmaVersion);\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Gets the last item of the given node.\n         * @param {ASTNode} node The node to get.\n         * @returns {ASTNode|null} The last node or null.\n         */\n        function getLastItem(node) {\n\n            /**\n             * Returns the last element of an array\n             * @param {any[]} array The input array\n             * @returns {any} The last element\n             */\n            function last(array) {\n                return array[array.length - 1];\n            }\n\n            switch (node.type) {\n                case \"ObjectExpression\":\n                case \"ObjectPattern\":\n                    return last(node.properties);\n                case \"ArrayExpression\":\n                case \"ArrayPattern\":\n                    return last(node.elements);\n                case \"ImportDeclaration\":\n                case \"ExportNamedDeclaration\":\n                    return last(node.specifiers);\n                case \"FunctionDeclaration\":\n                case \"FunctionExpression\":\n                case \"ArrowFunctionExpression\":\n                    return last(node.params);\n                case \"CallExpression\":\n                case \"NewExpression\":\n                    return last(node.arguments);\n                default:\n                    return null;\n            }\n        }\n\n        /**\n         * Gets the trailing comma token of the given node.\n         * If the trailing comma does not exist, this returns the token which is\n         * the insertion point of the trailing comma token.\n         * @param {ASTNode} node The node to get.\n         * @param {ASTNode} lastItem The last item of the node.\n         * @returns {Token} The trailing comma token or the insertion point.\n         */\n        function getTrailingToken(node, lastItem) {\n            switch (node.type) {\n                case \"ObjectExpression\":\n                case \"ArrayExpression\":\n                case \"CallExpression\":\n                case \"NewExpression\":\n                    return sourceCode.getLastToken(node, 1);\n                default: {\n                    const nextToken = sourceCode.getTokenAfter(lastItem);\n\n                    if (astUtils.isCommaToken(nextToken)) {\n                        return nextToken;\n                    }\n                    return sourceCode.getLastToken(lastItem);\n                }\n            }\n        }\n\n        /**\n         * Checks whether or not a given node is multiline.\n         * This rule handles a given node as multiline when the closing parenthesis\n         * and the last element are not on the same line.\n         * @param {ASTNode} node A node to check.\n         * @returns {boolean} `true` if the node is multiline.\n         */\n        function isMultiline(node) {\n            const lastItem = getLastItem(node);\n\n            if (!lastItem) {\n                return false;\n            }\n\n            const penultimateToken = getTrailingToken(node, lastItem);\n            const lastToken = sourceCode.getTokenAfter(penultimateToken);\n\n            return lastToken.loc.end.line !== penultimateToken.loc.end.line;\n        }\n\n        /**\n         * Reports a trailing comma if it exists.\n         * @param {ASTNode} node A node to check. Its type is one of\n         *   ObjectExpression, ObjectPattern, ArrayExpression, ArrayPattern,\n         *   ImportDeclaration, and ExportNamedDeclaration.\n         * @returns {void}\n         */\n        function forbidTrailingComma(node) {\n            const lastItem = getLastItem(node);\n\n            if (!lastItem || (node.type === \"ImportDeclaration\" && lastItem.type !== \"ImportSpecifier\")) {\n                return;\n            }\n\n            const trailingToken = getTrailingToken(node, lastItem);\n\n            if (astUtils.isCommaToken(trailingToken)) {\n                context.report({\n                    node: lastItem,\n                    loc: trailingToken.loc,\n                    messageId: \"unexpected\",\n                    fix(fixer) {\n                        return fixer.remove(trailingToken);\n                    }\n                });\n            }\n        }\n\n        /**\n         * Reports the last element of a given node if it does not have a trailing\n         * comma.\n         *\n         * If a given node is `ArrayPattern` which has `RestElement`, the trailing\n         * comma is disallowed, so report if it exists.\n         * @param {ASTNode} node A node to check. Its type is one of\n         *   ObjectExpression, ObjectPattern, ArrayExpression, ArrayPattern,\n         *   ImportDeclaration, and ExportNamedDeclaration.\n         * @returns {void}\n         */\n        function forceTrailingComma(node) {\n            const lastItem = getLastItem(node);\n\n            if (!lastItem || (node.type === \"ImportDeclaration\" && lastItem.type !== \"ImportSpecifier\")) {\n                return;\n            }\n            if (!isTrailingCommaAllowed(lastItem)) {\n                forbidTrailingComma(node);\n                return;\n            }\n\n            const trailingToken = getTrailingToken(node, lastItem);\n\n            if (trailingToken.value !== \",\") {\n                context.report({\n                    node: lastItem,\n                    loc: {\n                        start: trailingToken.loc.end,\n                        end: astUtils.getNextLocation(sourceCode, trailingToken.loc.end)\n                    },\n                    messageId: \"missing\",\n                    fix(fixer) {\n                        return fixer.insertTextAfter(trailingToken, \",\");\n                    }\n                });\n            }\n        }\n\n        /**\n         * If a given node is multiline, reports the last element of a given node\n         * when it does not have a trailing comma.\n         * Otherwise, reports a trailing comma if it exists.\n         * @param {ASTNode} node A node to check. Its type is one of\n         *   ObjectExpression, ObjectPattern, ArrayExpression, ArrayPattern,\n         *   ImportDeclaration, and ExportNamedDeclaration.\n         * @returns {void}\n         */\n        function forceTrailingCommaIfMultiline(node) {\n            if (isMultiline(node)) {\n                forceTrailingComma(node);\n            } else {\n                forbidTrailingComma(node);\n            }\n        }\n\n        /**\n         * Only if a given node is not multiline, reports the last element of a given node\n         * when it does not have a trailing comma.\n         * Otherwise, reports a trailing comma if it exists.\n         * @param {ASTNode} node A node to check. Its type is one of\n         *   ObjectExpression, ObjectPattern, ArrayExpression, ArrayPattern,\n         *   ImportDeclaration, and ExportNamedDeclaration.\n         * @returns {void}\n         */\n        function allowTrailingCommaIfMultiline(node) {\n            if (!isMultiline(node)) {\n                forbidTrailingComma(node);\n            }\n        }\n\n        const predicate = {\n            always: forceTrailingComma,\n            \"always-multiline\": forceTrailingCommaIfMultiline,\n            \"only-multiline\": allowTrailingCommaIfMultiline,\n            never: forbidTrailingComma,\n            ignore: () => {}\n        };\n\n        return {\n            ObjectExpression: predicate[options.objects],\n            ObjectPattern: predicate[options.objects],\n\n            ArrayExpression: predicate[options.arrays],\n            ArrayPattern: predicate[options.arrays],\n\n            ImportDeclaration: predicate[options.imports],\n\n            ExportNamedDeclaration: predicate[options.exports],\n\n            FunctionDeclaration: predicate[options.functions],\n            FunctionExpression: predicate[options.functions],\n            ArrowFunctionExpression: predicate[options.functions],\n            CallExpression: predicate[options.functions],\n            NewExpression: predicate[options.functions]\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}