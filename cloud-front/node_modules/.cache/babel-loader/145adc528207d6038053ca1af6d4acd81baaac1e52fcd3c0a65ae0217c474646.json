{"ast":null,"code":"/**\n * @fileoverview This option sets a specific tab width for your code\n *\n * This rule has been ported and modified from nodeca.\n * @author Vitaly Puzrin\n * @author Gyandeep Singh\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nrequire(\"core-js/modules/es.array.push.js\");\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/* istanbul ignore next: this rule has known coverage issues, but it's deprecated and shouldn't be updated in the future anyway. */\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce consistent indentation\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/indent-legacy\"\n    },\n    deprecated: true,\n    replacedBy: [\"indent\"],\n    fixable: \"whitespace\",\n    schema: [{\n      oneOf: [{\n        enum: [\"tab\"]\n      }, {\n        type: \"integer\",\n        minimum: 0\n      }]\n    }, {\n      type: \"object\",\n      properties: {\n        SwitchCase: {\n          type: \"integer\",\n          minimum: 0\n        },\n        VariableDeclarator: {\n          oneOf: [{\n            type: \"integer\",\n            minimum: 0\n          }, {\n            type: \"object\",\n            properties: {\n              var: {\n                type: \"integer\",\n                minimum: 0\n              },\n              let: {\n                type: \"integer\",\n                minimum: 0\n              },\n              const: {\n                type: \"integer\",\n                minimum: 0\n              }\n            }\n          }]\n        },\n        outerIIFEBody: {\n          type: \"integer\",\n          minimum: 0\n        },\n        MemberExpression: {\n          type: \"integer\",\n          minimum: 0\n        },\n        FunctionDeclaration: {\n          type: \"object\",\n          properties: {\n            parameters: {\n              oneOf: [{\n                type: \"integer\",\n                minimum: 0\n              }, {\n                enum: [\"first\"]\n              }]\n            },\n            body: {\n              type: \"integer\",\n              minimum: 0\n            }\n          }\n        },\n        FunctionExpression: {\n          type: \"object\",\n          properties: {\n            parameters: {\n              oneOf: [{\n                type: \"integer\",\n                minimum: 0\n              }, {\n                enum: [\"first\"]\n              }]\n            },\n            body: {\n              type: \"integer\",\n              minimum: 0\n            }\n          }\n        },\n        CallExpression: {\n          type: \"object\",\n          properties: {\n            parameters: {\n              oneOf: [{\n                type: \"integer\",\n                minimum: 0\n              }, {\n                enum: [\"first\"]\n              }]\n            }\n          }\n        },\n        ArrayExpression: {\n          oneOf: [{\n            type: \"integer\",\n            minimum: 0\n          }, {\n            enum: [\"first\"]\n          }]\n        },\n        ObjectExpression: {\n          oneOf: [{\n            type: \"integer\",\n            minimum: 0\n          }, {\n            enum: [\"first\"]\n          }]\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      expected: \"Expected indentation of {{expected}} but found {{actual}}.\"\n    }\n  },\n  create(context) {\n    const DEFAULT_VARIABLE_INDENT = 1;\n    const DEFAULT_PARAMETER_INDENT = null; // For backwards compatibility, don't check parameter indentation unless specified in the config\n    const DEFAULT_FUNCTION_BODY_INDENT = 1;\n    let indentType = \"space\";\n    let indentSize = 4;\n    const options = {\n      SwitchCase: 0,\n      VariableDeclarator: {\n        var: DEFAULT_VARIABLE_INDENT,\n        let: DEFAULT_VARIABLE_INDENT,\n        const: DEFAULT_VARIABLE_INDENT\n      },\n      outerIIFEBody: null,\n      FunctionDeclaration: {\n        parameters: DEFAULT_PARAMETER_INDENT,\n        body: DEFAULT_FUNCTION_BODY_INDENT\n      },\n      FunctionExpression: {\n        parameters: DEFAULT_PARAMETER_INDENT,\n        body: DEFAULT_FUNCTION_BODY_INDENT\n      },\n      CallExpression: {\n        arguments: DEFAULT_PARAMETER_INDENT\n      },\n      ArrayExpression: 1,\n      ObjectExpression: 1\n    };\n    const sourceCode = context.getSourceCode();\n    if (context.options.length) {\n      if (context.options[0] === \"tab\") {\n        indentSize = 1;\n        indentType = \"tab\";\n      } else /* istanbul ignore else : this will be caught by options validation */if (typeof context.options[0] === \"number\") {\n          indentSize = context.options[0];\n          indentType = \"space\";\n        }\n      if (context.options[1]) {\n        const opts = context.options[1];\n        options.SwitchCase = opts.SwitchCase || 0;\n        const variableDeclaratorRules = opts.VariableDeclarator;\n        if (typeof variableDeclaratorRules === \"number\") {\n          options.VariableDeclarator = {\n            var: variableDeclaratorRules,\n            let: variableDeclaratorRules,\n            const: variableDeclaratorRules\n          };\n        } else if (typeof variableDeclaratorRules === \"object\") {\n          Object.assign(options.VariableDeclarator, variableDeclaratorRules);\n        }\n        if (typeof opts.outerIIFEBody === \"number\") {\n          options.outerIIFEBody = opts.outerIIFEBody;\n        }\n        if (typeof opts.MemberExpression === \"number\") {\n          options.MemberExpression = opts.MemberExpression;\n        }\n        if (typeof opts.FunctionDeclaration === \"object\") {\n          Object.assign(options.FunctionDeclaration, opts.FunctionDeclaration);\n        }\n        if (typeof opts.FunctionExpression === \"object\") {\n          Object.assign(options.FunctionExpression, opts.FunctionExpression);\n        }\n        if (typeof opts.CallExpression === \"object\") {\n          Object.assign(options.CallExpression, opts.CallExpression);\n        }\n        if (typeof opts.ArrayExpression === \"number\" || typeof opts.ArrayExpression === \"string\") {\n          options.ArrayExpression = opts.ArrayExpression;\n        }\n        if (typeof opts.ObjectExpression === \"number\" || typeof opts.ObjectExpression === \"string\") {\n          options.ObjectExpression = opts.ObjectExpression;\n        }\n      }\n    }\n    const caseIndentStore = {};\n\n    /**\n     * Creates an error message for a line, given the expected/actual indentation.\n     * @param {int} expectedAmount The expected amount of indentation characters for this line\n     * @param {int} actualSpaces The actual number of indentation spaces that were found on this line\n     * @param {int} actualTabs The actual number of indentation tabs that were found on this line\n     * @returns {string} An error message for this line\n     */\n    function createErrorMessageData(expectedAmount, actualSpaces, actualTabs) {\n      const expectedStatement = `${expectedAmount} ${indentType}${expectedAmount === 1 ? \"\" : \"s\"}`; // e.g. \"2 tabs\"\n      const foundSpacesWord = `space${actualSpaces === 1 ? \"\" : \"s\"}`; // e.g. \"space\"\n      const foundTabsWord = `tab${actualTabs === 1 ? \"\" : \"s\"}`; // e.g. \"tabs\"\n      let foundStatement;\n      if (actualSpaces > 0 && actualTabs > 0) {\n        foundStatement = `${actualSpaces} ${foundSpacesWord} and ${actualTabs} ${foundTabsWord}`; // e.g. \"1 space and 2 tabs\"\n      } else if (actualSpaces > 0) {\n        /*\n         * Abbreviate the message if the expected indentation is also spaces.\n         * e.g. 'Expected 4 spaces but found 2' rather than 'Expected 4 spaces but found 2 spaces'\n         */\n        foundStatement = indentType === \"space\" ? actualSpaces : `${actualSpaces} ${foundSpacesWord}`;\n      } else if (actualTabs > 0) {\n        foundStatement = indentType === \"tab\" ? actualTabs : `${actualTabs} ${foundTabsWord}`;\n      } else {\n        foundStatement = \"0\";\n      }\n      return {\n        expected: expectedStatement,\n        actual: foundStatement\n      };\n    }\n\n    /**\n     * Reports a given indent violation\n     * @param {ASTNode} node Node violating the indent rule\n     * @param {int} needed Expected indentation character count\n     * @param {int} gottenSpaces Indentation space count in the actual node/code\n     * @param {int} gottenTabs Indentation tab count in the actual node/code\n     * @param {Object} [loc] Error line and column location\n     * @param {boolean} isLastNodeCheck Is the error for last node check\n     * @returns {void}\n     */\n    function report(node, needed, gottenSpaces, gottenTabs, loc, isLastNodeCheck) {\n      if (gottenSpaces && gottenTabs) {\n        // To avoid conflicts with `no-mixed-spaces-and-tabs`, don't report lines that have both spaces and tabs.\n        return;\n      }\n      const desiredIndent = (indentType === \"space\" ? \" \" : \"\\t\").repeat(needed);\n      const textRange = isLastNodeCheck ? [node.range[1] - node.loc.end.column, node.range[1] - node.loc.end.column + gottenSpaces + gottenTabs] : [node.range[0] - node.loc.start.column, node.range[0] - node.loc.start.column + gottenSpaces + gottenTabs];\n      context.report({\n        node,\n        loc,\n        messageId: \"expected\",\n        data: createErrorMessageData(needed, gottenSpaces, gottenTabs),\n        fix: fixer => fixer.replaceTextRange(textRange, desiredIndent)\n      });\n    }\n\n    /**\n     * Get the actual indent of node\n     * @param {ASTNode|Token} node Node to examine\n     * @param {boolean} [byLastLine=false] get indent of node's last line\n     * @returns {Object} The node's indent. Contains keys `space` and `tab`, representing the indent of each character. Also\n     * contains keys `goodChar` and `badChar`, where `goodChar` is the amount of the user's desired indentation character, and\n     * `badChar` is the amount of the other indentation character.\n     */\n    function getNodeIndent(node, byLastLine) {\n      const token = byLastLine ? sourceCode.getLastToken(node) : sourceCode.getFirstToken(node);\n      const srcCharsBeforeNode = sourceCode.getText(token, token.loc.start.column).split(\"\");\n      const indentChars = srcCharsBeforeNode.slice(0, srcCharsBeforeNode.findIndex(char => char !== \" \" && char !== \"\\t\"));\n      const spaces = indentChars.filter(char => char === \" \").length;\n      const tabs = indentChars.filter(char => char === \"\\t\").length;\n      return {\n        space: spaces,\n        tab: tabs,\n        goodChar: indentType === \"space\" ? spaces : tabs,\n        badChar: indentType === \"space\" ? tabs : spaces\n      };\n    }\n\n    /**\n     * Checks node is the first in its own start line. By default it looks by start line.\n     * @param {ASTNode} node The node to check\n     * @param {boolean} [byEndLocation=false] Lookup based on start position or end\n     * @returns {boolean} true if its the first in the its start line\n     */\n    function isNodeFirstInLine(node, byEndLocation) {\n      const firstToken = byEndLocation === true ? sourceCode.getLastToken(node, 1) : sourceCode.getTokenBefore(node),\n        startLine = byEndLocation === true ? node.loc.end.line : node.loc.start.line,\n        endLine = firstToken ? firstToken.loc.end.line : -1;\n      return startLine !== endLine;\n    }\n\n    /**\n     * Check indent for node\n     * @param {ASTNode} node Node to check\n     * @param {int} neededIndent needed indent\n     * @returns {void}\n     */\n    function checkNodeIndent(node, neededIndent) {\n      const actualIndent = getNodeIndent(node, false);\n      if (node.type !== \"ArrayExpression\" && node.type !== \"ObjectExpression\" && (actualIndent.goodChar !== neededIndent || actualIndent.badChar !== 0) && isNodeFirstInLine(node)) {\n        report(node, neededIndent, actualIndent.space, actualIndent.tab);\n      }\n      if (node.type === \"IfStatement\" && node.alternate) {\n        const elseToken = sourceCode.getTokenBefore(node.alternate);\n        checkNodeIndent(elseToken, neededIndent);\n        if (!isNodeFirstInLine(node.alternate)) {\n          checkNodeIndent(node.alternate, neededIndent);\n        }\n      }\n      if (node.type === \"TryStatement\" && node.handler) {\n        const catchToken = sourceCode.getFirstToken(node.handler);\n        checkNodeIndent(catchToken, neededIndent);\n      }\n      if (node.type === \"TryStatement\" && node.finalizer) {\n        const finallyToken = sourceCode.getTokenBefore(node.finalizer);\n        checkNodeIndent(finallyToken, neededIndent);\n      }\n      if (node.type === \"DoWhileStatement\") {\n        const whileToken = sourceCode.getTokenAfter(node.body);\n        checkNodeIndent(whileToken, neededIndent);\n      }\n    }\n\n    /**\n     * Check indent for nodes list\n     * @param {ASTNode[]} nodes list of node objects\n     * @param {int} indent needed indent\n     * @returns {void}\n     */\n    function checkNodesIndent(nodes, indent) {\n      nodes.forEach(node => checkNodeIndent(node, indent));\n    }\n\n    /**\n     * Check last node line indent this detects, that block closed correctly\n     * @param {ASTNode} node Node to examine\n     * @param {int} lastLineIndent needed indent\n     * @returns {void}\n     */\n    function checkLastNodeLineIndent(node, lastLineIndent) {\n      const lastToken = sourceCode.getLastToken(node);\n      const endIndent = getNodeIndent(lastToken, true);\n      if ((endIndent.goodChar !== lastLineIndent || endIndent.badChar !== 0) && isNodeFirstInLine(node, true)) {\n        report(node, lastLineIndent, endIndent.space, endIndent.tab, {\n          line: lastToken.loc.start.line,\n          column: lastToken.loc.start.column\n        }, true);\n      }\n    }\n\n    /**\n     * Check last node line indent this detects, that block closed correctly\n     * This function for more complicated return statement case, where closing parenthesis may be followed by ';'\n     * @param {ASTNode} node Node to examine\n     * @param {int} firstLineIndent first line needed indent\n     * @returns {void}\n     */\n    function checkLastReturnStatementLineIndent(node, firstLineIndent) {\n      /*\n       * in case if return statement ends with ');' we have traverse back to ')'\n       * otherwise we'll measure indent for ';' and replace ')'\n       */\n      const lastToken = sourceCode.getLastToken(node, astUtils.isClosingParenToken);\n      const textBeforeClosingParenthesis = sourceCode.getText(lastToken, lastToken.loc.start.column).slice(0, -1);\n      if (textBeforeClosingParenthesis.trim()) {\n        // There are tokens before the closing paren, don't report this case\n        return;\n      }\n      const endIndent = getNodeIndent(lastToken, true);\n      if (endIndent.goodChar !== firstLineIndent) {\n        report(node, firstLineIndent, endIndent.space, endIndent.tab, {\n          line: lastToken.loc.start.line,\n          column: lastToken.loc.start.column\n        }, true);\n      }\n    }\n\n    /**\n     * Check first node line indent is correct\n     * @param {ASTNode} node Node to examine\n     * @param {int} firstLineIndent needed indent\n     * @returns {void}\n     */\n    function checkFirstNodeLineIndent(node, firstLineIndent) {\n      const startIndent = getNodeIndent(node, false);\n      if ((startIndent.goodChar !== firstLineIndent || startIndent.badChar !== 0) && isNodeFirstInLine(node)) {\n        report(node, firstLineIndent, startIndent.space, startIndent.tab, {\n          line: node.loc.start.line,\n          column: node.loc.start.column\n        });\n      }\n    }\n\n    /**\n     * Returns a parent node of given node based on a specified type\n     * if not present then return null\n     * @param {ASTNode} node node to examine\n     * @param {string} type type that is being looked for\n     * @param {string} stopAtList end points for the evaluating code\n     * @returns {ASTNode|void} if found then node otherwise null\n     */\n    function getParentNodeByType(node, type, stopAtList) {\n      let parent = node.parent;\n      const stopAtSet = new Set(stopAtList || [\"Program\"]);\n      while (parent.type !== type && !stopAtSet.has(parent.type) && parent.type !== \"Program\") {\n        parent = parent.parent;\n      }\n      return parent.type === type ? parent : null;\n    }\n\n    /**\n     * Returns the VariableDeclarator based on the current node\n     * if not present then return null\n     * @param {ASTNode} node node to examine\n     * @returns {ASTNode|void} if found then node otherwise null\n     */\n    function getVariableDeclaratorNode(node) {\n      return getParentNodeByType(node, \"VariableDeclarator\");\n    }\n\n    /**\n     * Check to see if the node is part of the multi-line variable declaration.\n     * Also if its on the same line as the varNode\n     * @param {ASTNode} node node to check\n     * @param {ASTNode} varNode variable declaration node to check against\n     * @returns {boolean} True if all the above condition satisfy\n     */\n    function isNodeInVarOnTop(node, varNode) {\n      return varNode && varNode.parent.loc.start.line === node.loc.start.line && varNode.parent.declarations.length > 1;\n    }\n\n    /**\n     * Check to see if the argument before the callee node is multi-line and\n     * there should only be 1 argument before the callee node\n     * @param {ASTNode} node node to check\n     * @returns {boolean} True if arguments are multi-line\n     */\n    function isArgBeforeCalleeNodeMultiline(node) {\n      const parent = node.parent;\n      if (parent.arguments.length >= 2 && parent.arguments[1] === node) {\n        return parent.arguments[0].loc.end.line > parent.arguments[0].loc.start.line;\n      }\n      return false;\n    }\n\n    /**\n     * Check to see if the node is a file level IIFE\n     * @param {ASTNode} node The function node to check.\n     * @returns {boolean} True if the node is the outer IIFE\n     */\n    function isOuterIIFE(node) {\n      const parent = node.parent;\n      let stmt = parent.parent;\n\n      /*\n       * Verify that the node is an IIEF\n       */\n      if (parent.type !== \"CallExpression\" || parent.callee !== node) {\n        return false;\n      }\n\n      /*\n       * Navigate legal ancestors to determine whether this IIEF is outer\n       */\n      while (stmt.type === \"UnaryExpression\" && (stmt.operator === \"!\" || stmt.operator === \"~\" || stmt.operator === \"+\" || stmt.operator === \"-\") || stmt.type === \"AssignmentExpression\" || stmt.type === \"LogicalExpression\" || stmt.type === \"SequenceExpression\" || stmt.type === \"VariableDeclarator\") {\n        stmt = stmt.parent;\n      }\n      return (stmt.type === \"ExpressionStatement\" || stmt.type === \"VariableDeclaration\") && stmt.parent && stmt.parent.type === \"Program\";\n    }\n\n    /**\n     * Check indent for function block content\n     * @param {ASTNode} node A BlockStatement node that is inside of a function.\n     * @returns {void}\n     */\n    function checkIndentInFunctionBlock(node) {\n      /*\n       * Search first caller in chain.\n       * Ex.:\n       *\n       * Models <- Identifier\n       *   .User\n       *   .find()\n       *   .exec(function() {\n       *   // function body\n       * });\n       *\n       * Looks for 'Models'\n       */\n      const calleeNode = node.parent; // FunctionExpression\n      let indent;\n      if (calleeNode.parent && (calleeNode.parent.type === \"Property\" || calleeNode.parent.type === \"ArrayExpression\")) {\n        // If function is part of array or object, comma can be put at left\n        indent = getNodeIndent(calleeNode, false).goodChar;\n      } else {\n        // If function is standalone, simple calculate indent\n        indent = getNodeIndent(calleeNode).goodChar;\n      }\n      if (calleeNode.parent.type === \"CallExpression\") {\n        const calleeParent = calleeNode.parent;\n        if (calleeNode.type !== \"FunctionExpression\" && calleeNode.type !== \"ArrowFunctionExpression\") {\n          if (calleeParent && calleeParent.loc.start.line < node.loc.start.line) {\n            indent = getNodeIndent(calleeParent).goodChar;\n          }\n        } else {\n          if (isArgBeforeCalleeNodeMultiline(calleeNode) && calleeParent.callee.loc.start.line === calleeParent.callee.loc.end.line && !isNodeFirstInLine(calleeNode)) {\n            indent = getNodeIndent(calleeParent).goodChar;\n          }\n        }\n      }\n\n      /*\n       * function body indent should be indent + indent size, unless this\n       * is a FunctionDeclaration, FunctionExpression, or outer IIFE and the corresponding options are enabled.\n       */\n      let functionOffset = indentSize;\n      if (options.outerIIFEBody !== null && isOuterIIFE(calleeNode)) {\n        functionOffset = options.outerIIFEBody * indentSize;\n      } else if (calleeNode.type === \"FunctionExpression\") {\n        functionOffset = options.FunctionExpression.body * indentSize;\n      } else if (calleeNode.type === \"FunctionDeclaration\") {\n        functionOffset = options.FunctionDeclaration.body * indentSize;\n      }\n      indent += functionOffset;\n\n      // check if the node is inside a variable\n      const parentVarNode = getVariableDeclaratorNode(node);\n      if (parentVarNode && isNodeInVarOnTop(node, parentVarNode)) {\n        indent += indentSize * options.VariableDeclarator[parentVarNode.parent.kind];\n      }\n      if (node.body.length > 0) {\n        checkNodesIndent(node.body, indent);\n      }\n      checkLastNodeLineIndent(node, indent - functionOffset);\n    }\n\n    /**\n     * Checks if the given node starts and ends on the same line\n     * @param {ASTNode} node The node to check\n     * @returns {boolean} Whether or not the block starts and ends on the same line.\n     */\n    function isSingleLineNode(node) {\n      const lastToken = sourceCode.getLastToken(node),\n        startLine = node.loc.start.line,\n        endLine = lastToken.loc.end.line;\n      return startLine === endLine;\n    }\n\n    /**\n     * Check indent for array block content or object block content\n     * @param {ASTNode} node node to examine\n     * @returns {void}\n     */\n    function checkIndentInArrayOrObjectBlock(node) {\n      // Skip inline\n      if (isSingleLineNode(node)) {\n        return;\n      }\n      let elements = node.type === \"ArrayExpression\" ? node.elements : node.properties;\n\n      // filter out empty elements example would be [ , 2] so remove first element as espree considers it as null\n      elements = elements.filter(elem => elem !== null);\n      let nodeIndent;\n      let elementsIndent;\n      const parentVarNode = getVariableDeclaratorNode(node);\n\n      // TODO - come up with a better strategy in future\n      if (isNodeFirstInLine(node)) {\n        const parent = node.parent;\n        nodeIndent = getNodeIndent(parent).goodChar;\n        if (!parentVarNode || parentVarNode.loc.start.line !== node.loc.start.line) {\n          if (parent.type !== \"VariableDeclarator\" || parentVarNode === parentVarNode.parent.declarations[0]) {\n            if (parent.type === \"VariableDeclarator\" && parentVarNode.loc.start.line === parent.loc.start.line) {\n              nodeIndent += indentSize * options.VariableDeclarator[parentVarNode.parent.kind];\n            } else if (parent.type === \"ObjectExpression\" || parent.type === \"ArrayExpression\") {\n              const parentElements = node.parent.type === \"ObjectExpression\" ? node.parent.properties : node.parent.elements;\n              if (parentElements[0] && parentElements[0].loc.start.line === parent.loc.start.line && parentElements[0].loc.end.line !== parent.loc.start.line) {\n\n                /*\n                 * If the first element of the array spans multiple lines, don't increase the expected indentation of the rest.\n                 * e.g. [{\n                 *        foo: 1\n                 *      },\n                 *      {\n                 *        bar: 1\n                 *      }]\n                 * the second object is not indented.\n                 */\n              } else if (typeof options[parent.type] === \"number\") {\n                nodeIndent += options[parent.type] * indentSize;\n              } else {\n                nodeIndent = parentElements[0].loc.start.column;\n              }\n            } else if (parent.type === \"CallExpression\" || parent.type === \"NewExpression\") {\n              if (typeof options.CallExpression.arguments === \"number\") {\n                nodeIndent += options.CallExpression.arguments * indentSize;\n              } else if (options.CallExpression.arguments === \"first\") {\n                if (parent.arguments.indexOf(node) !== -1) {\n                  nodeIndent = parent.arguments[0].loc.start.column;\n                }\n              } else {\n                nodeIndent += indentSize;\n              }\n            } else if (parent.type === \"LogicalExpression\" || parent.type === \"ArrowFunctionExpression\") {\n              nodeIndent += indentSize;\n            }\n          }\n        }\n        checkFirstNodeLineIndent(node, nodeIndent);\n      } else {\n        nodeIndent = getNodeIndent(node).goodChar;\n      }\n      if (options[node.type] === \"first\") {\n        elementsIndent = elements.length ? elements[0].loc.start.column : 0; // If there are no elements, elementsIndent doesn't matter.\n      } else {\n        elementsIndent = nodeIndent + indentSize * options[node.type];\n      }\n\n      /*\n       * Check if the node is a multiple variable declaration; if so, then\n       * make sure indentation takes that into account.\n       */\n      if (isNodeInVarOnTop(node, parentVarNode)) {\n        elementsIndent += indentSize * options.VariableDeclarator[parentVarNode.parent.kind];\n      }\n      checkNodesIndent(elements, elementsIndent);\n      if (elements.length > 0) {\n        // Skip last block line check if last item in same line\n        if (elements[elements.length - 1].loc.end.line === node.loc.end.line) {\n          return;\n        }\n      }\n      checkLastNodeLineIndent(node, nodeIndent + (isNodeInVarOnTop(node, parentVarNode) ? options.VariableDeclarator[parentVarNode.parent.kind] * indentSize : 0));\n    }\n\n    /**\n     * Check if the node or node body is a BlockStatement or not\n     * @param {ASTNode} node node to test\n     * @returns {boolean} True if it or its body is a block statement\n     */\n    function isNodeBodyBlock(node) {\n      return node.type === \"BlockStatement\" || node.type === \"ClassBody\" || node.body && node.body.type === \"BlockStatement\" || node.consequent && node.consequent.type === \"BlockStatement\";\n    }\n\n    /**\n     * Check indentation for blocks\n     * @param {ASTNode} node node to check\n     * @returns {void}\n     */\n    function blockIndentationCheck(node) {\n      // Skip inline blocks\n      if (isSingleLineNode(node)) {\n        return;\n      }\n      if (node.parent && (node.parent.type === \"FunctionExpression\" || node.parent.type === \"FunctionDeclaration\" || node.parent.type === \"ArrowFunctionExpression\")) {\n        checkIndentInFunctionBlock(node);\n        return;\n      }\n      let indent;\n      let nodesToCheck = [];\n\n      /*\n       * For this statements we should check indent from statement beginning,\n       * not from the beginning of the block.\n       */\n      const statementsWithProperties = [\"IfStatement\", \"WhileStatement\", \"ForStatement\", \"ForInStatement\", \"ForOfStatement\", \"DoWhileStatement\", \"ClassDeclaration\", \"TryStatement\"];\n      if (node.parent && statementsWithProperties.indexOf(node.parent.type) !== -1 && isNodeBodyBlock(node)) {\n        indent = getNodeIndent(node.parent).goodChar;\n      } else if (node.parent && node.parent.type === \"CatchClause\") {\n        indent = getNodeIndent(node.parent.parent).goodChar;\n      } else {\n        indent = getNodeIndent(node).goodChar;\n      }\n      if (node.type === \"IfStatement\" && node.consequent.type !== \"BlockStatement\") {\n        nodesToCheck = [node.consequent];\n      } else if (Array.isArray(node.body)) {\n        nodesToCheck = node.body;\n      } else {\n        nodesToCheck = [node.body];\n      }\n      if (nodesToCheck.length > 0) {\n        checkNodesIndent(nodesToCheck, indent + indentSize);\n      }\n      if (node.type === \"BlockStatement\") {\n        checkLastNodeLineIndent(node, indent);\n      }\n    }\n\n    /**\n     * Filter out the elements which are on the same line of each other or the node.\n     * basically have only 1 elements from each line except the variable declaration line.\n     * @param {ASTNode} node Variable declaration node\n     * @returns {ASTNode[]} Filtered elements\n     */\n    function filterOutSameLineVars(node) {\n      return node.declarations.reduce((finalCollection, elem) => {\n        const lastElem = finalCollection[finalCollection.length - 1];\n        if (elem.loc.start.line !== node.loc.start.line && !lastElem || lastElem && lastElem.loc.start.line !== elem.loc.start.line) {\n          finalCollection.push(elem);\n        }\n        return finalCollection;\n      }, []);\n    }\n\n    /**\n     * Check indentation for variable declarations\n     * @param {ASTNode} node node to examine\n     * @returns {void}\n     */\n    function checkIndentInVariableDeclarations(node) {\n      const elements = filterOutSameLineVars(node);\n      const nodeIndent = getNodeIndent(node).goodChar;\n      const lastElement = elements[elements.length - 1];\n      const elementsIndent = nodeIndent + indentSize * options.VariableDeclarator[node.kind];\n      checkNodesIndent(elements, elementsIndent);\n\n      // Only check the last line if there is any token after the last item\n      if (sourceCode.getLastToken(node).loc.end.line <= lastElement.loc.end.line) {\n        return;\n      }\n      const tokenBeforeLastElement = sourceCode.getTokenBefore(lastElement);\n      if (tokenBeforeLastElement.value === \",\") {\n        // Special case for comma-first syntax where the semicolon is indented\n        checkLastNodeLineIndent(node, getNodeIndent(tokenBeforeLastElement).goodChar);\n      } else {\n        checkLastNodeLineIndent(node, elementsIndent - indentSize);\n      }\n    }\n\n    /**\n     * Check and decide whether to check for indentation for blockless nodes\n     * Scenarios are for or while statements without braces around them\n     * @param {ASTNode} node node to examine\n     * @returns {void}\n     */\n    function blockLessNodes(node) {\n      if (node.body.type !== \"BlockStatement\") {\n        blockIndentationCheck(node);\n      }\n    }\n\n    /**\n     * Returns the expected indentation for the case statement\n     * @param {ASTNode} node node to examine\n     * @param {int} [providedSwitchIndent] indent for switch statement\n     * @returns {int} indent size\n     */\n    function expectedCaseIndent(node, providedSwitchIndent) {\n      const switchNode = node.type === \"SwitchStatement\" ? node : node.parent;\n      const switchIndent = typeof providedSwitchIndent === \"undefined\" ? getNodeIndent(switchNode).goodChar : providedSwitchIndent;\n      let caseIndent;\n      if (caseIndentStore[switchNode.loc.start.line]) {\n        return caseIndentStore[switchNode.loc.start.line];\n      }\n      if (switchNode.cases.length > 0 && options.SwitchCase === 0) {\n        caseIndent = switchIndent;\n      } else {\n        caseIndent = switchIndent + indentSize * options.SwitchCase;\n      }\n      caseIndentStore[switchNode.loc.start.line] = caseIndent;\n      return caseIndent;\n    }\n\n    /**\n     * Checks whether a return statement is wrapped in ()\n     * @param {ASTNode} node node to examine\n     * @returns {boolean} the result\n     */\n    function isWrappedInParenthesis(node) {\n      const regex = /^return\\s*?\\(\\s*?\\);*?/u;\n      const statementWithoutArgument = sourceCode.getText(node).replace(sourceCode.getText(node.argument), \"\");\n      return regex.test(statementWithoutArgument);\n    }\n    return {\n      Program(node) {\n        if (node.body.length > 0) {\n          // Root nodes should have no indent\n          checkNodesIndent(node.body, getNodeIndent(node).goodChar);\n        }\n      },\n      ClassBody: blockIndentationCheck,\n      BlockStatement: blockIndentationCheck,\n      WhileStatement: blockLessNodes,\n      ForStatement: blockLessNodes,\n      ForInStatement: blockLessNodes,\n      ForOfStatement: blockLessNodes,\n      DoWhileStatement: blockLessNodes,\n      IfStatement(node) {\n        if (node.consequent.type !== \"BlockStatement\" && node.consequent.loc.start.line > node.loc.start.line) {\n          blockIndentationCheck(node);\n        }\n      },\n      VariableDeclaration(node) {\n        if (node.declarations[node.declarations.length - 1].loc.start.line > node.declarations[0].loc.start.line) {\n          checkIndentInVariableDeclarations(node);\n        }\n      },\n      ObjectExpression(node) {\n        checkIndentInArrayOrObjectBlock(node);\n      },\n      ArrayExpression(node) {\n        checkIndentInArrayOrObjectBlock(node);\n      },\n      MemberExpression(node) {\n        if (typeof options.MemberExpression === \"undefined\") {\n          return;\n        }\n        if (isSingleLineNode(node)) {\n          return;\n        }\n\n        /*\n         * The typical layout of variable declarations and assignments\n         * alter the expectation of correct indentation. Skip them.\n         * TODO: Add appropriate configuration options for variable\n         * declarations and assignments.\n         */\n        if (getParentNodeByType(node, \"VariableDeclarator\", [\"FunctionExpression\", \"ArrowFunctionExpression\"])) {\n          return;\n        }\n        if (getParentNodeByType(node, \"AssignmentExpression\", [\"FunctionExpression\"])) {\n          return;\n        }\n        const propertyIndent = getNodeIndent(node).goodChar + indentSize * options.MemberExpression;\n        const checkNodes = [node.property];\n        const dot = sourceCode.getTokenBefore(node.property);\n        if (dot.type === \"Punctuator\" && dot.value === \".\") {\n          checkNodes.push(dot);\n        }\n        checkNodesIndent(checkNodes, propertyIndent);\n      },\n      SwitchStatement(node) {\n        // Switch is not a 'BlockStatement'\n        const switchIndent = getNodeIndent(node).goodChar;\n        const caseIndent = expectedCaseIndent(node, switchIndent);\n        checkNodesIndent(node.cases, caseIndent);\n        checkLastNodeLineIndent(node, switchIndent);\n      },\n      SwitchCase(node) {\n        // Skip inline cases\n        if (isSingleLineNode(node)) {\n          return;\n        }\n        const caseIndent = expectedCaseIndent(node);\n        checkNodesIndent(node.consequent, caseIndent + indentSize);\n      },\n      FunctionDeclaration(node) {\n        if (isSingleLineNode(node)) {\n          return;\n        }\n        if (options.FunctionDeclaration.parameters === \"first\" && node.params.length) {\n          checkNodesIndent(node.params.slice(1), node.params[0].loc.start.column);\n        } else if (options.FunctionDeclaration.parameters !== null) {\n          checkNodesIndent(node.params, getNodeIndent(node).goodChar + indentSize * options.FunctionDeclaration.parameters);\n        }\n      },\n      FunctionExpression(node) {\n        if (isSingleLineNode(node)) {\n          return;\n        }\n        if (options.FunctionExpression.parameters === \"first\" && node.params.length) {\n          checkNodesIndent(node.params.slice(1), node.params[0].loc.start.column);\n        } else if (options.FunctionExpression.parameters !== null) {\n          checkNodesIndent(node.params, getNodeIndent(node).goodChar + indentSize * options.FunctionExpression.parameters);\n        }\n      },\n      ReturnStatement(node) {\n        if (isSingleLineNode(node)) {\n          return;\n        }\n        const firstLineIndent = getNodeIndent(node).goodChar;\n\n        // in case if return statement is wrapped in parenthesis\n        if (isWrappedInParenthesis(node)) {\n          checkLastReturnStatementLineIndent(node, firstLineIndent);\n        } else {\n          checkNodeIndent(node, firstLineIndent);\n        }\n      },\n      CallExpression(node) {\n        if (isSingleLineNode(node)) {\n          return;\n        }\n        if (options.CallExpression.arguments === \"first\" && node.arguments.length) {\n          checkNodesIndent(node.arguments.slice(1), node.arguments[0].loc.start.column);\n        } else if (options.CallExpression.arguments !== null) {\n          checkNodesIndent(node.arguments, getNodeIndent(node).goodChar + indentSize * options.CallExpression.arguments);\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["require","astUtils","module","exports","meta","type","docs","description","category","recommended","url","deprecated","replacedBy","fixable","schema","oneOf","enum","minimum","properties","SwitchCase","VariableDeclarator","var","let","const","outerIIFEBody","MemberExpression","FunctionDeclaration","parameters","body","FunctionExpression","CallExpression","ArrayExpression","ObjectExpression","additionalProperties","messages","expected","create","context","DEFAULT_VARIABLE_INDENT","DEFAULT_PARAMETER_INDENT","DEFAULT_FUNCTION_BODY_INDENT","indentType","indentSize","options","arguments","sourceCode","getSourceCode","length","opts","variableDeclaratorRules","Object","assign","caseIndentStore","createErrorMessageData","expectedAmount","actualSpaces","actualTabs","expectedStatement","foundSpacesWord","foundTabsWord","foundStatement","actual","report","node","needed","gottenSpaces","gottenTabs","loc","isLastNodeCheck","desiredIndent","repeat","textRange","range","end","column","start","messageId","data","fix","fixer","replaceTextRange","getNodeIndent","byLastLine","token","getLastToken","getFirstToken","srcCharsBeforeNode","getText","split","indentChars","slice","findIndex","char","spaces","filter","tabs","space","tab","goodChar","badChar","isNodeFirstInLine","byEndLocation","firstToken","getTokenBefore","startLine","line","endLine","checkNodeIndent","neededIndent","actualIndent","alternate","elseToken","handler","catchToken","finalizer","finallyToken","whileToken","getTokenAfter","checkNodesIndent","nodes","indent","forEach","checkLastNodeLineIndent","lastLineIndent","lastToken","endIndent","checkLastReturnStatementLineIndent","firstLineIndent","isClosingParenToken","textBeforeClosingParenthesis","trim","checkFirstNodeLineIndent","startIndent","getParentNodeByType","stopAtList","parent","stopAtSet","Set","has","getVariableDeclaratorNode","isNodeInVarOnTop","varNode","declarations","isArgBeforeCalleeNodeMultiline","isOuterIIFE","stmt","callee","operator","checkIndentInFunctionBlock","calleeNode","calleeParent","functionOffset","parentVarNode","kind","isSingleLineNode","checkIndentInArrayOrObjectBlock","elements","elem","nodeIndent","elementsIndent","parentElements","indexOf","isNodeBodyBlock","consequent","blockIndentationCheck","nodesToCheck","statementsWithProperties","Array","isArray","filterOutSameLineVars","reduce","finalCollection","lastElem","push","checkIndentInVariableDeclarations","lastElement","tokenBeforeLastElement","value","blockLessNodes","expectedCaseIndent","providedSwitchIndent","switchNode","switchIndent","caseIndent","cases","isWrappedInParenthesis","regex","statementWithoutArgument","replace","argument","test","Program","ClassBody","BlockStatement","WhileStatement","ForStatement","ForInStatement","ForOfStatement","DoWhileStatement","IfStatement","VariableDeclaration","propertyIndent","checkNodes","property","dot","SwitchStatement","params","ReturnStatement"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/indent-legacy.js"],"sourcesContent":["/**\n * @fileoverview This option sets a specific tab width for your code\n *\n * This rule has been ported and modified from nodeca.\n * @author Vitaly Puzrin\n * @author Gyandeep Singh\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/* istanbul ignore next: this rule has known coverage issues, but it's deprecated and shouldn't be updated in the future anyway. */\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce consistent indentation\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/indent-legacy\"\n        },\n\n        deprecated: true,\n\n        replacedBy: [\"indent\"],\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"tab\"]\n                    },\n                    {\n                        type: \"integer\",\n                        minimum: 0\n                    }\n                ]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    SwitchCase: {\n                        type: \"integer\",\n                        minimum: 0\n                    },\n                    VariableDeclarator: {\n                        oneOf: [\n                            {\n                                type: \"integer\",\n                                minimum: 0\n                            },\n                            {\n                                type: \"object\",\n                                properties: {\n                                    var: {\n                                        type: \"integer\",\n                                        minimum: 0\n                                    },\n                                    let: {\n                                        type: \"integer\",\n                                        minimum: 0\n                                    },\n                                    const: {\n                                        type: \"integer\",\n                                        minimum: 0\n                                    }\n                                }\n                            }\n                        ]\n                    },\n                    outerIIFEBody: {\n                        type: \"integer\",\n                        minimum: 0\n                    },\n                    MemberExpression: {\n                        type: \"integer\",\n                        minimum: 0\n                    },\n                    FunctionDeclaration: {\n                        type: \"object\",\n                        properties: {\n                            parameters: {\n                                oneOf: [\n                                    {\n                                        type: \"integer\",\n                                        minimum: 0\n                                    },\n                                    {\n                                        enum: [\"first\"]\n                                    }\n                                ]\n                            },\n                            body: {\n                                type: \"integer\",\n                                minimum: 0\n                            }\n                        }\n                    },\n                    FunctionExpression: {\n                        type: \"object\",\n                        properties: {\n                            parameters: {\n                                oneOf: [\n                                    {\n                                        type: \"integer\",\n                                        minimum: 0\n                                    },\n                                    {\n                                        enum: [\"first\"]\n                                    }\n                                ]\n                            },\n                            body: {\n                                type: \"integer\",\n                                minimum: 0\n                            }\n                        }\n                    },\n                    CallExpression: {\n                        type: \"object\",\n                        properties: {\n                            parameters: {\n                                oneOf: [\n                                    {\n                                        type: \"integer\",\n                                        minimum: 0\n                                    },\n                                    {\n                                        enum: [\"first\"]\n                                    }\n                                ]\n                            }\n                        }\n                    },\n                    ArrayExpression: {\n                        oneOf: [\n                            {\n                                type: \"integer\",\n                                minimum: 0\n                            },\n                            {\n                                enum: [\"first\"]\n                            }\n                        ]\n                    },\n                    ObjectExpression: {\n                        oneOf: [\n                            {\n                                type: \"integer\",\n                                minimum: 0\n                            },\n                            {\n                                enum: [\"first\"]\n                            }\n                        ]\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n        messages: {\n            expected: \"Expected indentation of {{expected}} but found {{actual}}.\"\n        }\n    },\n\n    create(context) {\n        const DEFAULT_VARIABLE_INDENT = 1;\n        const DEFAULT_PARAMETER_INDENT = null; // For backwards compatibility, don't check parameter indentation unless specified in the config\n        const DEFAULT_FUNCTION_BODY_INDENT = 1;\n\n        let indentType = \"space\";\n        let indentSize = 4;\n        const options = {\n            SwitchCase: 0,\n            VariableDeclarator: {\n                var: DEFAULT_VARIABLE_INDENT,\n                let: DEFAULT_VARIABLE_INDENT,\n                const: DEFAULT_VARIABLE_INDENT\n            },\n            outerIIFEBody: null,\n            FunctionDeclaration: {\n                parameters: DEFAULT_PARAMETER_INDENT,\n                body: DEFAULT_FUNCTION_BODY_INDENT\n            },\n            FunctionExpression: {\n                parameters: DEFAULT_PARAMETER_INDENT,\n                body: DEFAULT_FUNCTION_BODY_INDENT\n            },\n            CallExpression: {\n                arguments: DEFAULT_PARAMETER_INDENT\n            },\n            ArrayExpression: 1,\n            ObjectExpression: 1\n        };\n\n        const sourceCode = context.getSourceCode();\n\n        if (context.options.length) {\n            if (context.options[0] === \"tab\") {\n                indentSize = 1;\n                indentType = \"tab\";\n            } else /* istanbul ignore else : this will be caught by options validation */ if (typeof context.options[0] === \"number\") {\n                indentSize = context.options[0];\n                indentType = \"space\";\n            }\n\n            if (context.options[1]) {\n                const opts = context.options[1];\n\n                options.SwitchCase = opts.SwitchCase || 0;\n                const variableDeclaratorRules = opts.VariableDeclarator;\n\n                if (typeof variableDeclaratorRules === \"number\") {\n                    options.VariableDeclarator = {\n                        var: variableDeclaratorRules,\n                        let: variableDeclaratorRules,\n                        const: variableDeclaratorRules\n                    };\n                } else if (typeof variableDeclaratorRules === \"object\") {\n                    Object.assign(options.VariableDeclarator, variableDeclaratorRules);\n                }\n\n                if (typeof opts.outerIIFEBody === \"number\") {\n                    options.outerIIFEBody = opts.outerIIFEBody;\n                }\n\n                if (typeof opts.MemberExpression === \"number\") {\n                    options.MemberExpression = opts.MemberExpression;\n                }\n\n                if (typeof opts.FunctionDeclaration === \"object\") {\n                    Object.assign(options.FunctionDeclaration, opts.FunctionDeclaration);\n                }\n\n                if (typeof opts.FunctionExpression === \"object\") {\n                    Object.assign(options.FunctionExpression, opts.FunctionExpression);\n                }\n\n                if (typeof opts.CallExpression === \"object\") {\n                    Object.assign(options.CallExpression, opts.CallExpression);\n                }\n\n                if (typeof opts.ArrayExpression === \"number\" || typeof opts.ArrayExpression === \"string\") {\n                    options.ArrayExpression = opts.ArrayExpression;\n                }\n\n                if (typeof opts.ObjectExpression === \"number\" || typeof opts.ObjectExpression === \"string\") {\n                    options.ObjectExpression = opts.ObjectExpression;\n                }\n            }\n        }\n\n        const caseIndentStore = {};\n\n        /**\n         * Creates an error message for a line, given the expected/actual indentation.\n         * @param {int} expectedAmount The expected amount of indentation characters for this line\n         * @param {int} actualSpaces The actual number of indentation spaces that were found on this line\n         * @param {int} actualTabs The actual number of indentation tabs that were found on this line\n         * @returns {string} An error message for this line\n         */\n        function createErrorMessageData(expectedAmount, actualSpaces, actualTabs) {\n            const expectedStatement = `${expectedAmount} ${indentType}${expectedAmount === 1 ? \"\" : \"s\"}`; // e.g. \"2 tabs\"\n            const foundSpacesWord = `space${actualSpaces === 1 ? \"\" : \"s\"}`; // e.g. \"space\"\n            const foundTabsWord = `tab${actualTabs === 1 ? \"\" : \"s\"}`; // e.g. \"tabs\"\n            let foundStatement;\n\n            if (actualSpaces > 0 && actualTabs > 0) {\n                foundStatement = `${actualSpaces} ${foundSpacesWord} and ${actualTabs} ${foundTabsWord}`; // e.g. \"1 space and 2 tabs\"\n            } else if (actualSpaces > 0) {\n\n                /*\n                 * Abbreviate the message if the expected indentation is also spaces.\n                 * e.g. 'Expected 4 spaces but found 2' rather than 'Expected 4 spaces but found 2 spaces'\n                 */\n                foundStatement = indentType === \"space\" ? actualSpaces : `${actualSpaces} ${foundSpacesWord}`;\n            } else if (actualTabs > 0) {\n                foundStatement = indentType === \"tab\" ? actualTabs : `${actualTabs} ${foundTabsWord}`;\n            } else {\n                foundStatement = \"0\";\n            }\n            return {\n                expected: expectedStatement,\n                actual: foundStatement\n            };\n        }\n\n        /**\n         * Reports a given indent violation\n         * @param {ASTNode} node Node violating the indent rule\n         * @param {int} needed Expected indentation character count\n         * @param {int} gottenSpaces Indentation space count in the actual node/code\n         * @param {int} gottenTabs Indentation tab count in the actual node/code\n         * @param {Object} [loc] Error line and column location\n         * @param {boolean} isLastNodeCheck Is the error for last node check\n         * @returns {void}\n         */\n        function report(node, needed, gottenSpaces, gottenTabs, loc, isLastNodeCheck) {\n            if (gottenSpaces && gottenTabs) {\n\n                // To avoid conflicts with `no-mixed-spaces-and-tabs`, don't report lines that have both spaces and tabs.\n                return;\n            }\n\n            const desiredIndent = (indentType === \"space\" ? \" \" : \"\\t\").repeat(needed);\n\n            const textRange = isLastNodeCheck\n                ? [node.range[1] - node.loc.end.column, node.range[1] - node.loc.end.column + gottenSpaces + gottenTabs]\n                : [node.range[0] - node.loc.start.column, node.range[0] - node.loc.start.column + gottenSpaces + gottenTabs];\n\n            context.report({\n                node,\n                loc,\n                messageId: \"expected\",\n                data: createErrorMessageData(needed, gottenSpaces, gottenTabs),\n                fix: fixer => fixer.replaceTextRange(textRange, desiredIndent)\n            });\n        }\n\n        /**\n         * Get the actual indent of node\n         * @param {ASTNode|Token} node Node to examine\n         * @param {boolean} [byLastLine=false] get indent of node's last line\n         * @returns {Object} The node's indent. Contains keys `space` and `tab`, representing the indent of each character. Also\n         * contains keys `goodChar` and `badChar`, where `goodChar` is the amount of the user's desired indentation character, and\n         * `badChar` is the amount of the other indentation character.\n         */\n        function getNodeIndent(node, byLastLine) {\n            const token = byLastLine ? sourceCode.getLastToken(node) : sourceCode.getFirstToken(node);\n            const srcCharsBeforeNode = sourceCode.getText(token, token.loc.start.column).split(\"\");\n            const indentChars = srcCharsBeforeNode.slice(0, srcCharsBeforeNode.findIndex(char => char !== \" \" && char !== \"\\t\"));\n            const spaces = indentChars.filter(char => char === \" \").length;\n            const tabs = indentChars.filter(char => char === \"\\t\").length;\n\n            return {\n                space: spaces,\n                tab: tabs,\n                goodChar: indentType === \"space\" ? spaces : tabs,\n                badChar: indentType === \"space\" ? tabs : spaces\n            };\n        }\n\n        /**\n         * Checks node is the first in its own start line. By default it looks by start line.\n         * @param {ASTNode} node The node to check\n         * @param {boolean} [byEndLocation=false] Lookup based on start position or end\n         * @returns {boolean} true if its the first in the its start line\n         */\n        function isNodeFirstInLine(node, byEndLocation) {\n            const firstToken = byEndLocation === true ? sourceCode.getLastToken(node, 1) : sourceCode.getTokenBefore(node),\n                startLine = byEndLocation === true ? node.loc.end.line : node.loc.start.line,\n                endLine = firstToken ? firstToken.loc.end.line : -1;\n\n            return startLine !== endLine;\n        }\n\n        /**\n         * Check indent for node\n         * @param {ASTNode} node Node to check\n         * @param {int} neededIndent needed indent\n         * @returns {void}\n         */\n        function checkNodeIndent(node, neededIndent) {\n            const actualIndent = getNodeIndent(node, false);\n\n            if (\n                node.type !== \"ArrayExpression\" &&\n                node.type !== \"ObjectExpression\" &&\n                (actualIndent.goodChar !== neededIndent || actualIndent.badChar !== 0) &&\n                isNodeFirstInLine(node)\n            ) {\n                report(node, neededIndent, actualIndent.space, actualIndent.tab);\n            }\n\n            if (node.type === \"IfStatement\" && node.alternate) {\n                const elseToken = sourceCode.getTokenBefore(node.alternate);\n\n                checkNodeIndent(elseToken, neededIndent);\n\n                if (!isNodeFirstInLine(node.alternate)) {\n                    checkNodeIndent(node.alternate, neededIndent);\n                }\n            }\n\n            if (node.type === \"TryStatement\" && node.handler) {\n                const catchToken = sourceCode.getFirstToken(node.handler);\n\n                checkNodeIndent(catchToken, neededIndent);\n            }\n\n            if (node.type === \"TryStatement\" && node.finalizer) {\n                const finallyToken = sourceCode.getTokenBefore(node.finalizer);\n\n                checkNodeIndent(finallyToken, neededIndent);\n            }\n\n            if (node.type === \"DoWhileStatement\") {\n                const whileToken = sourceCode.getTokenAfter(node.body);\n\n                checkNodeIndent(whileToken, neededIndent);\n            }\n        }\n\n        /**\n         * Check indent for nodes list\n         * @param {ASTNode[]} nodes list of node objects\n         * @param {int} indent needed indent\n         * @returns {void}\n         */\n        function checkNodesIndent(nodes, indent) {\n            nodes.forEach(node => checkNodeIndent(node, indent));\n        }\n\n        /**\n         * Check last node line indent this detects, that block closed correctly\n         * @param {ASTNode} node Node to examine\n         * @param {int} lastLineIndent needed indent\n         * @returns {void}\n         */\n        function checkLastNodeLineIndent(node, lastLineIndent) {\n            const lastToken = sourceCode.getLastToken(node);\n            const endIndent = getNodeIndent(lastToken, true);\n\n            if ((endIndent.goodChar !== lastLineIndent || endIndent.badChar !== 0) && isNodeFirstInLine(node, true)) {\n                report(\n                    node,\n                    lastLineIndent,\n                    endIndent.space,\n                    endIndent.tab,\n                    { line: lastToken.loc.start.line, column: lastToken.loc.start.column },\n                    true\n                );\n            }\n        }\n\n        /**\n         * Check last node line indent this detects, that block closed correctly\n         * This function for more complicated return statement case, where closing parenthesis may be followed by ';'\n         * @param {ASTNode} node Node to examine\n         * @param {int} firstLineIndent first line needed indent\n         * @returns {void}\n         */\n        function checkLastReturnStatementLineIndent(node, firstLineIndent) {\n\n            /*\n             * in case if return statement ends with ');' we have traverse back to ')'\n             * otherwise we'll measure indent for ';' and replace ')'\n             */\n            const lastToken = sourceCode.getLastToken(node, astUtils.isClosingParenToken);\n            const textBeforeClosingParenthesis = sourceCode.getText(lastToken, lastToken.loc.start.column).slice(0, -1);\n\n            if (textBeforeClosingParenthesis.trim()) {\n\n                // There are tokens before the closing paren, don't report this case\n                return;\n            }\n\n            const endIndent = getNodeIndent(lastToken, true);\n\n            if (endIndent.goodChar !== firstLineIndent) {\n                report(\n                    node,\n                    firstLineIndent,\n                    endIndent.space,\n                    endIndent.tab,\n                    { line: lastToken.loc.start.line, column: lastToken.loc.start.column },\n                    true\n                );\n            }\n        }\n\n        /**\n         * Check first node line indent is correct\n         * @param {ASTNode} node Node to examine\n         * @param {int} firstLineIndent needed indent\n         * @returns {void}\n         */\n        function checkFirstNodeLineIndent(node, firstLineIndent) {\n            const startIndent = getNodeIndent(node, false);\n\n            if ((startIndent.goodChar !== firstLineIndent || startIndent.badChar !== 0) && isNodeFirstInLine(node)) {\n                report(\n                    node,\n                    firstLineIndent,\n                    startIndent.space,\n                    startIndent.tab,\n                    { line: node.loc.start.line, column: node.loc.start.column }\n                );\n            }\n        }\n\n        /**\n         * Returns a parent node of given node based on a specified type\n         * if not present then return null\n         * @param {ASTNode} node node to examine\n         * @param {string} type type that is being looked for\n         * @param {string} stopAtList end points for the evaluating code\n         * @returns {ASTNode|void} if found then node otherwise null\n         */\n        function getParentNodeByType(node, type, stopAtList) {\n            let parent = node.parent;\n            const stopAtSet = new Set(stopAtList || [\"Program\"]);\n\n            while (parent.type !== type && !stopAtSet.has(parent.type) && parent.type !== \"Program\") {\n                parent = parent.parent;\n            }\n\n            return parent.type === type ? parent : null;\n        }\n\n        /**\n         * Returns the VariableDeclarator based on the current node\n         * if not present then return null\n         * @param {ASTNode} node node to examine\n         * @returns {ASTNode|void} if found then node otherwise null\n         */\n        function getVariableDeclaratorNode(node) {\n            return getParentNodeByType(node, \"VariableDeclarator\");\n        }\n\n        /**\n         * Check to see if the node is part of the multi-line variable declaration.\n         * Also if its on the same line as the varNode\n         * @param {ASTNode} node node to check\n         * @param {ASTNode} varNode variable declaration node to check against\n         * @returns {boolean} True if all the above condition satisfy\n         */\n        function isNodeInVarOnTop(node, varNode) {\n            return varNode &&\n                varNode.parent.loc.start.line === node.loc.start.line &&\n                varNode.parent.declarations.length > 1;\n        }\n\n        /**\n         * Check to see if the argument before the callee node is multi-line and\n         * there should only be 1 argument before the callee node\n         * @param {ASTNode} node node to check\n         * @returns {boolean} True if arguments are multi-line\n         */\n        function isArgBeforeCalleeNodeMultiline(node) {\n            const parent = node.parent;\n\n            if (parent.arguments.length >= 2 && parent.arguments[1] === node) {\n                return parent.arguments[0].loc.end.line > parent.arguments[0].loc.start.line;\n            }\n\n            return false;\n        }\n\n        /**\n         * Check to see if the node is a file level IIFE\n         * @param {ASTNode} node The function node to check.\n         * @returns {boolean} True if the node is the outer IIFE\n         */\n        function isOuterIIFE(node) {\n            const parent = node.parent;\n            let stmt = parent.parent;\n\n            /*\n             * Verify that the node is an IIEF\n             */\n            if (\n                parent.type !== \"CallExpression\" ||\n                parent.callee !== node) {\n\n                return false;\n            }\n\n            /*\n             * Navigate legal ancestors to determine whether this IIEF is outer\n             */\n            while (\n                stmt.type === \"UnaryExpression\" && (\n                    stmt.operator === \"!\" ||\n                    stmt.operator === \"~\" ||\n                    stmt.operator === \"+\" ||\n                    stmt.operator === \"-\") ||\n                stmt.type === \"AssignmentExpression\" ||\n                stmt.type === \"LogicalExpression\" ||\n                stmt.type === \"SequenceExpression\" ||\n                stmt.type === \"VariableDeclarator\") {\n\n                stmt = stmt.parent;\n            }\n\n            return ((\n                stmt.type === \"ExpressionStatement\" ||\n                stmt.type === \"VariableDeclaration\") &&\n                stmt.parent && stmt.parent.type === \"Program\"\n            );\n        }\n\n        /**\n         * Check indent for function block content\n         * @param {ASTNode} node A BlockStatement node that is inside of a function.\n         * @returns {void}\n         */\n        function checkIndentInFunctionBlock(node) {\n\n            /*\n             * Search first caller in chain.\n             * Ex.:\n             *\n             * Models <- Identifier\n             *   .User\n             *   .find()\n             *   .exec(function() {\n             *   // function body\n             * });\n             *\n             * Looks for 'Models'\n             */\n            const calleeNode = node.parent; // FunctionExpression\n            let indent;\n\n            if (calleeNode.parent &&\n                (calleeNode.parent.type === \"Property\" ||\n                calleeNode.parent.type === \"ArrayExpression\")) {\n\n                // If function is part of array or object, comma can be put at left\n                indent = getNodeIndent(calleeNode, false).goodChar;\n            } else {\n\n                // If function is standalone, simple calculate indent\n                indent = getNodeIndent(calleeNode).goodChar;\n            }\n\n            if (calleeNode.parent.type === \"CallExpression\") {\n                const calleeParent = calleeNode.parent;\n\n                if (calleeNode.type !== \"FunctionExpression\" && calleeNode.type !== \"ArrowFunctionExpression\") {\n                    if (calleeParent && calleeParent.loc.start.line < node.loc.start.line) {\n                        indent = getNodeIndent(calleeParent).goodChar;\n                    }\n                } else {\n                    if (isArgBeforeCalleeNodeMultiline(calleeNode) &&\n                        calleeParent.callee.loc.start.line === calleeParent.callee.loc.end.line &&\n                        !isNodeFirstInLine(calleeNode)) {\n                        indent = getNodeIndent(calleeParent).goodChar;\n                    }\n                }\n            }\n\n            /*\n             * function body indent should be indent + indent size, unless this\n             * is a FunctionDeclaration, FunctionExpression, or outer IIFE and the corresponding options are enabled.\n             */\n            let functionOffset = indentSize;\n\n            if (options.outerIIFEBody !== null && isOuterIIFE(calleeNode)) {\n                functionOffset = options.outerIIFEBody * indentSize;\n            } else if (calleeNode.type === \"FunctionExpression\") {\n                functionOffset = options.FunctionExpression.body * indentSize;\n            } else if (calleeNode.type === \"FunctionDeclaration\") {\n                functionOffset = options.FunctionDeclaration.body * indentSize;\n            }\n            indent += functionOffset;\n\n            // check if the node is inside a variable\n            const parentVarNode = getVariableDeclaratorNode(node);\n\n            if (parentVarNode && isNodeInVarOnTop(node, parentVarNode)) {\n                indent += indentSize * options.VariableDeclarator[parentVarNode.parent.kind];\n            }\n\n            if (node.body.length > 0) {\n                checkNodesIndent(node.body, indent);\n            }\n\n            checkLastNodeLineIndent(node, indent - functionOffset);\n        }\n\n\n        /**\n         * Checks if the given node starts and ends on the same line\n         * @param {ASTNode} node The node to check\n         * @returns {boolean} Whether or not the block starts and ends on the same line.\n         */\n        function isSingleLineNode(node) {\n            const lastToken = sourceCode.getLastToken(node),\n                startLine = node.loc.start.line,\n                endLine = lastToken.loc.end.line;\n\n            return startLine === endLine;\n        }\n\n        /**\n         * Check indent for array block content or object block content\n         * @param {ASTNode} node node to examine\n         * @returns {void}\n         */\n        function checkIndentInArrayOrObjectBlock(node) {\n\n            // Skip inline\n            if (isSingleLineNode(node)) {\n                return;\n            }\n\n            let elements = (node.type === \"ArrayExpression\") ? node.elements : node.properties;\n\n            // filter out empty elements example would be [ , 2] so remove first element as espree considers it as null\n            elements = elements.filter(elem => elem !== null);\n\n            let nodeIndent;\n            let elementsIndent;\n            const parentVarNode = getVariableDeclaratorNode(node);\n\n            // TODO - come up with a better strategy in future\n            if (isNodeFirstInLine(node)) {\n                const parent = node.parent;\n\n                nodeIndent = getNodeIndent(parent).goodChar;\n                if (!parentVarNode || parentVarNode.loc.start.line !== node.loc.start.line) {\n                    if (parent.type !== \"VariableDeclarator\" || parentVarNode === parentVarNode.parent.declarations[0]) {\n                        if (parent.type === \"VariableDeclarator\" && parentVarNode.loc.start.line === parent.loc.start.line) {\n                            nodeIndent += (indentSize * options.VariableDeclarator[parentVarNode.parent.kind]);\n                        } else if (parent.type === \"ObjectExpression\" || parent.type === \"ArrayExpression\") {\n                            const parentElements = node.parent.type === \"ObjectExpression\" ? node.parent.properties : node.parent.elements;\n\n                            if (parentElements[0] &&\n                                    parentElements[0].loc.start.line === parent.loc.start.line &&\n                                    parentElements[0].loc.end.line !== parent.loc.start.line) {\n\n                                /*\n                                 * If the first element of the array spans multiple lines, don't increase the expected indentation of the rest.\n                                 * e.g. [{\n                                 *        foo: 1\n                                 *      },\n                                 *      {\n                                 *        bar: 1\n                                 *      }]\n                                 * the second object is not indented.\n                                 */\n                            } else if (typeof options[parent.type] === \"number\") {\n                                nodeIndent += options[parent.type] * indentSize;\n                            } else {\n                                nodeIndent = parentElements[0].loc.start.column;\n                            }\n                        } else if (parent.type === \"CallExpression\" || parent.type === \"NewExpression\") {\n                            if (typeof options.CallExpression.arguments === \"number\") {\n                                nodeIndent += options.CallExpression.arguments * indentSize;\n                            } else if (options.CallExpression.arguments === \"first\") {\n                                if (parent.arguments.indexOf(node) !== -1) {\n                                    nodeIndent = parent.arguments[0].loc.start.column;\n                                }\n                            } else {\n                                nodeIndent += indentSize;\n                            }\n                        } else if (parent.type === \"LogicalExpression\" || parent.type === \"ArrowFunctionExpression\") {\n                            nodeIndent += indentSize;\n                        }\n                    }\n                }\n\n                checkFirstNodeLineIndent(node, nodeIndent);\n            } else {\n                nodeIndent = getNodeIndent(node).goodChar;\n            }\n\n            if (options[node.type] === \"first\") {\n                elementsIndent = elements.length ? elements[0].loc.start.column : 0; // If there are no elements, elementsIndent doesn't matter.\n            } else {\n                elementsIndent = nodeIndent + indentSize * options[node.type];\n            }\n\n            /*\n             * Check if the node is a multiple variable declaration; if so, then\n             * make sure indentation takes that into account.\n             */\n            if (isNodeInVarOnTop(node, parentVarNode)) {\n                elementsIndent += indentSize * options.VariableDeclarator[parentVarNode.parent.kind];\n            }\n\n            checkNodesIndent(elements, elementsIndent);\n\n            if (elements.length > 0) {\n\n                // Skip last block line check if last item in same line\n                if (elements[elements.length - 1].loc.end.line === node.loc.end.line) {\n                    return;\n                }\n            }\n\n            checkLastNodeLineIndent(node, nodeIndent +\n                (isNodeInVarOnTop(node, parentVarNode) ? options.VariableDeclarator[parentVarNode.parent.kind] * indentSize : 0));\n        }\n\n        /**\n         * Check if the node or node body is a BlockStatement or not\n         * @param {ASTNode} node node to test\n         * @returns {boolean} True if it or its body is a block statement\n         */\n        function isNodeBodyBlock(node) {\n            return node.type === \"BlockStatement\" || node.type === \"ClassBody\" || (node.body && node.body.type === \"BlockStatement\") ||\n                (node.consequent && node.consequent.type === \"BlockStatement\");\n        }\n\n        /**\n         * Check indentation for blocks\n         * @param {ASTNode} node node to check\n         * @returns {void}\n         */\n        function blockIndentationCheck(node) {\n\n            // Skip inline blocks\n            if (isSingleLineNode(node)) {\n                return;\n            }\n\n            if (node.parent && (\n                node.parent.type === \"FunctionExpression\" ||\n                node.parent.type === \"FunctionDeclaration\" ||\n                node.parent.type === \"ArrowFunctionExpression\")\n            ) {\n                checkIndentInFunctionBlock(node);\n                return;\n            }\n\n            let indent;\n            let nodesToCheck = [];\n\n            /*\n             * For this statements we should check indent from statement beginning,\n             * not from the beginning of the block.\n             */\n            const statementsWithProperties = [\n                \"IfStatement\", \"WhileStatement\", \"ForStatement\", \"ForInStatement\", \"ForOfStatement\", \"DoWhileStatement\", \"ClassDeclaration\", \"TryStatement\"\n            ];\n\n            if (node.parent && statementsWithProperties.indexOf(node.parent.type) !== -1 && isNodeBodyBlock(node)) {\n                indent = getNodeIndent(node.parent).goodChar;\n            } else if (node.parent && node.parent.type === \"CatchClause\") {\n                indent = getNodeIndent(node.parent.parent).goodChar;\n            } else {\n                indent = getNodeIndent(node).goodChar;\n            }\n\n            if (node.type === \"IfStatement\" && node.consequent.type !== \"BlockStatement\") {\n                nodesToCheck = [node.consequent];\n            } else if (Array.isArray(node.body)) {\n                nodesToCheck = node.body;\n            } else {\n                nodesToCheck = [node.body];\n            }\n\n            if (nodesToCheck.length > 0) {\n                checkNodesIndent(nodesToCheck, indent + indentSize);\n            }\n\n            if (node.type === \"BlockStatement\") {\n                checkLastNodeLineIndent(node, indent);\n            }\n        }\n\n        /**\n         * Filter out the elements which are on the same line of each other or the node.\n         * basically have only 1 elements from each line except the variable declaration line.\n         * @param {ASTNode} node Variable declaration node\n         * @returns {ASTNode[]} Filtered elements\n         */\n        function filterOutSameLineVars(node) {\n            return node.declarations.reduce((finalCollection, elem) => {\n                const lastElem = finalCollection[finalCollection.length - 1];\n\n                if ((elem.loc.start.line !== node.loc.start.line && !lastElem) ||\n                    (lastElem && lastElem.loc.start.line !== elem.loc.start.line)) {\n                    finalCollection.push(elem);\n                }\n\n                return finalCollection;\n            }, []);\n        }\n\n        /**\n         * Check indentation for variable declarations\n         * @param {ASTNode} node node to examine\n         * @returns {void}\n         */\n        function checkIndentInVariableDeclarations(node) {\n            const elements = filterOutSameLineVars(node);\n            const nodeIndent = getNodeIndent(node).goodChar;\n            const lastElement = elements[elements.length - 1];\n\n            const elementsIndent = nodeIndent + indentSize * options.VariableDeclarator[node.kind];\n\n            checkNodesIndent(elements, elementsIndent);\n\n            // Only check the last line if there is any token after the last item\n            if (sourceCode.getLastToken(node).loc.end.line <= lastElement.loc.end.line) {\n                return;\n            }\n\n            const tokenBeforeLastElement = sourceCode.getTokenBefore(lastElement);\n\n            if (tokenBeforeLastElement.value === \",\") {\n\n                // Special case for comma-first syntax where the semicolon is indented\n                checkLastNodeLineIndent(node, getNodeIndent(tokenBeforeLastElement).goodChar);\n            } else {\n                checkLastNodeLineIndent(node, elementsIndent - indentSize);\n            }\n        }\n\n        /**\n         * Check and decide whether to check for indentation for blockless nodes\n         * Scenarios are for or while statements without braces around them\n         * @param {ASTNode} node node to examine\n         * @returns {void}\n         */\n        function blockLessNodes(node) {\n            if (node.body.type !== \"BlockStatement\") {\n                blockIndentationCheck(node);\n            }\n        }\n\n        /**\n         * Returns the expected indentation for the case statement\n         * @param {ASTNode} node node to examine\n         * @param {int} [providedSwitchIndent] indent for switch statement\n         * @returns {int} indent size\n         */\n        function expectedCaseIndent(node, providedSwitchIndent) {\n            const switchNode = (node.type === \"SwitchStatement\") ? node : node.parent;\n            const switchIndent = typeof providedSwitchIndent === \"undefined\"\n                ? getNodeIndent(switchNode).goodChar\n                : providedSwitchIndent;\n            let caseIndent;\n\n            if (caseIndentStore[switchNode.loc.start.line]) {\n                return caseIndentStore[switchNode.loc.start.line];\n            }\n\n            if (switchNode.cases.length > 0 && options.SwitchCase === 0) {\n                caseIndent = switchIndent;\n            } else {\n                caseIndent = switchIndent + (indentSize * options.SwitchCase);\n            }\n\n            caseIndentStore[switchNode.loc.start.line] = caseIndent;\n            return caseIndent;\n\n        }\n\n        /**\n         * Checks whether a return statement is wrapped in ()\n         * @param {ASTNode} node node to examine\n         * @returns {boolean} the result\n         */\n        function isWrappedInParenthesis(node) {\n            const regex = /^return\\s*?\\(\\s*?\\);*?/u;\n\n            const statementWithoutArgument = sourceCode.getText(node).replace(\n                sourceCode.getText(node.argument), \"\"\n            );\n\n            return regex.test(statementWithoutArgument);\n        }\n\n        return {\n            Program(node) {\n                if (node.body.length > 0) {\n\n                    // Root nodes should have no indent\n                    checkNodesIndent(node.body, getNodeIndent(node).goodChar);\n                }\n            },\n\n            ClassBody: blockIndentationCheck,\n\n            BlockStatement: blockIndentationCheck,\n\n            WhileStatement: blockLessNodes,\n\n            ForStatement: blockLessNodes,\n\n            ForInStatement: blockLessNodes,\n\n            ForOfStatement: blockLessNodes,\n\n            DoWhileStatement: blockLessNodes,\n\n            IfStatement(node) {\n                if (node.consequent.type !== \"BlockStatement\" && node.consequent.loc.start.line > node.loc.start.line) {\n                    blockIndentationCheck(node);\n                }\n            },\n\n            VariableDeclaration(node) {\n                if (node.declarations[node.declarations.length - 1].loc.start.line > node.declarations[0].loc.start.line) {\n                    checkIndentInVariableDeclarations(node);\n                }\n            },\n\n            ObjectExpression(node) {\n                checkIndentInArrayOrObjectBlock(node);\n            },\n\n            ArrayExpression(node) {\n                checkIndentInArrayOrObjectBlock(node);\n            },\n\n            MemberExpression(node) {\n\n                if (typeof options.MemberExpression === \"undefined\") {\n                    return;\n                }\n\n                if (isSingleLineNode(node)) {\n                    return;\n                }\n\n                /*\n                 * The typical layout of variable declarations and assignments\n                 * alter the expectation of correct indentation. Skip them.\n                 * TODO: Add appropriate configuration options for variable\n                 * declarations and assignments.\n                 */\n                if (getParentNodeByType(node, \"VariableDeclarator\", [\"FunctionExpression\", \"ArrowFunctionExpression\"])) {\n                    return;\n                }\n\n                if (getParentNodeByType(node, \"AssignmentExpression\", [\"FunctionExpression\"])) {\n                    return;\n                }\n\n                const propertyIndent = getNodeIndent(node).goodChar + indentSize * options.MemberExpression;\n\n                const checkNodes = [node.property];\n\n                const dot = sourceCode.getTokenBefore(node.property);\n\n                if (dot.type === \"Punctuator\" && dot.value === \".\") {\n                    checkNodes.push(dot);\n                }\n\n                checkNodesIndent(checkNodes, propertyIndent);\n            },\n\n            SwitchStatement(node) {\n\n                // Switch is not a 'BlockStatement'\n                const switchIndent = getNodeIndent(node).goodChar;\n                const caseIndent = expectedCaseIndent(node, switchIndent);\n\n                checkNodesIndent(node.cases, caseIndent);\n\n\n                checkLastNodeLineIndent(node, switchIndent);\n            },\n\n            SwitchCase(node) {\n\n                // Skip inline cases\n                if (isSingleLineNode(node)) {\n                    return;\n                }\n                const caseIndent = expectedCaseIndent(node);\n\n                checkNodesIndent(node.consequent, caseIndent + indentSize);\n            },\n\n            FunctionDeclaration(node) {\n                if (isSingleLineNode(node)) {\n                    return;\n                }\n                if (options.FunctionDeclaration.parameters === \"first\" && node.params.length) {\n                    checkNodesIndent(node.params.slice(1), node.params[0].loc.start.column);\n                } else if (options.FunctionDeclaration.parameters !== null) {\n                    checkNodesIndent(node.params, getNodeIndent(node).goodChar + indentSize * options.FunctionDeclaration.parameters);\n                }\n            },\n\n            FunctionExpression(node) {\n                if (isSingleLineNode(node)) {\n                    return;\n                }\n                if (options.FunctionExpression.parameters === \"first\" && node.params.length) {\n                    checkNodesIndent(node.params.slice(1), node.params[0].loc.start.column);\n                } else if (options.FunctionExpression.parameters !== null) {\n                    checkNodesIndent(node.params, getNodeIndent(node).goodChar + indentSize * options.FunctionExpression.parameters);\n                }\n            },\n\n            ReturnStatement(node) {\n                if (isSingleLineNode(node)) {\n                    return;\n                }\n\n                const firstLineIndent = getNodeIndent(node).goodChar;\n\n                // in case if return statement is wrapped in parenthesis\n                if (isWrappedInParenthesis(node)) {\n                    checkLastReturnStatementLineIndent(node, firstLineIndent);\n                } else {\n                    checkNodeIndent(node, firstLineIndent);\n                }\n            },\n\n            CallExpression(node) {\n                if (isSingleLineNode(node)) {\n                    return;\n                }\n                if (options.CallExpression.arguments === \"first\" && node.arguments.length) {\n                    checkNodesIndent(node.arguments.slice(1), node.arguments[0].loc.start.column);\n                } else if (options.CallExpression.arguments !== null) {\n                    checkNodesIndent(node.arguments, getNodeIndent(node).goodChar + indentSize * options.CallExpression.arguments);\n                }\n            }\n\n        };\n\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}