{"ast":null,"code":"/**\n * @fileoverview Require or disallow newline at the end of files\n * @author Nodeca Team <https://github.com/nodeca>\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"require or disallow newline at the end of files\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/eol-last\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      enum: [\"always\", \"never\", \"unix\", \"windows\"]\n    }],\n    messages: {\n      missing: \"Newline required at end of file but not found.\",\n      unexpected: \"Newline not allowed at end of file.\"\n    }\n  },\n  create(context) {\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    return {\n      Program: function checkBadEOF(node) {\n        const sourceCode = context.getSourceCode(),\n          src = sourceCode.getText(),\n          lastLine = sourceCode.lines[sourceCode.lines.length - 1],\n          location = {\n            column: lastLine.length,\n            line: sourceCode.lines.length\n          },\n          LF = \"\\n\",\n          CRLF = `\\r${LF}`,\n          endsWithNewline = src.endsWith(LF);\n\n        /*\n         * Empty source is always valid: No content in file so we don't\n         * need to lint for a newline on the last line of content.\n         */\n        if (!src.length) {\n          return;\n        }\n        let mode = context.options[0] || \"always\",\n          appendCRLF = false;\n        if (mode === \"unix\") {\n          // `\"unix\"` should behave exactly as `\"always\"`\n          mode = \"always\";\n        }\n        if (mode === \"windows\") {\n          // `\"windows\"` should behave exactly as `\"always\"`, but append CRLF in the fixer for backwards compatibility\n          mode = \"always\";\n          appendCRLF = true;\n        }\n        if (mode === \"always\" && !endsWithNewline) {\n          // File is not newline-terminated, but should be\n          context.report({\n            node,\n            loc: location,\n            messageId: \"missing\",\n            fix(fixer) {\n              return fixer.insertTextAfterRange([0, src.length], appendCRLF ? CRLF : LF);\n            }\n          });\n        } else if (mode === \"never\" && endsWithNewline) {\n          // File is newline-terminated, but shouldn't be\n          context.report({\n            node,\n            loc: location,\n            messageId: \"unexpected\",\n            fix(fixer) {\n              const finalEOLs = /(?:\\r?\\n)+$/u,\n                match = finalEOLs.exec(sourceCode.text),\n                start = match.index,\n                end = sourceCode.text.length;\n              return fixer.replaceTextRange([start, end], \"\");\n            }\n          });\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["module","exports","meta","type","docs","description","category","recommended","url","fixable","schema","enum","messages","missing","unexpected","create","context","Program","checkBadEOF","node","sourceCode","getSourceCode","src","getText","lastLine","lines","length","location","column","line","LF","CRLF","endsWithNewline","endsWith","mode","options","appendCRLF","report","loc","messageId","fix","fixer","insertTextAfterRange","finalEOLs","match","exec","text","start","index","end","replaceTextRange"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/eol-last.js"],"sourcesContent":["/**\n * @fileoverview Require or disallow newline at the end of files\n * @author Nodeca Team <https://github.com/nodeca>\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"require or disallow newline at the end of files\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/eol-last\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                enum: [\"always\", \"never\", \"unix\", \"windows\"]\n            }\n        ],\n\n        messages: {\n            missing: \"Newline required at end of file but not found.\",\n            unexpected: \"Newline not allowed at end of file.\"\n        }\n    },\n    create(context) {\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            Program: function checkBadEOF(node) {\n                const sourceCode = context.getSourceCode(),\n                    src = sourceCode.getText(),\n                    lastLine = sourceCode.lines[sourceCode.lines.length - 1],\n                    location = {\n                        column: lastLine.length,\n                        line: sourceCode.lines.length\n                    },\n                    LF = \"\\n\",\n                    CRLF = `\\r${LF}`,\n                    endsWithNewline = src.endsWith(LF);\n\n                /*\n                 * Empty source is always valid: No content in file so we don't\n                 * need to lint for a newline on the last line of content.\n                 */\n                if (!src.length) {\n                    return;\n                }\n\n                let mode = context.options[0] || \"always\",\n                    appendCRLF = false;\n\n                if (mode === \"unix\") {\n\n                    // `\"unix\"` should behave exactly as `\"always\"`\n                    mode = \"always\";\n                }\n                if (mode === \"windows\") {\n\n                    // `\"windows\"` should behave exactly as `\"always\"`, but append CRLF in the fixer for backwards compatibility\n                    mode = \"always\";\n                    appendCRLF = true;\n                }\n                if (mode === \"always\" && !endsWithNewline) {\n\n                    // File is not newline-terminated, but should be\n                    context.report({\n                        node,\n                        loc: location,\n                        messageId: \"missing\",\n                        fix(fixer) {\n                            return fixer.insertTextAfterRange([0, src.length], appendCRLF ? CRLF : LF);\n                        }\n                    });\n                } else if (mode === \"never\" && endsWithNewline) {\n\n                    // File is newline-terminated, but shouldn't be\n                    context.report({\n                        node,\n                        loc: location,\n                        messageId: \"unexpected\",\n                        fix(fixer) {\n                            const finalEOLs = /(?:\\r?\\n)+$/u,\n                                match = finalEOLs.exec(sourceCode.text),\n                                start = match.index,\n                                end = sourceCode.text.length;\n\n                            return fixer.replaceTextRange([start, end], \"\");\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,YAAY;;AAEZ;AACA;AACA;AAEAA,MAAM,CAACC,OAAO,GAAG;EACbC,IAAI,EAAE;IACFC,IAAI,EAAE,QAAQ;IAEdC,IAAI,EAAE;MACFC,WAAW,EAAE,iDAAiD;MAC9DC,QAAQ,EAAE,kBAAkB;MAC5BC,WAAW,EAAE,KAAK;MAClBC,GAAG,EAAE;IACT,CAAC;IAEDC,OAAO,EAAE,YAAY;IAErBC,MAAM,EAAE,CACJ;MACIC,IAAI,EAAE,CAAC,QAAQ,EAAE,OAAO,EAAE,MAAM,EAAE,SAAS;IAC/C,CAAC,CACJ;IAEDC,QAAQ,EAAE;MACNC,OAAO,EAAE,gDAAgD;MACzDC,UAAU,EAAE;IAChB;EACJ,CAAC;EACDC,MAAMA,CAACC,OAAO,EAAE;IAEZ;IACA;IACA;;IAEA,OAAO;MACHC,OAAO,EAAE,SAASC,WAAWA,CAACC,IAAI,EAAE;QAChC,MAAMC,UAAU,GAAGJ,OAAO,CAACK,aAAa,CAAC,CAAC;UACtCC,GAAG,GAAGF,UAAU,CAACG,OAAO,CAAC,CAAC;UAC1BC,QAAQ,GAAGJ,UAAU,CAACK,KAAK,CAACL,UAAU,CAACK,KAAK,CAACC,MAAM,GAAG,CAAC,CAAC;UACxDC,QAAQ,GAAG;YACPC,MAAM,EAAEJ,QAAQ,CAACE,MAAM;YACvBG,IAAI,EAAET,UAAU,CAACK,KAAK,CAACC;UAC3B,CAAC;UACDI,EAAE,GAAG,IAAI;UACTC,IAAI,GAAI,KAAID,EAAG,EAAC;UAChBE,eAAe,GAAGV,GAAG,CAACW,QAAQ,CAACH,EAAE,CAAC;;QAEtC;AAChB;AACA;AACA;QACgB,IAAI,CAACR,GAAG,CAACI,MAAM,EAAE;UACb;QACJ;QAEA,IAAIQ,IAAI,GAAGlB,OAAO,CAACmB,OAAO,CAAC,CAAC,CAAC,IAAI,QAAQ;UACrCC,UAAU,GAAG,KAAK;QAEtB,IAAIF,IAAI,KAAK,MAAM,EAAE;UAEjB;UACAA,IAAI,GAAG,QAAQ;QACnB;QACA,IAAIA,IAAI,KAAK,SAAS,EAAE;UAEpB;UACAA,IAAI,GAAG,QAAQ;UACfE,UAAU,GAAG,IAAI;QACrB;QACA,IAAIF,IAAI,KAAK,QAAQ,IAAI,CAACF,eAAe,EAAE;UAEvC;UACAhB,OAAO,CAACqB,MAAM,CAAC;YACXlB,IAAI;YACJmB,GAAG,EAAEX,QAAQ;YACbY,SAAS,EAAE,SAAS;YACpBC,GAAGA,CAACC,KAAK,EAAE;cACP,OAAOA,KAAK,CAACC,oBAAoB,CAAC,CAAC,CAAC,EAAEpB,GAAG,CAACI,MAAM,CAAC,EAAEU,UAAU,GAAGL,IAAI,GAAGD,EAAE,CAAC;YAC9E;UACJ,CAAC,CAAC;QACN,CAAC,MAAM,IAAII,IAAI,KAAK,OAAO,IAAIF,eAAe,EAAE;UAE5C;UACAhB,OAAO,CAACqB,MAAM,CAAC;YACXlB,IAAI;YACJmB,GAAG,EAAEX,QAAQ;YACbY,SAAS,EAAE,YAAY;YACvBC,GAAGA,CAACC,KAAK,EAAE;cACP,MAAME,SAAS,GAAG,cAAc;gBAC5BC,KAAK,GAAGD,SAAS,CAACE,IAAI,CAACzB,UAAU,CAAC0B,IAAI,CAAC;gBACvCC,KAAK,GAAGH,KAAK,CAACI,KAAK;gBACnBC,GAAG,GAAG7B,UAAU,CAAC0B,IAAI,CAACpB,MAAM;cAEhC,OAAOe,KAAK,CAACS,gBAAgB,CAAC,CAACH,KAAK,EAAEE,GAAG,CAAC,EAAE,EAAE,CAAC;YACnD;UACJ,CAAC,CAAC;QACN;MACJ;IACJ,CAAC;EACL;AACJ,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}