{"ast":null,"code":"/**\n * @fileoverview Rule to flag use constant conditions\n * @author Christian Schulz <http://rndm.de>\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\nrequire(\"core-js/modules/es.array.push.js\");\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow constant expressions in conditions\",\n      category: \"Possible Errors\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-constant-condition\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        checkLoops: {\n          type: \"boolean\",\n          default: true\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unexpected: \"Unexpected constant condition.\"\n    }\n  },\n  create(context) {\n    const options = context.options[0] || {},\n      checkLoops = options.checkLoops !== false,\n      loopSetStack = [];\n    let loopsInCurrentScope = new Set();\n\n    //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    /**\n     * Returns literal's value converted to the Boolean type\n     * @param {ASTNode} node any `Literal` node\n     * @returns {boolean | null} `true` when node is truthy, `false` when node is falsy,\n     *  `null` when it cannot be determined.\n     */\n    function getBooleanValue(node) {\n      if (node.value === null) {\n        /*\n         * it might be a null literal or bigint/regex literal in unsupported environments .\n         * https://github.com/estree/estree/blob/14df8a024956ea289bd55b9c2226a1d5b8a473ee/es5.md#regexpliteral\n         * https://github.com/estree/estree/blob/14df8a024956ea289bd55b9c2226a1d5b8a473ee/es2020.md#bigintliteral\n         */\n\n        if (node.raw === \"null\") {\n          return false;\n        }\n\n        // regex is always truthy\n        if (typeof node.regex === \"object\") {\n          return true;\n        }\n        return null;\n      }\n      return !!node.value;\n    }\n\n    /**\n     * Checks if a branch node of LogicalExpression short circuits the whole condition\n     * @param {ASTNode} node The branch of main condition which needs to be checked\n     * @param {string} operator The operator of the main LogicalExpression.\n     * @returns {boolean} true when condition short circuits whole condition\n     */\n    function isLogicalIdentity(node, operator) {\n      switch (node.type) {\n        case \"Literal\":\n          return operator === \"||\" && getBooleanValue(node) === true || operator === \"&&\" && getBooleanValue(node) === false;\n        case \"UnaryExpression\":\n          return operator === \"&&\" && node.operator === \"void\";\n        case \"LogicalExpression\":\n          /*\n           * handles `a && false || b`\n           * `false` is an identity element of `&&` but not `||`\n           */\n          return operator === node.operator && (isLogicalIdentity(node.left, operator) || isLogicalIdentity(node.right, operator));\n        case \"AssignmentExpression\":\n          return [\"||=\", \"&&=\"].includes(node.operator) && operator === node.operator.slice(0, -1) && isLogicalIdentity(node.right, operator);\n\n        // no default\n      }\n\n      return false;\n    }\n\n    /**\n     * Checks if a node has a constant truthiness value.\n     * @param {ASTNode} node The AST node to check.\n     * @param {boolean} inBooleanPosition `false` if checking branch of a condition.\n     *  `true` in all other cases\n     * @returns {Bool} true when node's truthiness is constant\n     * @private\n     */\n    function isConstant(node, inBooleanPosition) {\n      // node.elements can return null values in the case of sparse arrays ex. [,]\n      if (!node) {\n        return true;\n      }\n      switch (node.type) {\n        case \"Literal\":\n        case \"ArrowFunctionExpression\":\n        case \"FunctionExpression\":\n        case \"ObjectExpression\":\n          return true;\n        case \"TemplateLiteral\":\n          return inBooleanPosition && node.quasis.some(quasi => quasi.value.cooked.length) || node.expressions.every(exp => isConstant(exp, inBooleanPosition));\n        case \"ArrayExpression\":\n          {\n            if (node.parent.type === \"BinaryExpression\" && node.parent.operator === \"+\") {\n              return node.elements.every(element => isConstant(element, false));\n            }\n            return true;\n          }\n        case \"UnaryExpression\":\n          if (node.operator === \"void\" || node.operator === \"typeof\" && inBooleanPosition) {\n            return true;\n          }\n          if (node.operator === \"!\") {\n            return isConstant(node.argument, true);\n          }\n          return isConstant(node.argument, false);\n        case \"BinaryExpression\":\n          return isConstant(node.left, false) && isConstant(node.right, false) && node.operator !== \"in\";\n        case \"LogicalExpression\":\n          {\n            const isLeftConstant = isConstant(node.left, inBooleanPosition);\n            const isRightConstant = isConstant(node.right, inBooleanPosition);\n            const isLeftShortCircuit = isLeftConstant && isLogicalIdentity(node.left, node.operator);\n            const isRightShortCircuit = inBooleanPosition && isRightConstant && isLogicalIdentity(node.right, node.operator);\n            return isLeftConstant && isRightConstant || isLeftShortCircuit || isRightShortCircuit;\n          }\n        case \"AssignmentExpression\":\n          if (node.operator === \"=\") {\n            return isConstant(node.right, inBooleanPosition);\n          }\n          if ([\"||=\", \"&&=\"].includes(node.operator) && inBooleanPosition) {\n            return isLogicalIdentity(node.right, node.operator.slice(0, -1));\n          }\n          return false;\n        case \"SequenceExpression\":\n          return isConstant(node.expressions[node.expressions.length - 1], inBooleanPosition);\n\n        // no default\n      }\n\n      return false;\n    }\n\n    /**\n     * Tracks when the given node contains a constant condition.\n     * @param {ASTNode} node The AST node to check.\n     * @returns {void}\n     * @private\n     */\n    function trackConstantConditionLoop(node) {\n      if (node.test && isConstant(node.test, true)) {\n        loopsInCurrentScope.add(node);\n      }\n    }\n\n    /**\n     * Reports when the set contains the given constant condition node\n     * @param {ASTNode} node The AST node to check.\n     * @returns {void}\n     * @private\n     */\n    function checkConstantConditionLoopInSet(node) {\n      if (loopsInCurrentScope.has(node)) {\n        loopsInCurrentScope.delete(node);\n        context.report({\n          node: node.test,\n          messageId: \"unexpected\"\n        });\n      }\n    }\n\n    /**\n     * Reports when the given node contains a constant condition.\n     * @param {ASTNode} node The AST node to check.\n     * @returns {void}\n     * @private\n     */\n    function reportIfConstant(node) {\n      if (node.test && isConstant(node.test, true)) {\n        context.report({\n          node: node.test,\n          messageId: \"unexpected\"\n        });\n      }\n    }\n\n    /**\n     * Stores current set of constant loops in loopSetStack temporarily\n     * and uses a new set to track constant loops\n     * @returns {void}\n     * @private\n     */\n    function enterFunction() {\n      loopSetStack.push(loopsInCurrentScope);\n      loopsInCurrentScope = new Set();\n    }\n\n    /**\n     * Reports when the set still contains stored constant conditions\n     * @returns {void}\n     * @private\n     */\n    function exitFunction() {\n      loopsInCurrentScope = loopSetStack.pop();\n    }\n\n    /**\n     * Checks node when checkLoops option is enabled\n     * @param {ASTNode} node The AST node to check.\n     * @returns {void}\n     * @private\n     */\n    function checkLoop(node) {\n      if (checkLoops) {\n        trackConstantConditionLoop(node);\n      }\n    }\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    return {\n      ConditionalExpression: reportIfConstant,\n      IfStatement: reportIfConstant,\n      WhileStatement: checkLoop,\n      \"WhileStatement:exit\": checkConstantConditionLoopInSet,\n      DoWhileStatement: checkLoop,\n      \"DoWhileStatement:exit\": checkConstantConditionLoopInSet,\n      ForStatement: checkLoop,\n      \"ForStatement > .test\": node => checkLoop(node.parent),\n      \"ForStatement:exit\": checkConstantConditionLoopInSet,\n      FunctionDeclaration: enterFunction,\n      \"FunctionDeclaration:exit\": exitFunction,\n      FunctionExpression: enterFunction,\n      \"FunctionExpression:exit\": exitFunction,\n      YieldExpression: () => loopsInCurrentScope.clear()\n    };\n  }\n};","map":{"version":3,"names":["require","module","exports","meta","type","docs","description","category","recommended","url","schema","properties","checkLoops","default","additionalProperties","messages","unexpected","create","context","options","loopSetStack","loopsInCurrentScope","Set","getBooleanValue","node","value","raw","regex","isLogicalIdentity","operator","left","right","includes","slice","isConstant","inBooleanPosition","quasis","some","quasi","cooked","length","expressions","every","exp","parent","elements","element","argument","isLeftConstant","isRightConstant","isLeftShortCircuit","isRightShortCircuit","trackConstantConditionLoop","test","add","checkConstantConditionLoopInSet","has","delete","report","messageId","reportIfConstant","enterFunction","push","exitFunction","pop","checkLoop","ConditionalExpression","IfStatement","WhileStatement","DoWhileStatement","ForStatement","FunctionDeclaration","FunctionExpression","YieldExpression","clear"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/no-constant-condition.js"],"sourcesContent":["/**\n * @fileoverview Rule to flag use constant conditions\n * @author Christian Schulz <http://rndm.de>\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow constant expressions in conditions\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-constant-condition\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    checkLoops: {\n                        type: \"boolean\",\n                        default: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            unexpected: \"Unexpected constant condition.\"\n        }\n    },\n\n    create(context) {\n        const options = context.options[0] || {},\n            checkLoops = options.checkLoops !== false,\n            loopSetStack = [];\n\n        let loopsInCurrentScope = new Set();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Returns literal's value converted to the Boolean type\n         * @param {ASTNode} node any `Literal` node\n         * @returns {boolean | null} `true` when node is truthy, `false` when node is falsy,\n         *  `null` when it cannot be determined.\n         */\n        function getBooleanValue(node) {\n            if (node.value === null) {\n\n                /*\n                 * it might be a null literal or bigint/regex literal in unsupported environments .\n                 * https://github.com/estree/estree/blob/14df8a024956ea289bd55b9c2226a1d5b8a473ee/es5.md#regexpliteral\n                 * https://github.com/estree/estree/blob/14df8a024956ea289bd55b9c2226a1d5b8a473ee/es2020.md#bigintliteral\n                 */\n\n                if (node.raw === \"null\") {\n                    return false;\n                }\n\n                // regex is always truthy\n                if (typeof node.regex === \"object\") {\n                    return true;\n                }\n\n                return null;\n            }\n\n            return !!node.value;\n        }\n\n        /**\n         * Checks if a branch node of LogicalExpression short circuits the whole condition\n         * @param {ASTNode} node The branch of main condition which needs to be checked\n         * @param {string} operator The operator of the main LogicalExpression.\n         * @returns {boolean} true when condition short circuits whole condition\n         */\n        function isLogicalIdentity(node, operator) {\n            switch (node.type) {\n                case \"Literal\":\n                    return (operator === \"||\" && getBooleanValue(node) === true) ||\n                           (operator === \"&&\" && getBooleanValue(node) === false);\n\n                case \"UnaryExpression\":\n                    return (operator === \"&&\" && node.operator === \"void\");\n\n                case \"LogicalExpression\":\n\n                    /*\n                     * handles `a && false || b`\n                     * `false` is an identity element of `&&` but not `||`\n                     */\n                    return operator === node.operator &&\n                             (\n                                 isLogicalIdentity(node.left, operator) ||\n                                 isLogicalIdentity(node.right, operator)\n                             );\n\n                case \"AssignmentExpression\":\n                    return [\"||=\", \"&&=\"].includes(node.operator) &&\n                        operator === node.operator.slice(0, -1) &&\n                        isLogicalIdentity(node.right, operator);\n\n                // no default\n            }\n            return false;\n        }\n\n        /**\n         * Checks if a node has a constant truthiness value.\n         * @param {ASTNode} node The AST node to check.\n         * @param {boolean} inBooleanPosition `false` if checking branch of a condition.\n         *  `true` in all other cases\n         * @returns {Bool} true when node's truthiness is constant\n         * @private\n         */\n        function isConstant(node, inBooleanPosition) {\n\n            // node.elements can return null values in the case of sparse arrays ex. [,]\n            if (!node) {\n                return true;\n            }\n            switch (node.type) {\n                case \"Literal\":\n                case \"ArrowFunctionExpression\":\n                case \"FunctionExpression\":\n                case \"ObjectExpression\":\n                    return true;\n                case \"TemplateLiteral\":\n                    return (inBooleanPosition && node.quasis.some(quasi => quasi.value.cooked.length)) ||\n                        node.expressions.every(exp => isConstant(exp, inBooleanPosition));\n\n                case \"ArrayExpression\": {\n                    if (node.parent.type === \"BinaryExpression\" && node.parent.operator === \"+\") {\n                        return node.elements.every(element => isConstant(element, false));\n                    }\n                    return true;\n                }\n\n                case \"UnaryExpression\":\n                    if (\n                        node.operator === \"void\" ||\n                        node.operator === \"typeof\" && inBooleanPosition\n                    ) {\n                        return true;\n                    }\n\n                    if (node.operator === \"!\") {\n                        return isConstant(node.argument, true);\n                    }\n\n                    return isConstant(node.argument, false);\n\n                case \"BinaryExpression\":\n                    return isConstant(node.left, false) &&\n                            isConstant(node.right, false) &&\n                            node.operator !== \"in\";\n\n                case \"LogicalExpression\": {\n                    const isLeftConstant = isConstant(node.left, inBooleanPosition);\n                    const isRightConstant = isConstant(node.right, inBooleanPosition);\n                    const isLeftShortCircuit = (isLeftConstant && isLogicalIdentity(node.left, node.operator));\n                    const isRightShortCircuit = (inBooleanPosition && isRightConstant && isLogicalIdentity(node.right, node.operator));\n\n                    return (isLeftConstant && isRightConstant) ||\n                        isLeftShortCircuit ||\n                        isRightShortCircuit;\n                }\n\n                case \"AssignmentExpression\":\n                    if (node.operator === \"=\") {\n                        return isConstant(node.right, inBooleanPosition);\n                    }\n\n                    if ([\"||=\", \"&&=\"].includes(node.operator) && inBooleanPosition) {\n                        return isLogicalIdentity(node.right, node.operator.slice(0, -1));\n                    }\n\n                    return false;\n\n                case \"SequenceExpression\":\n                    return isConstant(node.expressions[node.expressions.length - 1], inBooleanPosition);\n\n                // no default\n            }\n            return false;\n        }\n\n        /**\n         * Tracks when the given node contains a constant condition.\n         * @param {ASTNode} node The AST node to check.\n         * @returns {void}\n         * @private\n         */\n        function trackConstantConditionLoop(node) {\n            if (node.test && isConstant(node.test, true)) {\n                loopsInCurrentScope.add(node);\n            }\n        }\n\n        /**\n         * Reports when the set contains the given constant condition node\n         * @param {ASTNode} node The AST node to check.\n         * @returns {void}\n         * @private\n         */\n        function checkConstantConditionLoopInSet(node) {\n            if (loopsInCurrentScope.has(node)) {\n                loopsInCurrentScope.delete(node);\n                context.report({ node: node.test, messageId: \"unexpected\" });\n            }\n        }\n\n        /**\n         * Reports when the given node contains a constant condition.\n         * @param {ASTNode} node The AST node to check.\n         * @returns {void}\n         * @private\n         */\n        function reportIfConstant(node) {\n            if (node.test && isConstant(node.test, true)) {\n                context.report({ node: node.test, messageId: \"unexpected\" });\n            }\n        }\n\n        /**\n         * Stores current set of constant loops in loopSetStack temporarily\n         * and uses a new set to track constant loops\n         * @returns {void}\n         * @private\n         */\n        function enterFunction() {\n            loopSetStack.push(loopsInCurrentScope);\n            loopsInCurrentScope = new Set();\n        }\n\n        /**\n         * Reports when the set still contains stored constant conditions\n         * @returns {void}\n         * @private\n         */\n        function exitFunction() {\n            loopsInCurrentScope = loopSetStack.pop();\n        }\n\n        /**\n         * Checks node when checkLoops option is enabled\n         * @param {ASTNode} node The AST node to check.\n         * @returns {void}\n         * @private\n         */\n        function checkLoop(node) {\n            if (checkLoops) {\n                trackConstantConditionLoop(node);\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            ConditionalExpression: reportIfConstant,\n            IfStatement: reportIfConstant,\n            WhileStatement: checkLoop,\n            \"WhileStatement:exit\": checkConstantConditionLoopInSet,\n            DoWhileStatement: checkLoop,\n            \"DoWhileStatement:exit\": checkConstantConditionLoopInSet,\n            ForStatement: checkLoop,\n            \"ForStatement > .test\": node => checkLoop(node.parent),\n            \"ForStatement:exit\": checkConstantConditionLoopInSet,\n            FunctionDeclaration: enterFunction,\n            \"FunctionDeclaration:exit\": exitFunction,\n            FunctionExpression: enterFunction,\n            \"FunctionExpression:exit\": exitFunction,\n            YieldExpression: () => loopsInCurrentScope.clear()\n        };\n\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}