{"ast":null,"code":"/**\n * @fileoverview Rule to flag statements that use magic numbers (adapted from https://github.com/danielstjules/buddy.js)\n * @author Vincent Lemeunier\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n// Maximum array length by the ECMAScript Specification.\nconst MAX_ARRAY_LENGTH = 2 ** 32 - 1;\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/**\n * Convert the value to bigint if it's a string. Otherwise return the value as-is.\n * @param {bigint|number|string} x The value to normalize.\n * @returns {bigint|number} The normalized value.\n */\nfunction normalizeIgnoreValue(x) {\n  if (typeof x === \"string\") {\n    return BigInt(x.slice(0, -1));\n  }\n  return x;\n}\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow magic numbers\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-magic-numbers\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        detectObjects: {\n          type: \"boolean\",\n          default: false\n        },\n        enforceConst: {\n          type: \"boolean\",\n          default: false\n        },\n        ignore: {\n          type: \"array\",\n          items: {\n            anyOf: [{\n              type: \"number\"\n            }, {\n              type: \"string\",\n              pattern: \"^[+-]?(?:0|[1-9][0-9]*)n$\"\n            }]\n          },\n          uniqueItems: true\n        },\n        ignoreArrayIndexes: {\n          type: \"boolean\",\n          default: false\n        },\n        ignoreDefaultValues: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      useConst: \"Number constants declarations must use 'const'.\",\n      noMagic: \"No magic number: {{raw}}.\"\n    }\n  },\n  create(context) {\n    const config = context.options[0] || {},\n      detectObjects = !!config.detectObjects,\n      enforceConst = !!config.enforceConst,\n      ignore = (config.ignore || []).map(normalizeIgnoreValue),\n      ignoreArrayIndexes = !!config.ignoreArrayIndexes,\n      ignoreDefaultValues = !!config.ignoreDefaultValues;\n    const okTypes = detectObjects ? [] : [\"ObjectExpression\", \"Property\", \"AssignmentExpression\"];\n\n    /**\n     * Returns whether the rule is configured to ignore the given value\n     * @param {bigint|number} value The value to check\n     * @returns {boolean} true if the value is ignored\n     */\n    function isIgnoredValue(value) {\n      return ignore.indexOf(value) !== -1;\n    }\n\n    /**\n     * Returns whether the number is a default value assignment.\n     * @param {ASTNode} fullNumberNode `Literal` or `UnaryExpression` full number node\n     * @returns {boolean} true if the number is a default value\n     */\n    function isDefaultValue(fullNumberNode) {\n      const parent = fullNumberNode.parent;\n      return parent.type === \"AssignmentPattern\" && parent.right === fullNumberNode;\n    }\n\n    /**\n     * Returns whether the given node is used as a radix within parseInt() or Number.parseInt()\n     * @param {ASTNode} fullNumberNode `Literal` or `UnaryExpression` full number node\n     * @returns {boolean} true if the node is radix\n     */\n    function isParseIntRadix(fullNumberNode) {\n      const parent = fullNumberNode.parent;\n      return parent.type === \"CallExpression\" && fullNumberNode === parent.arguments[1] && (astUtils.isSpecificId(parent.callee, \"parseInt\") || astUtils.isSpecificMemberAccess(parent.callee, \"Number\", \"parseInt\"));\n    }\n\n    /**\n     * Returns whether the given node is a direct child of a JSX node.\n     * In particular, it aims to detect numbers used as prop values in JSX tags.\n     * Example: <input maxLength={10} />\n     * @param {ASTNode} fullNumberNode `Literal` or `UnaryExpression` full number node\n     * @returns {boolean} true if the node is a JSX number\n     */\n    function isJSXNumber(fullNumberNode) {\n      return fullNumberNode.parent.type.indexOf(\"JSX\") === 0;\n    }\n\n    /**\n     * Returns whether the given node is used as an array index.\n     * Value must coerce to a valid array index name: \"0\", \"1\", \"2\" ... \"4294967294\".\n     *\n     * All other values, like \"-1\", \"2.5\", or \"4294967295\", are just \"normal\" object properties,\n     * which can be created and accessed on an array in addition to the array index properties,\n     * but they don't affect array's length and are not considered by methods such as .map(), .forEach() etc.\n     *\n     * The maximum array length by the specification is 2 ** 32 - 1 = 4294967295,\n     * thus the maximum valid index is 2 ** 32 - 2 = 4294967294.\n     *\n     * All notations are allowed, as long as the value coerces to one of \"0\", \"1\", \"2\" ... \"4294967294\".\n     *\n     * Valid examples:\n     * a[0], a[1], a[1.2e1], a[0xAB], a[0n], a[1n]\n     * a[-0] (same as a[0] because -0 coerces to \"0\")\n     * a[-0n] (-0n evaluates to 0n)\n     *\n     * Invalid examples:\n     * a[-1], a[-0xAB], a[-1n], a[2.5], a[1.23e1], a[12e-1]\n     * a[4294967295] (above the max index, it's an access to a regular property a[\"4294967295\"])\n     * a[999999999999999999999] (even if it wasn't above the max index, it would be a[\"1e+21\"])\n     * a[1e310] (same as a[\"Infinity\"])\n     * @param {ASTNode} fullNumberNode `Literal` or `UnaryExpression` full number node\n     * @param {bigint|number} value Value expressed by the fullNumberNode\n     * @returns {boolean} true if the node is a valid array index\n     */\n    function isArrayIndex(fullNumberNode, value) {\n      const parent = fullNumberNode.parent;\n      return parent.type === \"MemberExpression\" && parent.property === fullNumberNode && (Number.isInteger(value) || typeof value === \"bigint\") && value >= 0 && value < MAX_ARRAY_LENGTH;\n    }\n    return {\n      Literal(node) {\n        if (!astUtils.isNumericLiteral(node)) {\n          return;\n        }\n        let fullNumberNode;\n        let value;\n        let raw;\n\n        // Treat unary minus as a part of the number\n        if (node.parent.type === \"UnaryExpression\" && node.parent.operator === \"-\") {\n          fullNumberNode = node.parent;\n          value = -node.value;\n          raw = `-${node.raw}`;\n        } else {\n          fullNumberNode = node;\n          value = node.value;\n          raw = node.raw;\n        }\n        const parent = fullNumberNode.parent;\n\n        // Always allow radix arguments and JSX props\n        if (isIgnoredValue(value) || ignoreDefaultValues && isDefaultValue(fullNumberNode) || isParseIntRadix(fullNumberNode) || isJSXNumber(fullNumberNode) || ignoreArrayIndexes && isArrayIndex(fullNumberNode, value)) {\n          return;\n        }\n        if (parent.type === \"VariableDeclarator\") {\n          if (enforceConst && parent.parent.kind !== \"const\") {\n            context.report({\n              node: fullNumberNode,\n              messageId: \"useConst\"\n            });\n          }\n        } else if (okTypes.indexOf(parent.type) === -1 || parent.type === \"AssignmentExpression\" && parent.left.type === \"Identifier\") {\n          context.report({\n            node: fullNumberNode,\n            messageId: \"noMagic\",\n            data: {\n              raw\n            }\n          });\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","MAX_ARRAY_LENGTH","normalizeIgnoreValue","x","BigInt","slice","module","exports","meta","type","docs","description","category","recommended","url","schema","properties","detectObjects","default","enforceConst","ignore","items","anyOf","pattern","uniqueItems","ignoreArrayIndexes","ignoreDefaultValues","additionalProperties","messages","useConst","noMagic","create","context","config","options","map","okTypes","isIgnoredValue","value","indexOf","isDefaultValue","fullNumberNode","parent","right","isParseIntRadix","arguments","isSpecificId","callee","isSpecificMemberAccess","isJSXNumber","isArrayIndex","property","Number","isInteger","Literal","node","isNumericLiteral","raw","operator","kind","report","messageId","left","data"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/no-magic-numbers.js"],"sourcesContent":["/**\n * @fileoverview Rule to flag statements that use magic numbers (adapted from https://github.com/danielstjules/buddy.js)\n * @author Vincent Lemeunier\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n// Maximum array length by the ECMAScript Specification.\nconst MAX_ARRAY_LENGTH = 2 ** 32 - 1;\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/**\n * Convert the value to bigint if it's a string. Otherwise return the value as-is.\n * @param {bigint|number|string} x The value to normalize.\n * @returns {bigint|number} The normalized value.\n */\nfunction normalizeIgnoreValue(x) {\n    if (typeof x === \"string\") {\n        return BigInt(x.slice(0, -1));\n    }\n    return x;\n}\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow magic numbers\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-magic-numbers\"\n        },\n\n        schema: [{\n            type: \"object\",\n            properties: {\n                detectObjects: {\n                    type: \"boolean\",\n                    default: false\n                },\n                enforceConst: {\n                    type: \"boolean\",\n                    default: false\n                },\n                ignore: {\n                    type: \"array\",\n                    items: {\n                        anyOf: [\n                            { type: \"number\" },\n                            { type: \"string\", pattern: \"^[+-]?(?:0|[1-9][0-9]*)n$\" }\n                        ]\n                    },\n                    uniqueItems: true\n                },\n                ignoreArrayIndexes: {\n                    type: \"boolean\",\n                    default: false\n                },\n                ignoreDefaultValues: {\n                    type: \"boolean\",\n                    default: false\n                }\n            },\n            additionalProperties: false\n        }],\n\n        messages: {\n            useConst: \"Number constants declarations must use 'const'.\",\n            noMagic: \"No magic number: {{raw}}.\"\n        }\n    },\n\n    create(context) {\n        const config = context.options[0] || {},\n            detectObjects = !!config.detectObjects,\n            enforceConst = !!config.enforceConst,\n            ignore = (config.ignore || []).map(normalizeIgnoreValue),\n            ignoreArrayIndexes = !!config.ignoreArrayIndexes,\n            ignoreDefaultValues = !!config.ignoreDefaultValues;\n\n        const okTypes = detectObjects ? [] : [\"ObjectExpression\", \"Property\", \"AssignmentExpression\"];\n\n        /**\n         * Returns whether the rule is configured to ignore the given value\n         * @param {bigint|number} value The value to check\n         * @returns {boolean} true if the value is ignored\n         */\n        function isIgnoredValue(value) {\n            return ignore.indexOf(value) !== -1;\n        }\n\n        /**\n         * Returns whether the number is a default value assignment.\n         * @param {ASTNode} fullNumberNode `Literal` or `UnaryExpression` full number node\n         * @returns {boolean} true if the number is a default value\n         */\n        function isDefaultValue(fullNumberNode) {\n            const parent = fullNumberNode.parent;\n\n            return parent.type === \"AssignmentPattern\" && parent.right === fullNumberNode;\n        }\n\n        /**\n         * Returns whether the given node is used as a radix within parseInt() or Number.parseInt()\n         * @param {ASTNode} fullNumberNode `Literal` or `UnaryExpression` full number node\n         * @returns {boolean} true if the node is radix\n         */\n        function isParseIntRadix(fullNumberNode) {\n            const parent = fullNumberNode.parent;\n\n            return parent.type === \"CallExpression\" && fullNumberNode === parent.arguments[1] &&\n                (\n                    astUtils.isSpecificId(parent.callee, \"parseInt\") ||\n                    astUtils.isSpecificMemberAccess(parent.callee, \"Number\", \"parseInt\")\n                );\n        }\n\n        /**\n         * Returns whether the given node is a direct child of a JSX node.\n         * In particular, it aims to detect numbers used as prop values in JSX tags.\n         * Example: <input maxLength={10} />\n         * @param {ASTNode} fullNumberNode `Literal` or `UnaryExpression` full number node\n         * @returns {boolean} true if the node is a JSX number\n         */\n        function isJSXNumber(fullNumberNode) {\n            return fullNumberNode.parent.type.indexOf(\"JSX\") === 0;\n        }\n\n        /**\n         * Returns whether the given node is used as an array index.\n         * Value must coerce to a valid array index name: \"0\", \"1\", \"2\" ... \"4294967294\".\n         *\n         * All other values, like \"-1\", \"2.5\", or \"4294967295\", are just \"normal\" object properties,\n         * which can be created and accessed on an array in addition to the array index properties,\n         * but they don't affect array's length and are not considered by methods such as .map(), .forEach() etc.\n         *\n         * The maximum array length by the specification is 2 ** 32 - 1 = 4294967295,\n         * thus the maximum valid index is 2 ** 32 - 2 = 4294967294.\n         *\n         * All notations are allowed, as long as the value coerces to one of \"0\", \"1\", \"2\" ... \"4294967294\".\n         *\n         * Valid examples:\n         * a[0], a[1], a[1.2e1], a[0xAB], a[0n], a[1n]\n         * a[-0] (same as a[0] because -0 coerces to \"0\")\n         * a[-0n] (-0n evaluates to 0n)\n         *\n         * Invalid examples:\n         * a[-1], a[-0xAB], a[-1n], a[2.5], a[1.23e1], a[12e-1]\n         * a[4294967295] (above the max index, it's an access to a regular property a[\"4294967295\"])\n         * a[999999999999999999999] (even if it wasn't above the max index, it would be a[\"1e+21\"])\n         * a[1e310] (same as a[\"Infinity\"])\n         * @param {ASTNode} fullNumberNode `Literal` or `UnaryExpression` full number node\n         * @param {bigint|number} value Value expressed by the fullNumberNode\n         * @returns {boolean} true if the node is a valid array index\n         */\n        function isArrayIndex(fullNumberNode, value) {\n            const parent = fullNumberNode.parent;\n\n            return parent.type === \"MemberExpression\" && parent.property === fullNumberNode &&\n                (Number.isInteger(value) || typeof value === \"bigint\") &&\n                value >= 0 && value < MAX_ARRAY_LENGTH;\n        }\n\n        return {\n            Literal(node) {\n                if (!astUtils.isNumericLiteral(node)) {\n                    return;\n                }\n\n                let fullNumberNode;\n                let value;\n                let raw;\n\n                // Treat unary minus as a part of the number\n                if (node.parent.type === \"UnaryExpression\" && node.parent.operator === \"-\") {\n                    fullNumberNode = node.parent;\n                    value = -node.value;\n                    raw = `-${node.raw}`;\n                } else {\n                    fullNumberNode = node;\n                    value = node.value;\n                    raw = node.raw;\n                }\n\n                const parent = fullNumberNode.parent;\n\n                // Always allow radix arguments and JSX props\n                if (\n                    isIgnoredValue(value) ||\n                    (ignoreDefaultValues && isDefaultValue(fullNumberNode)) ||\n                    isParseIntRadix(fullNumberNode) ||\n                    isJSXNumber(fullNumberNode) ||\n                    (ignoreArrayIndexes && isArrayIndex(fullNumberNode, value))\n                ) {\n                    return;\n                }\n\n                if (parent.type === \"VariableDeclarator\") {\n                    if (enforceConst && parent.parent.kind !== \"const\") {\n                        context.report({\n                            node: fullNumberNode,\n                            messageId: \"useConst\"\n                        });\n                    }\n                } else if (\n                    okTypes.indexOf(parent.type) === -1 ||\n                    (parent.type === \"AssignmentExpression\" && parent.left.type === \"Identifier\")\n                ) {\n                    context.report({\n                        node: fullNumberNode,\n                        messageId: \"noMagic\",\n                        data: {\n                            raw\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}