{"ast":null,"code":"/**\n * @fileoverview Define utility functions for token store.\n * @author Toru Nagashima\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Gets `token.range[0]` from the given token.\n * @param {Node|Token|Comment} token The token to get.\n * @returns {number} The start location.\n * @private\n */\nfunction getStartLocation(token) {\n  return token.range[0];\n}\n\n//------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\n/**\n * Finds the index of the first token which is after the given location.\n * If it was not found, this returns `tokens.length`.\n * @param {(Token|Comment)[]} tokens It searches the token in this list.\n * @param {number} location The location to search.\n * @returns {number} The found index or `tokens.length`.\n */\nexports.search = function search(tokens, location) {\n  const index = tokens.findIndex(el => location <= getStartLocation(el));\n  return index === -1 ? tokens.length : index;\n};\n\n/**\n * Gets the index of the `startLoc` in `tokens`.\n * `startLoc` can be the value of `node.range[1]`, so this checks about `startLoc - 1` as well.\n * @param {(Token|Comment)[]} tokens The tokens to find an index.\n * @param {Object} indexMap The map from locations to indices.\n * @param {number} startLoc The location to get an index.\n * @returns {number} The index.\n */\nexports.getFirstIndex = function getFirstIndex(tokens, indexMap, startLoc) {\n  if (startLoc in indexMap) {\n    return indexMap[startLoc];\n  }\n  if (startLoc - 1 in indexMap) {\n    const index = indexMap[startLoc - 1];\n    const token = index >= 0 && index < tokens.length ? tokens[index] : null;\n\n    /*\n     * For the map of \"comment's location -> token's index\", it points the next token of a comment.\n     * In that case, +1 is unnecessary.\n     */\n    if (token && token.range[0] >= startLoc) {\n      return index;\n    }\n    return index + 1;\n  }\n  return 0;\n};\n\n/**\n * Gets the index of the `endLoc` in `tokens`.\n * The information of end locations are recorded at `endLoc - 1` in `indexMap`, so this checks about `endLoc - 1` as well.\n * @param {(Token|Comment)[]} tokens The tokens to find an index.\n * @param {Object} indexMap The map from locations to indices.\n * @param {number} endLoc The location to get an index.\n * @returns {number} The index.\n */\nexports.getLastIndex = function getLastIndex(tokens, indexMap, endLoc) {\n  if (endLoc in indexMap) {\n    return indexMap[endLoc] - 1;\n  }\n  if (endLoc - 1 in indexMap) {\n    const index = indexMap[endLoc - 1];\n    const token = index >= 0 && index < tokens.length ? tokens[index] : null;\n\n    /*\n     * For the map of \"comment's location -> token's index\", it points the next token of a comment.\n     * In that case, -1 is necessary.\n     */\n    if (token && token.range[1] > endLoc) {\n      return index - 1;\n    }\n    return index;\n  }\n  return tokens.length - 1;\n};","map":{"version":3,"names":["getStartLocation","token","range","exports","search","tokens","location","index","findIndex","el","length","getFirstIndex","indexMap","startLoc","getLastIndex","endLoc"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/source-code/token-store/utils.js"],"sourcesContent":["/**\n * @fileoverview Define utility functions for token store.\n * @author Toru Nagashima\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Gets `token.range[0]` from the given token.\n * @param {Node|Token|Comment} token The token to get.\n * @returns {number} The start location.\n * @private\n */\nfunction getStartLocation(token) {\n    return token.range[0];\n}\n\n//------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\n/**\n * Finds the index of the first token which is after the given location.\n * If it was not found, this returns `tokens.length`.\n * @param {(Token|Comment)[]} tokens It searches the token in this list.\n * @param {number} location The location to search.\n * @returns {number} The found index or `tokens.length`.\n */\nexports.search = function search(tokens, location) {\n    const index = tokens.findIndex(el => location <= getStartLocation(el));\n\n    return index === -1 ? tokens.length : index;\n};\n\n/**\n * Gets the index of the `startLoc` in `tokens`.\n * `startLoc` can be the value of `node.range[1]`, so this checks about `startLoc - 1` as well.\n * @param {(Token|Comment)[]} tokens The tokens to find an index.\n * @param {Object} indexMap The map from locations to indices.\n * @param {number} startLoc The location to get an index.\n * @returns {number} The index.\n */\nexports.getFirstIndex = function getFirstIndex(tokens, indexMap, startLoc) {\n    if (startLoc in indexMap) {\n        return indexMap[startLoc];\n    }\n    if ((startLoc - 1) in indexMap) {\n        const index = indexMap[startLoc - 1];\n        const token = (index >= 0 && index < tokens.length) ? tokens[index] : null;\n\n        /*\n         * For the map of \"comment's location -> token's index\", it points the next token of a comment.\n         * In that case, +1 is unnecessary.\n         */\n        if (token && token.range[0] >= startLoc) {\n            return index;\n        }\n        return index + 1;\n    }\n    return 0;\n};\n\n/**\n * Gets the index of the `endLoc` in `tokens`.\n * The information of end locations are recorded at `endLoc - 1` in `indexMap`, so this checks about `endLoc - 1` as well.\n * @param {(Token|Comment)[]} tokens The tokens to find an index.\n * @param {Object} indexMap The map from locations to indices.\n * @param {number} endLoc The location to get an index.\n * @returns {number} The index.\n */\nexports.getLastIndex = function getLastIndex(tokens, indexMap, endLoc) {\n    if (endLoc in indexMap) {\n        return indexMap[endLoc] - 1;\n    }\n    if ((endLoc - 1) in indexMap) {\n        const index = indexMap[endLoc - 1];\n        const token = (index >= 0 && index < tokens.length) ? tokens[index] : null;\n\n        /*\n         * For the map of \"comment's location -> token's index\", it points the next token of a comment.\n         * In that case, -1 is necessary.\n         */\n        if (token && token.range[1] > endLoc) {\n            return index - 1;\n        }\n        return index;\n    }\n    return tokens.length - 1;\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,YAAY;;AAEZ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,gBAAgBA,CAACC,KAAK,EAAE;EAC7B,OAAOA,KAAK,CAACC,KAAK,CAAC,CAAC,CAAC;AACzB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACAC,OAAO,CAACC,MAAM,GAAG,SAASA,MAAMA,CAACC,MAAM,EAAEC,QAAQ,EAAE;EAC/C,MAAMC,KAAK,GAAGF,MAAM,CAACG,SAAS,CAACC,EAAE,IAAIH,QAAQ,IAAIN,gBAAgB,CAACS,EAAE,CAAC,CAAC;EAEtE,OAAOF,KAAK,KAAK,CAAC,CAAC,GAAGF,MAAM,CAACK,MAAM,GAAGH,KAAK;AAC/C,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAJ,OAAO,CAACQ,aAAa,GAAG,SAASA,aAAaA,CAACN,MAAM,EAAEO,QAAQ,EAAEC,QAAQ,EAAE;EACvE,IAAIA,QAAQ,IAAID,QAAQ,EAAE;IACtB,OAAOA,QAAQ,CAACC,QAAQ,CAAC;EAC7B;EACA,IAAKA,QAAQ,GAAG,CAAC,IAAKD,QAAQ,EAAE;IAC5B,MAAML,KAAK,GAAGK,QAAQ,CAACC,QAAQ,GAAG,CAAC,CAAC;IACpC,MAAMZ,KAAK,GAAIM,KAAK,IAAI,CAAC,IAAIA,KAAK,GAAGF,MAAM,CAACK,MAAM,GAAIL,MAAM,CAACE,KAAK,CAAC,GAAG,IAAI;;IAE1E;AACR;AACA;AACA;IACQ,IAAIN,KAAK,IAAIA,KAAK,CAACC,KAAK,CAAC,CAAC,CAAC,IAAIW,QAAQ,EAAE;MACrC,OAAON,KAAK;IAChB;IACA,OAAOA,KAAK,GAAG,CAAC;EACpB;EACA,OAAO,CAAC;AACZ,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAJ,OAAO,CAACW,YAAY,GAAG,SAASA,YAAYA,CAACT,MAAM,EAAEO,QAAQ,EAAEG,MAAM,EAAE;EACnE,IAAIA,MAAM,IAAIH,QAAQ,EAAE;IACpB,OAAOA,QAAQ,CAACG,MAAM,CAAC,GAAG,CAAC;EAC/B;EACA,IAAKA,MAAM,GAAG,CAAC,IAAKH,QAAQ,EAAE;IAC1B,MAAML,KAAK,GAAGK,QAAQ,CAACG,MAAM,GAAG,CAAC,CAAC;IAClC,MAAMd,KAAK,GAAIM,KAAK,IAAI,CAAC,IAAIA,KAAK,GAAGF,MAAM,CAACK,MAAM,GAAIL,MAAM,CAACE,KAAK,CAAC,GAAG,IAAI;;IAE1E;AACR;AACA;AACA;IACQ,IAAIN,KAAK,IAAIA,KAAK,CAACC,KAAK,CAAC,CAAC,CAAC,GAAGa,MAAM,EAAE;MAClC,OAAOR,KAAK,GAAG,CAAC;IACpB;IACA,OAAOA,KAAK;EAChB;EACA,OAAOF,MAAM,CAACK,MAAM,GAAG,CAAC;AAC5B,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}