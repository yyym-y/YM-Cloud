{"ast":null,"code":"/**\n * @fileoverview A class of the code path analyzer.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst assert = require(\"assert\"),\n  {\n    breakableTypePattern\n  } = require(\"../../shared/ast-utils\"),\n  CodePath = require(\"./code-path\"),\n  CodePathSegment = require(\"./code-path-segment\"),\n  IdGenerator = require(\"./id-generator\"),\n  debug = require(\"./debug-helpers\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given node is a `case` node (not `default` node).\n * @param {ASTNode} node A `SwitchCase` node to check.\n * @returns {boolean} `true` if the node is a `case` node (not `default` node).\n */\nfunction isCaseNode(node) {\n  return Boolean(node.test);\n}\n\n/**\n * Checks whether the given logical operator is taken into account for the code\n * path analysis.\n * @param {string} operator The operator found in the LogicalExpression node\n * @returns {boolean} `true` if the operator is \"&&\" or \"||\" or \"??\"\n */\nfunction isHandledLogicalOperator(operator) {\n  return operator === \"&&\" || operator === \"||\" || operator === \"??\";\n}\n\n/**\n * Checks whether the given assignment operator is a logical assignment operator.\n * Logical assignments are taken into account for the code path analysis\n * because of their short-circuiting semantics.\n * @param {string} operator The operator found in the AssignmentExpression node\n * @returns {boolean} `true` if the operator is \"&&=\" or \"||=\" or \"??=\"\n */\nfunction isLogicalAssignmentOperator(operator) {\n  return operator === \"&&=\" || operator === \"||=\" || operator === \"??=\";\n}\n\n/**\n * Gets the label if the parent node of a given node is a LabeledStatement.\n * @param {ASTNode} node A node to get.\n * @returns {string|null} The label or `null`.\n */\nfunction getLabel(node) {\n  if (node.parent.type === \"LabeledStatement\") {\n    return node.parent.label.name;\n  }\n  return null;\n}\n\n/**\n * Checks whether or not a given logical expression node goes different path\n * between the `true` case and the `false` case.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node is a test of a choice statement.\n */\nfunction isForkingByTrueOrFalse(node) {\n  const parent = node.parent;\n  switch (parent.type) {\n    case \"ConditionalExpression\":\n    case \"IfStatement\":\n    case \"WhileStatement\":\n    case \"DoWhileStatement\":\n    case \"ForStatement\":\n      return parent.test === node;\n    case \"LogicalExpression\":\n      return isHandledLogicalOperator(parent.operator);\n    case \"AssignmentExpression\":\n      return isLogicalAssignmentOperator(parent.operator);\n    default:\n      return false;\n  }\n}\n\n/**\n * Gets the boolean value of a given literal node.\n *\n * This is used to detect infinity loops (e.g. `while (true) {}`).\n * Statements preceded by an infinity loop are unreachable if the loop didn't\n * have any `break` statement.\n * @param {ASTNode} node A node to get.\n * @returns {boolean|undefined} a boolean value if the node is a Literal node,\n *   otherwise `undefined`.\n */\nfunction getBooleanValueIfSimpleConstant(node) {\n  if (node.type === \"Literal\") {\n    return Boolean(node.value);\n  }\n  return void 0;\n}\n\n/**\n * Checks that a given identifier node is a reference or not.\n *\n * This is used to detect the first throwable node in a `try` block.\n * @param {ASTNode} node An Identifier node to check.\n * @returns {boolean} `true` if the node is a reference.\n */\nfunction isIdentifierReference(node) {\n  const parent = node.parent;\n  switch (parent.type) {\n    case \"LabeledStatement\":\n    case \"BreakStatement\":\n    case \"ContinueStatement\":\n    case \"ArrayPattern\":\n    case \"RestElement\":\n    case \"ImportSpecifier\":\n    case \"ImportDefaultSpecifier\":\n    case \"ImportNamespaceSpecifier\":\n    case \"CatchClause\":\n      return false;\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n    case \"ArrowFunctionExpression\":\n    case \"ClassDeclaration\":\n    case \"ClassExpression\":\n    case \"VariableDeclarator\":\n      return parent.id !== node;\n    case \"Property\":\n    case \"MethodDefinition\":\n      return parent.key !== node || parent.computed || parent.shorthand;\n    case \"AssignmentPattern\":\n      return parent.key !== node;\n    default:\n      return true;\n  }\n}\n\n/**\n * Updates the current segment with the head segment.\n * This is similar to local branches and tracking branches of git.\n *\n * To separate the current and the head is in order to not make useless segments.\n *\n * In this process, both \"onCodePathSegmentStart\" and \"onCodePathSegmentEnd\"\n * events are fired.\n * @param {CodePathAnalyzer} analyzer The instance.\n * @param {ASTNode} node The current AST node.\n * @returns {void}\n */\nfunction forwardCurrentToHead(analyzer, node) {\n  const codePath = analyzer.codePath;\n  const state = CodePath.getState(codePath);\n  const currentSegments = state.currentSegments;\n  const headSegments = state.headSegments;\n  const end = Math.max(currentSegments.length, headSegments.length);\n  let i, currentSegment, headSegment;\n\n  // Fires leaving events.\n  for (i = 0; i < end; ++i) {\n    currentSegment = currentSegments[i];\n    headSegment = headSegments[i];\n    if (currentSegment !== headSegment && currentSegment) {\n      debug.dump(`onCodePathSegmentEnd ${currentSegment.id}`);\n      if (currentSegment.reachable) {\n        analyzer.emitter.emit(\"onCodePathSegmentEnd\", currentSegment, node);\n      }\n    }\n  }\n\n  // Update state.\n  state.currentSegments = headSegments;\n\n  // Fires entering events.\n  for (i = 0; i < end; ++i) {\n    currentSegment = currentSegments[i];\n    headSegment = headSegments[i];\n    if (currentSegment !== headSegment && headSegment) {\n      debug.dump(`onCodePathSegmentStart ${headSegment.id}`);\n      CodePathSegment.markUsed(headSegment);\n      if (headSegment.reachable) {\n        analyzer.emitter.emit(\"onCodePathSegmentStart\", headSegment, node);\n      }\n    }\n  }\n}\n\n/**\n * Updates the current segment with empty.\n * This is called at the last of functions or the program.\n * @param {CodePathAnalyzer} analyzer The instance.\n * @param {ASTNode} node The current AST node.\n * @returns {void}\n */\nfunction leaveFromCurrentSegment(analyzer, node) {\n  const state = CodePath.getState(analyzer.codePath);\n  const currentSegments = state.currentSegments;\n  for (let i = 0; i < currentSegments.length; ++i) {\n    const currentSegment = currentSegments[i];\n    debug.dump(`onCodePathSegmentEnd ${currentSegment.id}`);\n    if (currentSegment.reachable) {\n      analyzer.emitter.emit(\"onCodePathSegmentEnd\", currentSegment, node);\n    }\n  }\n  state.currentSegments = [];\n}\n\n/**\n * Updates the code path due to the position of a given node in the parent node\n * thereof.\n *\n * For example, if the node is `parent.consequent`, this creates a fork from the\n * current path.\n * @param {CodePathAnalyzer} analyzer The instance.\n * @param {ASTNode} node The current AST node.\n * @returns {void}\n */\nfunction preprocess(analyzer, node) {\n  const codePath = analyzer.codePath;\n  const state = CodePath.getState(codePath);\n  const parent = node.parent;\n  switch (parent.type) {\n    // The `arguments.length == 0` case is in `postprocess` function.\n    case \"CallExpression\":\n      if (parent.optional === true && parent.arguments.length >= 1 && parent.arguments[0] === node) {\n        state.makeOptionalRight();\n      }\n      break;\n    case \"MemberExpression\":\n      if (parent.optional === true && parent.property === node) {\n        state.makeOptionalRight();\n      }\n      break;\n    case \"LogicalExpression\":\n      if (parent.right === node && isHandledLogicalOperator(parent.operator)) {\n        state.makeLogicalRight();\n      }\n      break;\n    case \"AssignmentExpression\":\n      if (parent.right === node && isLogicalAssignmentOperator(parent.operator)) {\n        state.makeLogicalRight();\n      }\n      break;\n    case \"ConditionalExpression\":\n    case \"IfStatement\":\n      /*\n       * Fork if this node is at `consequent`/`alternate`.\n       * `popForkContext()` exists at `IfStatement:exit` and\n       * `ConditionalExpression:exit`.\n       */\n      if (parent.consequent === node) {\n        state.makeIfConsequent();\n      } else if (parent.alternate === node) {\n        state.makeIfAlternate();\n      }\n      break;\n    case \"SwitchCase\":\n      if (parent.consequent[0] === node) {\n        state.makeSwitchCaseBody(false, !parent.test);\n      }\n      break;\n    case \"TryStatement\":\n      if (parent.handler === node) {\n        state.makeCatchBlock();\n      } else if (parent.finalizer === node) {\n        state.makeFinallyBlock();\n      }\n      break;\n    case \"WhileStatement\":\n      if (parent.test === node) {\n        state.makeWhileTest(getBooleanValueIfSimpleConstant(node));\n      } else {\n        assert(parent.body === node);\n        state.makeWhileBody();\n      }\n      break;\n    case \"DoWhileStatement\":\n      if (parent.body === node) {\n        state.makeDoWhileBody();\n      } else {\n        assert(parent.test === node);\n        state.makeDoWhileTest(getBooleanValueIfSimpleConstant(node));\n      }\n      break;\n    case \"ForStatement\":\n      if (parent.test === node) {\n        state.makeForTest(getBooleanValueIfSimpleConstant(node));\n      } else if (parent.update === node) {\n        state.makeForUpdate();\n      } else if (parent.body === node) {\n        state.makeForBody();\n      }\n      break;\n    case \"ForInStatement\":\n    case \"ForOfStatement\":\n      if (parent.left === node) {\n        state.makeForInOfLeft();\n      } else if (parent.right === node) {\n        state.makeForInOfRight();\n      } else {\n        assert(parent.body === node);\n        state.makeForInOfBody();\n      }\n      break;\n    case \"AssignmentPattern\":\n      /*\n       * Fork if this node is at `right`.\n       * `left` is executed always, so it uses the current path.\n       * `popForkContext()` exists at `AssignmentPattern:exit`.\n       */\n      if (parent.right === node) {\n        state.pushForkContext();\n        state.forkBypassPath();\n        state.forkPath();\n      }\n      break;\n    default:\n      break;\n  }\n}\n\n/**\n * Updates the code path due to the type of a given node in entering.\n * @param {CodePathAnalyzer} analyzer The instance.\n * @param {ASTNode} node The current AST node.\n * @returns {void}\n */\nfunction processCodePathToEnter(analyzer, node) {\n  let codePath = analyzer.codePath;\n  let state = codePath && CodePath.getState(codePath);\n  const parent = node.parent;\n  switch (node.type) {\n    case \"Program\":\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n    case \"ArrowFunctionExpression\":\n      if (codePath) {\n        // Emits onCodePathSegmentStart events if updated.\n        forwardCurrentToHead(analyzer, node);\n        debug.dumpState(node, state, false);\n      }\n\n      // Create the code path of this scope.\n      codePath = analyzer.codePath = new CodePath(analyzer.idGenerator.next(), codePath, analyzer.onLooped);\n      state = CodePath.getState(codePath);\n\n      // Emits onCodePathStart events.\n      debug.dump(`onCodePathStart ${codePath.id}`);\n      analyzer.emitter.emit(\"onCodePathStart\", codePath, node);\n      break;\n    case \"ChainExpression\":\n      state.pushChainContext();\n      break;\n    case \"CallExpression\":\n      if (node.optional === true) {\n        state.makeOptionalNode();\n      }\n      break;\n    case \"MemberExpression\":\n      if (node.optional === true) {\n        state.makeOptionalNode();\n      }\n      break;\n    case \"LogicalExpression\":\n      if (isHandledLogicalOperator(node.operator)) {\n        state.pushChoiceContext(node.operator, isForkingByTrueOrFalse(node));\n      }\n      break;\n    case \"AssignmentExpression\":\n      if (isLogicalAssignmentOperator(node.operator)) {\n        state.pushChoiceContext(node.operator.slice(0, -1),\n        // removes `=` from the end\n        isForkingByTrueOrFalse(node));\n      }\n      break;\n    case \"ConditionalExpression\":\n    case \"IfStatement\":\n      state.pushChoiceContext(\"test\", false);\n      break;\n    case \"SwitchStatement\":\n      state.pushSwitchContext(node.cases.some(isCaseNode), getLabel(node));\n      break;\n    case \"TryStatement\":\n      state.pushTryContext(Boolean(node.finalizer));\n      break;\n    case \"SwitchCase\":\n      /*\n       * Fork if this node is after the 2st node in `cases`.\n       * It's similar to `else` blocks.\n       * The next `test` node is processed in this path.\n       */\n      if (parent.discriminant !== node && parent.cases[0] !== node) {\n        state.forkPath();\n      }\n      break;\n    case \"WhileStatement\":\n    case \"DoWhileStatement\":\n    case \"ForStatement\":\n    case \"ForInStatement\":\n    case \"ForOfStatement\":\n      state.pushLoopContext(node.type, getLabel(node));\n      break;\n    case \"LabeledStatement\":\n      if (!breakableTypePattern.test(node.body.type)) {\n        state.pushBreakContext(false, node.label.name);\n      }\n      break;\n    default:\n      break;\n  }\n\n  // Emits onCodePathSegmentStart events if updated.\n  forwardCurrentToHead(analyzer, node);\n  debug.dumpState(node, state, false);\n}\n\n/**\n * Updates the code path due to the type of a given node in leaving.\n * @param {CodePathAnalyzer} analyzer The instance.\n * @param {ASTNode} node The current AST node.\n * @returns {void}\n */\nfunction processCodePathToExit(analyzer, node) {\n  const codePath = analyzer.codePath;\n  const state = CodePath.getState(codePath);\n  let dontForward = false;\n  switch (node.type) {\n    case \"ChainExpression\":\n      state.popChainContext();\n      break;\n    case \"IfStatement\":\n    case \"ConditionalExpression\":\n      state.popChoiceContext();\n      break;\n    case \"LogicalExpression\":\n      if (isHandledLogicalOperator(node.operator)) {\n        state.popChoiceContext();\n      }\n      break;\n    case \"AssignmentExpression\":\n      if (isLogicalAssignmentOperator(node.operator)) {\n        state.popChoiceContext();\n      }\n      break;\n    case \"SwitchStatement\":\n      state.popSwitchContext();\n      break;\n    case \"SwitchCase\":\n      /*\n       * This is the same as the process at the 1st `consequent` node in\n       * `preprocess` function.\n       * Must do if this `consequent` is empty.\n       */\n      if (node.consequent.length === 0) {\n        state.makeSwitchCaseBody(true, !node.test);\n      }\n      if (state.forkContext.reachable) {\n        dontForward = true;\n      }\n      break;\n    case \"TryStatement\":\n      state.popTryContext();\n      break;\n    case \"BreakStatement\":\n      forwardCurrentToHead(analyzer, node);\n      state.makeBreak(node.label && node.label.name);\n      dontForward = true;\n      break;\n    case \"ContinueStatement\":\n      forwardCurrentToHead(analyzer, node);\n      state.makeContinue(node.label && node.label.name);\n      dontForward = true;\n      break;\n    case \"ReturnStatement\":\n      forwardCurrentToHead(analyzer, node);\n      state.makeReturn();\n      dontForward = true;\n      break;\n    case \"ThrowStatement\":\n      forwardCurrentToHead(analyzer, node);\n      state.makeThrow();\n      dontForward = true;\n      break;\n    case \"Identifier\":\n      if (isIdentifierReference(node)) {\n        state.makeFirstThrowablePathInTryBlock();\n        dontForward = true;\n      }\n      break;\n    case \"CallExpression\":\n    case \"ImportExpression\":\n    case \"MemberExpression\":\n    case \"NewExpression\":\n    case \"YieldExpression\":\n      state.makeFirstThrowablePathInTryBlock();\n      break;\n    case \"WhileStatement\":\n    case \"DoWhileStatement\":\n    case \"ForStatement\":\n    case \"ForInStatement\":\n    case \"ForOfStatement\":\n      state.popLoopContext();\n      break;\n    case \"AssignmentPattern\":\n      state.popForkContext();\n      break;\n    case \"LabeledStatement\":\n      if (!breakableTypePattern.test(node.body.type)) {\n        state.popBreakContext();\n      }\n      break;\n    default:\n      break;\n  }\n\n  // Emits onCodePathSegmentStart events if updated.\n  if (!dontForward) {\n    forwardCurrentToHead(analyzer, node);\n  }\n  debug.dumpState(node, state, true);\n}\n\n/**\n * Updates the code path to finalize the current code path.\n * @param {CodePathAnalyzer} analyzer The instance.\n * @param {ASTNode} node The current AST node.\n * @returns {void}\n */\nfunction postprocess(analyzer, node) {\n  switch (node.type) {\n    case \"Program\":\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n    case \"ArrowFunctionExpression\":\n      {\n        let codePath = analyzer.codePath;\n\n        // Mark the current path as the final node.\n        CodePath.getState(codePath).makeFinal();\n\n        // Emits onCodePathSegmentEnd event of the current segments.\n        leaveFromCurrentSegment(analyzer, node);\n\n        // Emits onCodePathEnd event of this code path.\n        debug.dump(`onCodePathEnd ${codePath.id}`);\n        analyzer.emitter.emit(\"onCodePathEnd\", codePath, node);\n        debug.dumpDot(codePath);\n        codePath = analyzer.codePath = analyzer.codePath.upper;\n        if (codePath) {\n          debug.dumpState(node, CodePath.getState(codePath), true);\n        }\n        break;\n      }\n\n    // The `arguments.length >= 1` case is in `preprocess` function.\n    case \"CallExpression\":\n      if (node.optional === true && node.arguments.length === 0) {\n        CodePath.getState(analyzer.codePath).makeOptionalRight();\n      }\n      break;\n    default:\n      break;\n  }\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * The class to analyze code paths.\n * This class implements the EventGenerator interface.\n */\nclass CodePathAnalyzer {\n  // eslint-disable-next-line jsdoc/require-description\n  /**\n   * @param {EventGenerator} eventGenerator An event generator to wrap.\n   */\n  constructor(eventGenerator) {\n    this.original = eventGenerator;\n    this.emitter = eventGenerator.emitter;\n    this.codePath = null;\n    this.idGenerator = new IdGenerator(\"s\");\n    this.currentNode = null;\n    this.onLooped = this.onLooped.bind(this);\n  }\n\n  /**\n   * Does the process to enter a given AST node.\n   * This updates state of analysis and calls `enterNode` of the wrapped.\n   * @param {ASTNode} node A node which is entering.\n   * @returns {void}\n   */\n  enterNode(node) {\n    this.currentNode = node;\n\n    // Updates the code path due to node's position in its parent node.\n    if (node.parent) {\n      preprocess(this, node);\n    }\n\n    /*\n     * Updates the code path.\n     * And emits onCodePathStart/onCodePathSegmentStart events.\n     */\n    processCodePathToEnter(this, node);\n\n    // Emits node events.\n    this.original.enterNode(node);\n    this.currentNode = null;\n  }\n\n  /**\n   * Does the process to leave a given AST node.\n   * This updates state of analysis and calls `leaveNode` of the wrapped.\n   * @param {ASTNode} node A node which is leaving.\n   * @returns {void}\n   */\n  leaveNode(node) {\n    this.currentNode = node;\n\n    /*\n     * Updates the code path.\n     * And emits onCodePathStart/onCodePathSegmentStart events.\n     */\n    processCodePathToExit(this, node);\n\n    // Emits node events.\n    this.original.leaveNode(node);\n\n    // Emits the last onCodePathStart/onCodePathSegmentStart events.\n    postprocess(this, node);\n    this.currentNode = null;\n  }\n\n  /**\n   * This is called on a code path looped.\n   * Then this raises a looped event.\n   * @param {CodePathSegment} fromSegment A segment of prev.\n   * @param {CodePathSegment} toSegment A segment of next.\n   * @returns {void}\n   */\n  onLooped(fromSegment, toSegment) {\n    if (fromSegment.reachable && toSegment.reachable) {\n      debug.dump(`onCodePathSegmentLoop ${fromSegment.id} -> ${toSegment.id}`);\n      this.emitter.emit(\"onCodePathSegmentLoop\", fromSegment, toSegment, this.currentNode);\n    }\n  }\n}\nmodule.exports = CodePathAnalyzer;","map":{"version":3,"names":["assert","require","breakableTypePattern","CodePath","CodePathSegment","IdGenerator","debug","isCaseNode","node","Boolean","test","isHandledLogicalOperator","operator","isLogicalAssignmentOperator","getLabel","parent","type","label","name","isForkingByTrueOrFalse","getBooleanValueIfSimpleConstant","value","isIdentifierReference","id","key","computed","shorthand","forwardCurrentToHead","analyzer","codePath","state","getState","currentSegments","headSegments","end","Math","max","length","i","currentSegment","headSegment","dump","reachable","emitter","emit","markUsed","leaveFromCurrentSegment","preprocess","optional","arguments","makeOptionalRight","property","right","makeLogicalRight","consequent","makeIfConsequent","alternate","makeIfAlternate","makeSwitchCaseBody","handler","makeCatchBlock","finalizer","makeFinallyBlock","makeWhileTest","body","makeWhileBody","makeDoWhileBody","makeDoWhileTest","makeForTest","update","makeForUpdate","makeForBody","left","makeForInOfLeft","makeForInOfRight","makeForInOfBody","pushForkContext","forkBypassPath","forkPath","processCodePathToEnter","dumpState","idGenerator","next","onLooped","pushChainContext","makeOptionalNode","pushChoiceContext","slice","pushSwitchContext","cases","some","pushTryContext","discriminant","pushLoopContext","pushBreakContext","processCodePathToExit","dontForward","popChainContext","popChoiceContext","popSwitchContext","forkContext","popTryContext","makeBreak","makeContinue","makeReturn","makeThrow","makeFirstThrowablePathInTryBlock","popLoopContext","popForkContext","popBreakContext","postprocess","makeFinal","dumpDot","upper","CodePathAnalyzer","constructor","eventGenerator","original","currentNode","bind","enterNode","leaveNode","fromSegment","toSegment","module","exports"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/linter/code-path-analysis/code-path-analyzer.js"],"sourcesContent":["/**\n * @fileoverview A class of the code path analyzer.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst assert = require(\"assert\"),\n    { breakableTypePattern } = require(\"../../shared/ast-utils\"),\n    CodePath = require(\"./code-path\"),\n    CodePathSegment = require(\"./code-path-segment\"),\n    IdGenerator = require(\"./id-generator\"),\n    debug = require(\"./debug-helpers\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given node is a `case` node (not `default` node).\n * @param {ASTNode} node A `SwitchCase` node to check.\n * @returns {boolean} `true` if the node is a `case` node (not `default` node).\n */\nfunction isCaseNode(node) {\n    return Boolean(node.test);\n}\n\n/**\n * Checks whether the given logical operator is taken into account for the code\n * path analysis.\n * @param {string} operator The operator found in the LogicalExpression node\n * @returns {boolean} `true` if the operator is \"&&\" or \"||\" or \"??\"\n */\nfunction isHandledLogicalOperator(operator) {\n    return operator === \"&&\" || operator === \"||\" || operator === \"??\";\n}\n\n/**\n * Checks whether the given assignment operator is a logical assignment operator.\n * Logical assignments are taken into account for the code path analysis\n * because of their short-circuiting semantics.\n * @param {string} operator The operator found in the AssignmentExpression node\n * @returns {boolean} `true` if the operator is \"&&=\" or \"||=\" or \"??=\"\n */\nfunction isLogicalAssignmentOperator(operator) {\n    return operator === \"&&=\" || operator === \"||=\" || operator === \"??=\";\n}\n\n/**\n * Gets the label if the parent node of a given node is a LabeledStatement.\n * @param {ASTNode} node A node to get.\n * @returns {string|null} The label or `null`.\n */\nfunction getLabel(node) {\n    if (node.parent.type === \"LabeledStatement\") {\n        return node.parent.label.name;\n    }\n    return null;\n}\n\n/**\n * Checks whether or not a given logical expression node goes different path\n * between the `true` case and the `false` case.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node is a test of a choice statement.\n */\nfunction isForkingByTrueOrFalse(node) {\n    const parent = node.parent;\n\n    switch (parent.type) {\n        case \"ConditionalExpression\":\n        case \"IfStatement\":\n        case \"WhileStatement\":\n        case \"DoWhileStatement\":\n        case \"ForStatement\":\n            return parent.test === node;\n\n        case \"LogicalExpression\":\n            return isHandledLogicalOperator(parent.operator);\n\n        case \"AssignmentExpression\":\n            return isLogicalAssignmentOperator(parent.operator);\n\n        default:\n            return false;\n    }\n}\n\n/**\n * Gets the boolean value of a given literal node.\n *\n * This is used to detect infinity loops (e.g. `while (true) {}`).\n * Statements preceded by an infinity loop are unreachable if the loop didn't\n * have any `break` statement.\n * @param {ASTNode} node A node to get.\n * @returns {boolean|undefined} a boolean value if the node is a Literal node,\n *   otherwise `undefined`.\n */\nfunction getBooleanValueIfSimpleConstant(node) {\n    if (node.type === \"Literal\") {\n        return Boolean(node.value);\n    }\n    return void 0;\n}\n\n/**\n * Checks that a given identifier node is a reference or not.\n *\n * This is used to detect the first throwable node in a `try` block.\n * @param {ASTNode} node An Identifier node to check.\n * @returns {boolean} `true` if the node is a reference.\n */\nfunction isIdentifierReference(node) {\n    const parent = node.parent;\n\n    switch (parent.type) {\n        case \"LabeledStatement\":\n        case \"BreakStatement\":\n        case \"ContinueStatement\":\n        case \"ArrayPattern\":\n        case \"RestElement\":\n        case \"ImportSpecifier\":\n        case \"ImportDefaultSpecifier\":\n        case \"ImportNamespaceSpecifier\":\n        case \"CatchClause\":\n            return false;\n\n        case \"FunctionDeclaration\":\n        case \"FunctionExpression\":\n        case \"ArrowFunctionExpression\":\n        case \"ClassDeclaration\":\n        case \"ClassExpression\":\n        case \"VariableDeclarator\":\n            return parent.id !== node;\n\n        case \"Property\":\n        case \"MethodDefinition\":\n            return (\n                parent.key !== node ||\n                parent.computed ||\n                parent.shorthand\n            );\n\n        case \"AssignmentPattern\":\n            return parent.key !== node;\n\n        default:\n            return true;\n    }\n}\n\n/**\n * Updates the current segment with the head segment.\n * This is similar to local branches and tracking branches of git.\n *\n * To separate the current and the head is in order to not make useless segments.\n *\n * In this process, both \"onCodePathSegmentStart\" and \"onCodePathSegmentEnd\"\n * events are fired.\n * @param {CodePathAnalyzer} analyzer The instance.\n * @param {ASTNode} node The current AST node.\n * @returns {void}\n */\nfunction forwardCurrentToHead(analyzer, node) {\n    const codePath = analyzer.codePath;\n    const state = CodePath.getState(codePath);\n    const currentSegments = state.currentSegments;\n    const headSegments = state.headSegments;\n    const end = Math.max(currentSegments.length, headSegments.length);\n    let i, currentSegment, headSegment;\n\n    // Fires leaving events.\n    for (i = 0; i < end; ++i) {\n        currentSegment = currentSegments[i];\n        headSegment = headSegments[i];\n\n        if (currentSegment !== headSegment && currentSegment) {\n            debug.dump(`onCodePathSegmentEnd ${currentSegment.id}`);\n\n            if (currentSegment.reachable) {\n                analyzer.emitter.emit(\n                    \"onCodePathSegmentEnd\",\n                    currentSegment,\n                    node\n                );\n            }\n        }\n    }\n\n    // Update state.\n    state.currentSegments = headSegments;\n\n    // Fires entering events.\n    for (i = 0; i < end; ++i) {\n        currentSegment = currentSegments[i];\n        headSegment = headSegments[i];\n\n        if (currentSegment !== headSegment && headSegment) {\n            debug.dump(`onCodePathSegmentStart ${headSegment.id}`);\n\n            CodePathSegment.markUsed(headSegment);\n            if (headSegment.reachable) {\n                analyzer.emitter.emit(\n                    \"onCodePathSegmentStart\",\n                    headSegment,\n                    node\n                );\n            }\n        }\n    }\n\n}\n\n/**\n * Updates the current segment with empty.\n * This is called at the last of functions or the program.\n * @param {CodePathAnalyzer} analyzer The instance.\n * @param {ASTNode} node The current AST node.\n * @returns {void}\n */\nfunction leaveFromCurrentSegment(analyzer, node) {\n    const state = CodePath.getState(analyzer.codePath);\n    const currentSegments = state.currentSegments;\n\n    for (let i = 0; i < currentSegments.length; ++i) {\n        const currentSegment = currentSegments[i];\n\n        debug.dump(`onCodePathSegmentEnd ${currentSegment.id}`);\n        if (currentSegment.reachable) {\n            analyzer.emitter.emit(\n                \"onCodePathSegmentEnd\",\n                currentSegment,\n                node\n            );\n        }\n    }\n\n    state.currentSegments = [];\n}\n\n/**\n * Updates the code path due to the position of a given node in the parent node\n * thereof.\n *\n * For example, if the node is `parent.consequent`, this creates a fork from the\n * current path.\n * @param {CodePathAnalyzer} analyzer The instance.\n * @param {ASTNode} node The current AST node.\n * @returns {void}\n */\nfunction preprocess(analyzer, node) {\n    const codePath = analyzer.codePath;\n    const state = CodePath.getState(codePath);\n    const parent = node.parent;\n\n    switch (parent.type) {\n\n        // The `arguments.length == 0` case is in `postprocess` function.\n        case \"CallExpression\":\n            if (parent.optional === true && parent.arguments.length >= 1 && parent.arguments[0] === node) {\n                state.makeOptionalRight();\n            }\n            break;\n        case \"MemberExpression\":\n            if (parent.optional === true && parent.property === node) {\n                state.makeOptionalRight();\n            }\n            break;\n\n        case \"LogicalExpression\":\n            if (\n                parent.right === node &&\n                isHandledLogicalOperator(parent.operator)\n            ) {\n                state.makeLogicalRight();\n            }\n            break;\n\n        case \"AssignmentExpression\":\n            if (\n                parent.right === node &&\n                isLogicalAssignmentOperator(parent.operator)\n            ) {\n                state.makeLogicalRight();\n            }\n            break;\n\n        case \"ConditionalExpression\":\n        case \"IfStatement\":\n\n            /*\n             * Fork if this node is at `consequent`/`alternate`.\n             * `popForkContext()` exists at `IfStatement:exit` and\n             * `ConditionalExpression:exit`.\n             */\n            if (parent.consequent === node) {\n                state.makeIfConsequent();\n            } else if (parent.alternate === node) {\n                state.makeIfAlternate();\n            }\n            break;\n\n        case \"SwitchCase\":\n            if (parent.consequent[0] === node) {\n                state.makeSwitchCaseBody(false, !parent.test);\n            }\n            break;\n\n        case \"TryStatement\":\n            if (parent.handler === node) {\n                state.makeCatchBlock();\n            } else if (parent.finalizer === node) {\n                state.makeFinallyBlock();\n            }\n            break;\n\n        case \"WhileStatement\":\n            if (parent.test === node) {\n                state.makeWhileTest(getBooleanValueIfSimpleConstant(node));\n            } else {\n                assert(parent.body === node);\n                state.makeWhileBody();\n            }\n            break;\n\n        case \"DoWhileStatement\":\n            if (parent.body === node) {\n                state.makeDoWhileBody();\n            } else {\n                assert(parent.test === node);\n                state.makeDoWhileTest(getBooleanValueIfSimpleConstant(node));\n            }\n            break;\n\n        case \"ForStatement\":\n            if (parent.test === node) {\n                state.makeForTest(getBooleanValueIfSimpleConstant(node));\n            } else if (parent.update === node) {\n                state.makeForUpdate();\n            } else if (parent.body === node) {\n                state.makeForBody();\n            }\n            break;\n\n        case \"ForInStatement\":\n        case \"ForOfStatement\":\n            if (parent.left === node) {\n                state.makeForInOfLeft();\n            } else if (parent.right === node) {\n                state.makeForInOfRight();\n            } else {\n                assert(parent.body === node);\n                state.makeForInOfBody();\n            }\n            break;\n\n        case \"AssignmentPattern\":\n\n            /*\n             * Fork if this node is at `right`.\n             * `left` is executed always, so it uses the current path.\n             * `popForkContext()` exists at `AssignmentPattern:exit`.\n             */\n            if (parent.right === node) {\n                state.pushForkContext();\n                state.forkBypassPath();\n                state.forkPath();\n            }\n            break;\n\n        default:\n            break;\n    }\n}\n\n/**\n * Updates the code path due to the type of a given node in entering.\n * @param {CodePathAnalyzer} analyzer The instance.\n * @param {ASTNode} node The current AST node.\n * @returns {void}\n */\nfunction processCodePathToEnter(analyzer, node) {\n    let codePath = analyzer.codePath;\n    let state = codePath && CodePath.getState(codePath);\n    const parent = node.parent;\n\n    switch (node.type) {\n        case \"Program\":\n        case \"FunctionDeclaration\":\n        case \"FunctionExpression\":\n        case \"ArrowFunctionExpression\":\n            if (codePath) {\n\n                // Emits onCodePathSegmentStart events if updated.\n                forwardCurrentToHead(analyzer, node);\n                debug.dumpState(node, state, false);\n            }\n\n            // Create the code path of this scope.\n            codePath = analyzer.codePath = new CodePath(\n                analyzer.idGenerator.next(),\n                codePath,\n                analyzer.onLooped\n            );\n            state = CodePath.getState(codePath);\n\n            // Emits onCodePathStart events.\n            debug.dump(`onCodePathStart ${codePath.id}`);\n            analyzer.emitter.emit(\"onCodePathStart\", codePath, node);\n            break;\n\n        case \"ChainExpression\":\n            state.pushChainContext();\n            break;\n        case \"CallExpression\":\n            if (node.optional === true) {\n                state.makeOptionalNode();\n            }\n            break;\n        case \"MemberExpression\":\n            if (node.optional === true) {\n                state.makeOptionalNode();\n            }\n            break;\n\n        case \"LogicalExpression\":\n            if (isHandledLogicalOperator(node.operator)) {\n                state.pushChoiceContext(\n                    node.operator,\n                    isForkingByTrueOrFalse(node)\n                );\n            }\n            break;\n\n        case \"AssignmentExpression\":\n            if (isLogicalAssignmentOperator(node.operator)) {\n                state.pushChoiceContext(\n                    node.operator.slice(0, -1), // removes `=` from the end\n                    isForkingByTrueOrFalse(node)\n                );\n            }\n            break;\n\n        case \"ConditionalExpression\":\n        case \"IfStatement\":\n            state.pushChoiceContext(\"test\", false);\n            break;\n\n        case \"SwitchStatement\":\n            state.pushSwitchContext(\n                node.cases.some(isCaseNode),\n                getLabel(node)\n            );\n            break;\n\n        case \"TryStatement\":\n            state.pushTryContext(Boolean(node.finalizer));\n            break;\n\n        case \"SwitchCase\":\n\n            /*\n             * Fork if this node is after the 2st node in `cases`.\n             * It's similar to `else` blocks.\n             * The next `test` node is processed in this path.\n             */\n            if (parent.discriminant !== node && parent.cases[0] !== node) {\n                state.forkPath();\n            }\n            break;\n\n        case \"WhileStatement\":\n        case \"DoWhileStatement\":\n        case \"ForStatement\":\n        case \"ForInStatement\":\n        case \"ForOfStatement\":\n            state.pushLoopContext(node.type, getLabel(node));\n            break;\n\n        case \"LabeledStatement\":\n            if (!breakableTypePattern.test(node.body.type)) {\n                state.pushBreakContext(false, node.label.name);\n            }\n            break;\n\n        default:\n            break;\n    }\n\n    // Emits onCodePathSegmentStart events if updated.\n    forwardCurrentToHead(analyzer, node);\n    debug.dumpState(node, state, false);\n}\n\n/**\n * Updates the code path due to the type of a given node in leaving.\n * @param {CodePathAnalyzer} analyzer The instance.\n * @param {ASTNode} node The current AST node.\n * @returns {void}\n */\nfunction processCodePathToExit(analyzer, node) {\n    const codePath = analyzer.codePath;\n    const state = CodePath.getState(codePath);\n    let dontForward = false;\n\n    switch (node.type) {\n        case \"ChainExpression\":\n            state.popChainContext();\n            break;\n\n        case \"IfStatement\":\n        case \"ConditionalExpression\":\n            state.popChoiceContext();\n            break;\n\n        case \"LogicalExpression\":\n            if (isHandledLogicalOperator(node.operator)) {\n                state.popChoiceContext();\n            }\n            break;\n\n        case \"AssignmentExpression\":\n            if (isLogicalAssignmentOperator(node.operator)) {\n                state.popChoiceContext();\n            }\n            break;\n\n        case \"SwitchStatement\":\n            state.popSwitchContext();\n            break;\n\n        case \"SwitchCase\":\n\n            /*\n             * This is the same as the process at the 1st `consequent` node in\n             * `preprocess` function.\n             * Must do if this `consequent` is empty.\n             */\n            if (node.consequent.length === 0) {\n                state.makeSwitchCaseBody(true, !node.test);\n            }\n            if (state.forkContext.reachable) {\n                dontForward = true;\n            }\n            break;\n\n        case \"TryStatement\":\n            state.popTryContext();\n            break;\n\n        case \"BreakStatement\":\n            forwardCurrentToHead(analyzer, node);\n            state.makeBreak(node.label && node.label.name);\n            dontForward = true;\n            break;\n\n        case \"ContinueStatement\":\n            forwardCurrentToHead(analyzer, node);\n            state.makeContinue(node.label && node.label.name);\n            dontForward = true;\n            break;\n\n        case \"ReturnStatement\":\n            forwardCurrentToHead(analyzer, node);\n            state.makeReturn();\n            dontForward = true;\n            break;\n\n        case \"ThrowStatement\":\n            forwardCurrentToHead(analyzer, node);\n            state.makeThrow();\n            dontForward = true;\n            break;\n\n        case \"Identifier\":\n            if (isIdentifierReference(node)) {\n                state.makeFirstThrowablePathInTryBlock();\n                dontForward = true;\n            }\n            break;\n\n        case \"CallExpression\":\n        case \"ImportExpression\":\n        case \"MemberExpression\":\n        case \"NewExpression\":\n        case \"YieldExpression\":\n            state.makeFirstThrowablePathInTryBlock();\n            break;\n\n        case \"WhileStatement\":\n        case \"DoWhileStatement\":\n        case \"ForStatement\":\n        case \"ForInStatement\":\n        case \"ForOfStatement\":\n            state.popLoopContext();\n            break;\n\n        case \"AssignmentPattern\":\n            state.popForkContext();\n            break;\n\n        case \"LabeledStatement\":\n            if (!breakableTypePattern.test(node.body.type)) {\n                state.popBreakContext();\n            }\n            break;\n\n        default:\n            break;\n    }\n\n    // Emits onCodePathSegmentStart events if updated.\n    if (!dontForward) {\n        forwardCurrentToHead(analyzer, node);\n    }\n    debug.dumpState(node, state, true);\n}\n\n/**\n * Updates the code path to finalize the current code path.\n * @param {CodePathAnalyzer} analyzer The instance.\n * @param {ASTNode} node The current AST node.\n * @returns {void}\n */\nfunction postprocess(analyzer, node) {\n    switch (node.type) {\n        case \"Program\":\n        case \"FunctionDeclaration\":\n        case \"FunctionExpression\":\n        case \"ArrowFunctionExpression\": {\n            let codePath = analyzer.codePath;\n\n            // Mark the current path as the final node.\n            CodePath.getState(codePath).makeFinal();\n\n            // Emits onCodePathSegmentEnd event of the current segments.\n            leaveFromCurrentSegment(analyzer, node);\n\n            // Emits onCodePathEnd event of this code path.\n            debug.dump(`onCodePathEnd ${codePath.id}`);\n            analyzer.emitter.emit(\"onCodePathEnd\", codePath, node);\n            debug.dumpDot(codePath);\n\n            codePath = analyzer.codePath = analyzer.codePath.upper;\n            if (codePath) {\n                debug.dumpState(node, CodePath.getState(codePath), true);\n            }\n            break;\n        }\n\n        // The `arguments.length >= 1` case is in `preprocess` function.\n        case \"CallExpression\":\n            if (node.optional === true && node.arguments.length === 0) {\n                CodePath.getState(analyzer.codePath).makeOptionalRight();\n            }\n            break;\n\n        default:\n            break;\n    }\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * The class to analyze code paths.\n * This class implements the EventGenerator interface.\n */\nclass CodePathAnalyzer {\n\n    // eslint-disable-next-line jsdoc/require-description\n    /**\n     * @param {EventGenerator} eventGenerator An event generator to wrap.\n     */\n    constructor(eventGenerator) {\n        this.original = eventGenerator;\n        this.emitter = eventGenerator.emitter;\n        this.codePath = null;\n        this.idGenerator = new IdGenerator(\"s\");\n        this.currentNode = null;\n        this.onLooped = this.onLooped.bind(this);\n    }\n\n    /**\n     * Does the process to enter a given AST node.\n     * This updates state of analysis and calls `enterNode` of the wrapped.\n     * @param {ASTNode} node A node which is entering.\n     * @returns {void}\n     */\n    enterNode(node) {\n        this.currentNode = node;\n\n        // Updates the code path due to node's position in its parent node.\n        if (node.parent) {\n            preprocess(this, node);\n        }\n\n        /*\n         * Updates the code path.\n         * And emits onCodePathStart/onCodePathSegmentStart events.\n         */\n        processCodePathToEnter(this, node);\n\n        // Emits node events.\n        this.original.enterNode(node);\n\n        this.currentNode = null;\n    }\n\n    /**\n     * Does the process to leave a given AST node.\n     * This updates state of analysis and calls `leaveNode` of the wrapped.\n     * @param {ASTNode} node A node which is leaving.\n     * @returns {void}\n     */\n    leaveNode(node) {\n        this.currentNode = node;\n\n        /*\n         * Updates the code path.\n         * And emits onCodePathStart/onCodePathSegmentStart events.\n         */\n        processCodePathToExit(this, node);\n\n        // Emits node events.\n        this.original.leaveNode(node);\n\n        // Emits the last onCodePathStart/onCodePathSegmentStart events.\n        postprocess(this, node);\n\n        this.currentNode = null;\n    }\n\n    /**\n     * This is called on a code path looped.\n     * Then this raises a looped event.\n     * @param {CodePathSegment} fromSegment A segment of prev.\n     * @param {CodePathSegment} toSegment A segment of next.\n     * @returns {void}\n     */\n    onLooped(fromSegment, toSegment) {\n        if (fromSegment.reachable && toSegment.reachable) {\n            debug.dump(`onCodePathSegmentLoop ${fromSegment.id} -> ${toSegment.id}`);\n            this.emitter.emit(\n                \"onCodePathSegmentLoop\",\n                fromSegment,\n                toSegment,\n                this.currentNode\n            );\n        }\n    }\n}\n\nmodule.exports = CodePathAnalyzer;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}