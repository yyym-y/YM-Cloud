{"ast":null,"code":"/**\n * @fileoverview The factory of `ConfigArray` objects.\n *\n * This class provides methods to create `ConfigArray` instance.\n *\n * - `create(configData, options)`\n *     Create a `ConfigArray` instance from a config data. This is to handle CLI\n *     options except `--config`.\n * - `loadFile(filePath, options)`\n *     Create a `ConfigArray` instance from a config file. This is to handle\n *     `--config` option. If the file was not found, throws the following error:\n *      - If the filename was `*.js`, a `MODULE_NOT_FOUND` error.\n *      - If the filename was `package.json`, an IO error or an\n *        `ESLINT_CONFIG_FIELD_NOT_FOUND` error.\n *      - Otherwise, an IO error such as `ENOENT`.\n * - `loadInDirectory(directoryPath, options)`\n *     Create a `ConfigArray` instance from a config file which is on a given\n *     directory. This tries to load `.eslintrc.*` or `package.json`. If not\n *     found, returns an empty `ConfigArray`.\n * - `loadESLintIgnore(filePath)`\n *     Create a `ConfigArray` instance from a config file that is `.eslintignore`\n *     format. This is to handle `--ignore-path` option.\n * - `loadDefaultESLintIgnore()`\n *     Create a `ConfigArray` instance from `.eslintignore` or `package.json` in\n *     the current working directory.\n *\n * `ConfigArrayFactory` class has the responsibility that loads configuration\n * files, including loading `extends`, `parser`, and `plugins`. The created\n * `ConfigArray` instance has the loaded `extends`, `parser`, and `plugins`.\n *\n * But this class doesn't handle cascading. `CascadingConfigArrayFactory` class\n * handles cascading and hierarchy.\n *\n * @author Toru Nagashima <https://github.com/mysticatea>\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst fs = require(\"fs\");\nconst path = require(\"path\");\nconst importFresh = require(\"import-fresh\");\nconst stripComments = require(\"strip-json-comments\");\nconst ConfigValidator = require(\"./shared/config-validator\");\nconst naming = require(\"./shared/naming\");\nconst ModuleResolver = require(\"./shared/relative-module-resolver\");\nconst {\n  ConfigArray,\n  ConfigDependency,\n  IgnorePattern,\n  OverrideTester\n} = require(\"./config-array\");\nconst debug = require(\"debug\")(\"eslintrc:config-array-factory\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst configFilenames = [\".eslintrc.js\", \".eslintrc.cjs\", \".eslintrc.yaml\", \".eslintrc.yml\", \".eslintrc.json\", \".eslintrc\", \"package.json\"];\n\n// Define types for VSCode IntelliSense.\n/** @typedef {import(\"./shared/types\").ConfigData} ConfigData */\n/** @typedef {import(\"./shared/types\").OverrideConfigData} OverrideConfigData */\n/** @typedef {import(\"./shared/types\").Parser} Parser */\n/** @typedef {import(\"./shared/types\").Plugin} Plugin */\n/** @typedef {import(\"./shared/types\").Rule} Rule */\n/** @typedef {import(\"./config-array/config-dependency\").DependentParser} DependentParser */\n/** @typedef {import(\"./config-array/config-dependency\").DependentPlugin} DependentPlugin */\n/** @typedef {ConfigArray[0]} ConfigArrayElement */\n\n/**\n * @typedef {Object} ConfigArrayFactoryOptions\n * @property {Map<string,Plugin>} [additionalPluginPool] The map for additional plugins.\n * @property {string} [cwd] The path to the current working directory.\n * @property {string} [resolvePluginsRelativeTo] A path to the directory that plugins should be resolved from. Defaults to `cwd`.\n * @property {Map<string,Rule>} builtInRules The rules that are built in to ESLint.\n * @property {Object} [resolver=ModuleResolver] The module resolver object.\n * @property {string} eslintAllPath The path to the definitions for eslint:all.\n * @property {string} eslintRecommendedPath The path to the definitions for eslint:recommended.\n */\n\n/**\n * @typedef {Object} ConfigArrayFactoryInternalSlots\n * @property {Map<string,Plugin>} additionalPluginPool The map for additional plugins.\n * @property {string} cwd The path to the current working directory.\n * @property {string | undefined} resolvePluginsRelativeTo An absolute path the the directory that plugins should be resolved from.\n * @property {Map<string,Rule>} builtInRules The rules that are built in to ESLint.\n * @property {Object} [resolver=ModuleResolver] The module resolver object.\n * @property {string} eslintAllPath The path to the definitions for eslint:all.\n * @property {string} eslintRecommendedPath The path to the definitions for eslint:recommended.\n */\n\n/**\n * @typedef {Object} ConfigArrayFactoryLoadingContext\n * @property {string} filePath The path to the current configuration.\n * @property {string} matchBasePath The base path to resolve relative paths in `overrides[].files`, `overrides[].excludedFiles`, and `ignorePatterns`.\n * @property {string} name The name of the current configuration.\n * @property {string} pluginBasePath The base path to resolve plugins.\n * @property {\"config\" | \"ignore\" | \"implicit-processor\"} type The type of the current configuration. This is `\"config\"` in normal. This is `\"ignore\"` if it came from `.eslintignore`. This is `\"implicit-processor\"` if it came from legacy file-extension processors.\n */\n\n/**\n * @typedef {Object} ConfigArrayFactoryLoadingContext\n * @property {string} filePath The path to the current configuration.\n * @property {string} matchBasePath The base path to resolve relative paths in `overrides[].files`, `overrides[].excludedFiles`, and `ignorePatterns`.\n * @property {string} name The name of the current configuration.\n * @property {\"config\" | \"ignore\" | \"implicit-processor\"} type The type of the current configuration. This is `\"config\"` in normal. This is `\"ignore\"` if it came from `.eslintignore`. This is `\"implicit-processor\"` if it came from legacy file-extension processors.\n */\n\n/** @type {WeakMap<ConfigArrayFactory, ConfigArrayFactoryInternalSlots>} */\nconst internalSlotsMap = new WeakMap();\n\n/**\n * Check if a given string is a file path.\n * @param {string} nameOrPath A module name or file path.\n * @returns {boolean} `true` if the `nameOrPath` is a file path.\n */\nfunction isFilePath(nameOrPath) {\n  return /^\\.{1,2}[/\\\\]/u.test(nameOrPath) || path.isAbsolute(nameOrPath);\n}\n\n/**\n * Convenience wrapper for synchronously reading file contents.\n * @param {string} filePath The filename to read.\n * @returns {string} The file contents, with the BOM removed.\n * @private\n */\nfunction readFile(filePath) {\n  return fs.readFileSync(filePath, \"utf8\").replace(/^\\ufeff/u, \"\");\n}\n\n/**\n * Loads a YAML configuration from a file.\n * @param {string} filePath The filename to load.\n * @returns {ConfigData} The configuration object from the file.\n * @throws {Error} If the file cannot be read.\n * @private\n */\nfunction loadYAMLConfigFile(filePath) {\n  debug(`Loading YAML config file: ${filePath}`);\n\n  // lazy load YAML to improve performance when not used\n  const yaml = require(\"js-yaml\");\n  try {\n    // empty YAML file can be null, so always use\n    return yaml.safeLoad(readFile(filePath)) || {};\n  } catch (e) {\n    debug(`Error reading YAML file: ${filePath}`);\n    e.message = `Cannot read config file: ${filePath}\\nError: ${e.message}`;\n    throw e;\n  }\n}\n\n/**\n * Loads a JSON configuration from a file.\n * @param {string} filePath The filename to load.\n * @returns {ConfigData} The configuration object from the file.\n * @throws {Error} If the file cannot be read.\n * @private\n */\nfunction loadJSONConfigFile(filePath) {\n  debug(`Loading JSON config file: ${filePath}`);\n  try {\n    return JSON.parse(stripComments(readFile(filePath)));\n  } catch (e) {\n    debug(`Error reading JSON file: ${filePath}`);\n    e.message = `Cannot read config file: ${filePath}\\nError: ${e.message}`;\n    e.messageTemplate = \"failed-to-read-json\";\n    e.messageData = {\n      path: filePath,\n      message: e.message\n    };\n    throw e;\n  }\n}\n\n/**\n * Loads a legacy (.eslintrc) configuration from a file.\n * @param {string} filePath The filename to load.\n * @returns {ConfigData} The configuration object from the file.\n * @throws {Error} If the file cannot be read.\n * @private\n */\nfunction loadLegacyConfigFile(filePath) {\n  debug(`Loading legacy config file: ${filePath}`);\n\n  // lazy load YAML to improve performance when not used\n  const yaml = require(\"js-yaml\");\n  try {\n    return yaml.safeLoad(stripComments(readFile(filePath))) || /* istanbul ignore next */{};\n  } catch (e) {\n    debug(\"Error reading YAML file: %s\\n%o\", filePath, e);\n    e.message = `Cannot read config file: ${filePath}\\nError: ${e.message}`;\n    throw e;\n  }\n}\n\n/**\n * Loads a JavaScript configuration from a file.\n * @param {string} filePath The filename to load.\n * @returns {ConfigData} The configuration object from the file.\n * @throws {Error} If the file cannot be read.\n * @private\n */\nfunction loadJSConfigFile(filePath) {\n  debug(`Loading JS config file: ${filePath}`);\n  try {\n    return importFresh(filePath);\n  } catch (e) {\n    debug(`Error reading JavaScript file: ${filePath}`);\n    e.message = `Cannot read config file: ${filePath}\\nError: ${e.message}`;\n    throw e;\n  }\n}\n\n/**\n * Loads a configuration from a package.json file.\n * @param {string} filePath The filename to load.\n * @returns {ConfigData} The configuration object from the file.\n * @throws {Error} If the file cannot be read.\n * @private\n */\nfunction loadPackageJSONConfigFile(filePath) {\n  debug(`Loading package.json config file: ${filePath}`);\n  try {\n    const packageData = loadJSONConfigFile(filePath);\n    if (!Object.hasOwnProperty.call(packageData, \"eslintConfig\")) {\n      throw Object.assign(new Error(\"package.json file doesn't have 'eslintConfig' field.\"), {\n        code: \"ESLINT_CONFIG_FIELD_NOT_FOUND\"\n      });\n    }\n    return packageData.eslintConfig;\n  } catch (e) {\n    debug(`Error reading package.json file: ${filePath}`);\n    e.message = `Cannot read config file: ${filePath}\\nError: ${e.message}`;\n    throw e;\n  }\n}\n\n/**\n * Loads a `.eslintignore` from a file.\n * @param {string} filePath The filename to load.\n * @returns {string[]} The ignore patterns from the file.\n * @private\n */\nfunction loadESLintIgnoreFile(filePath) {\n  debug(`Loading .eslintignore file: ${filePath}`);\n  try {\n    return readFile(filePath).split(/\\r?\\n/gu).filter(line => line.trim() !== \"\" && !line.startsWith(\"#\"));\n  } catch (e) {\n    debug(`Error reading .eslintignore file: ${filePath}`);\n    e.message = `Cannot read .eslintignore file: ${filePath}\\nError: ${e.message}`;\n    throw e;\n  }\n}\n\n/**\n * Creates an error to notify about a missing config to extend from.\n * @param {string} configName The name of the missing config.\n * @param {string} importerName The name of the config that imported the missing config\n * @param {string} messageTemplate The text template to source error strings from.\n * @returns {Error} The error object to throw\n * @private\n */\nfunction configInvalidError(configName, importerName, messageTemplate) {\n  return Object.assign(new Error(`Failed to load config \"${configName}\" to extend from.`), {\n    messageTemplate,\n    messageData: {\n      configName,\n      importerName\n    }\n  });\n}\n\n/**\n * Loads a configuration file regardless of the source. Inspects the file path\n * to determine the correctly way to load the config file.\n * @param {string} filePath The path to the configuration.\n * @returns {ConfigData|null} The configuration information.\n * @private\n */\nfunction loadConfigFile(filePath) {\n  switch (path.extname(filePath)) {\n    case \".js\":\n    case \".cjs\":\n      return loadJSConfigFile(filePath);\n    case \".json\":\n      if (path.basename(filePath) === \"package.json\") {\n        return loadPackageJSONConfigFile(filePath);\n      }\n      return loadJSONConfigFile(filePath);\n    case \".yaml\":\n    case \".yml\":\n      return loadYAMLConfigFile(filePath);\n    default:\n      return loadLegacyConfigFile(filePath);\n  }\n}\n\n/**\n * Write debug log.\n * @param {string} request The requested module name.\n * @param {string} relativeTo The file path to resolve the request relative to.\n * @param {string} filePath The resolved file path.\n * @returns {void}\n */\nfunction writeDebugLogForLoading(request, relativeTo, filePath) {\n  /* istanbul ignore next */\n  if (debug.enabled) {\n    let nameAndVersion = null;\n    try {\n      const packageJsonPath = ModuleResolver.resolve(`${request}/package.json`, relativeTo);\n      const {\n        version = \"unknown\"\n      } = require(packageJsonPath);\n      nameAndVersion = `${request}@${version}`;\n    } catch (error) {\n      debug(\"package.json was not found:\", error.message);\n      nameAndVersion = request;\n    }\n    debug(\"Loaded: %s (%s)\", nameAndVersion, filePath);\n  }\n}\n\n/**\n * Create a new context with default values.\n * @param {ConfigArrayFactoryInternalSlots} slots The internal slots.\n * @param {\"config\" | \"ignore\" | \"implicit-processor\" | undefined} providedType The type of the current configuration. Default is `\"config\"`.\n * @param {string | undefined} providedName The name of the current configuration. Default is the relative path from `cwd` to `filePath`.\n * @param {string | undefined} providedFilePath The path to the current configuration. Default is empty string.\n * @param {string | undefined} providedMatchBasePath The type of the current configuration. Default is the directory of `filePath` or `cwd`.\n * @returns {ConfigArrayFactoryLoadingContext} The created context.\n */\nfunction createContext({\n  cwd,\n  resolvePluginsRelativeTo\n}, providedType, providedName, providedFilePath, providedMatchBasePath) {\n  const filePath = providedFilePath ? path.resolve(cwd, providedFilePath) : \"\";\n  const matchBasePath = providedMatchBasePath && path.resolve(cwd, providedMatchBasePath) || filePath && path.dirname(filePath) || cwd;\n  const name = providedName || filePath && path.relative(cwd, filePath) || \"\";\n  const pluginBasePath = resolvePluginsRelativeTo || filePath && path.dirname(filePath) || cwd;\n  const type = providedType || \"config\";\n  return {\n    filePath,\n    matchBasePath,\n    name,\n    pluginBasePath,\n    type\n  };\n}\n\n/**\n * Normalize a given plugin.\n * - Ensure the object to have four properties: configs, environments, processors, and rules.\n * - Ensure the object to not have other properties.\n * @param {Plugin} plugin The plugin to normalize.\n * @returns {Plugin} The normalized plugin.\n */\nfunction normalizePlugin(plugin) {\n  return {\n    configs: plugin.configs || {},\n    environments: plugin.environments || {},\n    processors: plugin.processors || {},\n    rules: plugin.rules || {}\n  };\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * The factory of `ConfigArray` objects.\n */\nclass ConfigArrayFactory {\n  /**\n   * Initialize this instance.\n   * @param {ConfigArrayFactoryOptions} [options] The map for additional plugins.\n   */\n  constructor({\n    additionalPluginPool = new Map(),\n    cwd = process.cwd(),\n    resolvePluginsRelativeTo,\n    builtInRules,\n    resolver = ModuleResolver,\n    eslintAllPath,\n    eslintRecommendedPath\n  } = {}) {\n    internalSlotsMap.set(this, {\n      additionalPluginPool,\n      cwd,\n      resolvePluginsRelativeTo: resolvePluginsRelativeTo && path.resolve(cwd, resolvePluginsRelativeTo),\n      builtInRules,\n      resolver,\n      eslintAllPath,\n      eslintRecommendedPath\n    });\n  }\n\n  /**\n   * Create `ConfigArray` instance from a config data.\n   * @param {ConfigData|null} configData The config data to create.\n   * @param {Object} [options] The options.\n   * @param {string} [options.basePath] The base path to resolve relative paths in `overrides[].files`, `overrides[].excludedFiles`, and `ignorePatterns`.\n   * @param {string} [options.filePath] The path to this config data.\n   * @param {string} [options.name] The config name.\n   * @returns {ConfigArray} Loaded config.\n   */\n  create(configData, {\n    basePath,\n    filePath,\n    name\n  } = {}) {\n    if (!configData) {\n      return new ConfigArray();\n    }\n    const slots = internalSlotsMap.get(this);\n    const ctx = createContext(slots, \"config\", name, filePath, basePath);\n    const elements = this._normalizeConfigData(configData, ctx);\n    return new ConfigArray(...elements);\n  }\n\n  /**\n   * Load a config file.\n   * @param {string} filePath The path to a config file.\n   * @param {Object} [options] The options.\n   * @param {string} [options.basePath] The base path to resolve relative paths in `overrides[].files`, `overrides[].excludedFiles`, and `ignorePatterns`.\n   * @param {string} [options.name] The config name.\n   * @returns {ConfigArray} Loaded config.\n   */\n  loadFile(filePath, {\n    basePath,\n    name\n  } = {}) {\n    const slots = internalSlotsMap.get(this);\n    const ctx = createContext(slots, \"config\", name, filePath, basePath);\n    return new ConfigArray(...this._loadConfigData(ctx));\n  }\n\n  /**\n   * Load the config file on a given directory if exists.\n   * @param {string} directoryPath The path to a directory.\n   * @param {Object} [options] The options.\n   * @param {string} [options.basePath] The base path to resolve relative paths in `overrides[].files`, `overrides[].excludedFiles`, and `ignorePatterns`.\n   * @param {string} [options.name] The config name.\n   * @returns {ConfigArray} Loaded config. An empty `ConfigArray` if any config doesn't exist.\n   */\n  loadInDirectory(directoryPath, {\n    basePath,\n    name\n  } = {}) {\n    const slots = internalSlotsMap.get(this);\n    for (const filename of configFilenames) {\n      const ctx = createContext(slots, \"config\", name, path.join(directoryPath, filename), basePath);\n      if (fs.existsSync(ctx.filePath) && fs.statSync(ctx.filePath).isFile()) {\n        let configData;\n        try {\n          configData = loadConfigFile(ctx.filePath);\n        } catch (error) {\n          if (!error || error.code !== \"ESLINT_CONFIG_FIELD_NOT_FOUND\") {\n            throw error;\n          }\n        }\n        if (configData) {\n          debug(`Config file found: ${ctx.filePath}`);\n          return new ConfigArray(...this._normalizeConfigData(configData, ctx));\n        }\n      }\n    }\n    debug(`Config file not found on ${directoryPath}`);\n    return new ConfigArray();\n  }\n\n  /**\n   * Check if a config file on a given directory exists or not.\n   * @param {string} directoryPath The path to a directory.\n   * @returns {string | null} The path to the found config file. If not found then null.\n   */\n  static getPathToConfigFileInDirectory(directoryPath) {\n    for (const filename of configFilenames) {\n      const filePath = path.join(directoryPath, filename);\n      if (fs.existsSync(filePath)) {\n        if (filename === \"package.json\") {\n          try {\n            loadPackageJSONConfigFile(filePath);\n            return filePath;\n          } catch {/* ignore */}\n        } else {\n          return filePath;\n        }\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Load `.eslintignore` file.\n   * @param {string} filePath The path to a `.eslintignore` file to load.\n   * @returns {ConfigArray} Loaded config. An empty `ConfigArray` if any config doesn't exist.\n   */\n  loadESLintIgnore(filePath) {\n    const slots = internalSlotsMap.get(this);\n    const ctx = createContext(slots, \"ignore\", void 0, filePath, slots.cwd);\n    const ignorePatterns = loadESLintIgnoreFile(ctx.filePath);\n    return new ConfigArray(...this._normalizeESLintIgnoreData(ignorePatterns, ctx));\n  }\n\n  /**\n   * Load `.eslintignore` file in the current working directory.\n   * @returns {ConfigArray} Loaded config. An empty `ConfigArray` if any config doesn't exist.\n   */\n  loadDefaultESLintIgnore() {\n    const slots = internalSlotsMap.get(this);\n    const eslintIgnorePath = path.resolve(slots.cwd, \".eslintignore\");\n    const packageJsonPath = path.resolve(slots.cwd, \"package.json\");\n    if (fs.existsSync(eslintIgnorePath)) {\n      return this.loadESLintIgnore(eslintIgnorePath);\n    }\n    if (fs.existsSync(packageJsonPath)) {\n      const data = loadJSONConfigFile(packageJsonPath);\n      if (Object.hasOwnProperty.call(data, \"eslintIgnore\")) {\n        if (!Array.isArray(data.eslintIgnore)) {\n          throw new Error(\"Package.json eslintIgnore property requires an array of paths\");\n        }\n        const ctx = createContext(slots, \"ignore\", \"eslintIgnore in package.json\", packageJsonPath, slots.cwd);\n        return new ConfigArray(...this._normalizeESLintIgnoreData(data.eslintIgnore, ctx));\n      }\n    }\n    return new ConfigArray();\n  }\n\n  /**\n   * Load a given config file.\n   * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n   * @returns {IterableIterator<ConfigArrayElement>} Loaded config.\n   * @private\n   */\n  _loadConfigData(ctx) {\n    return this._normalizeConfigData(loadConfigFile(ctx.filePath), ctx);\n  }\n\n  /**\n   * Normalize a given `.eslintignore` data to config array elements.\n   * @param {string[]} ignorePatterns The patterns to ignore files.\n   * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n   * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n   * @private\n   */\n  *_normalizeESLintIgnoreData(ignorePatterns, ctx) {\n    const elements = this._normalizeObjectConfigData({\n      ignorePatterns\n    }, ctx);\n\n    // Set `ignorePattern.loose` flag for backward compatibility.\n    for (const element of elements) {\n      if (element.ignorePattern) {\n        element.ignorePattern.loose = true;\n      }\n      yield element;\n    }\n  }\n\n  /**\n   * Normalize a given config to an array.\n   * @param {ConfigData} configData The config data to normalize.\n   * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n   * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n   * @private\n   */\n  _normalizeConfigData(configData, ctx) {\n    const validator = new ConfigValidator();\n    validator.validateConfigSchema(configData, ctx.name || ctx.filePath);\n    return this._normalizeObjectConfigData(configData, ctx);\n  }\n\n  /**\n   * Normalize a given config to an array.\n   * @param {ConfigData|OverrideConfigData} configData The config data to normalize.\n   * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n   * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n   * @private\n   */\n  *_normalizeObjectConfigData(configData, ctx) {\n    const {\n      files,\n      excludedFiles,\n      ...configBody\n    } = configData;\n    const criteria = OverrideTester.create(files, excludedFiles, ctx.matchBasePath);\n    const elements = this._normalizeObjectConfigDataBody(configBody, ctx);\n\n    // Apply the criteria to every element.\n    for (const element of elements) {\n      /*\n       * Merge the criteria.\n       * This is for the `overrides` entries that came from the\n       * configurations of `overrides[].extends`.\n       */\n      element.criteria = OverrideTester.and(criteria, element.criteria);\n\n      /*\n       * Remove `root` property to ignore `root` settings which came from\n       * `extends` in `overrides`.\n       */\n      if (element.criteria) {\n        element.root = void 0;\n      }\n      yield element;\n    }\n  }\n\n  /**\n   * Normalize a given config to an array.\n   * @param {ConfigData} configData The config data to normalize.\n   * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n   * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n   * @private\n   */\n  *_normalizeObjectConfigDataBody({\n    env,\n    extends: extend,\n    globals,\n    ignorePatterns,\n    noInlineConfig,\n    parser: parserName,\n    parserOptions,\n    plugins: pluginList,\n    processor,\n    reportUnusedDisableDirectives,\n    root,\n    rules,\n    settings,\n    overrides: overrideList = []\n  }, ctx) {\n    const extendList = Array.isArray(extend) ? extend : [extend];\n    const ignorePattern = ignorePatterns && new IgnorePattern(Array.isArray(ignorePatterns) ? ignorePatterns : [ignorePatterns], ctx.matchBasePath);\n\n    // Flatten `extends`.\n    for (const extendName of extendList.filter(Boolean)) {\n      yield* this._loadExtends(extendName, ctx);\n    }\n\n    // Load parser & plugins.\n    const parser = parserName && this._loadParser(parserName, ctx);\n    const plugins = pluginList && this._loadPlugins(pluginList, ctx);\n\n    // Yield pseudo config data for file extension processors.\n    if (plugins) {\n      yield* this._takeFileExtensionProcessors(plugins, ctx);\n    }\n\n    // Yield the config data except `extends` and `overrides`.\n    yield {\n      // Debug information.\n      type: ctx.type,\n      name: ctx.name,\n      filePath: ctx.filePath,\n      // Config data.\n      criteria: null,\n      env,\n      globals,\n      ignorePattern,\n      noInlineConfig,\n      parser,\n      parserOptions,\n      plugins,\n      processor,\n      reportUnusedDisableDirectives,\n      root,\n      rules,\n      settings\n    };\n\n    // Flatten `overries`.\n    for (let i = 0; i < overrideList.length; ++i) {\n      yield* this._normalizeObjectConfigData(overrideList[i], {\n        ...ctx,\n        name: `${ctx.name}#overrides[${i}]`\n      });\n    }\n  }\n\n  /**\n   * Load configs of an element in `extends`.\n   * @param {string} extendName The name of a base config.\n   * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n   * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n   * @private\n   */\n  _loadExtends(extendName, ctx) {\n    debug(\"Loading {extends:%j} relative to %s\", extendName, ctx.filePath);\n    try {\n      if (extendName.startsWith(\"eslint:\")) {\n        return this._loadExtendedBuiltInConfig(extendName, ctx);\n      }\n      if (extendName.startsWith(\"plugin:\")) {\n        return this._loadExtendedPluginConfig(extendName, ctx);\n      }\n      return this._loadExtendedShareableConfig(extendName, ctx);\n    } catch (error) {\n      error.message += `\\nReferenced from: ${ctx.filePath || ctx.name}`;\n      throw error;\n    }\n  }\n\n  /**\n   * Load configs of an element in `extends`.\n   * @param {string} extendName The name of a base config.\n   * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n   * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n   * @private\n   */\n  _loadExtendedBuiltInConfig(extendName, ctx) {\n    const {\n      eslintAllPath,\n      eslintRecommendedPath\n    } = internalSlotsMap.get(this);\n    if (extendName === \"eslint:recommended\") {\n      return this._loadConfigData({\n        ...ctx,\n        filePath: eslintRecommendedPath,\n        name: `${ctx.name} » ${extendName}`\n      });\n    }\n    if (extendName === \"eslint:all\") {\n      return this._loadConfigData({\n        ...ctx,\n        filePath: eslintAllPath,\n        name: `${ctx.name} » ${extendName}`\n      });\n    }\n    throw configInvalidError(extendName, ctx.name, \"extend-config-missing\");\n  }\n\n  /**\n   * Load configs of an element in `extends`.\n   * @param {string} extendName The name of a base config.\n   * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n   * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n   * @private\n   */\n  _loadExtendedPluginConfig(extendName, ctx) {\n    const slashIndex = extendName.lastIndexOf(\"/\");\n    if (slashIndex === -1) {\n      throw configInvalidError(extendName, ctx.filePath, \"plugin-invalid\");\n    }\n    const pluginName = extendName.slice(\"plugin:\".length, slashIndex);\n    const configName = extendName.slice(slashIndex + 1);\n    if (isFilePath(pluginName)) {\n      throw new Error(\"'extends' cannot use a file path for plugins.\");\n    }\n    const plugin = this._loadPlugin(pluginName, ctx);\n    const configData = plugin.definition && plugin.definition.configs[configName];\n    if (configData) {\n      return this._normalizeConfigData(configData, {\n        ...ctx,\n        filePath: plugin.filePath || ctx.filePath,\n        name: `${ctx.name} » plugin:${plugin.id}/${configName}`\n      });\n    }\n    throw plugin.error || configInvalidError(extendName, ctx.filePath, \"extend-config-missing\");\n  }\n\n  /**\n   * Load configs of an element in `extends`.\n   * @param {string} extendName The name of a base config.\n   * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n   * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n   * @private\n   */\n  _loadExtendedShareableConfig(extendName, ctx) {\n    const {\n      cwd,\n      resolver\n    } = internalSlotsMap.get(this);\n    const relativeTo = ctx.filePath || path.join(cwd, \"__placeholder__.js\");\n    let request;\n    if (isFilePath(extendName)) {\n      request = extendName;\n    } else if (extendName.startsWith(\".\")) {\n      request = `./${extendName}`; // For backward compatibility. A ton of tests depended on this behavior.\n    } else {\n      request = naming.normalizePackageName(extendName, \"eslint-config\");\n    }\n    let filePath;\n    try {\n      filePath = resolver.resolve(request, relativeTo);\n    } catch (error) {\n      /* istanbul ignore else */\n      if (error && error.code === \"MODULE_NOT_FOUND\") {\n        throw configInvalidError(extendName, ctx.filePath, \"extend-config-missing\");\n      }\n      throw error;\n    }\n    writeDebugLogForLoading(request, relativeTo, filePath);\n    return this._loadConfigData({\n      ...ctx,\n      filePath,\n      name: `${ctx.name} » ${request}`\n    });\n  }\n\n  /**\n   * Load given plugins.\n   * @param {string[]} names The plugin names to load.\n   * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n   * @returns {Record<string,DependentPlugin>} The loaded parser.\n   * @private\n   */\n  _loadPlugins(names, ctx) {\n    return names.reduce((map, name) => {\n      if (isFilePath(name)) {\n        throw new Error(\"Plugins array cannot includes file paths.\");\n      }\n      const plugin = this._loadPlugin(name, ctx);\n      map[plugin.id] = plugin;\n      return map;\n    }, {});\n  }\n\n  /**\n   * Load a given parser.\n   * @param {string} nameOrPath The package name or the path to a parser file.\n   * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n   * @returns {DependentParser} The loaded parser.\n   */\n  _loadParser(nameOrPath, ctx) {\n    debug(\"Loading parser %j from %s\", nameOrPath, ctx.filePath);\n    const {\n      cwd\n    } = internalSlotsMap.get(this);\n    const relativeTo = ctx.filePath || path.join(cwd, \"__placeholder__.js\");\n    try {\n      const filePath = ModuleResolver.resolve(nameOrPath, relativeTo);\n      writeDebugLogForLoading(nameOrPath, relativeTo, filePath);\n      return new ConfigDependency({\n        definition: require(filePath),\n        filePath,\n        id: nameOrPath,\n        importerName: ctx.name,\n        importerPath: ctx.filePath\n      });\n    } catch (error) {\n      // If the parser name is \"espree\", load the espree of ESLint.\n      if (nameOrPath === \"espree\") {\n        debug(\"Fallback espree.\");\n        return new ConfigDependency({\n          definition: require(\"espree\"),\n          filePath: require.resolve(\"espree\"),\n          id: nameOrPath,\n          importerName: ctx.name,\n          importerPath: ctx.filePath\n        });\n      }\n      debug(\"Failed to load parser '%s' declared in '%s'.\", nameOrPath, ctx.name);\n      error.message = `Failed to load parser '${nameOrPath}' declared in '${ctx.name}': ${error.message}`;\n      return new ConfigDependency({\n        error,\n        id: nameOrPath,\n        importerName: ctx.name,\n        importerPath: ctx.filePath\n      });\n    }\n  }\n\n  /**\n   * Load a given plugin.\n   * @param {string} name The plugin name to load.\n   * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n   * @returns {DependentPlugin} The loaded plugin.\n   * @private\n   */\n  _loadPlugin(name, ctx) {\n    debug(\"Loading plugin %j from %s\", name, ctx.filePath);\n    const {\n      additionalPluginPool\n    } = internalSlotsMap.get(this);\n    const request = naming.normalizePackageName(name, \"eslint-plugin\");\n    const id = naming.getShorthandName(request, \"eslint-plugin\");\n    const relativeTo = path.join(ctx.pluginBasePath, \"__placeholder__.js\");\n    if (name.match(/\\s+/u)) {\n      const error = Object.assign(new Error(`Whitespace found in plugin name '${name}'`), {\n        messageTemplate: \"whitespace-found\",\n        messageData: {\n          pluginName: request\n        }\n      });\n      return new ConfigDependency({\n        error,\n        id,\n        importerName: ctx.name,\n        importerPath: ctx.filePath\n      });\n    }\n\n    // Check for additional pool.\n    const plugin = additionalPluginPool.get(request) || additionalPluginPool.get(id);\n    if (plugin) {\n      return new ConfigDependency({\n        definition: normalizePlugin(plugin),\n        filePath: \"\",\n        // It's unknown where the plugin came from.\n        id,\n        importerName: ctx.name,\n        importerPath: ctx.filePath\n      });\n    }\n    let filePath;\n    let error;\n    try {\n      filePath = ModuleResolver.resolve(request, relativeTo);\n    } catch (resolveError) {\n      error = resolveError;\n      /* istanbul ignore else */\n      if (error && error.code === \"MODULE_NOT_FOUND\") {\n        error.messageTemplate = \"plugin-missing\";\n        error.messageData = {\n          pluginName: request,\n          resolvePluginsRelativeTo: ctx.pluginBasePath,\n          importerName: ctx.name\n        };\n      }\n    }\n    if (filePath) {\n      try {\n        writeDebugLogForLoading(request, relativeTo, filePath);\n        const startTime = Date.now();\n        const pluginDefinition = require(filePath);\n        debug(`Plugin ${filePath} loaded in: ${Date.now() - startTime}ms`);\n        return new ConfigDependency({\n          definition: normalizePlugin(pluginDefinition),\n          filePath,\n          id,\n          importerName: ctx.name,\n          importerPath: ctx.filePath\n        });\n      } catch (loadError) {\n        error = loadError;\n      }\n    }\n    debug(\"Failed to load plugin '%s' declared in '%s'.\", name, ctx.name);\n    error.message = `Failed to load plugin '${name}' declared in '${ctx.name}': ${error.message}`;\n    return new ConfigDependency({\n      error,\n      id,\n      importerName: ctx.name,\n      importerPath: ctx.filePath\n    });\n  }\n\n  /**\n   * Take file expression processors as config array elements.\n   * @param {Record<string,DependentPlugin>} plugins The plugin definitions.\n   * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n   * @returns {IterableIterator<ConfigArrayElement>} The config array elements of file expression processors.\n   * @private\n   */\n  *_takeFileExtensionProcessors(plugins, ctx) {\n    for (const pluginId of Object.keys(plugins)) {\n      const processors = plugins[pluginId] && plugins[pluginId].definition && plugins[pluginId].definition.processors;\n      if (!processors) {\n        continue;\n      }\n      for (const processorId of Object.keys(processors)) {\n        if (processorId.startsWith(\".\")) {\n          yield* this._normalizeObjectConfigData({\n            files: [`*${processorId}`],\n            processor: `${pluginId}/${processorId}`\n          }, {\n            ...ctx,\n            type: \"implicit-processor\",\n            name: `${ctx.name}#processors[\"${pluginId}/${processorId}\"]`\n          });\n        }\n      }\n    }\n  }\n}\nmodule.exports = {\n  ConfigArrayFactory,\n  createContext\n};","map":{"version":3,"names":["fs","require","path","importFresh","stripComments","ConfigValidator","naming","ModuleResolver","ConfigArray","ConfigDependency","IgnorePattern","OverrideTester","debug","configFilenames","internalSlotsMap","WeakMap","isFilePath","nameOrPath","test","isAbsolute","readFile","filePath","readFileSync","replace","loadYAMLConfigFile","yaml","safeLoad","e","message","loadJSONConfigFile","JSON","parse","messageTemplate","messageData","loadLegacyConfigFile","loadJSConfigFile","loadPackageJSONConfigFile","packageData","Object","hasOwnProperty","call","assign","Error","code","eslintConfig","loadESLintIgnoreFile","split","filter","line","trim","startsWith","configInvalidError","configName","importerName","loadConfigFile","extname","basename","writeDebugLogForLoading","request","relativeTo","enabled","nameAndVersion","packageJsonPath","resolve","version","error","createContext","cwd","resolvePluginsRelativeTo","providedType","providedName","providedFilePath","providedMatchBasePath","matchBasePath","dirname","name","relative","pluginBasePath","type","normalizePlugin","plugin","configs","environments","processors","rules","ConfigArrayFactory","constructor","additionalPluginPool","Map","process","builtInRules","resolver","eslintAllPath","eslintRecommendedPath","set","create","configData","basePath","slots","get","ctx","elements","_normalizeConfigData","loadFile","_loadConfigData","loadInDirectory","directoryPath","filename","join","existsSync","statSync","isFile","getPathToConfigFileInDirectory","loadESLintIgnore","ignorePatterns","_normalizeESLintIgnoreData","loadDefaultESLintIgnore","eslintIgnorePath","data","Array","isArray","eslintIgnore","_normalizeObjectConfigData","element","ignorePattern","loose","validator","validateConfigSchema","files","excludedFiles","configBody","criteria","_normalizeObjectConfigDataBody","and","root","env","extends","extend","globals","noInlineConfig","parser","parserName","parserOptions","plugins","pluginList","processor","reportUnusedDisableDirectives","settings","overrides","overrideList","extendList","extendName","Boolean","_loadExtends","_loadParser","_loadPlugins","_takeFileExtensionProcessors","i","length","_loadExtendedBuiltInConfig","_loadExtendedPluginConfig","_loadExtendedShareableConfig","slashIndex","lastIndexOf","pluginName","slice","_loadPlugin","definition","id","normalizePackageName","names","reduce","map","importerPath","getShorthandName","match","resolveError","startTime","Date","now","pluginDefinition","loadError","pluginId","keys","processorId","module","exports"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/@eslint/eslintrc/lib/config-array-factory.js"],"sourcesContent":["/**\n * @fileoverview The factory of `ConfigArray` objects.\n *\n * This class provides methods to create `ConfigArray` instance.\n *\n * - `create(configData, options)`\n *     Create a `ConfigArray` instance from a config data. This is to handle CLI\n *     options except `--config`.\n * - `loadFile(filePath, options)`\n *     Create a `ConfigArray` instance from a config file. This is to handle\n *     `--config` option. If the file was not found, throws the following error:\n *      - If the filename was `*.js`, a `MODULE_NOT_FOUND` error.\n *      - If the filename was `package.json`, an IO error or an\n *        `ESLINT_CONFIG_FIELD_NOT_FOUND` error.\n *      - Otherwise, an IO error such as `ENOENT`.\n * - `loadInDirectory(directoryPath, options)`\n *     Create a `ConfigArray` instance from a config file which is on a given\n *     directory. This tries to load `.eslintrc.*` or `package.json`. If not\n *     found, returns an empty `ConfigArray`.\n * - `loadESLintIgnore(filePath)`\n *     Create a `ConfigArray` instance from a config file that is `.eslintignore`\n *     format. This is to handle `--ignore-path` option.\n * - `loadDefaultESLintIgnore()`\n *     Create a `ConfigArray` instance from `.eslintignore` or `package.json` in\n *     the current working directory.\n *\n * `ConfigArrayFactory` class has the responsibility that loads configuration\n * files, including loading `extends`, `parser`, and `plugins`. The created\n * `ConfigArray` instance has the loaded `extends`, `parser`, and `plugins`.\n *\n * But this class doesn't handle cascading. `CascadingConfigArrayFactory` class\n * handles cascading and hierarchy.\n *\n * @author Toru Nagashima <https://github.com/mysticatea>\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst fs = require(\"fs\");\nconst path = require(\"path\");\nconst importFresh = require(\"import-fresh\");\nconst stripComments = require(\"strip-json-comments\");\nconst ConfigValidator = require(\"./shared/config-validator\");\nconst naming = require(\"./shared/naming\");\nconst ModuleResolver = require(\"./shared/relative-module-resolver\");\nconst {\n    ConfigArray,\n    ConfigDependency,\n    IgnorePattern,\n    OverrideTester\n} = require(\"./config-array\");\nconst debug = require(\"debug\")(\"eslintrc:config-array-factory\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst configFilenames = [\n    \".eslintrc.js\",\n    \".eslintrc.cjs\",\n    \".eslintrc.yaml\",\n    \".eslintrc.yml\",\n    \".eslintrc.json\",\n    \".eslintrc\",\n    \"package.json\"\n];\n\n// Define types for VSCode IntelliSense.\n/** @typedef {import(\"./shared/types\").ConfigData} ConfigData */\n/** @typedef {import(\"./shared/types\").OverrideConfigData} OverrideConfigData */\n/** @typedef {import(\"./shared/types\").Parser} Parser */\n/** @typedef {import(\"./shared/types\").Plugin} Plugin */\n/** @typedef {import(\"./shared/types\").Rule} Rule */\n/** @typedef {import(\"./config-array/config-dependency\").DependentParser} DependentParser */\n/** @typedef {import(\"./config-array/config-dependency\").DependentPlugin} DependentPlugin */\n/** @typedef {ConfigArray[0]} ConfigArrayElement */\n\n/**\n * @typedef {Object} ConfigArrayFactoryOptions\n * @property {Map<string,Plugin>} [additionalPluginPool] The map for additional plugins.\n * @property {string} [cwd] The path to the current working directory.\n * @property {string} [resolvePluginsRelativeTo] A path to the directory that plugins should be resolved from. Defaults to `cwd`.\n * @property {Map<string,Rule>} builtInRules The rules that are built in to ESLint.\n * @property {Object} [resolver=ModuleResolver] The module resolver object.\n * @property {string} eslintAllPath The path to the definitions for eslint:all.\n * @property {string} eslintRecommendedPath The path to the definitions for eslint:recommended.\n */\n\n/**\n * @typedef {Object} ConfigArrayFactoryInternalSlots\n * @property {Map<string,Plugin>} additionalPluginPool The map for additional plugins.\n * @property {string} cwd The path to the current working directory.\n * @property {string | undefined} resolvePluginsRelativeTo An absolute path the the directory that plugins should be resolved from.\n * @property {Map<string,Rule>} builtInRules The rules that are built in to ESLint.\n * @property {Object} [resolver=ModuleResolver] The module resolver object.\n * @property {string} eslintAllPath The path to the definitions for eslint:all.\n * @property {string} eslintRecommendedPath The path to the definitions for eslint:recommended.\n */\n\n/**\n * @typedef {Object} ConfigArrayFactoryLoadingContext\n * @property {string} filePath The path to the current configuration.\n * @property {string} matchBasePath The base path to resolve relative paths in `overrides[].files`, `overrides[].excludedFiles`, and `ignorePatterns`.\n * @property {string} name The name of the current configuration.\n * @property {string} pluginBasePath The base path to resolve plugins.\n * @property {\"config\" | \"ignore\" | \"implicit-processor\"} type The type of the current configuration. This is `\"config\"` in normal. This is `\"ignore\"` if it came from `.eslintignore`. This is `\"implicit-processor\"` if it came from legacy file-extension processors.\n */\n\n/**\n * @typedef {Object} ConfigArrayFactoryLoadingContext\n * @property {string} filePath The path to the current configuration.\n * @property {string} matchBasePath The base path to resolve relative paths in `overrides[].files`, `overrides[].excludedFiles`, and `ignorePatterns`.\n * @property {string} name The name of the current configuration.\n * @property {\"config\" | \"ignore\" | \"implicit-processor\"} type The type of the current configuration. This is `\"config\"` in normal. This is `\"ignore\"` if it came from `.eslintignore`. This is `\"implicit-processor\"` if it came from legacy file-extension processors.\n */\n\n/** @type {WeakMap<ConfigArrayFactory, ConfigArrayFactoryInternalSlots>} */\nconst internalSlotsMap = new WeakMap();\n\n/**\n * Check if a given string is a file path.\n * @param {string} nameOrPath A module name or file path.\n * @returns {boolean} `true` if the `nameOrPath` is a file path.\n */\nfunction isFilePath(nameOrPath) {\n    return (\n        /^\\.{1,2}[/\\\\]/u.test(nameOrPath) ||\n        path.isAbsolute(nameOrPath)\n    );\n}\n\n/**\n * Convenience wrapper for synchronously reading file contents.\n * @param {string} filePath The filename to read.\n * @returns {string} The file contents, with the BOM removed.\n * @private\n */\nfunction readFile(filePath) {\n    return fs.readFileSync(filePath, \"utf8\").replace(/^\\ufeff/u, \"\");\n}\n\n/**\n * Loads a YAML configuration from a file.\n * @param {string} filePath The filename to load.\n * @returns {ConfigData} The configuration object from the file.\n * @throws {Error} If the file cannot be read.\n * @private\n */\nfunction loadYAMLConfigFile(filePath) {\n    debug(`Loading YAML config file: ${filePath}`);\n\n    // lazy load YAML to improve performance when not used\n    const yaml = require(\"js-yaml\");\n\n    try {\n\n        // empty YAML file can be null, so always use\n        return yaml.safeLoad(readFile(filePath)) || {};\n    } catch (e) {\n        debug(`Error reading YAML file: ${filePath}`);\n        e.message = `Cannot read config file: ${filePath}\\nError: ${e.message}`;\n        throw e;\n    }\n}\n\n/**\n * Loads a JSON configuration from a file.\n * @param {string} filePath The filename to load.\n * @returns {ConfigData} The configuration object from the file.\n * @throws {Error} If the file cannot be read.\n * @private\n */\nfunction loadJSONConfigFile(filePath) {\n    debug(`Loading JSON config file: ${filePath}`);\n\n    try {\n        return JSON.parse(stripComments(readFile(filePath)));\n    } catch (e) {\n        debug(`Error reading JSON file: ${filePath}`);\n        e.message = `Cannot read config file: ${filePath}\\nError: ${e.message}`;\n        e.messageTemplate = \"failed-to-read-json\";\n        e.messageData = {\n            path: filePath,\n            message: e.message\n        };\n        throw e;\n    }\n}\n\n/**\n * Loads a legacy (.eslintrc) configuration from a file.\n * @param {string} filePath The filename to load.\n * @returns {ConfigData} The configuration object from the file.\n * @throws {Error} If the file cannot be read.\n * @private\n */\nfunction loadLegacyConfigFile(filePath) {\n    debug(`Loading legacy config file: ${filePath}`);\n\n    // lazy load YAML to improve performance when not used\n    const yaml = require(\"js-yaml\");\n\n    try {\n        return yaml.safeLoad(stripComments(readFile(filePath))) || /* istanbul ignore next */ {};\n    } catch (e) {\n        debug(\"Error reading YAML file: %s\\n%o\", filePath, e);\n        e.message = `Cannot read config file: ${filePath}\\nError: ${e.message}`;\n        throw e;\n    }\n}\n\n/**\n * Loads a JavaScript configuration from a file.\n * @param {string} filePath The filename to load.\n * @returns {ConfigData} The configuration object from the file.\n * @throws {Error} If the file cannot be read.\n * @private\n */\nfunction loadJSConfigFile(filePath) {\n    debug(`Loading JS config file: ${filePath}`);\n    try {\n        return importFresh(filePath);\n    } catch (e) {\n        debug(`Error reading JavaScript file: ${filePath}`);\n        e.message = `Cannot read config file: ${filePath}\\nError: ${e.message}`;\n        throw e;\n    }\n}\n\n/**\n * Loads a configuration from a package.json file.\n * @param {string} filePath The filename to load.\n * @returns {ConfigData} The configuration object from the file.\n * @throws {Error} If the file cannot be read.\n * @private\n */\nfunction loadPackageJSONConfigFile(filePath) {\n    debug(`Loading package.json config file: ${filePath}`);\n    try {\n        const packageData = loadJSONConfigFile(filePath);\n\n        if (!Object.hasOwnProperty.call(packageData, \"eslintConfig\")) {\n            throw Object.assign(\n                new Error(\"package.json file doesn't have 'eslintConfig' field.\"),\n                { code: \"ESLINT_CONFIG_FIELD_NOT_FOUND\" }\n            );\n        }\n\n        return packageData.eslintConfig;\n    } catch (e) {\n        debug(`Error reading package.json file: ${filePath}`);\n        e.message = `Cannot read config file: ${filePath}\\nError: ${e.message}`;\n        throw e;\n    }\n}\n\n/**\n * Loads a `.eslintignore` from a file.\n * @param {string} filePath The filename to load.\n * @returns {string[]} The ignore patterns from the file.\n * @private\n */\nfunction loadESLintIgnoreFile(filePath) {\n    debug(`Loading .eslintignore file: ${filePath}`);\n\n    try {\n        return readFile(filePath)\n            .split(/\\r?\\n/gu)\n            .filter(line => line.trim() !== \"\" && !line.startsWith(\"#\"));\n    } catch (e) {\n        debug(`Error reading .eslintignore file: ${filePath}`);\n        e.message = `Cannot read .eslintignore file: ${filePath}\\nError: ${e.message}`;\n        throw e;\n    }\n}\n\n/**\n * Creates an error to notify about a missing config to extend from.\n * @param {string} configName The name of the missing config.\n * @param {string} importerName The name of the config that imported the missing config\n * @param {string} messageTemplate The text template to source error strings from.\n * @returns {Error} The error object to throw\n * @private\n */\nfunction configInvalidError(configName, importerName, messageTemplate) {\n    return Object.assign(\n        new Error(`Failed to load config \"${configName}\" to extend from.`),\n        {\n            messageTemplate,\n            messageData: { configName, importerName }\n        }\n    );\n}\n\n/**\n * Loads a configuration file regardless of the source. Inspects the file path\n * to determine the correctly way to load the config file.\n * @param {string} filePath The path to the configuration.\n * @returns {ConfigData|null} The configuration information.\n * @private\n */\nfunction loadConfigFile(filePath) {\n    switch (path.extname(filePath)) {\n        case \".js\":\n        case \".cjs\":\n            return loadJSConfigFile(filePath);\n\n        case \".json\":\n            if (path.basename(filePath) === \"package.json\") {\n                return loadPackageJSONConfigFile(filePath);\n            }\n            return loadJSONConfigFile(filePath);\n\n        case \".yaml\":\n        case \".yml\":\n            return loadYAMLConfigFile(filePath);\n\n        default:\n            return loadLegacyConfigFile(filePath);\n    }\n}\n\n/**\n * Write debug log.\n * @param {string} request The requested module name.\n * @param {string} relativeTo The file path to resolve the request relative to.\n * @param {string} filePath The resolved file path.\n * @returns {void}\n */\nfunction writeDebugLogForLoading(request, relativeTo, filePath) {\n    /* istanbul ignore next */\n    if (debug.enabled) {\n        let nameAndVersion = null;\n\n        try {\n            const packageJsonPath = ModuleResolver.resolve(\n                `${request}/package.json`,\n                relativeTo\n            );\n            const { version = \"unknown\" } = require(packageJsonPath);\n\n            nameAndVersion = `${request}@${version}`;\n        } catch (error) {\n            debug(\"package.json was not found:\", error.message);\n            nameAndVersion = request;\n        }\n\n        debug(\"Loaded: %s (%s)\", nameAndVersion, filePath);\n    }\n}\n\n/**\n * Create a new context with default values.\n * @param {ConfigArrayFactoryInternalSlots} slots The internal slots.\n * @param {\"config\" | \"ignore\" | \"implicit-processor\" | undefined} providedType The type of the current configuration. Default is `\"config\"`.\n * @param {string | undefined} providedName The name of the current configuration. Default is the relative path from `cwd` to `filePath`.\n * @param {string | undefined} providedFilePath The path to the current configuration. Default is empty string.\n * @param {string | undefined} providedMatchBasePath The type of the current configuration. Default is the directory of `filePath` or `cwd`.\n * @returns {ConfigArrayFactoryLoadingContext} The created context.\n */\nfunction createContext(\n    { cwd, resolvePluginsRelativeTo },\n    providedType,\n    providedName,\n    providedFilePath,\n    providedMatchBasePath\n) {\n    const filePath = providedFilePath\n        ? path.resolve(cwd, providedFilePath)\n        : \"\";\n    const matchBasePath =\n        (providedMatchBasePath && path.resolve(cwd, providedMatchBasePath)) ||\n        (filePath && path.dirname(filePath)) ||\n        cwd;\n    const name =\n        providedName ||\n        (filePath && path.relative(cwd, filePath)) ||\n        \"\";\n    const pluginBasePath =\n        resolvePluginsRelativeTo ||\n        (filePath && path.dirname(filePath)) ||\n        cwd;\n    const type = providedType || \"config\";\n\n    return { filePath, matchBasePath, name, pluginBasePath, type };\n}\n\n/**\n * Normalize a given plugin.\n * - Ensure the object to have four properties: configs, environments, processors, and rules.\n * - Ensure the object to not have other properties.\n * @param {Plugin} plugin The plugin to normalize.\n * @returns {Plugin} The normalized plugin.\n */\nfunction normalizePlugin(plugin) {\n    return {\n        configs: plugin.configs || {},\n        environments: plugin.environments || {},\n        processors: plugin.processors || {},\n        rules: plugin.rules || {}\n    };\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * The factory of `ConfigArray` objects.\n */\nclass ConfigArrayFactory {\n\n    /**\n     * Initialize this instance.\n     * @param {ConfigArrayFactoryOptions} [options] The map for additional plugins.\n     */\n    constructor({\n        additionalPluginPool = new Map(),\n        cwd = process.cwd(),\n        resolvePluginsRelativeTo,\n        builtInRules,\n        resolver = ModuleResolver,\n        eslintAllPath,\n        eslintRecommendedPath\n    } = {}) {\n        internalSlotsMap.set(this, {\n            additionalPluginPool,\n            cwd,\n            resolvePluginsRelativeTo:\n                resolvePluginsRelativeTo &&\n                path.resolve(cwd, resolvePluginsRelativeTo),\n            builtInRules,\n            resolver,\n            eslintAllPath,\n            eslintRecommendedPath\n        });\n    }\n\n    /**\n     * Create `ConfigArray` instance from a config data.\n     * @param {ConfigData|null} configData The config data to create.\n     * @param {Object} [options] The options.\n     * @param {string} [options.basePath] The base path to resolve relative paths in `overrides[].files`, `overrides[].excludedFiles`, and `ignorePatterns`.\n     * @param {string} [options.filePath] The path to this config data.\n     * @param {string} [options.name] The config name.\n     * @returns {ConfigArray} Loaded config.\n     */\n    create(configData, { basePath, filePath, name } = {}) {\n        if (!configData) {\n            return new ConfigArray();\n        }\n\n        const slots = internalSlotsMap.get(this);\n        const ctx = createContext(slots, \"config\", name, filePath, basePath);\n        const elements = this._normalizeConfigData(configData, ctx);\n\n        return new ConfigArray(...elements);\n    }\n\n    /**\n     * Load a config file.\n     * @param {string} filePath The path to a config file.\n     * @param {Object} [options] The options.\n     * @param {string} [options.basePath] The base path to resolve relative paths in `overrides[].files`, `overrides[].excludedFiles`, and `ignorePatterns`.\n     * @param {string} [options.name] The config name.\n     * @returns {ConfigArray} Loaded config.\n     */\n    loadFile(filePath, { basePath, name } = {}) {\n        const slots = internalSlotsMap.get(this);\n        const ctx = createContext(slots, \"config\", name, filePath, basePath);\n\n        return new ConfigArray(...this._loadConfigData(ctx));\n    }\n\n    /**\n     * Load the config file on a given directory if exists.\n     * @param {string} directoryPath The path to a directory.\n     * @param {Object} [options] The options.\n     * @param {string} [options.basePath] The base path to resolve relative paths in `overrides[].files`, `overrides[].excludedFiles`, and `ignorePatterns`.\n     * @param {string} [options.name] The config name.\n     * @returns {ConfigArray} Loaded config. An empty `ConfigArray` if any config doesn't exist.\n     */\n    loadInDirectory(directoryPath, { basePath, name } = {}) {\n        const slots = internalSlotsMap.get(this);\n\n        for (const filename of configFilenames) {\n            const ctx = createContext(\n                slots,\n                \"config\",\n                name,\n                path.join(directoryPath, filename),\n                basePath\n            );\n\n            if (fs.existsSync(ctx.filePath) && fs.statSync(ctx.filePath).isFile()) {\n                let configData;\n\n                try {\n                    configData = loadConfigFile(ctx.filePath);\n                } catch (error) {\n                    if (!error || error.code !== \"ESLINT_CONFIG_FIELD_NOT_FOUND\") {\n                        throw error;\n                    }\n                }\n\n                if (configData) {\n                    debug(`Config file found: ${ctx.filePath}`);\n                    return new ConfigArray(\n                        ...this._normalizeConfigData(configData, ctx)\n                    );\n                }\n            }\n        }\n\n        debug(`Config file not found on ${directoryPath}`);\n        return new ConfigArray();\n    }\n\n    /**\n     * Check if a config file on a given directory exists or not.\n     * @param {string} directoryPath The path to a directory.\n     * @returns {string | null} The path to the found config file. If not found then null.\n     */\n    static getPathToConfigFileInDirectory(directoryPath) {\n        for (const filename of configFilenames) {\n            const filePath = path.join(directoryPath, filename);\n\n            if (fs.existsSync(filePath)) {\n                if (filename === \"package.json\") {\n                    try {\n                        loadPackageJSONConfigFile(filePath);\n                        return filePath;\n                    } catch { /* ignore */ }\n                } else {\n                    return filePath;\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Load `.eslintignore` file.\n     * @param {string} filePath The path to a `.eslintignore` file to load.\n     * @returns {ConfigArray} Loaded config. An empty `ConfigArray` if any config doesn't exist.\n     */\n    loadESLintIgnore(filePath) {\n        const slots = internalSlotsMap.get(this);\n        const ctx = createContext(\n            slots,\n            \"ignore\",\n            void 0,\n            filePath,\n            slots.cwd\n        );\n        const ignorePatterns = loadESLintIgnoreFile(ctx.filePath);\n\n        return new ConfigArray(\n            ...this._normalizeESLintIgnoreData(ignorePatterns, ctx)\n        );\n    }\n\n    /**\n     * Load `.eslintignore` file in the current working directory.\n     * @returns {ConfigArray} Loaded config. An empty `ConfigArray` if any config doesn't exist.\n     */\n    loadDefaultESLintIgnore() {\n        const slots = internalSlotsMap.get(this);\n        const eslintIgnorePath = path.resolve(slots.cwd, \".eslintignore\");\n        const packageJsonPath = path.resolve(slots.cwd, \"package.json\");\n\n        if (fs.existsSync(eslintIgnorePath)) {\n            return this.loadESLintIgnore(eslintIgnorePath);\n        }\n        if (fs.existsSync(packageJsonPath)) {\n            const data = loadJSONConfigFile(packageJsonPath);\n\n            if (Object.hasOwnProperty.call(data, \"eslintIgnore\")) {\n                if (!Array.isArray(data.eslintIgnore)) {\n                    throw new Error(\"Package.json eslintIgnore property requires an array of paths\");\n                }\n                const ctx = createContext(\n                    slots,\n                    \"ignore\",\n                    \"eslintIgnore in package.json\",\n                    packageJsonPath,\n                    slots.cwd\n                );\n\n                return new ConfigArray(\n                    ...this._normalizeESLintIgnoreData(data.eslintIgnore, ctx)\n                );\n            }\n        }\n\n        return new ConfigArray();\n    }\n\n    /**\n     * Load a given config file.\n     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n     * @returns {IterableIterator<ConfigArrayElement>} Loaded config.\n     * @private\n     */\n    _loadConfigData(ctx) {\n        return this._normalizeConfigData(loadConfigFile(ctx.filePath), ctx);\n    }\n\n    /**\n     * Normalize a given `.eslintignore` data to config array elements.\n     * @param {string[]} ignorePatterns The patterns to ignore files.\n     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n     * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n     * @private\n     */\n    *_normalizeESLintIgnoreData(ignorePatterns, ctx) {\n        const elements = this._normalizeObjectConfigData(\n            { ignorePatterns },\n            ctx\n        );\n\n        // Set `ignorePattern.loose` flag for backward compatibility.\n        for (const element of elements) {\n            if (element.ignorePattern) {\n                element.ignorePattern.loose = true;\n            }\n            yield element;\n        }\n    }\n\n    /**\n     * Normalize a given config to an array.\n     * @param {ConfigData} configData The config data to normalize.\n     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n     * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n     * @private\n     */\n    _normalizeConfigData(configData, ctx) {\n        const validator = new ConfigValidator();\n\n        validator.validateConfigSchema(configData, ctx.name || ctx.filePath);\n        return this._normalizeObjectConfigData(configData, ctx);\n    }\n\n    /**\n     * Normalize a given config to an array.\n     * @param {ConfigData|OverrideConfigData} configData The config data to normalize.\n     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n     * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n     * @private\n     */\n    *_normalizeObjectConfigData(configData, ctx) {\n        const { files, excludedFiles, ...configBody } = configData;\n        const criteria = OverrideTester.create(\n            files,\n            excludedFiles,\n            ctx.matchBasePath\n        );\n        const elements = this._normalizeObjectConfigDataBody(configBody, ctx);\n\n        // Apply the criteria to every element.\n        for (const element of elements) {\n\n            /*\n             * Merge the criteria.\n             * This is for the `overrides` entries that came from the\n             * configurations of `overrides[].extends`.\n             */\n            element.criteria = OverrideTester.and(criteria, element.criteria);\n\n            /*\n             * Remove `root` property to ignore `root` settings which came from\n             * `extends` in `overrides`.\n             */\n            if (element.criteria) {\n                element.root = void 0;\n            }\n\n            yield element;\n        }\n    }\n\n    /**\n     * Normalize a given config to an array.\n     * @param {ConfigData} configData The config data to normalize.\n     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n     * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n     * @private\n     */\n    *_normalizeObjectConfigDataBody(\n        {\n            env,\n            extends: extend,\n            globals,\n            ignorePatterns,\n            noInlineConfig,\n            parser: parserName,\n            parserOptions,\n            plugins: pluginList,\n            processor,\n            reportUnusedDisableDirectives,\n            root,\n            rules,\n            settings,\n            overrides: overrideList = []\n        },\n        ctx\n    ) {\n        const extendList = Array.isArray(extend) ? extend : [extend];\n        const ignorePattern = ignorePatterns && new IgnorePattern(\n            Array.isArray(ignorePatterns) ? ignorePatterns : [ignorePatterns],\n            ctx.matchBasePath\n        );\n\n        // Flatten `extends`.\n        for (const extendName of extendList.filter(Boolean)) {\n            yield* this._loadExtends(extendName, ctx);\n        }\n\n        // Load parser & plugins.\n        const parser = parserName && this._loadParser(parserName, ctx);\n        const plugins = pluginList && this._loadPlugins(pluginList, ctx);\n\n        // Yield pseudo config data for file extension processors.\n        if (plugins) {\n            yield* this._takeFileExtensionProcessors(plugins, ctx);\n        }\n\n        // Yield the config data except `extends` and `overrides`.\n        yield {\n\n            // Debug information.\n            type: ctx.type,\n            name: ctx.name,\n            filePath: ctx.filePath,\n\n            // Config data.\n            criteria: null,\n            env,\n            globals,\n            ignorePattern,\n            noInlineConfig,\n            parser,\n            parserOptions,\n            plugins,\n            processor,\n            reportUnusedDisableDirectives,\n            root,\n            rules,\n            settings\n        };\n\n        // Flatten `overries`.\n        for (let i = 0; i < overrideList.length; ++i) {\n            yield* this._normalizeObjectConfigData(\n                overrideList[i],\n                { ...ctx, name: `${ctx.name}#overrides[${i}]` }\n            );\n        }\n    }\n\n    /**\n     * Load configs of an element in `extends`.\n     * @param {string} extendName The name of a base config.\n     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n     * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n     * @private\n     */\n    _loadExtends(extendName, ctx) {\n        debug(\"Loading {extends:%j} relative to %s\", extendName, ctx.filePath);\n        try {\n            if (extendName.startsWith(\"eslint:\")) {\n                return this._loadExtendedBuiltInConfig(extendName, ctx);\n            }\n            if (extendName.startsWith(\"plugin:\")) {\n                return this._loadExtendedPluginConfig(extendName, ctx);\n            }\n            return this._loadExtendedShareableConfig(extendName, ctx);\n        } catch (error) {\n            error.message += `\\nReferenced from: ${ctx.filePath || ctx.name}`;\n            throw error;\n        }\n    }\n\n    /**\n     * Load configs of an element in `extends`.\n     * @param {string} extendName The name of a base config.\n     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n     * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n     * @private\n     */\n    _loadExtendedBuiltInConfig(extendName, ctx) {\n        const { eslintAllPath, eslintRecommendedPath } = internalSlotsMap.get(this);\n\n        if (extendName === \"eslint:recommended\") {\n            return this._loadConfigData({\n                ...ctx,\n                filePath: eslintRecommendedPath,\n                name: `${ctx.name} » ${extendName}`\n            });\n        }\n        if (extendName === \"eslint:all\") {\n            return this._loadConfigData({\n                ...ctx,\n                filePath: eslintAllPath,\n                name: `${ctx.name} » ${extendName}`\n            });\n        }\n\n        throw configInvalidError(extendName, ctx.name, \"extend-config-missing\");\n    }\n\n    /**\n     * Load configs of an element in `extends`.\n     * @param {string} extendName The name of a base config.\n     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n     * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n     * @private\n     */\n    _loadExtendedPluginConfig(extendName, ctx) {\n        const slashIndex = extendName.lastIndexOf(\"/\");\n\n        if (slashIndex === -1) {\n            throw configInvalidError(extendName, ctx.filePath, \"plugin-invalid\");\n        }\n\n        const pluginName = extendName.slice(\"plugin:\".length, slashIndex);\n        const configName = extendName.slice(slashIndex + 1);\n\n        if (isFilePath(pluginName)) {\n            throw new Error(\"'extends' cannot use a file path for plugins.\");\n        }\n\n        const plugin = this._loadPlugin(pluginName, ctx);\n        const configData =\n            plugin.definition &&\n            plugin.definition.configs[configName];\n\n        if (configData) {\n            return this._normalizeConfigData(configData, {\n                ...ctx,\n                filePath: plugin.filePath || ctx.filePath,\n                name: `${ctx.name} » plugin:${plugin.id}/${configName}`\n            });\n        }\n\n        throw plugin.error || configInvalidError(extendName, ctx.filePath, \"extend-config-missing\");\n    }\n\n    /**\n     * Load configs of an element in `extends`.\n     * @param {string} extendName The name of a base config.\n     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n     * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n     * @private\n     */\n    _loadExtendedShareableConfig(extendName, ctx) {\n        const { cwd, resolver } = internalSlotsMap.get(this);\n        const relativeTo = ctx.filePath || path.join(cwd, \"__placeholder__.js\");\n        let request;\n\n        if (isFilePath(extendName)) {\n            request = extendName;\n        } else if (extendName.startsWith(\".\")) {\n            request = `./${extendName}`; // For backward compatibility. A ton of tests depended on this behavior.\n        } else {\n            request = naming.normalizePackageName(\n                extendName,\n                \"eslint-config\"\n            );\n        }\n\n        let filePath;\n\n        try {\n            filePath = resolver.resolve(request, relativeTo);\n        } catch (error) {\n            /* istanbul ignore else */\n            if (error && error.code === \"MODULE_NOT_FOUND\") {\n                throw configInvalidError(extendName, ctx.filePath, \"extend-config-missing\");\n            }\n            throw error;\n        }\n\n        writeDebugLogForLoading(request, relativeTo, filePath);\n        return this._loadConfigData({\n            ...ctx,\n            filePath,\n            name: `${ctx.name} » ${request}`\n        });\n    }\n\n    /**\n     * Load given plugins.\n     * @param {string[]} names The plugin names to load.\n     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n     * @returns {Record<string,DependentPlugin>} The loaded parser.\n     * @private\n     */\n    _loadPlugins(names, ctx) {\n        return names.reduce((map, name) => {\n            if (isFilePath(name)) {\n                throw new Error(\"Plugins array cannot includes file paths.\");\n            }\n            const plugin = this._loadPlugin(name, ctx);\n\n            map[plugin.id] = plugin;\n\n            return map;\n        }, {});\n    }\n\n    /**\n     * Load a given parser.\n     * @param {string} nameOrPath The package name or the path to a parser file.\n     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n     * @returns {DependentParser} The loaded parser.\n     */\n    _loadParser(nameOrPath, ctx) {\n        debug(\"Loading parser %j from %s\", nameOrPath, ctx.filePath);\n\n        const { cwd } = internalSlotsMap.get(this);\n        const relativeTo = ctx.filePath || path.join(cwd, \"__placeholder__.js\");\n\n        try {\n            const filePath = ModuleResolver.resolve(nameOrPath, relativeTo);\n\n            writeDebugLogForLoading(nameOrPath, relativeTo, filePath);\n\n            return new ConfigDependency({\n                definition: require(filePath),\n                filePath,\n                id: nameOrPath,\n                importerName: ctx.name,\n                importerPath: ctx.filePath\n            });\n        } catch (error) {\n\n            // If the parser name is \"espree\", load the espree of ESLint.\n            if (nameOrPath === \"espree\") {\n                debug(\"Fallback espree.\");\n                return new ConfigDependency({\n                    definition: require(\"espree\"),\n                    filePath: require.resolve(\"espree\"),\n                    id: nameOrPath,\n                    importerName: ctx.name,\n                    importerPath: ctx.filePath\n                });\n            }\n\n            debug(\"Failed to load parser '%s' declared in '%s'.\", nameOrPath, ctx.name);\n            error.message = `Failed to load parser '${nameOrPath}' declared in '${ctx.name}': ${error.message}`;\n\n            return new ConfigDependency({\n                error,\n                id: nameOrPath,\n                importerName: ctx.name,\n                importerPath: ctx.filePath\n            });\n        }\n    }\n\n    /**\n     * Load a given plugin.\n     * @param {string} name The plugin name to load.\n     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n     * @returns {DependentPlugin} The loaded plugin.\n     * @private\n     */\n    _loadPlugin(name, ctx) {\n        debug(\"Loading plugin %j from %s\", name, ctx.filePath);\n\n        const { additionalPluginPool } = internalSlotsMap.get(this);\n        const request = naming.normalizePackageName(name, \"eslint-plugin\");\n        const id = naming.getShorthandName(request, \"eslint-plugin\");\n        const relativeTo = path.join(ctx.pluginBasePath, \"__placeholder__.js\");\n\n        if (name.match(/\\s+/u)) {\n            const error = Object.assign(\n                new Error(`Whitespace found in plugin name '${name}'`),\n                {\n                    messageTemplate: \"whitespace-found\",\n                    messageData: { pluginName: request }\n                }\n            );\n\n            return new ConfigDependency({\n                error,\n                id,\n                importerName: ctx.name,\n                importerPath: ctx.filePath\n            });\n        }\n\n        // Check for additional pool.\n        const plugin =\n            additionalPluginPool.get(request) ||\n            additionalPluginPool.get(id);\n\n        if (plugin) {\n            return new ConfigDependency({\n                definition: normalizePlugin(plugin),\n                filePath: \"\", // It's unknown where the plugin came from.\n                id,\n                importerName: ctx.name,\n                importerPath: ctx.filePath\n            });\n        }\n\n        let filePath;\n        let error;\n\n        try {\n            filePath = ModuleResolver.resolve(request, relativeTo);\n        } catch (resolveError) {\n            error = resolveError;\n            /* istanbul ignore else */\n            if (error && error.code === \"MODULE_NOT_FOUND\") {\n                error.messageTemplate = \"plugin-missing\";\n                error.messageData = {\n                    pluginName: request,\n                    resolvePluginsRelativeTo: ctx.pluginBasePath,\n                    importerName: ctx.name\n                };\n            }\n        }\n\n        if (filePath) {\n            try {\n                writeDebugLogForLoading(request, relativeTo, filePath);\n\n                const startTime = Date.now();\n                const pluginDefinition = require(filePath);\n\n                debug(`Plugin ${filePath} loaded in: ${Date.now() - startTime}ms`);\n\n                return new ConfigDependency({\n                    definition: normalizePlugin(pluginDefinition),\n                    filePath,\n                    id,\n                    importerName: ctx.name,\n                    importerPath: ctx.filePath\n                });\n            } catch (loadError) {\n                error = loadError;\n            }\n        }\n\n        debug(\"Failed to load plugin '%s' declared in '%s'.\", name, ctx.name);\n        error.message = `Failed to load plugin '${name}' declared in '${ctx.name}': ${error.message}`;\n        return new ConfigDependency({\n            error,\n            id,\n            importerName: ctx.name,\n            importerPath: ctx.filePath\n        });\n    }\n\n    /**\n     * Take file expression processors as config array elements.\n     * @param {Record<string,DependentPlugin>} plugins The plugin definitions.\n     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n     * @returns {IterableIterator<ConfigArrayElement>} The config array elements of file expression processors.\n     * @private\n     */\n    *_takeFileExtensionProcessors(plugins, ctx) {\n        for (const pluginId of Object.keys(plugins)) {\n            const processors =\n                plugins[pluginId] &&\n                plugins[pluginId].definition &&\n                plugins[pluginId].definition.processors;\n\n            if (!processors) {\n                continue;\n            }\n\n            for (const processorId of Object.keys(processors)) {\n                if (processorId.startsWith(\".\")) {\n                    yield* this._normalizeObjectConfigData(\n                        {\n                            files: [`*${processorId}`],\n                            processor: `${pluginId}/${processorId}`\n                        },\n                        {\n                            ...ctx,\n                            type: \"implicit-processor\",\n                            name: `${ctx.name}#processors[\"${pluginId}/${processorId}\"]`\n                        }\n                    );\n                }\n            }\n        }\n    }\n}\n\nmodule.exports = { ConfigArrayFactory, createContext };\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}