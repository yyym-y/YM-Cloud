{"ast":null,"code":"/**\n * @fileoverview Rule to flag when IIFE is not wrapped in parens\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils\");\nconst eslintUtils = require(\"eslint-utils\");\n\n//----------------------------------------------------------------------\n// Helpers\n//----------------------------------------------------------------------\n\n/**\n * Check if the given node is callee of a `NewExpression` node\n * @param {ASTNode} node node to check\n * @returns {boolean} True if the node is callee of a `NewExpression` node\n * @private\n */\nfunction isCalleeOfNewExpression(node) {\n  const maybeCallee = node.parent.type === \"ChainExpression\" ? node.parent : node;\n  return maybeCallee.parent.type === \"NewExpression\" && maybeCallee.parent.callee === maybeCallee;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"require parentheses around immediate `function` invocations\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/wrap-iife\"\n    },\n    schema: [{\n      enum: [\"outside\", \"inside\", \"any\"]\n    }, {\n      type: \"object\",\n      properties: {\n        functionPrototypeMethods: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    fixable: \"code\",\n    messages: {\n      wrapInvocation: \"Wrap an immediate function invocation in parentheses.\",\n      wrapExpression: \"Wrap only the function expression in parens.\",\n      moveInvocation: \"Move the invocation into the parens that contain the function.\"\n    }\n  },\n  create(context) {\n    const style = context.options[0] || \"outside\";\n    const includeFunctionPrototypeMethods = context.options[1] && context.options[1].functionPrototypeMethods;\n    const sourceCode = context.getSourceCode();\n\n    /**\n     * Check if the node is wrapped in any (). All parens count: grouping parens and parens for constructs such as if()\n     * @param {ASTNode} node node to evaluate\n     * @returns {boolean} True if it is wrapped in any parens\n     * @private\n     */\n    function isWrappedInAnyParens(node) {\n      return astUtils.isParenthesised(sourceCode, node);\n    }\n\n    /**\n     * Check if the node is wrapped in grouping (). Parens for constructs such as if() don't count\n     * @param {ASTNode} node node to evaluate\n     * @returns {boolean} True if it is wrapped in grouping parens\n     * @private\n     */\n    function isWrappedInGroupingParens(node) {\n      return eslintUtils.isParenthesized(1, node, sourceCode);\n    }\n\n    /**\n     * Get the function node from an IIFE\n     * @param {ASTNode} node node to evaluate\n     * @returns {ASTNode} node that is the function expression of the given IIFE, or null if none exist\n     */\n    function getFunctionNodeFromIIFE(node) {\n      const callee = astUtils.skipChainExpression(node.callee);\n      if (callee.type === \"FunctionExpression\") {\n        return callee;\n      }\n      if (includeFunctionPrototypeMethods && callee.type === \"MemberExpression\" && callee.object.type === \"FunctionExpression\" && (astUtils.getStaticPropertyName(callee) === \"call\" || astUtils.getStaticPropertyName(callee) === \"apply\")) {\n        return callee.object;\n      }\n      return null;\n    }\n    return {\n      CallExpression(node) {\n        const innerNode = getFunctionNodeFromIIFE(node);\n        if (!innerNode) {\n          return;\n        }\n        const isCallExpressionWrapped = isWrappedInAnyParens(node),\n          isFunctionExpressionWrapped = isWrappedInAnyParens(innerNode);\n        if (!isCallExpressionWrapped && !isFunctionExpressionWrapped) {\n          context.report({\n            node,\n            messageId: \"wrapInvocation\",\n            fix(fixer) {\n              const nodeToSurround = style === \"inside\" ? innerNode : node;\n              return fixer.replaceText(nodeToSurround, `(${sourceCode.getText(nodeToSurround)})`);\n            }\n          });\n        } else if (style === \"inside\" && !isFunctionExpressionWrapped) {\n          context.report({\n            node,\n            messageId: \"wrapExpression\",\n            fix(fixer) {\n              // The outer call expression will always be wrapped at this point.\n\n              if (isWrappedInGroupingParens(node) && !isCalleeOfNewExpression(node)) {\n                /*\n                 * Parenthesize the function expression and remove unnecessary grouping parens around the call expression.\n                 * Replace the range between the end of the function expression and the end of the call expression.\n                 * for example, in `(function(foo) {}(bar))`, the range `(bar))` should get replaced with `)(bar)`.\n                 */\n\n                const parenAfter = sourceCode.getTokenAfter(node);\n                return fixer.replaceTextRange([innerNode.range[1], parenAfter.range[1]], `)${sourceCode.getText().slice(innerNode.range[1], parenAfter.range[0])}`);\n              }\n\n              /*\n               * Call expression is wrapped in mandatory parens such as if(), or in necessary grouping parens.\n               * These parens cannot be removed, so just parenthesize the function expression.\n               */\n\n              return fixer.replaceText(innerNode, `(${sourceCode.getText(innerNode)})`);\n            }\n          });\n        } else if (style === \"outside\" && !isCallExpressionWrapped) {\n          context.report({\n            node,\n            messageId: \"moveInvocation\",\n            fix(fixer) {\n              /*\n               * The inner function expression will always be wrapped at this point.\n               * It's only necessary to replace the range between the end of the function expression\n               * and the call expression. For example, in `(function(foo) {})(bar)`, the range `)(bar)`\n               * should get replaced with `(bar))`.\n               */\n              const parenAfter = sourceCode.getTokenAfter(innerNode);\n              return fixer.replaceTextRange([parenAfter.range[0], node.range[1]], `${sourceCode.getText().slice(parenAfter.range[1], node.range[1])})`);\n            }\n          });\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","eslintUtils","isCalleeOfNewExpression","node","maybeCallee","parent","type","callee","module","exports","meta","docs","description","category","recommended","url","schema","enum","properties","functionPrototypeMethods","default","additionalProperties","fixable","messages","wrapInvocation","wrapExpression","moveInvocation","create","context","style","options","includeFunctionPrototypeMethods","sourceCode","getSourceCode","isWrappedInAnyParens","isParenthesised","isWrappedInGroupingParens","isParenthesized","getFunctionNodeFromIIFE","skipChainExpression","object","getStaticPropertyName","CallExpression","innerNode","isCallExpressionWrapped","isFunctionExpressionWrapped","report","messageId","fix","fixer","nodeToSurround","replaceText","getText","parenAfter","getTokenAfter","replaceTextRange","range","slice"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/wrap-iife.js"],"sourcesContent":["/**\n * @fileoverview Rule to flag when IIFE is not wrapped in parens\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\nconst eslintUtils = require(\"eslint-utils\");\n\n//----------------------------------------------------------------------\n// Helpers\n//----------------------------------------------------------------------\n\n/**\n * Check if the given node is callee of a `NewExpression` node\n * @param {ASTNode} node node to check\n * @returns {boolean} True if the node is callee of a `NewExpression` node\n * @private\n */\nfunction isCalleeOfNewExpression(node) {\n    const maybeCallee = node.parent.type === \"ChainExpression\"\n        ? node.parent\n        : node;\n\n    return (\n        maybeCallee.parent.type === \"NewExpression\" &&\n        maybeCallee.parent.callee === maybeCallee\n    );\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"require parentheses around immediate `function` invocations\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/wrap-iife\"\n        },\n\n        schema: [\n            {\n                enum: [\"outside\", \"inside\", \"any\"]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    functionPrototypeMethods: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: \"code\",\n        messages: {\n            wrapInvocation: \"Wrap an immediate function invocation in parentheses.\",\n            wrapExpression: \"Wrap only the function expression in parens.\",\n            moveInvocation: \"Move the invocation into the parens that contain the function.\"\n        }\n    },\n\n    create(context) {\n\n        const style = context.options[0] || \"outside\";\n        const includeFunctionPrototypeMethods = context.options[1] && context.options[1].functionPrototypeMethods;\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Check if the node is wrapped in any (). All parens count: grouping parens and parens for constructs such as if()\n         * @param {ASTNode} node node to evaluate\n         * @returns {boolean} True if it is wrapped in any parens\n         * @private\n         */\n        function isWrappedInAnyParens(node) {\n            return astUtils.isParenthesised(sourceCode, node);\n        }\n\n        /**\n         * Check if the node is wrapped in grouping (). Parens for constructs such as if() don't count\n         * @param {ASTNode} node node to evaluate\n         * @returns {boolean} True if it is wrapped in grouping parens\n         * @private\n         */\n        function isWrappedInGroupingParens(node) {\n            return eslintUtils.isParenthesized(1, node, sourceCode);\n        }\n\n        /**\n         * Get the function node from an IIFE\n         * @param {ASTNode} node node to evaluate\n         * @returns {ASTNode} node that is the function expression of the given IIFE, or null if none exist\n         */\n        function getFunctionNodeFromIIFE(node) {\n            const callee = astUtils.skipChainExpression(node.callee);\n\n            if (callee.type === \"FunctionExpression\") {\n                return callee;\n            }\n\n            if (includeFunctionPrototypeMethods &&\n                callee.type === \"MemberExpression\" &&\n                callee.object.type === \"FunctionExpression\" &&\n                (astUtils.getStaticPropertyName(callee) === \"call\" || astUtils.getStaticPropertyName(callee) === \"apply\")\n            ) {\n                return callee.object;\n            }\n\n            return null;\n        }\n\n\n        return {\n            CallExpression(node) {\n                const innerNode = getFunctionNodeFromIIFE(node);\n\n                if (!innerNode) {\n                    return;\n                }\n\n                const isCallExpressionWrapped = isWrappedInAnyParens(node),\n                    isFunctionExpressionWrapped = isWrappedInAnyParens(innerNode);\n\n                if (!isCallExpressionWrapped && !isFunctionExpressionWrapped) {\n                    context.report({\n                        node,\n                        messageId: \"wrapInvocation\",\n                        fix(fixer) {\n                            const nodeToSurround = style === \"inside\" ? innerNode : node;\n\n                            return fixer.replaceText(nodeToSurround, `(${sourceCode.getText(nodeToSurround)})`);\n                        }\n                    });\n                } else if (style === \"inside\" && !isFunctionExpressionWrapped) {\n                    context.report({\n                        node,\n                        messageId: \"wrapExpression\",\n                        fix(fixer) {\n\n                            // The outer call expression will always be wrapped at this point.\n\n                            if (isWrappedInGroupingParens(node) && !isCalleeOfNewExpression(node)) {\n\n                                /*\n                                 * Parenthesize the function expression and remove unnecessary grouping parens around the call expression.\n                                 * Replace the range between the end of the function expression and the end of the call expression.\n                                 * for example, in `(function(foo) {}(bar))`, the range `(bar))` should get replaced with `)(bar)`.\n                                 */\n\n                                const parenAfter = sourceCode.getTokenAfter(node);\n\n                                return fixer.replaceTextRange(\n                                    [innerNode.range[1], parenAfter.range[1]],\n                                    `)${sourceCode.getText().slice(innerNode.range[1], parenAfter.range[0])}`\n                                );\n                            }\n\n                            /*\n                             * Call expression is wrapped in mandatory parens such as if(), or in necessary grouping parens.\n                             * These parens cannot be removed, so just parenthesize the function expression.\n                             */\n\n                            return fixer.replaceText(innerNode, `(${sourceCode.getText(innerNode)})`);\n                        }\n                    });\n                } else if (style === \"outside\" && !isCallExpressionWrapped) {\n                    context.report({\n                        node,\n                        messageId: \"moveInvocation\",\n                        fix(fixer) {\n\n                            /*\n                             * The inner function expression will always be wrapped at this point.\n                             * It's only necessary to replace the range between the end of the function expression\n                             * and the call expression. For example, in `(function(foo) {})(bar)`, the range `)(bar)`\n                             * should get replaced with `(bar))`.\n                             */\n                            const parenAfter = sourceCode.getTokenAfter(innerNode);\n\n                            return fixer.replaceTextRange(\n                                [parenAfter.range[0], node.range[1]],\n                                `${sourceCode.getText().slice(parenAfter.range[1], node.range[1])})`\n                            );\n                        }\n                    });\n                }\n            }\n        };\n\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}