{"ast":null,"code":"/**\n * @fileoverview Rule to flag comparisons to the value NaN\n * @author James Allardice\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Determines if the given node is a NaN `Identifier` node.\n * @param {ASTNode|null} node The node to check.\n * @returns {boolean} `true` if the node is 'NaN' identifier.\n */\nfunction isNaNIdentifier(node) {\n  return Boolean(node) && (astUtils.isSpecificId(node, \"NaN\") || astUtils.isSpecificMemberAccess(node, \"Number\", \"NaN\"));\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"require calls to `isNaN()` when checking for `NaN`\",\n      category: \"Possible Errors\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/use-isnan\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        enforceForSwitchCase: {\n          type: \"boolean\",\n          default: true\n        },\n        enforceForIndexOf: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      comparisonWithNaN: \"Use the isNaN function to compare with NaN.\",\n      switchNaN: \"'switch(NaN)' can never match a case clause. Use Number.isNaN instead of the switch.\",\n      caseNaN: \"'case NaN' can never match. Use Number.isNaN before the switch.\",\n      indexOfNaN: \"Array prototype method '{{ methodName }}' cannot find NaN.\"\n    }\n  },\n  create(context) {\n    const enforceForSwitchCase = !context.options[0] || context.options[0].enforceForSwitchCase;\n    const enforceForIndexOf = context.options[0] && context.options[0].enforceForIndexOf;\n\n    /**\n     * Checks the given `BinaryExpression` node for `foo === NaN` and other comparisons.\n     * @param {ASTNode} node The node to check.\n     * @returns {void}\n     */\n    function checkBinaryExpression(node) {\n      if (/^(?:[<>]|[!=]=)=?$/u.test(node.operator) && (isNaNIdentifier(node.left) || isNaNIdentifier(node.right))) {\n        context.report({\n          node,\n          messageId: \"comparisonWithNaN\"\n        });\n      }\n    }\n\n    /**\n     * Checks the discriminant and all case clauses of the given `SwitchStatement` node for `switch(NaN)` and `case NaN:`\n     * @param {ASTNode} node The node to check.\n     * @returns {void}\n     */\n    function checkSwitchStatement(node) {\n      if (isNaNIdentifier(node.discriminant)) {\n        context.report({\n          node,\n          messageId: \"switchNaN\"\n        });\n      }\n      for (const switchCase of node.cases) {\n        if (isNaNIdentifier(switchCase.test)) {\n          context.report({\n            node: switchCase,\n            messageId: \"caseNaN\"\n          });\n        }\n      }\n    }\n\n    /**\n     * Checks the given `CallExpression` node for `.indexOf(NaN)` and `.lastIndexOf(NaN)`.\n     * @param {ASTNode} node The node to check.\n     * @returns {void}\n     */\n    function checkCallExpression(node) {\n      const callee = astUtils.skipChainExpression(node.callee);\n      if (callee.type === \"MemberExpression\") {\n        const methodName = astUtils.getStaticPropertyName(callee);\n        if ((methodName === \"indexOf\" || methodName === \"lastIndexOf\") && node.arguments.length === 1 && isNaNIdentifier(node.arguments[0])) {\n          context.report({\n            node,\n            messageId: \"indexOfNaN\",\n            data: {\n              methodName\n            }\n          });\n        }\n      }\n    }\n    const listeners = {\n      BinaryExpression: checkBinaryExpression\n    };\n    if (enforceForSwitchCase) {\n      listeners.SwitchStatement = checkSwitchStatement;\n    }\n    if (enforceForIndexOf) {\n      listeners.CallExpression = checkCallExpression;\n    }\n    return listeners;\n  }\n};","map":{"version":3,"names":["astUtils","require","isNaNIdentifier","node","Boolean","isSpecificId","isSpecificMemberAccess","module","exports","meta","type","docs","description","category","recommended","url","schema","properties","enforceForSwitchCase","default","enforceForIndexOf","additionalProperties","messages","comparisonWithNaN","switchNaN","caseNaN","indexOfNaN","create","context","options","checkBinaryExpression","test","operator","left","right","report","messageId","checkSwitchStatement","discriminant","switchCase","cases","checkCallExpression","callee","skipChainExpression","methodName","getStaticPropertyName","arguments","length","data","listeners","BinaryExpression","SwitchStatement","CallExpression"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/use-isnan.js"],"sourcesContent":["/**\n * @fileoverview Rule to flag comparisons to the value NaN\n * @author James Allardice\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Determines if the given node is a NaN `Identifier` node.\n * @param {ASTNode|null} node The node to check.\n * @returns {boolean} `true` if the node is 'NaN' identifier.\n */\nfunction isNaNIdentifier(node) {\n    return Boolean(node) && (\n        astUtils.isSpecificId(node, \"NaN\") ||\n        astUtils.isSpecificMemberAccess(node, \"Number\", \"NaN\")\n    );\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"require calls to `isNaN()` when checking for `NaN`\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/use-isnan\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    enforceForSwitchCase: {\n                        type: \"boolean\",\n                        default: true\n                    },\n                    enforceForIndexOf: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            comparisonWithNaN: \"Use the isNaN function to compare with NaN.\",\n            switchNaN: \"'switch(NaN)' can never match a case clause. Use Number.isNaN instead of the switch.\",\n            caseNaN: \"'case NaN' can never match. Use Number.isNaN before the switch.\",\n            indexOfNaN: \"Array prototype method '{{ methodName }}' cannot find NaN.\"\n        }\n    },\n\n    create(context) {\n\n        const enforceForSwitchCase = !context.options[0] || context.options[0].enforceForSwitchCase;\n        const enforceForIndexOf = context.options[0] && context.options[0].enforceForIndexOf;\n\n        /**\n         * Checks the given `BinaryExpression` node for `foo === NaN` and other comparisons.\n         * @param {ASTNode} node The node to check.\n         * @returns {void}\n         */\n        function checkBinaryExpression(node) {\n            if (\n                /^(?:[<>]|[!=]=)=?$/u.test(node.operator) &&\n                (isNaNIdentifier(node.left) || isNaNIdentifier(node.right))\n            ) {\n                context.report({ node, messageId: \"comparisonWithNaN\" });\n            }\n        }\n\n        /**\n         * Checks the discriminant and all case clauses of the given `SwitchStatement` node for `switch(NaN)` and `case NaN:`\n         * @param {ASTNode} node The node to check.\n         * @returns {void}\n         */\n        function checkSwitchStatement(node) {\n            if (isNaNIdentifier(node.discriminant)) {\n                context.report({ node, messageId: \"switchNaN\" });\n            }\n\n            for (const switchCase of node.cases) {\n                if (isNaNIdentifier(switchCase.test)) {\n                    context.report({ node: switchCase, messageId: \"caseNaN\" });\n                }\n            }\n        }\n\n        /**\n         * Checks the given `CallExpression` node for `.indexOf(NaN)` and `.lastIndexOf(NaN)`.\n         * @param {ASTNode} node The node to check.\n         * @returns {void}\n         */\n        function checkCallExpression(node) {\n            const callee = astUtils.skipChainExpression(node.callee);\n\n            if (callee.type === \"MemberExpression\") {\n                const methodName = astUtils.getStaticPropertyName(callee);\n\n                if (\n                    (methodName === \"indexOf\" || methodName === \"lastIndexOf\") &&\n                    node.arguments.length === 1 &&\n                    isNaNIdentifier(node.arguments[0])\n                ) {\n                    context.report({ node, messageId: \"indexOfNaN\", data: { methodName } });\n                }\n            }\n        }\n\n        const listeners = {\n            BinaryExpression: checkBinaryExpression\n        };\n\n        if (enforceForSwitchCase) {\n            listeners.SwitchStatement = checkSwitchStatement;\n        }\n\n        if (enforceForIndexOf) {\n            listeners.CallExpression = checkCallExpression;\n        }\n\n        return listeners;\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}