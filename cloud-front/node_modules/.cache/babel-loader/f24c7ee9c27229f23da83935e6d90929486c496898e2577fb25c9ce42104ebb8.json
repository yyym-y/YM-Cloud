{"ast":null,"code":"/**\n * @fileoverview Rule to require function names to match the name of the variable or property to which they are assigned.\n * @author Annie Zhang, Pavel Strashkin\n */\n\n\"use strict\";\n\n//--------------------------------------------------------------------------\n// Requirements\n//--------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils\");\nconst esutils = require(\"esutils\");\n\n//--------------------------------------------------------------------------\n// Helpers\n//--------------------------------------------------------------------------\n\n/**\n * Determines if a pattern is `module.exports` or `module[\"exports\"]`\n * @param {ASTNode} pattern The left side of the AssignmentExpression\n * @returns {boolean} True if the pattern is `module.exports` or `module[\"exports\"]`\n */\nfunction isModuleExports(pattern) {\n  if (pattern.type === \"MemberExpression\" && pattern.object.type === \"Identifier\" && pattern.object.name === \"module\") {\n    // module.exports\n    if (pattern.property.type === \"Identifier\" && pattern.property.name === \"exports\") {\n      return true;\n    }\n\n    // module[\"exports\"]\n    if (pattern.property.type === \"Literal\" && pattern.property.value === \"exports\") {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Determines if a string name is a valid identifier\n * @param {string} name The string to be checked\n * @param {int} ecmaVersion The ECMAScript version if specified in the parserOptions config\n * @returns {boolean} True if the string is a valid identifier\n */\nfunction isIdentifier(name, ecmaVersion) {\n  if (ecmaVersion >= 6) {\n    return esutils.keyword.isIdentifierES6(name);\n  }\n  return esutils.keyword.isIdentifierES5(name);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst alwaysOrNever = {\n  enum: [\"always\", \"never\"]\n};\nconst optionsObject = {\n  type: \"object\",\n  properties: {\n    considerPropertyDescriptor: {\n      type: \"boolean\"\n    },\n    includeCommonJSModuleExports: {\n      type: \"boolean\"\n    }\n  },\n  additionalProperties: false\n};\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require function names to match the name of the variable or property to which they are assigned\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/func-name-matching\"\n    },\n    schema: {\n      anyOf: [{\n        type: \"array\",\n        additionalItems: false,\n        items: [alwaysOrNever, optionsObject]\n      }, {\n        type: \"array\",\n        additionalItems: false,\n        items: [optionsObject]\n      }]\n    },\n    messages: {\n      matchProperty: \"Function name `{{funcName}}` should match property name `{{name}}`.\",\n      matchVariable: \"Function name `{{funcName}}` should match variable name `{{name}}`.\",\n      notMatchProperty: \"Function name `{{funcName}}` should not match property name `{{name}}`.\",\n      notMatchVariable: \"Function name `{{funcName}}` should not match variable name `{{name}}`.\"\n    }\n  },\n  create(context) {\n    const options = (typeof context.options[0] === \"object\" ? context.options[0] : context.options[1]) || {};\n    const nameMatches = typeof context.options[0] === \"string\" ? context.options[0] : \"always\";\n    const considerPropertyDescriptor = options.considerPropertyDescriptor;\n    const includeModuleExports = options.includeCommonJSModuleExports;\n    const ecmaVersion = context.parserOptions && context.parserOptions.ecmaVersion ? context.parserOptions.ecmaVersion : 5;\n\n    /**\n     * Check whether node is a certain CallExpression.\n     * @param {string} objName object name\n     * @param {string} funcName function name\n     * @param {ASTNode} node The node to check\n     * @returns {boolean} `true` if node matches CallExpression\n     */\n    function isPropertyCall(objName, funcName, node) {\n      if (!node) {\n        return false;\n      }\n      return node.type === \"CallExpression\" && astUtils.isSpecificMemberAccess(node.callee, objName, funcName);\n    }\n\n    /**\n     * Compares identifiers based on the nameMatches option\n     * @param {string} x the first identifier\n     * @param {string} y the second identifier\n     * @returns {boolean} whether the two identifiers should warn.\n     */\n    function shouldWarn(x, y) {\n      return nameMatches === \"always\" && x !== y || nameMatches === \"never\" && x === y;\n    }\n\n    /**\n     * Reports\n     * @param {ASTNode} node The node to report\n     * @param {string} name The variable or property name\n     * @param {string} funcName The function name\n     * @param {boolean} isProp True if the reported node is a property assignment\n     * @returns {void}\n     */\n    function report(node, name, funcName, isProp) {\n      let messageId;\n      if (nameMatches === \"always\" && isProp) {\n        messageId = \"matchProperty\";\n      } else if (nameMatches === \"always\") {\n        messageId = \"matchVariable\";\n      } else if (isProp) {\n        messageId = \"notMatchProperty\";\n      } else {\n        messageId = \"notMatchVariable\";\n      }\n      context.report({\n        node,\n        messageId,\n        data: {\n          name,\n          funcName\n        }\n      });\n    }\n\n    /**\n     * Determines whether a given node is a string literal\n     * @param {ASTNode} node The node to check\n     * @returns {boolean} `true` if the node is a string literal\n     */\n    function isStringLiteral(node) {\n      return node.type === \"Literal\" && typeof node.value === \"string\";\n    }\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    return {\n      VariableDeclarator(node) {\n        if (!node.init || node.init.type !== \"FunctionExpression\" || node.id.type !== \"Identifier\") {\n          return;\n        }\n        if (node.init.id && shouldWarn(node.id.name, node.init.id.name)) {\n          report(node, node.id.name, node.init.id.name, false);\n        }\n      },\n      AssignmentExpression(node) {\n        if (node.right.type !== \"FunctionExpression\" || node.left.computed && node.left.property.type !== \"Literal\" || !includeModuleExports && isModuleExports(node.left) || node.left.type !== \"Identifier\" && node.left.type !== \"MemberExpression\") {\n          return;\n        }\n        const isProp = node.left.type === \"MemberExpression\";\n        const name = isProp ? astUtils.getStaticPropertyName(node.left) : node.left.name;\n        if (node.right.id && isIdentifier(name) && shouldWarn(name, node.right.id.name)) {\n          report(node, name, node.right.id.name, isProp);\n        }\n      },\n      Property(node) {\n        if (node.value.type !== \"FunctionExpression\" || !node.value.id || node.computed && !isStringLiteral(node.key)) {\n          return;\n        }\n        if (node.key.type === \"Identifier\") {\n          const functionName = node.value.id.name;\n          let propertyName = node.key.name;\n          if (considerPropertyDescriptor && propertyName === \"value\") {\n            if (isPropertyCall(\"Object\", \"defineProperty\", node.parent.parent) || isPropertyCall(\"Reflect\", \"defineProperty\", node.parent.parent)) {\n              const property = node.parent.parent.arguments[1];\n              if (isStringLiteral(property) && shouldWarn(property.value, functionName)) {\n                report(node, property.value, functionName, true);\n              }\n            } else if (isPropertyCall(\"Object\", \"defineProperties\", node.parent.parent.parent.parent)) {\n              propertyName = node.parent.parent.key.name;\n              if (!node.parent.parent.computed && shouldWarn(propertyName, functionName)) {\n                report(node, propertyName, functionName, true);\n              }\n            } else if (isPropertyCall(\"Object\", \"create\", node.parent.parent.parent.parent)) {\n              propertyName = node.parent.parent.key.name;\n              if (!node.parent.parent.computed && shouldWarn(propertyName, functionName)) {\n                report(node, propertyName, functionName, true);\n              }\n            } else if (shouldWarn(propertyName, functionName)) {\n              report(node, propertyName, functionName, true);\n            }\n          } else if (shouldWarn(propertyName, functionName)) {\n            report(node, propertyName, functionName, true);\n          }\n          return;\n        }\n        if (isStringLiteral(node.key) && isIdentifier(node.key.value, ecmaVersion) && shouldWarn(node.key.value, node.value.id.name)) {\n          report(node, node.key.value, node.value.id.name, true);\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","esutils","isModuleExports","pattern","type","object","name","property","value","isIdentifier","ecmaVersion","keyword","isIdentifierES6","isIdentifierES5","alwaysOrNever","enum","optionsObject","properties","considerPropertyDescriptor","includeCommonJSModuleExports","additionalProperties","module","exports","meta","docs","description","category","recommended","url","schema","anyOf","additionalItems","items","messages","matchProperty","matchVariable","notMatchProperty","notMatchVariable","create","context","options","nameMatches","includeModuleExports","parserOptions","isPropertyCall","objName","funcName","node","isSpecificMemberAccess","callee","shouldWarn","x","y","report","isProp","messageId","data","isStringLiteral","VariableDeclarator","init","id","AssignmentExpression","right","left","computed","getStaticPropertyName","Property","key","functionName","propertyName","parent","arguments"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/func-name-matching.js"],"sourcesContent":["/**\n * @fileoverview Rule to require function names to match the name of the variable or property to which they are assigned.\n * @author Annie Zhang, Pavel Strashkin\n */\n\n\"use strict\";\n\n//--------------------------------------------------------------------------\n// Requirements\n//--------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\nconst esutils = require(\"esutils\");\n\n//--------------------------------------------------------------------------\n// Helpers\n//--------------------------------------------------------------------------\n\n/**\n * Determines if a pattern is `module.exports` or `module[\"exports\"]`\n * @param {ASTNode} pattern The left side of the AssignmentExpression\n * @returns {boolean} True if the pattern is `module.exports` or `module[\"exports\"]`\n */\nfunction isModuleExports(pattern) {\n    if (pattern.type === \"MemberExpression\" && pattern.object.type === \"Identifier\" && pattern.object.name === \"module\") {\n\n        // module.exports\n        if (pattern.property.type === \"Identifier\" && pattern.property.name === \"exports\") {\n            return true;\n        }\n\n        // module[\"exports\"]\n        if (pattern.property.type === \"Literal\" && pattern.property.value === \"exports\") {\n            return true;\n        }\n    }\n    return false;\n}\n\n/**\n * Determines if a string name is a valid identifier\n * @param {string} name The string to be checked\n * @param {int} ecmaVersion The ECMAScript version if specified in the parserOptions config\n * @returns {boolean} True if the string is a valid identifier\n */\nfunction isIdentifier(name, ecmaVersion) {\n    if (ecmaVersion >= 6) {\n        return esutils.keyword.isIdentifierES6(name);\n    }\n    return esutils.keyword.isIdentifierES5(name);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst alwaysOrNever = { enum: [\"always\", \"never\"] };\nconst optionsObject = {\n    type: \"object\",\n    properties: {\n        considerPropertyDescriptor: {\n            type: \"boolean\"\n        },\n        includeCommonJSModuleExports: {\n            type: \"boolean\"\n        }\n    },\n    additionalProperties: false\n};\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require function names to match the name of the variable or property to which they are assigned\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/func-name-matching\"\n        },\n\n        schema: {\n            anyOf: [{\n                type: \"array\",\n                additionalItems: false,\n                items: [alwaysOrNever, optionsObject]\n            }, {\n                type: \"array\",\n                additionalItems: false,\n                items: [optionsObject]\n            }]\n        },\n\n        messages: {\n            matchProperty: \"Function name `{{funcName}}` should match property name `{{name}}`.\",\n            matchVariable: \"Function name `{{funcName}}` should match variable name `{{name}}`.\",\n            notMatchProperty: \"Function name `{{funcName}}` should not match property name `{{name}}`.\",\n            notMatchVariable: \"Function name `{{funcName}}` should not match variable name `{{name}}`.\"\n        }\n    },\n\n    create(context) {\n        const options = (typeof context.options[0] === \"object\" ? context.options[0] : context.options[1]) || {};\n        const nameMatches = typeof context.options[0] === \"string\" ? context.options[0] : \"always\";\n        const considerPropertyDescriptor = options.considerPropertyDescriptor;\n        const includeModuleExports = options.includeCommonJSModuleExports;\n        const ecmaVersion = context.parserOptions && context.parserOptions.ecmaVersion ? context.parserOptions.ecmaVersion : 5;\n\n        /**\n         * Check whether node is a certain CallExpression.\n         * @param {string} objName object name\n         * @param {string} funcName function name\n         * @param {ASTNode} node The node to check\n         * @returns {boolean} `true` if node matches CallExpression\n         */\n        function isPropertyCall(objName, funcName, node) {\n            if (!node) {\n                return false;\n            }\n            return node.type === \"CallExpression\" && astUtils.isSpecificMemberAccess(node.callee, objName, funcName);\n        }\n\n        /**\n         * Compares identifiers based on the nameMatches option\n         * @param {string} x the first identifier\n         * @param {string} y the second identifier\n         * @returns {boolean} whether the two identifiers should warn.\n         */\n        function shouldWarn(x, y) {\n            return (nameMatches === \"always\" && x !== y) || (nameMatches === \"never\" && x === y);\n        }\n\n        /**\n         * Reports\n         * @param {ASTNode} node The node to report\n         * @param {string} name The variable or property name\n         * @param {string} funcName The function name\n         * @param {boolean} isProp True if the reported node is a property assignment\n         * @returns {void}\n         */\n        function report(node, name, funcName, isProp) {\n            let messageId;\n\n            if (nameMatches === \"always\" && isProp) {\n                messageId = \"matchProperty\";\n            } else if (nameMatches === \"always\") {\n                messageId = \"matchVariable\";\n            } else if (isProp) {\n                messageId = \"notMatchProperty\";\n            } else {\n                messageId = \"notMatchVariable\";\n            }\n            context.report({\n                node,\n                messageId,\n                data: {\n                    name,\n                    funcName\n                }\n            });\n        }\n\n        /**\n         * Determines whether a given node is a string literal\n         * @param {ASTNode} node The node to check\n         * @returns {boolean} `true` if the node is a string literal\n         */\n        function isStringLiteral(node) {\n            return node.type === \"Literal\" && typeof node.value === \"string\";\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            VariableDeclarator(node) {\n                if (!node.init || node.init.type !== \"FunctionExpression\" || node.id.type !== \"Identifier\") {\n                    return;\n                }\n                if (node.init.id && shouldWarn(node.id.name, node.init.id.name)) {\n                    report(node, node.id.name, node.init.id.name, false);\n                }\n            },\n\n            AssignmentExpression(node) {\n                if (\n                    node.right.type !== \"FunctionExpression\" ||\n                    (node.left.computed && node.left.property.type !== \"Literal\") ||\n                    (!includeModuleExports && isModuleExports(node.left)) ||\n                    (node.left.type !== \"Identifier\" && node.left.type !== \"MemberExpression\")\n                ) {\n                    return;\n                }\n\n                const isProp = node.left.type === \"MemberExpression\";\n                const name = isProp ? astUtils.getStaticPropertyName(node.left) : node.left.name;\n\n                if (node.right.id && isIdentifier(name) && shouldWarn(name, node.right.id.name)) {\n                    report(node, name, node.right.id.name, isProp);\n                }\n            },\n\n            Property(node) {\n                if (node.value.type !== \"FunctionExpression\" || !node.value.id || node.computed && !isStringLiteral(node.key)) {\n                    return;\n                }\n\n                if (node.key.type === \"Identifier\") {\n                    const functionName = node.value.id.name;\n                    let propertyName = node.key.name;\n\n                    if (considerPropertyDescriptor && propertyName === \"value\") {\n                        if (isPropertyCall(\"Object\", \"defineProperty\", node.parent.parent) || isPropertyCall(\"Reflect\", \"defineProperty\", node.parent.parent)) {\n                            const property = node.parent.parent.arguments[1];\n\n                            if (isStringLiteral(property) && shouldWarn(property.value, functionName)) {\n                                report(node, property.value, functionName, true);\n                            }\n                        } else if (isPropertyCall(\"Object\", \"defineProperties\", node.parent.parent.parent.parent)) {\n                            propertyName = node.parent.parent.key.name;\n                            if (!node.parent.parent.computed && shouldWarn(propertyName, functionName)) {\n                                report(node, propertyName, functionName, true);\n                            }\n                        } else if (isPropertyCall(\"Object\", \"create\", node.parent.parent.parent.parent)) {\n                            propertyName = node.parent.parent.key.name;\n                            if (!node.parent.parent.computed && shouldWarn(propertyName, functionName)) {\n                                report(node, propertyName, functionName, true);\n                            }\n                        } else if (shouldWarn(propertyName, functionName)) {\n                            report(node, propertyName, functionName, true);\n                        }\n                    } else if (shouldWarn(propertyName, functionName)) {\n                        report(node, propertyName, functionName, true);\n                    }\n                    return;\n                }\n\n                if (\n                    isStringLiteral(node.key) &&\n                    isIdentifier(node.key.value, ecmaVersion) &&\n                    shouldWarn(node.key.value, node.value.id.name)\n                ) {\n                    report(node, node.key.value, node.value.id.name, true);\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}