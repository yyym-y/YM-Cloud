{"ast":null,"code":"/**\n * @fileoverview This rule should require or disallow spaces before or after unary operations.\n * @author Marcin Kumorek\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce consistent spacing before or after unary operators\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/space-unary-ops\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      type: \"object\",\n      properties: {\n        words: {\n          type: \"boolean\",\n          default: true\n        },\n        nonwords: {\n          type: \"boolean\",\n          default: false\n        },\n        overrides: {\n          type: \"object\",\n          additionalProperties: {\n            type: \"boolean\"\n          }\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unexpectedBefore: \"Unexpected space before unary operator '{{operator}}'.\",\n      unexpectedAfter: \"Unexpected space after unary operator '{{operator}}'.\",\n      unexpectedAfterWord: \"Unexpected space after unary word operator '{{word}}'.\",\n      wordOperator: \"Unary word operator '{{word}}' must be followed by whitespace.\",\n      operator: \"Unary operator '{{operator}}' must be followed by whitespace.\",\n      beforeUnaryExpressions: \"Space is required before unary expressions '{{token}}'.\"\n    }\n  },\n  create(context) {\n    const options = context.options[0] || {\n      words: true,\n      nonwords: false\n    };\n    const sourceCode = context.getSourceCode();\n\n    //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    /**\n     * Check if the node is the first \"!\" in a \"!!\" convert to Boolean expression\n     * @param {ASTnode} node AST node\n     * @returns {boolean} Whether or not the node is first \"!\" in \"!!\"\n     */\n    function isFirstBangInBangBangExpression(node) {\n      return node && node.type === \"UnaryExpression\" && node.argument.operator === \"!\" && node.argument && node.argument.type === \"UnaryExpression\" && node.argument.operator === \"!\";\n    }\n\n    /**\n     * Checks if an override exists for a given operator.\n     * @param {string} operator Operator\n     * @returns {boolean} Whether or not an override has been provided for the operator\n     */\n    function overrideExistsForOperator(operator) {\n      return options.overrides && Object.prototype.hasOwnProperty.call(options.overrides, operator);\n    }\n\n    /**\n     * Gets the value that the override was set to for this operator\n     * @param {string} operator Operator\n     * @returns {boolean} Whether or not an override enforces a space with this operator\n     */\n    function overrideEnforcesSpaces(operator) {\n      return options.overrides[operator];\n    }\n\n    /**\n     * Verify Unary Word Operator has spaces after the word operator\n     * @param {ASTnode} node AST node\n     * @param {Object} firstToken first token from the AST node\n     * @param {Object} secondToken second token from the AST node\n     * @param {string} word The word to be used for reporting\n     * @returns {void}\n     */\n    function verifyWordHasSpaces(node, firstToken, secondToken, word) {\n      if (secondToken.range[0] === firstToken.range[1]) {\n        context.report({\n          node,\n          messageId: \"wordOperator\",\n          data: {\n            word\n          },\n          fix(fixer) {\n            return fixer.insertTextAfter(firstToken, \" \");\n          }\n        });\n      }\n    }\n\n    /**\n     * Verify Unary Word Operator doesn't have spaces after the word operator\n     * @param {ASTnode} node AST node\n     * @param {Object} firstToken first token from the AST node\n     * @param {Object} secondToken second token from the AST node\n     * @param {string} word The word to be used for reporting\n     * @returns {void}\n     */\n    function verifyWordDoesntHaveSpaces(node, firstToken, secondToken, word) {\n      if (astUtils.canTokensBeAdjacent(firstToken, secondToken)) {\n        if (secondToken.range[0] > firstToken.range[1]) {\n          context.report({\n            node,\n            messageId: \"unexpectedAfterWord\",\n            data: {\n              word\n            },\n            fix(fixer) {\n              return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);\n            }\n          });\n        }\n      }\n    }\n\n    /**\n     * Check Unary Word Operators for spaces after the word operator\n     * @param {ASTnode} node AST node\n     * @param {Object} firstToken first token from the AST node\n     * @param {Object} secondToken second token from the AST node\n     * @param {string} word The word to be used for reporting\n     * @returns {void}\n     */\n    function checkUnaryWordOperatorForSpaces(node, firstToken, secondToken, word) {\n      if (overrideExistsForOperator(word)) {\n        if (overrideEnforcesSpaces(word)) {\n          verifyWordHasSpaces(node, firstToken, secondToken, word);\n        } else {\n          verifyWordDoesntHaveSpaces(node, firstToken, secondToken, word);\n        }\n      } else if (options.words) {\n        verifyWordHasSpaces(node, firstToken, secondToken, word);\n      } else {\n        verifyWordDoesntHaveSpaces(node, firstToken, secondToken, word);\n      }\n    }\n\n    /**\n     * Verifies YieldExpressions satisfy spacing requirements\n     * @param {ASTnode} node AST node\n     * @returns {void}\n     */\n    function checkForSpacesAfterYield(node) {\n      const tokens = sourceCode.getFirstTokens(node, 3),\n        word = \"yield\";\n      if (!node.argument || node.delegate) {\n        return;\n      }\n      checkUnaryWordOperatorForSpaces(node, tokens[0], tokens[1], word);\n    }\n\n    /**\n     * Verifies AwaitExpressions satisfy spacing requirements\n     * @param {ASTNode} node AwaitExpression AST node\n     * @returns {void}\n     */\n    function checkForSpacesAfterAwait(node) {\n      const tokens = sourceCode.getFirstTokens(node, 3);\n      checkUnaryWordOperatorForSpaces(node, tokens[0], tokens[1], \"await\");\n    }\n\n    /**\n     * Verifies UnaryExpression, UpdateExpression and NewExpression have spaces before or after the operator\n     * @param {ASTnode} node AST node\n     * @param {Object} firstToken First token in the expression\n     * @param {Object} secondToken Second token in the expression\n     * @returns {void}\n     */\n    function verifyNonWordsHaveSpaces(node, firstToken, secondToken) {\n      if (node.prefix) {\n        if (isFirstBangInBangBangExpression(node)) {\n          return;\n        }\n        if (firstToken.range[1] === secondToken.range[0]) {\n          context.report({\n            node,\n            messageId: \"operator\",\n            data: {\n              operator: firstToken.value\n            },\n            fix(fixer) {\n              return fixer.insertTextAfter(firstToken, \" \");\n            }\n          });\n        }\n      } else {\n        if (firstToken.range[1] === secondToken.range[0]) {\n          context.report({\n            node,\n            messageId: \"beforeUnaryExpressions\",\n            data: {\n              token: secondToken.value\n            },\n            fix(fixer) {\n              return fixer.insertTextBefore(secondToken, \" \");\n            }\n          });\n        }\n      }\n    }\n\n    /**\n     * Verifies UnaryExpression, UpdateExpression and NewExpression don't have spaces before or after the operator\n     * @param {ASTnode} node AST node\n     * @param {Object} firstToken First token in the expression\n     * @param {Object} secondToken Second token in the expression\n     * @returns {void}\n     */\n    function verifyNonWordsDontHaveSpaces(node, firstToken, secondToken) {\n      if (node.prefix) {\n        if (secondToken.range[0] > firstToken.range[1]) {\n          context.report({\n            node,\n            messageId: \"unexpectedAfter\",\n            data: {\n              operator: firstToken.value\n            },\n            fix(fixer) {\n              if (astUtils.canTokensBeAdjacent(firstToken, secondToken)) {\n                return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);\n              }\n              return null;\n            }\n          });\n        }\n      } else {\n        if (secondToken.range[0] > firstToken.range[1]) {\n          context.report({\n            node,\n            messageId: \"unexpectedBefore\",\n            data: {\n              operator: secondToken.value\n            },\n            fix(fixer) {\n              return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);\n            }\n          });\n        }\n      }\n    }\n\n    /**\n     * Verifies UnaryExpression, UpdateExpression and NewExpression satisfy spacing requirements\n     * @param {ASTnode} node AST node\n     * @returns {void}\n     */\n    function checkForSpaces(node) {\n      const tokens = node.type === \"UpdateExpression\" && !node.prefix ? sourceCode.getLastTokens(node, 2) : sourceCode.getFirstTokens(node, 2);\n      const firstToken = tokens[0];\n      const secondToken = tokens[1];\n      if ((node.type === \"NewExpression\" || node.prefix) && firstToken.type === \"Keyword\") {\n        checkUnaryWordOperatorForSpaces(node, firstToken, secondToken, firstToken.value);\n        return;\n      }\n      const operator = node.prefix ? tokens[0].value : tokens[1].value;\n      if (overrideExistsForOperator(operator)) {\n        if (overrideEnforcesSpaces(operator)) {\n          verifyNonWordsHaveSpaces(node, firstToken, secondToken);\n        } else {\n          verifyNonWordsDontHaveSpaces(node, firstToken, secondToken);\n        }\n      } else if (options.nonwords) {\n        verifyNonWordsHaveSpaces(node, firstToken, secondToken);\n      } else {\n        verifyNonWordsDontHaveSpaces(node, firstToken, secondToken);\n      }\n    }\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    return {\n      UnaryExpression: checkForSpaces,\n      UpdateExpression: checkForSpaces,\n      NewExpression: checkForSpaces,\n      YieldExpression: checkForSpacesAfterYield,\n      AwaitExpression: checkForSpacesAfterAwait\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","module","exports","meta","type","docs","description","category","recommended","url","fixable","schema","properties","words","default","nonwords","overrides","additionalProperties","messages","unexpectedBefore","unexpectedAfter","unexpectedAfterWord","wordOperator","operator","beforeUnaryExpressions","create","context","options","sourceCode","getSourceCode","isFirstBangInBangBangExpression","node","argument","overrideExistsForOperator","Object","prototype","hasOwnProperty","call","overrideEnforcesSpaces","verifyWordHasSpaces","firstToken","secondToken","word","range","report","messageId","data","fix","fixer","insertTextAfter","verifyWordDoesntHaveSpaces","canTokensBeAdjacent","removeRange","checkUnaryWordOperatorForSpaces","checkForSpacesAfterYield","tokens","getFirstTokens","delegate","checkForSpacesAfterAwait","verifyNonWordsHaveSpaces","prefix","value","token","insertTextBefore","verifyNonWordsDontHaveSpaces","checkForSpaces","getLastTokens","UnaryExpression","UpdateExpression","NewExpression","YieldExpression","AwaitExpression"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/space-unary-ops.js"],"sourcesContent":["/**\n * @fileoverview This rule should require or disallow spaces before or after unary operations.\n * @author Marcin Kumorek\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce consistent spacing before or after unary operators\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/space-unary-ops\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    words: {\n                        type: \"boolean\",\n                        default: true\n                    },\n                    nonwords: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    overrides: {\n                        type: \"object\",\n                        additionalProperties: {\n                            type: \"boolean\"\n                        }\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n        messages: {\n            unexpectedBefore: \"Unexpected space before unary operator '{{operator}}'.\",\n            unexpectedAfter: \"Unexpected space after unary operator '{{operator}}'.\",\n            unexpectedAfterWord: \"Unexpected space after unary word operator '{{word}}'.\",\n            wordOperator: \"Unary word operator '{{word}}' must be followed by whitespace.\",\n            operator: \"Unary operator '{{operator}}' must be followed by whitespace.\",\n            beforeUnaryExpressions: \"Space is required before unary expressions '{{token}}'.\"\n        }\n    },\n\n    create(context) {\n        const options = context.options[0] || { words: true, nonwords: false };\n\n        const sourceCode = context.getSourceCode();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Check if the node is the first \"!\" in a \"!!\" convert to Boolean expression\n         * @param {ASTnode} node AST node\n         * @returns {boolean} Whether or not the node is first \"!\" in \"!!\"\n         */\n        function isFirstBangInBangBangExpression(node) {\n            return node && node.type === \"UnaryExpression\" && node.argument.operator === \"!\" &&\n                node.argument && node.argument.type === \"UnaryExpression\" && node.argument.operator === \"!\";\n        }\n\n        /**\n         * Checks if an override exists for a given operator.\n         * @param {string} operator Operator\n         * @returns {boolean} Whether or not an override has been provided for the operator\n         */\n        function overrideExistsForOperator(operator) {\n            return options.overrides && Object.prototype.hasOwnProperty.call(options.overrides, operator);\n        }\n\n        /**\n         * Gets the value that the override was set to for this operator\n         * @param {string} operator Operator\n         * @returns {boolean} Whether or not an override enforces a space with this operator\n         */\n        function overrideEnforcesSpaces(operator) {\n            return options.overrides[operator];\n        }\n\n        /**\n         * Verify Unary Word Operator has spaces after the word operator\n         * @param {ASTnode} node AST node\n         * @param {Object} firstToken first token from the AST node\n         * @param {Object} secondToken second token from the AST node\n         * @param {string} word The word to be used for reporting\n         * @returns {void}\n         */\n        function verifyWordHasSpaces(node, firstToken, secondToken, word) {\n            if (secondToken.range[0] === firstToken.range[1]) {\n                context.report({\n                    node,\n                    messageId: \"wordOperator\",\n                    data: {\n                        word\n                    },\n                    fix(fixer) {\n                        return fixer.insertTextAfter(firstToken, \" \");\n                    }\n                });\n            }\n        }\n\n        /**\n         * Verify Unary Word Operator doesn't have spaces after the word operator\n         * @param {ASTnode} node AST node\n         * @param {Object} firstToken first token from the AST node\n         * @param {Object} secondToken second token from the AST node\n         * @param {string} word The word to be used for reporting\n         * @returns {void}\n         */\n        function verifyWordDoesntHaveSpaces(node, firstToken, secondToken, word) {\n            if (astUtils.canTokensBeAdjacent(firstToken, secondToken)) {\n                if (secondToken.range[0] > firstToken.range[1]) {\n                    context.report({\n                        node,\n                        messageId: \"unexpectedAfterWord\",\n                        data: {\n                            word\n                        },\n                        fix(fixer) {\n                            return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);\n                        }\n                    });\n                }\n            }\n        }\n\n        /**\n         * Check Unary Word Operators for spaces after the word operator\n         * @param {ASTnode} node AST node\n         * @param {Object} firstToken first token from the AST node\n         * @param {Object} secondToken second token from the AST node\n         * @param {string} word The word to be used for reporting\n         * @returns {void}\n         */\n        function checkUnaryWordOperatorForSpaces(node, firstToken, secondToken, word) {\n            if (overrideExistsForOperator(word)) {\n                if (overrideEnforcesSpaces(word)) {\n                    verifyWordHasSpaces(node, firstToken, secondToken, word);\n                } else {\n                    verifyWordDoesntHaveSpaces(node, firstToken, secondToken, word);\n                }\n            } else if (options.words) {\n                verifyWordHasSpaces(node, firstToken, secondToken, word);\n            } else {\n                verifyWordDoesntHaveSpaces(node, firstToken, secondToken, word);\n            }\n        }\n\n        /**\n         * Verifies YieldExpressions satisfy spacing requirements\n         * @param {ASTnode} node AST node\n         * @returns {void}\n         */\n        function checkForSpacesAfterYield(node) {\n            const tokens = sourceCode.getFirstTokens(node, 3),\n                word = \"yield\";\n\n            if (!node.argument || node.delegate) {\n                return;\n            }\n\n            checkUnaryWordOperatorForSpaces(node, tokens[0], tokens[1], word);\n        }\n\n        /**\n         * Verifies AwaitExpressions satisfy spacing requirements\n         * @param {ASTNode} node AwaitExpression AST node\n         * @returns {void}\n         */\n        function checkForSpacesAfterAwait(node) {\n            const tokens = sourceCode.getFirstTokens(node, 3);\n\n            checkUnaryWordOperatorForSpaces(node, tokens[0], tokens[1], \"await\");\n        }\n\n        /**\n         * Verifies UnaryExpression, UpdateExpression and NewExpression have spaces before or after the operator\n         * @param {ASTnode} node AST node\n         * @param {Object} firstToken First token in the expression\n         * @param {Object} secondToken Second token in the expression\n         * @returns {void}\n         */\n        function verifyNonWordsHaveSpaces(node, firstToken, secondToken) {\n            if (node.prefix) {\n                if (isFirstBangInBangBangExpression(node)) {\n                    return;\n                }\n                if (firstToken.range[1] === secondToken.range[0]) {\n                    context.report({\n                        node,\n                        messageId: \"operator\",\n                        data: {\n                            operator: firstToken.value\n                        },\n                        fix(fixer) {\n                            return fixer.insertTextAfter(firstToken, \" \");\n                        }\n                    });\n                }\n            } else {\n                if (firstToken.range[1] === secondToken.range[0]) {\n                    context.report({\n                        node,\n                        messageId: \"beforeUnaryExpressions\",\n                        data: {\n                            token: secondToken.value\n                        },\n                        fix(fixer) {\n                            return fixer.insertTextBefore(secondToken, \" \");\n                        }\n                    });\n                }\n            }\n        }\n\n        /**\n         * Verifies UnaryExpression, UpdateExpression and NewExpression don't have spaces before or after the operator\n         * @param {ASTnode} node AST node\n         * @param {Object} firstToken First token in the expression\n         * @param {Object} secondToken Second token in the expression\n         * @returns {void}\n         */\n        function verifyNonWordsDontHaveSpaces(node, firstToken, secondToken) {\n            if (node.prefix) {\n                if (secondToken.range[0] > firstToken.range[1]) {\n                    context.report({\n                        node,\n                        messageId: \"unexpectedAfter\",\n                        data: {\n                            operator: firstToken.value\n                        },\n                        fix(fixer) {\n                            if (astUtils.canTokensBeAdjacent(firstToken, secondToken)) {\n                                return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);\n                            }\n                            return null;\n                        }\n                    });\n                }\n            } else {\n                if (secondToken.range[0] > firstToken.range[1]) {\n                    context.report({\n                        node,\n                        messageId: \"unexpectedBefore\",\n                        data: {\n                            operator: secondToken.value\n                        },\n                        fix(fixer) {\n                            return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);\n                        }\n                    });\n                }\n            }\n        }\n\n        /**\n         * Verifies UnaryExpression, UpdateExpression and NewExpression satisfy spacing requirements\n         * @param {ASTnode} node AST node\n         * @returns {void}\n         */\n        function checkForSpaces(node) {\n            const tokens = node.type === \"UpdateExpression\" && !node.prefix\n                ? sourceCode.getLastTokens(node, 2)\n                : sourceCode.getFirstTokens(node, 2);\n            const firstToken = tokens[0];\n            const secondToken = tokens[1];\n\n            if ((node.type === \"NewExpression\" || node.prefix) && firstToken.type === \"Keyword\") {\n                checkUnaryWordOperatorForSpaces(node, firstToken, secondToken, firstToken.value);\n                return;\n            }\n\n            const operator = node.prefix ? tokens[0].value : tokens[1].value;\n\n            if (overrideExistsForOperator(operator)) {\n                if (overrideEnforcesSpaces(operator)) {\n                    verifyNonWordsHaveSpaces(node, firstToken, secondToken);\n                } else {\n                    verifyNonWordsDontHaveSpaces(node, firstToken, secondToken);\n                }\n            } else if (options.nonwords) {\n                verifyNonWordsHaveSpaces(node, firstToken, secondToken);\n            } else {\n                verifyNonWordsDontHaveSpaces(node, firstToken, secondToken);\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            UnaryExpression: checkForSpaces,\n            UpdateExpression: checkForSpaces,\n            NewExpression: checkForSpaces,\n            YieldExpression: checkForSpacesAfterYield,\n            AwaitExpression: checkForSpacesAfterAwait\n        };\n\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}