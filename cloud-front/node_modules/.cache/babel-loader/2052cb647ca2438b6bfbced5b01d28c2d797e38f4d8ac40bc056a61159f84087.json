{"ast":null,"code":"/**\n * @fileoverview Rule to flag unnecessary bind calls\n * @author Bence Dányi <bence@danyi.me>\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst SIDE_EFFECT_FREE_NODE_TYPES = new Set([\"Literal\", \"Identifier\", \"ThisExpression\", \"FunctionExpression\"]);\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow unnecessary calls to `.bind()`\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-extra-bind\"\n    },\n    schema: [],\n    fixable: \"code\",\n    messages: {\n      unexpected: \"The function binding is unnecessary.\"\n    }\n  },\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    let scopeInfo = null;\n\n    /**\n     * Checks if a node is free of side effects.\n     *\n     * This check is stricter than it needs to be, in order to keep the implementation simple.\n     * @param {ASTNode} node A node to check.\n     * @returns {boolean} True if the node is known to be side-effect free, false otherwise.\n     */\n    function isSideEffectFree(node) {\n      return SIDE_EFFECT_FREE_NODE_TYPES.has(node.type);\n    }\n\n    /**\n     * Reports a given function node.\n     * @param {ASTNode} node A node to report. This is a FunctionExpression or\n     *      an ArrowFunctionExpression.\n     * @returns {void}\n     */\n    function report(node) {\n      const memberNode = node.parent;\n      const callNode = memberNode.parent.type === \"ChainExpression\" ? memberNode.parent.parent : memberNode.parent;\n      context.report({\n        node: callNode,\n        messageId: \"unexpected\",\n        loc: memberNode.property.loc,\n        fix(fixer) {\n          if (!isSideEffectFree(callNode.arguments[0])) {\n            return null;\n          }\n\n          /*\n           * The list of the first/last token pair of a removal range.\n           * This is two parts because closing parentheses may exist between the method name and arguments.\n           * E.g. `(function(){}.bind ) (obj)`\n           *                    ^^^^^   ^^^^^ < removal ranges\n           * E.g. `(function(){}?.['bind'] ) ?.(obj)`\n           *                    ^^^^^^^^^^   ^^^^^^^ < removal ranges\n           */\n          const tokenPairs = [[\n          // `.`, `?.`, or `[` token.\n          sourceCode.getTokenAfter(memberNode.object, astUtils.isNotClosingParenToken),\n          // property name or `]` token.\n          sourceCode.getLastToken(memberNode)], [\n          // `?.` or `(` token of arguments.\n          sourceCode.getTokenAfter(memberNode, astUtils.isNotClosingParenToken),\n          // `)` token of arguments.\n          sourceCode.getLastToken(callNode)]];\n          const firstTokenToRemove = tokenPairs[0][0];\n          const lastTokenToRemove = tokenPairs[1][1];\n          if (sourceCode.commentsExistBetween(firstTokenToRemove, lastTokenToRemove)) {\n            return null;\n          }\n          return tokenPairs.map(([start, end]) => fixer.removeRange([start.range[0], end.range[1]]));\n        }\n      });\n    }\n\n    /**\n     * Checks whether or not a given function node is the callee of `.bind()`\n     * method.\n     *\n     * e.g. `(function() {}.bind(foo))`\n     * @param {ASTNode} node A node to report. This is a FunctionExpression or\n     *      an ArrowFunctionExpression.\n     * @returns {boolean} `true` if the node is the callee of `.bind()` method.\n     */\n    function isCalleeOfBindMethod(node) {\n      if (!astUtils.isSpecificMemberAccess(node.parent, null, \"bind\")) {\n        return false;\n      }\n\n      // The node of `*.bind` member access.\n      const bindNode = node.parent.parent.type === \"ChainExpression\" ? node.parent.parent : node.parent;\n      return bindNode.parent.type === \"CallExpression\" && bindNode.parent.callee === bindNode && bindNode.parent.arguments.length === 1 && bindNode.parent.arguments[0].type !== \"SpreadElement\";\n    }\n\n    /**\n     * Adds a scope information object to the stack.\n     * @param {ASTNode} node A node to add. This node is a FunctionExpression\n     *      or a FunctionDeclaration node.\n     * @returns {void}\n     */\n    function enterFunction(node) {\n      scopeInfo = {\n        isBound: isCalleeOfBindMethod(node),\n        thisFound: false,\n        upper: scopeInfo\n      };\n    }\n\n    /**\n     * Removes the scope information object from the top of the stack.\n     * At the same time, this reports the function node if the function has\n     * `.bind()` and the `this` keywords found.\n     * @param {ASTNode} node A node to remove. This node is a\n     *      FunctionExpression or a FunctionDeclaration node.\n     * @returns {void}\n     */\n    function exitFunction(node) {\n      if (scopeInfo.isBound && !scopeInfo.thisFound) {\n        report(node);\n      }\n      scopeInfo = scopeInfo.upper;\n    }\n\n    /**\n     * Reports a given arrow function if the function is callee of `.bind()`\n     * method.\n     * @param {ASTNode} node A node to report. This node is an\n     *      ArrowFunctionExpression.\n     * @returns {void}\n     */\n    function exitArrowFunction(node) {\n      if (isCalleeOfBindMethod(node)) {\n        report(node);\n      }\n    }\n\n    /**\n     * Set the mark as the `this` keyword was found in this scope.\n     * @returns {void}\n     */\n    function markAsThisFound() {\n      if (scopeInfo) {\n        scopeInfo.thisFound = true;\n      }\n    }\n    return {\n      \"ArrowFunctionExpression:exit\": exitArrowFunction,\n      FunctionDeclaration: enterFunction,\n      \"FunctionDeclaration:exit\": exitFunction,\n      FunctionExpression: enterFunction,\n      \"FunctionExpression:exit\": exitFunction,\n      ThisExpression: markAsThisFound\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","SIDE_EFFECT_FREE_NODE_TYPES","Set","module","exports","meta","type","docs","description","category","recommended","url","schema","fixable","messages","unexpected","create","context","sourceCode","getSourceCode","scopeInfo","isSideEffectFree","node","has","report","memberNode","parent","callNode","messageId","loc","property","fix","fixer","arguments","tokenPairs","getTokenAfter","object","isNotClosingParenToken","getLastToken","firstTokenToRemove","lastTokenToRemove","commentsExistBetween","map","start","end","removeRange","range","isCalleeOfBindMethod","isSpecificMemberAccess","bindNode","callee","length","enterFunction","isBound","thisFound","upper","exitFunction","exitArrowFunction","markAsThisFound","FunctionDeclaration","FunctionExpression","ThisExpression"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/no-extra-bind.js"],"sourcesContent":["/**\n * @fileoverview Rule to flag unnecessary bind calls\n * @author Bence Dányi <bence@danyi.me>\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst SIDE_EFFECT_FREE_NODE_TYPES = new Set([\"Literal\", \"Identifier\", \"ThisExpression\", \"FunctionExpression\"]);\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow unnecessary calls to `.bind()`\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-extra-bind\"\n        },\n\n        schema: [],\n        fixable: \"code\",\n\n        messages: {\n            unexpected: \"The function binding is unnecessary.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        let scopeInfo = null;\n\n        /**\n         * Checks if a node is free of side effects.\n         *\n         * This check is stricter than it needs to be, in order to keep the implementation simple.\n         * @param {ASTNode} node A node to check.\n         * @returns {boolean} True if the node is known to be side-effect free, false otherwise.\n         */\n        function isSideEffectFree(node) {\n            return SIDE_EFFECT_FREE_NODE_TYPES.has(node.type);\n        }\n\n        /**\n         * Reports a given function node.\n         * @param {ASTNode} node A node to report. This is a FunctionExpression or\n         *      an ArrowFunctionExpression.\n         * @returns {void}\n         */\n        function report(node) {\n            const memberNode = node.parent;\n            const callNode = memberNode.parent.type === \"ChainExpression\"\n                ? memberNode.parent.parent\n                : memberNode.parent;\n\n            context.report({\n                node: callNode,\n                messageId: \"unexpected\",\n                loc: memberNode.property.loc,\n\n                fix(fixer) {\n                    if (!isSideEffectFree(callNode.arguments[0])) {\n                        return null;\n                    }\n\n                    /*\n                     * The list of the first/last token pair of a removal range.\n                     * This is two parts because closing parentheses may exist between the method name and arguments.\n                     * E.g. `(function(){}.bind ) (obj)`\n                     *                    ^^^^^   ^^^^^ < removal ranges\n                     * E.g. `(function(){}?.['bind'] ) ?.(obj)`\n                     *                    ^^^^^^^^^^   ^^^^^^^ < removal ranges\n                     */\n                    const tokenPairs = [\n                        [\n\n                            // `.`, `?.`, or `[` token.\n                            sourceCode.getTokenAfter(\n                                memberNode.object,\n                                astUtils.isNotClosingParenToken\n                            ),\n\n                            // property name or `]` token.\n                            sourceCode.getLastToken(memberNode)\n                        ],\n                        [\n\n                            // `?.` or `(` token of arguments.\n                            sourceCode.getTokenAfter(\n                                memberNode,\n                                astUtils.isNotClosingParenToken\n                            ),\n\n                            // `)` token of arguments.\n                            sourceCode.getLastToken(callNode)\n                        ]\n                    ];\n                    const firstTokenToRemove = tokenPairs[0][0];\n                    const lastTokenToRemove = tokenPairs[1][1];\n\n                    if (sourceCode.commentsExistBetween(firstTokenToRemove, lastTokenToRemove)) {\n                        return null;\n                    }\n\n                    return tokenPairs.map(([start, end]) =>\n                        fixer.removeRange([start.range[0], end.range[1]]));\n                }\n            });\n        }\n\n        /**\n         * Checks whether or not a given function node is the callee of `.bind()`\n         * method.\n         *\n         * e.g. `(function() {}.bind(foo))`\n         * @param {ASTNode} node A node to report. This is a FunctionExpression or\n         *      an ArrowFunctionExpression.\n         * @returns {boolean} `true` if the node is the callee of `.bind()` method.\n         */\n        function isCalleeOfBindMethod(node) {\n            if (!astUtils.isSpecificMemberAccess(node.parent, null, \"bind\")) {\n                return false;\n            }\n\n            // The node of `*.bind` member access.\n            const bindNode = node.parent.parent.type === \"ChainExpression\"\n                ? node.parent.parent\n                : node.parent;\n\n            return (\n                bindNode.parent.type === \"CallExpression\" &&\n                bindNode.parent.callee === bindNode &&\n                bindNode.parent.arguments.length === 1 &&\n                bindNode.parent.arguments[0].type !== \"SpreadElement\"\n            );\n        }\n\n        /**\n         * Adds a scope information object to the stack.\n         * @param {ASTNode} node A node to add. This node is a FunctionExpression\n         *      or a FunctionDeclaration node.\n         * @returns {void}\n         */\n        function enterFunction(node) {\n            scopeInfo = {\n                isBound: isCalleeOfBindMethod(node),\n                thisFound: false,\n                upper: scopeInfo\n            };\n        }\n\n        /**\n         * Removes the scope information object from the top of the stack.\n         * At the same time, this reports the function node if the function has\n         * `.bind()` and the `this` keywords found.\n         * @param {ASTNode} node A node to remove. This node is a\n         *      FunctionExpression or a FunctionDeclaration node.\n         * @returns {void}\n         */\n        function exitFunction(node) {\n            if (scopeInfo.isBound && !scopeInfo.thisFound) {\n                report(node);\n            }\n\n            scopeInfo = scopeInfo.upper;\n        }\n\n        /**\n         * Reports a given arrow function if the function is callee of `.bind()`\n         * method.\n         * @param {ASTNode} node A node to report. This node is an\n         *      ArrowFunctionExpression.\n         * @returns {void}\n         */\n        function exitArrowFunction(node) {\n            if (isCalleeOfBindMethod(node)) {\n                report(node);\n            }\n        }\n\n        /**\n         * Set the mark as the `this` keyword was found in this scope.\n         * @returns {void}\n         */\n        function markAsThisFound() {\n            if (scopeInfo) {\n                scopeInfo.thisFound = true;\n            }\n        }\n\n        return {\n            \"ArrowFunctionExpression:exit\": exitArrowFunction,\n            FunctionDeclaration: enterFunction,\n            \"FunctionDeclaration:exit\": exitFunction,\n            FunctionExpression: enterFunction,\n            \"FunctionExpression:exit\": exitFunction,\n            ThisExpression: markAsThisFound\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}