{"ast":null,"code":"/**\n * @fileoverview Rule to define spacing before/after arrow function's arrow.\n * @author Jxck\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce consistent spacing before and after the arrow in arrow functions\",\n      category: \"ECMAScript 6\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/arrow-spacing\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      type: \"object\",\n      properties: {\n        before: {\n          type: \"boolean\",\n          default: true\n        },\n        after: {\n          type: \"boolean\",\n          default: true\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      expectedBefore: \"Missing space before =>.\",\n      unexpectedBefore: \"Unexpected space before =>.\",\n      expectedAfter: \"Missing space after =>.\",\n      unexpectedAfter: \"Unexpected space after =>.\"\n    }\n  },\n  create(context) {\n    // merge rules with default\n    const rule = Object.assign({}, context.options[0]);\n    rule.before = rule.before !== false;\n    rule.after = rule.after !== false;\n    const sourceCode = context.getSourceCode();\n\n    /**\n     * Get tokens of arrow(`=>`) and before/after arrow.\n     * @param {ASTNode} node The arrow function node.\n     * @returns {Object} Tokens of arrow and before/after arrow.\n     */\n    function getTokens(node) {\n      const arrow = sourceCode.getTokenBefore(node.body, astUtils.isArrowToken);\n      return {\n        before: sourceCode.getTokenBefore(arrow),\n        arrow,\n        after: sourceCode.getTokenAfter(arrow)\n      };\n    }\n\n    /**\n     * Count spaces before/after arrow(`=>`) token.\n     * @param {Object} tokens Tokens before/after arrow.\n     * @returns {Object} count of space before/after arrow.\n     */\n    function countSpaces(tokens) {\n      const before = tokens.arrow.range[0] - tokens.before.range[1];\n      const after = tokens.after.range[0] - tokens.arrow.range[1];\n      return {\n        before,\n        after\n      };\n    }\n\n    /**\n     * Determines whether space(s) before after arrow(`=>`) is satisfy rule.\n     * if before/after value is `true`, there should be space(s).\n     * if before/after value is `false`, there should be no space.\n     * @param {ASTNode} node The arrow function node.\n     * @returns {void}\n     */\n    function spaces(node) {\n      const tokens = getTokens(node);\n      const countSpace = countSpaces(tokens);\n      if (rule.before) {\n        // should be space(s) before arrow\n        if (countSpace.before === 0) {\n          context.report({\n            node: tokens.before,\n            messageId: \"expectedBefore\",\n            fix(fixer) {\n              return fixer.insertTextBefore(tokens.arrow, \" \");\n            }\n          });\n        }\n      } else {\n        // should be no space before arrow\n        if (countSpace.before > 0) {\n          context.report({\n            node: tokens.before,\n            messageId: \"unexpectedBefore\",\n            fix(fixer) {\n              return fixer.removeRange([tokens.before.range[1], tokens.arrow.range[0]]);\n            }\n          });\n        }\n      }\n      if (rule.after) {\n        // should be space(s) after arrow\n        if (countSpace.after === 0) {\n          context.report({\n            node: tokens.after,\n            messageId: \"expectedAfter\",\n            fix(fixer) {\n              return fixer.insertTextAfter(tokens.arrow, \" \");\n            }\n          });\n        }\n      } else {\n        // should be no space after arrow\n        if (countSpace.after > 0) {\n          context.report({\n            node: tokens.after,\n            messageId: \"unexpectedAfter\",\n            fix(fixer) {\n              return fixer.removeRange([tokens.arrow.range[1], tokens.after.range[0]]);\n            }\n          });\n        }\n      }\n    }\n    return {\n      ArrowFunctionExpression: spaces\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","module","exports","meta","type","docs","description","category","recommended","url","fixable","schema","properties","before","default","after","additionalProperties","messages","expectedBefore","unexpectedBefore","expectedAfter","unexpectedAfter","create","context","rule","Object","assign","options","sourceCode","getSourceCode","getTokens","node","arrow","getTokenBefore","body","isArrowToken","getTokenAfter","countSpaces","tokens","range","spaces","countSpace","report","messageId","fix","fixer","insertTextBefore","removeRange","insertTextAfter","ArrowFunctionExpression"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/arrow-spacing.js"],"sourcesContent":["/**\n * @fileoverview Rule to define spacing before/after arrow function's arrow.\n * @author Jxck\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce consistent spacing before and after the arrow in arrow functions\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/arrow-spacing\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    before: {\n                        type: \"boolean\",\n                        default: true\n                    },\n                    after: {\n                        type: \"boolean\",\n                        default: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            expectedBefore: \"Missing space before =>.\",\n            unexpectedBefore: \"Unexpected space before =>.\",\n\n            expectedAfter: \"Missing space after =>.\",\n            unexpectedAfter: \"Unexpected space after =>.\"\n        }\n    },\n\n    create(context) {\n\n        // merge rules with default\n        const rule = Object.assign({}, context.options[0]);\n\n        rule.before = rule.before !== false;\n        rule.after = rule.after !== false;\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Get tokens of arrow(`=>`) and before/after arrow.\n         * @param {ASTNode} node The arrow function node.\n         * @returns {Object} Tokens of arrow and before/after arrow.\n         */\n        function getTokens(node) {\n            const arrow = sourceCode.getTokenBefore(node.body, astUtils.isArrowToken);\n\n            return {\n                before: sourceCode.getTokenBefore(arrow),\n                arrow,\n                after: sourceCode.getTokenAfter(arrow)\n            };\n        }\n\n        /**\n         * Count spaces before/after arrow(`=>`) token.\n         * @param {Object} tokens Tokens before/after arrow.\n         * @returns {Object} count of space before/after arrow.\n         */\n        function countSpaces(tokens) {\n            const before = tokens.arrow.range[0] - tokens.before.range[1];\n            const after = tokens.after.range[0] - tokens.arrow.range[1];\n\n            return { before, after };\n        }\n\n        /**\n         * Determines whether space(s) before after arrow(`=>`) is satisfy rule.\n         * if before/after value is `true`, there should be space(s).\n         * if before/after value is `false`, there should be no space.\n         * @param {ASTNode} node The arrow function node.\n         * @returns {void}\n         */\n        function spaces(node) {\n            const tokens = getTokens(node);\n            const countSpace = countSpaces(tokens);\n\n            if (rule.before) {\n\n                // should be space(s) before arrow\n                if (countSpace.before === 0) {\n                    context.report({\n                        node: tokens.before,\n                        messageId: \"expectedBefore\",\n                        fix(fixer) {\n                            return fixer.insertTextBefore(tokens.arrow, \" \");\n                        }\n                    });\n                }\n            } else {\n\n                // should be no space before arrow\n                if (countSpace.before > 0) {\n                    context.report({\n                        node: tokens.before,\n                        messageId: \"unexpectedBefore\",\n                        fix(fixer) {\n                            return fixer.removeRange([tokens.before.range[1], tokens.arrow.range[0]]);\n                        }\n                    });\n                }\n            }\n\n            if (rule.after) {\n\n                // should be space(s) after arrow\n                if (countSpace.after === 0) {\n                    context.report({\n                        node: tokens.after,\n                        messageId: \"expectedAfter\",\n                        fix(fixer) {\n                            return fixer.insertTextAfter(tokens.arrow, \" \");\n                        }\n                    });\n                }\n            } else {\n\n                // should be no space after arrow\n                if (countSpace.after > 0) {\n                    context.report({\n                        node: tokens.after,\n                        messageId: \"unexpectedAfter\",\n                        fix(fixer) {\n                            return fixer.removeRange([tokens.arrow.range[1], tokens.after.range[0]]);\n                        }\n                    });\n                }\n            }\n        }\n\n        return {\n            ArrowFunctionExpression: spaces\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}