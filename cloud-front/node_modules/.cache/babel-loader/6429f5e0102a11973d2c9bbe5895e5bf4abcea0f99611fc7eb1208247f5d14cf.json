{"ast":null,"code":"/**\n * @fileoverview enforce or disallow capitalization of the first letter of a comment\n * @author Kevin Partington\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst LETTER_PATTERN = require(\"./utils/patterns/letters\");\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst DEFAULT_IGNORE_PATTERN = astUtils.COMMENTS_IGNORE_PATTERN,\n  WHITESPACE = /\\s/gu,\n  MAYBE_URL = /^\\s*[^:/?#\\s]+:\\/\\/[^?#]/u; // TODO: Combine w/ max-len pattern?\n\n/*\n * Base schema body for defining the basic capitalization rule, ignorePattern,\n * and ignoreInlineComments values.\n * This can be used in a few different ways in the actual schema.\n */\nconst SCHEMA_BODY = {\n  type: \"object\",\n  properties: {\n    ignorePattern: {\n      type: \"string\"\n    },\n    ignoreInlineComments: {\n      type: \"boolean\"\n    },\n    ignoreConsecutiveComments: {\n      type: \"boolean\"\n    }\n  },\n  additionalProperties: false\n};\nconst DEFAULTS = {\n  ignorePattern: \"\",\n  ignoreInlineComments: false,\n  ignoreConsecutiveComments: false\n};\n\n/**\n * Get normalized options for either block or line comments from the given\n * user-provided options.\n * - If the user-provided options is just a string, returns a normalized\n *   set of options using default values for all other options.\n * - If the user-provided options is an object, then a normalized option\n *   set is returned. Options specified in overrides will take priority\n *   over options specified in the main options object, which will in\n *   turn take priority over the rule's defaults.\n * @param {Object|string} rawOptions The user-provided options.\n * @param {string} which Either \"line\" or \"block\".\n * @returns {Object} The normalized options.\n */\nfunction getNormalizedOptions(rawOptions, which) {\n  return Object.assign({}, DEFAULTS, rawOptions[which] || rawOptions);\n}\n\n/**\n * Get normalized options for block and line comments.\n * @param {Object|string} rawOptions The user-provided options.\n * @returns {Object} An object with \"Line\" and \"Block\" keys and corresponding\n * normalized options objects.\n */\nfunction getAllNormalizedOptions(rawOptions = {}) {\n  return {\n    Line: getNormalizedOptions(rawOptions, \"line\"),\n    Block: getNormalizedOptions(rawOptions, \"block\")\n  };\n}\n\n/**\n * Creates a regular expression for each ignorePattern defined in the rule\n * options.\n *\n * This is done in order to avoid invoking the RegExp constructor repeatedly.\n * @param {Object} normalizedOptions The normalized rule options.\n * @returns {void}\n */\nfunction createRegExpForIgnorePatterns(normalizedOptions) {\n  Object.keys(normalizedOptions).forEach(key => {\n    const ignorePatternStr = normalizedOptions[key].ignorePattern;\n    if (ignorePatternStr) {\n      const regExp = RegExp(`^\\\\s*(?:${ignorePatternStr})`, \"u\");\n      normalizedOptions[key].ignorePatternRegExp = regExp;\n    }\n  });\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"enforce or disallow capitalization of the first letter of a comment\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/capitalized-comments\"\n    },\n    fixable: \"code\",\n    schema: [{\n      enum: [\"always\", \"never\"]\n    }, {\n      oneOf: [SCHEMA_BODY, {\n        type: \"object\",\n        properties: {\n          line: SCHEMA_BODY,\n          block: SCHEMA_BODY\n        },\n        additionalProperties: false\n      }]\n    }],\n    messages: {\n      unexpectedLowercaseComment: \"Comments should not begin with a lowercase character.\",\n      unexpectedUppercaseComment: \"Comments should not begin with an uppercase character.\"\n    }\n  },\n  create(context) {\n    const capitalize = context.options[0] || \"always\",\n      normalizedOptions = getAllNormalizedOptions(context.options[1]),\n      sourceCode = context.getSourceCode();\n    createRegExpForIgnorePatterns(normalizedOptions);\n\n    //----------------------------------------------------------------------\n    // Helpers\n    //----------------------------------------------------------------------\n\n    /**\n     * Checks whether a comment is an inline comment.\n     *\n     * For the purpose of this rule, a comment is inline if:\n     * 1. The comment is preceded by a token on the same line; and\n     * 2. The command is followed by a token on the same line.\n     *\n     * Note that the comment itself need not be single-line!\n     *\n     * Also, it follows from this definition that only block comments can\n     * be considered as possibly inline. This is because line comments\n     * would consume any following tokens on the same line as the comment.\n     * @param {ASTNode} comment The comment node to check.\n     * @returns {boolean} True if the comment is an inline comment, false\n     * otherwise.\n     */\n    function isInlineComment(comment) {\n      const previousToken = sourceCode.getTokenBefore(comment, {\n          includeComments: true\n        }),\n        nextToken = sourceCode.getTokenAfter(comment, {\n          includeComments: true\n        });\n      return Boolean(previousToken && nextToken && comment.loc.start.line === previousToken.loc.end.line && comment.loc.end.line === nextToken.loc.start.line);\n    }\n\n    /**\n     * Determine if a comment follows another comment.\n     * @param {ASTNode} comment The comment to check.\n     * @returns {boolean} True if the comment follows a valid comment.\n     */\n    function isConsecutiveComment(comment) {\n      const previousTokenOrComment = sourceCode.getTokenBefore(comment, {\n        includeComments: true\n      });\n      return Boolean(previousTokenOrComment && [\"Block\", \"Line\"].indexOf(previousTokenOrComment.type) !== -1);\n    }\n\n    /**\n     * Check a comment to determine if it is valid for this rule.\n     * @param {ASTNode} comment The comment node to process.\n     * @param {Object} options The options for checking this comment.\n     * @returns {boolean} True if the comment is valid, false otherwise.\n     */\n    function isCommentValid(comment, options) {\n      // 1. Check for default ignore pattern.\n      if (DEFAULT_IGNORE_PATTERN.test(comment.value)) {\n        return true;\n      }\n\n      // 2. Check for custom ignore pattern.\n      const commentWithoutAsterisks = comment.value.replace(/\\*/gu, \"\");\n      if (options.ignorePatternRegExp && options.ignorePatternRegExp.test(commentWithoutAsterisks)) {\n        return true;\n      }\n\n      // 3. Check for inline comments.\n      if (options.ignoreInlineComments && isInlineComment(comment)) {\n        return true;\n      }\n\n      // 4. Is this a consecutive comment (and are we tolerating those)?\n      if (options.ignoreConsecutiveComments && isConsecutiveComment(comment)) {\n        return true;\n      }\n\n      // 5. Does the comment start with a possible URL?\n      if (MAYBE_URL.test(commentWithoutAsterisks)) {\n        return true;\n      }\n\n      // 6. Is the initial word character a letter?\n      const commentWordCharsOnly = commentWithoutAsterisks.replace(WHITESPACE, \"\");\n      if (commentWordCharsOnly.length === 0) {\n        return true;\n      }\n      const firstWordChar = commentWordCharsOnly[0];\n      if (!LETTER_PATTERN.test(firstWordChar)) {\n        return true;\n      }\n\n      // 7. Check the case of the initial word character.\n      const isUppercase = firstWordChar !== firstWordChar.toLocaleLowerCase(),\n        isLowercase = firstWordChar !== firstWordChar.toLocaleUpperCase();\n      if (capitalize === \"always\" && isLowercase) {\n        return false;\n      }\n      if (capitalize === \"never\" && isUppercase) {\n        return false;\n      }\n      return true;\n    }\n\n    /**\n     * Process a comment to determine if it needs to be reported.\n     * @param {ASTNode} comment The comment node to process.\n     * @returns {void}\n     */\n    function processComment(comment) {\n      const options = normalizedOptions[comment.type],\n        commentValid = isCommentValid(comment, options);\n      if (!commentValid) {\n        const messageId = capitalize === \"always\" ? \"unexpectedLowercaseComment\" : \"unexpectedUppercaseComment\";\n        context.report({\n          node: null,\n          // Intentionally using loc instead\n          loc: comment.loc,\n          messageId,\n          fix(fixer) {\n            const match = comment.value.match(LETTER_PATTERN);\n            return fixer.replaceTextRange(\n            // Offset match.index by 2 to account for the first 2 characters that start the comment (// or /*)\n            [comment.range[0] + match.index + 2, comment.range[0] + match.index + 3], capitalize === \"always\" ? match[0].toLocaleUpperCase() : match[0].toLocaleLowerCase());\n          }\n        });\n      }\n    }\n\n    //----------------------------------------------------------------------\n    // Public\n    //----------------------------------------------------------------------\n\n    return {\n      Program() {\n        const comments = sourceCode.getAllComments();\n        comments.filter(token => token.type !== \"Shebang\").forEach(processComment);\n      }\n    };\n  }\n};","map":{"version":3,"names":["LETTER_PATTERN","require","astUtils","DEFAULT_IGNORE_PATTERN","COMMENTS_IGNORE_PATTERN","WHITESPACE","MAYBE_URL","SCHEMA_BODY","type","properties","ignorePattern","ignoreInlineComments","ignoreConsecutiveComments","additionalProperties","DEFAULTS","getNormalizedOptions","rawOptions","which","Object","assign","getAllNormalizedOptions","Line","Block","createRegExpForIgnorePatterns","normalizedOptions","keys","forEach","key","ignorePatternStr","regExp","RegExp","ignorePatternRegExp","module","exports","meta","docs","description","category","recommended","url","fixable","schema","enum","oneOf","line","block","messages","unexpectedLowercaseComment","unexpectedUppercaseComment","create","context","capitalize","options","sourceCode","getSourceCode","isInlineComment","comment","previousToken","getTokenBefore","includeComments","nextToken","getTokenAfter","Boolean","loc","start","end","isConsecutiveComment","previousTokenOrComment","indexOf","isCommentValid","test","value","commentWithoutAsterisks","replace","commentWordCharsOnly","length","firstWordChar","isUppercase","toLocaleLowerCase","isLowercase","toLocaleUpperCase","processComment","commentValid","messageId","report","node","fix","fixer","match","replaceTextRange","range","index","Program","comments","getAllComments","filter","token"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/capitalized-comments.js"],"sourcesContent":["/**\n * @fileoverview enforce or disallow capitalization of the first letter of a comment\n * @author Kevin Partington\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst LETTER_PATTERN = require(\"./utils/patterns/letters\");\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst DEFAULT_IGNORE_PATTERN = astUtils.COMMENTS_IGNORE_PATTERN,\n    WHITESPACE = /\\s/gu,\n    MAYBE_URL = /^\\s*[^:/?#\\s]+:\\/\\/[^?#]/u; // TODO: Combine w/ max-len pattern?\n\n/*\n * Base schema body for defining the basic capitalization rule, ignorePattern,\n * and ignoreInlineComments values.\n * This can be used in a few different ways in the actual schema.\n */\nconst SCHEMA_BODY = {\n    type: \"object\",\n    properties: {\n        ignorePattern: {\n            type: \"string\"\n        },\n        ignoreInlineComments: {\n            type: \"boolean\"\n        },\n        ignoreConsecutiveComments: {\n            type: \"boolean\"\n        }\n    },\n    additionalProperties: false\n};\nconst DEFAULTS = {\n    ignorePattern: \"\",\n    ignoreInlineComments: false,\n    ignoreConsecutiveComments: false\n};\n\n/**\n * Get normalized options for either block or line comments from the given\n * user-provided options.\n * - If the user-provided options is just a string, returns a normalized\n *   set of options using default values for all other options.\n * - If the user-provided options is an object, then a normalized option\n *   set is returned. Options specified in overrides will take priority\n *   over options specified in the main options object, which will in\n *   turn take priority over the rule's defaults.\n * @param {Object|string} rawOptions The user-provided options.\n * @param {string} which Either \"line\" or \"block\".\n * @returns {Object} The normalized options.\n */\nfunction getNormalizedOptions(rawOptions, which) {\n    return Object.assign({}, DEFAULTS, rawOptions[which] || rawOptions);\n}\n\n/**\n * Get normalized options for block and line comments.\n * @param {Object|string} rawOptions The user-provided options.\n * @returns {Object} An object with \"Line\" and \"Block\" keys and corresponding\n * normalized options objects.\n */\nfunction getAllNormalizedOptions(rawOptions = {}) {\n    return {\n        Line: getNormalizedOptions(rawOptions, \"line\"),\n        Block: getNormalizedOptions(rawOptions, \"block\")\n    };\n}\n\n/**\n * Creates a regular expression for each ignorePattern defined in the rule\n * options.\n *\n * This is done in order to avoid invoking the RegExp constructor repeatedly.\n * @param {Object} normalizedOptions The normalized rule options.\n * @returns {void}\n */\nfunction createRegExpForIgnorePatterns(normalizedOptions) {\n    Object.keys(normalizedOptions).forEach(key => {\n        const ignorePatternStr = normalizedOptions[key].ignorePattern;\n\n        if (ignorePatternStr) {\n            const regExp = RegExp(`^\\\\s*(?:${ignorePatternStr})`, \"u\");\n\n            normalizedOptions[key].ignorePatternRegExp = regExp;\n        }\n    });\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce or disallow capitalization of the first letter of a comment\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/capitalized-comments\"\n        },\n\n        fixable: \"code\",\n\n        schema: [\n            { enum: [\"always\", \"never\"] },\n            {\n                oneOf: [\n                    SCHEMA_BODY,\n                    {\n                        type: \"object\",\n                        properties: {\n                            line: SCHEMA_BODY,\n                            block: SCHEMA_BODY\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ],\n\n        messages: {\n            unexpectedLowercaseComment: \"Comments should not begin with a lowercase character.\",\n            unexpectedUppercaseComment: \"Comments should not begin with an uppercase character.\"\n        }\n    },\n\n    create(context) {\n\n        const capitalize = context.options[0] || \"always\",\n            normalizedOptions = getAllNormalizedOptions(context.options[1]),\n            sourceCode = context.getSourceCode();\n\n        createRegExpForIgnorePatterns(normalizedOptions);\n\n        //----------------------------------------------------------------------\n        // Helpers\n        //----------------------------------------------------------------------\n\n        /**\n         * Checks whether a comment is an inline comment.\n         *\n         * For the purpose of this rule, a comment is inline if:\n         * 1. The comment is preceded by a token on the same line; and\n         * 2. The command is followed by a token on the same line.\n         *\n         * Note that the comment itself need not be single-line!\n         *\n         * Also, it follows from this definition that only block comments can\n         * be considered as possibly inline. This is because line comments\n         * would consume any following tokens on the same line as the comment.\n         * @param {ASTNode} comment The comment node to check.\n         * @returns {boolean} True if the comment is an inline comment, false\n         * otherwise.\n         */\n        function isInlineComment(comment) {\n            const previousToken = sourceCode.getTokenBefore(comment, { includeComments: true }),\n                nextToken = sourceCode.getTokenAfter(comment, { includeComments: true });\n\n            return Boolean(\n                previousToken &&\n                nextToken &&\n                comment.loc.start.line === previousToken.loc.end.line &&\n                comment.loc.end.line === nextToken.loc.start.line\n            );\n        }\n\n        /**\n         * Determine if a comment follows another comment.\n         * @param {ASTNode} comment The comment to check.\n         * @returns {boolean} True if the comment follows a valid comment.\n         */\n        function isConsecutiveComment(comment) {\n            const previousTokenOrComment = sourceCode.getTokenBefore(comment, { includeComments: true });\n\n            return Boolean(\n                previousTokenOrComment &&\n                [\"Block\", \"Line\"].indexOf(previousTokenOrComment.type) !== -1\n            );\n        }\n\n        /**\n         * Check a comment to determine if it is valid for this rule.\n         * @param {ASTNode} comment The comment node to process.\n         * @param {Object} options The options for checking this comment.\n         * @returns {boolean} True if the comment is valid, false otherwise.\n         */\n        function isCommentValid(comment, options) {\n\n            // 1. Check for default ignore pattern.\n            if (DEFAULT_IGNORE_PATTERN.test(comment.value)) {\n                return true;\n            }\n\n            // 2. Check for custom ignore pattern.\n            const commentWithoutAsterisks = comment.value\n                .replace(/\\*/gu, \"\");\n\n            if (options.ignorePatternRegExp && options.ignorePatternRegExp.test(commentWithoutAsterisks)) {\n                return true;\n            }\n\n            // 3. Check for inline comments.\n            if (options.ignoreInlineComments && isInlineComment(comment)) {\n                return true;\n            }\n\n            // 4. Is this a consecutive comment (and are we tolerating those)?\n            if (options.ignoreConsecutiveComments && isConsecutiveComment(comment)) {\n                return true;\n            }\n\n            // 5. Does the comment start with a possible URL?\n            if (MAYBE_URL.test(commentWithoutAsterisks)) {\n                return true;\n            }\n\n            // 6. Is the initial word character a letter?\n            const commentWordCharsOnly = commentWithoutAsterisks\n                .replace(WHITESPACE, \"\");\n\n            if (commentWordCharsOnly.length === 0) {\n                return true;\n            }\n\n            const firstWordChar = commentWordCharsOnly[0];\n\n            if (!LETTER_PATTERN.test(firstWordChar)) {\n                return true;\n            }\n\n            // 7. Check the case of the initial word character.\n            const isUppercase = firstWordChar !== firstWordChar.toLocaleLowerCase(),\n                isLowercase = firstWordChar !== firstWordChar.toLocaleUpperCase();\n\n            if (capitalize === \"always\" && isLowercase) {\n                return false;\n            }\n            if (capitalize === \"never\" && isUppercase) {\n                return false;\n            }\n\n            return true;\n        }\n\n        /**\n         * Process a comment to determine if it needs to be reported.\n         * @param {ASTNode} comment The comment node to process.\n         * @returns {void}\n         */\n        function processComment(comment) {\n            const options = normalizedOptions[comment.type],\n                commentValid = isCommentValid(comment, options);\n\n            if (!commentValid) {\n                const messageId = capitalize === \"always\"\n                    ? \"unexpectedLowercaseComment\"\n                    : \"unexpectedUppercaseComment\";\n\n                context.report({\n                    node: null, // Intentionally using loc instead\n                    loc: comment.loc,\n                    messageId,\n                    fix(fixer) {\n                        const match = comment.value.match(LETTER_PATTERN);\n\n                        return fixer.replaceTextRange(\n\n                            // Offset match.index by 2 to account for the first 2 characters that start the comment (// or /*)\n                            [comment.range[0] + match.index + 2, comment.range[0] + match.index + 3],\n                            capitalize === \"always\" ? match[0].toLocaleUpperCase() : match[0].toLocaleLowerCase()\n                        );\n                    }\n                });\n            }\n        }\n\n        //----------------------------------------------------------------------\n        // Public\n        //----------------------------------------------------------------------\n\n        return {\n            Program() {\n                const comments = sourceCode.getAllComments();\n\n                comments.filter(token => token.type !== \"Shebang\").forEach(processComment);\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}