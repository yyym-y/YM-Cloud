{"ast":null,"code":"/**\n * @fileoverview A rule to suggest using of const declaration for variables that are never reassigned after declared.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nrequire(\"core-js/modules/es.array.push.js\");\nconst FixTracker = require(\"./utils/fix-tracker\");\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst PATTERN_TYPE = /^(?:.+?Pattern|RestElement|SpreadProperty|ExperimentalRestProperty|Property)$/u;\nconst DECLARATION_HOST_TYPE = /^(?:Program|BlockStatement|SwitchCase)$/u;\nconst DESTRUCTURING_HOST_TYPE = /^(?:VariableDeclarator|AssignmentExpression)$/u;\n\n/**\n * Checks whether a given node is located at `ForStatement.init` or not.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node is located at `ForStatement.init`.\n */\nfunction isInitOfForStatement(node) {\n  return node.parent.type === \"ForStatement\" && node.parent.init === node;\n}\n\n/**\n * Checks whether a given Identifier node becomes a VariableDeclaration or not.\n * @param {ASTNode} identifier An Identifier node to check.\n * @returns {boolean} `true` if the node can become a VariableDeclaration.\n */\nfunction canBecomeVariableDeclaration(identifier) {\n  let node = identifier.parent;\n  while (PATTERN_TYPE.test(node.type)) {\n    node = node.parent;\n  }\n  return node.type === \"VariableDeclarator\" || node.type === \"AssignmentExpression\" && node.parent.type === \"ExpressionStatement\" && DECLARATION_HOST_TYPE.test(node.parent.parent.type);\n}\n\n/**\n * Checks if an property or element is from outer scope or function parameters\n * in destructing pattern.\n * @param {string} name A variable name to be checked.\n * @param {eslint-scope.Scope} initScope A scope to start find.\n * @returns {boolean} Indicates if the variable is from outer scope or function parameters.\n */\nfunction isOuterVariableInDestructing(name, initScope) {\n  if (initScope.through.find(ref => ref.resolved && ref.resolved.name === name)) {\n    return true;\n  }\n  const variable = astUtils.getVariableByName(initScope, name);\n  if (variable !== null) {\n    return variable.defs.some(def => def.type === \"Parameter\");\n  }\n  return false;\n}\n\n/**\n * Gets the VariableDeclarator/AssignmentExpression node that a given reference\n * belongs to.\n * This is used to detect a mix of reassigned and never reassigned in a\n * destructuring.\n * @param {eslint-scope.Reference} reference A reference to get.\n * @returns {ASTNode|null} A VariableDeclarator/AssignmentExpression node or\n *      null.\n */\nfunction getDestructuringHost(reference) {\n  if (!reference.isWrite()) {\n    return null;\n  }\n  let node = reference.identifier.parent;\n  while (PATTERN_TYPE.test(node.type)) {\n    node = node.parent;\n  }\n  if (!DESTRUCTURING_HOST_TYPE.test(node.type)) {\n    return null;\n  }\n  return node;\n}\n\n/**\n * Determines if a destructuring assignment node contains\n * any MemberExpression nodes. This is used to determine if a\n * variable that is only written once using destructuring can be\n * safely converted into a const declaration.\n * @param {ASTNode} node The ObjectPattern or ArrayPattern node to check.\n * @returns {boolean} True if the destructuring pattern contains\n *      a MemberExpression, false if not.\n */\nfunction hasMemberExpressionAssignment(node) {\n  switch (node.type) {\n    case \"ObjectPattern\":\n      return node.properties.some(prop => {\n        if (prop) {\n          /*\n           * Spread elements have an argument property while\n           * others have a value property. Because different\n           * parsers use different node types for spread elements,\n           * we just check if there is an argument property.\n           */\n          return hasMemberExpressionAssignment(prop.argument || prop.value);\n        }\n        return false;\n      });\n    case \"ArrayPattern\":\n      return node.elements.some(element => {\n        if (element) {\n          return hasMemberExpressionAssignment(element);\n        }\n        return false;\n      });\n    case \"AssignmentPattern\":\n      return hasMemberExpressionAssignment(node.left);\n    case \"MemberExpression\":\n      return true;\n\n    // no default\n  }\n\n  return false;\n}\n\n/**\n * Gets an identifier node of a given variable.\n *\n * If the initialization exists or one or more reading references exist before\n * the first assignment, the identifier node is the node of the declaration.\n * Otherwise, the identifier node is the node of the first assignment.\n *\n * If the variable should not change to const, this function returns null.\n * - If the variable is reassigned.\n * - If the variable is never initialized nor assigned.\n * - If the variable is initialized in a different scope from the declaration.\n * - If the unique assignment of the variable cannot change to a declaration.\n *   e.g. `if (a) b = 1` / `return (b = 1)`\n * - If the variable is declared in the global scope and `eslintUsed` is `true`.\n *   `/*exported foo` directive comment makes such variables. This rule does not\n *   warn such variables because this rule cannot distinguish whether the\n *   exported variables are reassigned or not.\n * @param {eslint-scope.Variable} variable A variable to get.\n * @param {boolean} ignoreReadBeforeAssign\n *      The value of `ignoreReadBeforeAssign` option.\n * @returns {ASTNode|null}\n *      An Identifier node if the variable should change to const.\n *      Otherwise, null.\n */\nfunction getIdentifierIfShouldBeConst(variable, ignoreReadBeforeAssign) {\n  if (variable.eslintUsed && variable.scope.type === \"global\") {\n    return null;\n  }\n\n  // Finds the unique WriteReference.\n  let writer = null;\n  let isReadBeforeInit = false;\n  const references = variable.references;\n  for (let i = 0; i < references.length; ++i) {\n    const reference = references[i];\n    if (reference.isWrite()) {\n      const isReassigned = writer !== null && writer.identifier !== reference.identifier;\n      if (isReassigned) {\n        return null;\n      }\n      const destructuringHost = getDestructuringHost(reference);\n      if (destructuringHost !== null && destructuringHost.left !== void 0) {\n        const leftNode = destructuringHost.left;\n        let hasOuterVariables = false,\n          hasNonIdentifiers = false;\n        if (leftNode.type === \"ObjectPattern\") {\n          const properties = leftNode.properties;\n          hasOuterVariables = properties.filter(prop => prop.value).map(prop => prop.value.name).some(name => isOuterVariableInDestructing(name, variable.scope));\n          hasNonIdentifiers = hasMemberExpressionAssignment(leftNode);\n        } else if (leftNode.type === \"ArrayPattern\") {\n          const elements = leftNode.elements;\n          hasOuterVariables = elements.map(element => element && element.name).some(name => isOuterVariableInDestructing(name, variable.scope));\n          hasNonIdentifiers = hasMemberExpressionAssignment(leftNode);\n        }\n        if (hasOuterVariables || hasNonIdentifiers) {\n          return null;\n        }\n      }\n      writer = reference;\n    } else if (reference.isRead() && writer === null) {\n      if (ignoreReadBeforeAssign) {\n        return null;\n      }\n      isReadBeforeInit = true;\n    }\n  }\n\n  /*\n   * If the assignment is from a different scope, ignore it.\n   * If the assignment cannot change to a declaration, ignore it.\n   */\n  const shouldBeConst = writer !== null && writer.from === variable.scope && canBecomeVariableDeclaration(writer.identifier);\n  if (!shouldBeConst) {\n    return null;\n  }\n  if (isReadBeforeInit) {\n    return variable.defs[0].name;\n  }\n  return writer.identifier;\n}\n\n/**\n * Groups by the VariableDeclarator/AssignmentExpression node that each\n * reference of given variables belongs to.\n * This is used to detect a mix of reassigned and never reassigned in a\n * destructuring.\n * @param {eslint-scope.Variable[]} variables Variables to group by destructuring.\n * @param {boolean} ignoreReadBeforeAssign\n *      The value of `ignoreReadBeforeAssign` option.\n * @returns {Map<ASTNode, ASTNode[]>} Grouped identifier nodes.\n */\nfunction groupByDestructuring(variables, ignoreReadBeforeAssign) {\n  const identifierMap = new Map();\n  for (let i = 0; i < variables.length; ++i) {\n    const variable = variables[i];\n    const references = variable.references;\n    const identifier = getIdentifierIfShouldBeConst(variable, ignoreReadBeforeAssign);\n    let prevId = null;\n    for (let j = 0; j < references.length; ++j) {\n      const reference = references[j];\n      const id = reference.identifier;\n\n      /*\n       * Avoid counting a reference twice or more for default values of\n       * destructuring.\n       */\n      if (id === prevId) {\n        continue;\n      }\n      prevId = id;\n\n      // Add the identifier node into the destructuring group.\n      const group = getDestructuringHost(reference);\n      if (group) {\n        if (identifierMap.has(group)) {\n          identifierMap.get(group).push(identifier);\n        } else {\n          identifierMap.set(group, [identifier]);\n        }\n      }\n    }\n  }\n  return identifierMap;\n}\n\n/**\n * Finds the nearest parent of node with a given type.\n * @param {ASTNode} node The node to search from.\n * @param {string} type The type field of the parent node.\n * @param {Function} shouldStop A predicate that returns true if the traversal should stop, and false otherwise.\n * @returns {ASTNode} The closest ancestor with the specified type; null if no such ancestor exists.\n */\nfunction findUp(node, type, shouldStop) {\n  if (!node || shouldStop(node)) {\n    return null;\n  }\n  if (node.type === type) {\n    return node;\n  }\n  return findUp(node.parent, type, shouldStop);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require `const` declarations for variables that are never reassigned after declared\",\n      category: \"ECMAScript 6\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/prefer-const\"\n    },\n    fixable: \"code\",\n    schema: [{\n      type: \"object\",\n      properties: {\n        destructuring: {\n          enum: [\"any\", \"all\"],\n          default: \"any\"\n        },\n        ignoreReadBeforeAssign: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      useConst: \"'{{name}}' is never reassigned. Use 'const' instead.\"\n    }\n  },\n  create(context) {\n    const options = context.options[0] || {};\n    const sourceCode = context.getSourceCode();\n    const shouldMatchAnyDestructuredVariable = options.destructuring !== \"all\";\n    const ignoreReadBeforeAssign = options.ignoreReadBeforeAssign === true;\n    const variables = [];\n    let reportCount = 0;\n    let checkedId = null;\n    let checkedName = \"\";\n\n    /**\n     * Reports given identifier nodes if all of the nodes should be declared\n     * as const.\n     *\n     * The argument 'nodes' is an array of Identifier nodes.\n     * This node is the result of 'getIdentifierIfShouldBeConst()', so it's\n     * nullable. In simple declaration or assignment cases, the length of\n     * the array is 1. In destructuring cases, the length of the array can\n     * be 2 or more.\n     * @param {(eslint-scope.Reference|null)[]} nodes\n     *      References which are grouped by destructuring to report.\n     * @returns {void}\n     */\n    function checkGroup(nodes) {\n      const nodesToReport = nodes.filter(Boolean);\n      if (nodes.length && (shouldMatchAnyDestructuredVariable || nodesToReport.length === nodes.length)) {\n        const varDeclParent = findUp(nodes[0], \"VariableDeclaration\", parentNode => parentNode.type.endsWith(\"Statement\"));\n        const isVarDecParentNull = varDeclParent === null;\n        if (!isVarDecParentNull && varDeclParent.declarations.length > 0) {\n          const firstDeclaration = varDeclParent.declarations[0];\n          if (firstDeclaration.init) {\n            const firstDecParent = firstDeclaration.init.parent;\n\n            /*\n             * First we check the declaration type and then depending on\n             * if the type is a \"VariableDeclarator\" or its an \"ObjectPattern\"\n             * we compare the name and id from the first identifier, if the names are different\n             * we assign the new name, id and reset the count of reportCount and nodeCount in\n             * order to check each block for the number of reported errors and base our fix\n             * based on comparing nodes.length and nodesToReport.length.\n             */\n\n            if (firstDecParent.type === \"VariableDeclarator\") {\n              if (firstDecParent.id.name !== checkedName) {\n                checkedName = firstDecParent.id.name;\n                reportCount = 0;\n              }\n              if (firstDecParent.id.type === \"ObjectPattern\") {\n                if (firstDecParent.init.name !== checkedName) {\n                  checkedName = firstDecParent.init.name;\n                  reportCount = 0;\n                }\n              }\n              if (firstDecParent.id !== checkedId) {\n                checkedId = firstDecParent.id;\n                reportCount = 0;\n              }\n            }\n          }\n        }\n        let shouldFix = varDeclParent && (\n        // Don't do a fix unless all variables in the declarations are initialized (or it's in a for-in or for-of loop)\n        varDeclParent.parent.type === \"ForInStatement\" || varDeclParent.parent.type === \"ForOfStatement\" || varDeclParent.declarations.every(declaration => declaration.init)) &&\n        /*\n         * If options.destructuring is \"all\", then this warning will not occur unless\n         * every assignment in the destructuring should be const. In that case, it's safe\n         * to apply the fix.\n         */\n        nodesToReport.length === nodes.length;\n        if (!isVarDecParentNull && varDeclParent.declarations && varDeclParent.declarations.length !== 1) {\n          if (varDeclParent && varDeclParent.declarations && varDeclParent.declarations.length >= 1) {\n            /*\n             * Add nodesToReport.length to a count, then comparing the count to the length\n             * of the declarations in the current block.\n             */\n\n            reportCount += nodesToReport.length;\n            shouldFix = shouldFix && reportCount === varDeclParent.declarations.length;\n          }\n        }\n        nodesToReport.forEach(node => {\n          context.report({\n            node,\n            messageId: \"useConst\",\n            data: node,\n            fix: shouldFix ? fixer => {\n              const letKeywordToken = sourceCode.getFirstToken(varDeclParent, t => t.value === varDeclParent.kind);\n\n              /**\n               * Extend the replacement range to the whole declaration,\n               * in order to prevent other fixes in the same pass\n               * https://github.com/eslint/eslint/issues/13899\n               */\n              return new FixTracker(fixer, sourceCode).retainRange(varDeclParent.range).replaceTextRange(letKeywordToken.range, \"const\");\n            } : null\n          });\n        });\n      }\n    }\n    return {\n      \"Program:exit\"() {\n        groupByDestructuring(variables, ignoreReadBeforeAssign).forEach(checkGroup);\n      },\n      VariableDeclaration(node) {\n        if (node.kind === \"let\" && !isInitOfForStatement(node)) {\n          variables.push(...context.getDeclaredVariables(node));\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["require","FixTracker","astUtils","PATTERN_TYPE","DECLARATION_HOST_TYPE","DESTRUCTURING_HOST_TYPE","isInitOfForStatement","node","parent","type","init","canBecomeVariableDeclaration","identifier","test","isOuterVariableInDestructing","name","initScope","through","find","ref","resolved","variable","getVariableByName","defs","some","def","getDestructuringHost","reference","isWrite","hasMemberExpressionAssignment","properties","prop","argument","value","elements","element","left","getIdentifierIfShouldBeConst","ignoreReadBeforeAssign","eslintUsed","scope","writer","isReadBeforeInit","references","i","length","isReassigned","destructuringHost","leftNode","hasOuterVariables","hasNonIdentifiers","filter","map","isRead","shouldBeConst","from","groupByDestructuring","variables","identifierMap","Map","prevId","j","id","group","has","get","push","set","findUp","shouldStop","module","exports","meta","docs","description","category","recommended","url","fixable","schema","destructuring","enum","default","additionalProperties","messages","useConst","create","context","options","sourceCode","getSourceCode","shouldMatchAnyDestructuredVariable","reportCount","checkedId","checkedName","checkGroup","nodes","nodesToReport","Boolean","varDeclParent","parentNode","endsWith","isVarDecParentNull","declarations","firstDeclaration","firstDecParent","shouldFix","every","declaration","forEach","report","messageId","data","fix","fixer","letKeywordToken","getFirstToken","t","kind","retainRange","range","replaceTextRange","Program:exit","VariableDeclaration","getDeclaredVariables"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/prefer-const.js"],"sourcesContent":["/**\n * @fileoverview A rule to suggest using of const declaration for variables that are never reassigned after declared.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst FixTracker = require(\"./utils/fix-tracker\");\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst PATTERN_TYPE = /^(?:.+?Pattern|RestElement|SpreadProperty|ExperimentalRestProperty|Property)$/u;\nconst DECLARATION_HOST_TYPE = /^(?:Program|BlockStatement|SwitchCase)$/u;\nconst DESTRUCTURING_HOST_TYPE = /^(?:VariableDeclarator|AssignmentExpression)$/u;\n\n/**\n * Checks whether a given node is located at `ForStatement.init` or not.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node is located at `ForStatement.init`.\n */\nfunction isInitOfForStatement(node) {\n    return node.parent.type === \"ForStatement\" && node.parent.init === node;\n}\n\n/**\n * Checks whether a given Identifier node becomes a VariableDeclaration or not.\n * @param {ASTNode} identifier An Identifier node to check.\n * @returns {boolean} `true` if the node can become a VariableDeclaration.\n */\nfunction canBecomeVariableDeclaration(identifier) {\n    let node = identifier.parent;\n\n    while (PATTERN_TYPE.test(node.type)) {\n        node = node.parent;\n    }\n\n    return (\n        node.type === \"VariableDeclarator\" ||\n        (\n            node.type === \"AssignmentExpression\" &&\n            node.parent.type === \"ExpressionStatement\" &&\n            DECLARATION_HOST_TYPE.test(node.parent.parent.type)\n        )\n    );\n}\n\n/**\n * Checks if an property or element is from outer scope or function parameters\n * in destructing pattern.\n * @param {string} name A variable name to be checked.\n * @param {eslint-scope.Scope} initScope A scope to start find.\n * @returns {boolean} Indicates if the variable is from outer scope or function parameters.\n */\nfunction isOuterVariableInDestructing(name, initScope) {\n\n    if (initScope.through.find(ref => ref.resolved && ref.resolved.name === name)) {\n        return true;\n    }\n\n    const variable = astUtils.getVariableByName(initScope, name);\n\n    if (variable !== null) {\n        return variable.defs.some(def => def.type === \"Parameter\");\n    }\n\n    return false;\n}\n\n/**\n * Gets the VariableDeclarator/AssignmentExpression node that a given reference\n * belongs to.\n * This is used to detect a mix of reassigned and never reassigned in a\n * destructuring.\n * @param {eslint-scope.Reference} reference A reference to get.\n * @returns {ASTNode|null} A VariableDeclarator/AssignmentExpression node or\n *      null.\n */\nfunction getDestructuringHost(reference) {\n    if (!reference.isWrite()) {\n        return null;\n    }\n    let node = reference.identifier.parent;\n\n    while (PATTERN_TYPE.test(node.type)) {\n        node = node.parent;\n    }\n\n    if (!DESTRUCTURING_HOST_TYPE.test(node.type)) {\n        return null;\n    }\n    return node;\n}\n\n/**\n * Determines if a destructuring assignment node contains\n * any MemberExpression nodes. This is used to determine if a\n * variable that is only written once using destructuring can be\n * safely converted into a const declaration.\n * @param {ASTNode} node The ObjectPattern or ArrayPattern node to check.\n * @returns {boolean} True if the destructuring pattern contains\n *      a MemberExpression, false if not.\n */\nfunction hasMemberExpressionAssignment(node) {\n    switch (node.type) {\n        case \"ObjectPattern\":\n            return node.properties.some(prop => {\n                if (prop) {\n\n                    /*\n                     * Spread elements have an argument property while\n                     * others have a value property. Because different\n                     * parsers use different node types for spread elements,\n                     * we just check if there is an argument property.\n                     */\n                    return hasMemberExpressionAssignment(prop.argument || prop.value);\n                }\n\n                return false;\n            });\n\n        case \"ArrayPattern\":\n            return node.elements.some(element => {\n                if (element) {\n                    return hasMemberExpressionAssignment(element);\n                }\n\n                return false;\n            });\n\n        case \"AssignmentPattern\":\n            return hasMemberExpressionAssignment(node.left);\n\n        case \"MemberExpression\":\n            return true;\n\n        // no default\n    }\n\n    return false;\n}\n\n/**\n * Gets an identifier node of a given variable.\n *\n * If the initialization exists or one or more reading references exist before\n * the first assignment, the identifier node is the node of the declaration.\n * Otherwise, the identifier node is the node of the first assignment.\n *\n * If the variable should not change to const, this function returns null.\n * - If the variable is reassigned.\n * - If the variable is never initialized nor assigned.\n * - If the variable is initialized in a different scope from the declaration.\n * - If the unique assignment of the variable cannot change to a declaration.\n *   e.g. `if (a) b = 1` / `return (b = 1)`\n * - If the variable is declared in the global scope and `eslintUsed` is `true`.\n *   `/*exported foo` directive comment makes such variables. This rule does not\n *   warn such variables because this rule cannot distinguish whether the\n *   exported variables are reassigned or not.\n * @param {eslint-scope.Variable} variable A variable to get.\n * @param {boolean} ignoreReadBeforeAssign\n *      The value of `ignoreReadBeforeAssign` option.\n * @returns {ASTNode|null}\n *      An Identifier node if the variable should change to const.\n *      Otherwise, null.\n */\nfunction getIdentifierIfShouldBeConst(variable, ignoreReadBeforeAssign) {\n    if (variable.eslintUsed && variable.scope.type === \"global\") {\n        return null;\n    }\n\n    // Finds the unique WriteReference.\n    let writer = null;\n    let isReadBeforeInit = false;\n    const references = variable.references;\n\n    for (let i = 0; i < references.length; ++i) {\n        const reference = references[i];\n\n        if (reference.isWrite()) {\n            const isReassigned = (\n                writer !== null &&\n                writer.identifier !== reference.identifier\n            );\n\n            if (isReassigned) {\n                return null;\n            }\n\n            const destructuringHost = getDestructuringHost(reference);\n\n            if (destructuringHost !== null && destructuringHost.left !== void 0) {\n                const leftNode = destructuringHost.left;\n                let hasOuterVariables = false,\n                    hasNonIdentifiers = false;\n\n                if (leftNode.type === \"ObjectPattern\") {\n                    const properties = leftNode.properties;\n\n                    hasOuterVariables = properties\n                        .filter(prop => prop.value)\n                        .map(prop => prop.value.name)\n                        .some(name => isOuterVariableInDestructing(name, variable.scope));\n\n                    hasNonIdentifiers = hasMemberExpressionAssignment(leftNode);\n\n                } else if (leftNode.type === \"ArrayPattern\") {\n                    const elements = leftNode.elements;\n\n                    hasOuterVariables = elements\n                        .map(element => element && element.name)\n                        .some(name => isOuterVariableInDestructing(name, variable.scope));\n\n                    hasNonIdentifiers = hasMemberExpressionAssignment(leftNode);\n                }\n\n                if (hasOuterVariables || hasNonIdentifiers) {\n                    return null;\n                }\n\n            }\n\n            writer = reference;\n\n        } else if (reference.isRead() && writer === null) {\n            if (ignoreReadBeforeAssign) {\n                return null;\n            }\n            isReadBeforeInit = true;\n        }\n    }\n\n    /*\n     * If the assignment is from a different scope, ignore it.\n     * If the assignment cannot change to a declaration, ignore it.\n     */\n    const shouldBeConst = (\n        writer !== null &&\n        writer.from === variable.scope &&\n        canBecomeVariableDeclaration(writer.identifier)\n    );\n\n    if (!shouldBeConst) {\n        return null;\n    }\n\n    if (isReadBeforeInit) {\n        return variable.defs[0].name;\n    }\n\n    return writer.identifier;\n}\n\n/**\n * Groups by the VariableDeclarator/AssignmentExpression node that each\n * reference of given variables belongs to.\n * This is used to detect a mix of reassigned and never reassigned in a\n * destructuring.\n * @param {eslint-scope.Variable[]} variables Variables to group by destructuring.\n * @param {boolean} ignoreReadBeforeAssign\n *      The value of `ignoreReadBeforeAssign` option.\n * @returns {Map<ASTNode, ASTNode[]>} Grouped identifier nodes.\n */\nfunction groupByDestructuring(variables, ignoreReadBeforeAssign) {\n    const identifierMap = new Map();\n\n    for (let i = 0; i < variables.length; ++i) {\n        const variable = variables[i];\n        const references = variable.references;\n        const identifier = getIdentifierIfShouldBeConst(variable, ignoreReadBeforeAssign);\n        let prevId = null;\n\n        for (let j = 0; j < references.length; ++j) {\n            const reference = references[j];\n            const id = reference.identifier;\n\n            /*\n             * Avoid counting a reference twice or more for default values of\n             * destructuring.\n             */\n            if (id === prevId) {\n                continue;\n            }\n            prevId = id;\n\n            // Add the identifier node into the destructuring group.\n            const group = getDestructuringHost(reference);\n\n            if (group) {\n                if (identifierMap.has(group)) {\n                    identifierMap.get(group).push(identifier);\n                } else {\n                    identifierMap.set(group, [identifier]);\n                }\n            }\n        }\n    }\n\n    return identifierMap;\n}\n\n/**\n * Finds the nearest parent of node with a given type.\n * @param {ASTNode} node The node to search from.\n * @param {string} type The type field of the parent node.\n * @param {Function} shouldStop A predicate that returns true if the traversal should stop, and false otherwise.\n * @returns {ASTNode} The closest ancestor with the specified type; null if no such ancestor exists.\n */\nfunction findUp(node, type, shouldStop) {\n    if (!node || shouldStop(node)) {\n        return null;\n    }\n    if (node.type === type) {\n        return node;\n    }\n    return findUp(node.parent, type, shouldStop);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require `const` declarations for variables that are never reassigned after declared\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/prefer-const\"\n        },\n\n        fixable: \"code\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    destructuring: { enum: [\"any\", \"all\"], default: \"any\" },\n                    ignoreReadBeforeAssign: { type: \"boolean\", default: false }\n                },\n                additionalProperties: false\n            }\n        ],\n        messages: {\n            useConst: \"'{{name}}' is never reassigned. Use 'const' instead.\"\n        }\n    },\n\n    create(context) {\n        const options = context.options[0] || {};\n        const sourceCode = context.getSourceCode();\n        const shouldMatchAnyDestructuredVariable = options.destructuring !== \"all\";\n        const ignoreReadBeforeAssign = options.ignoreReadBeforeAssign === true;\n        const variables = [];\n        let reportCount = 0;\n        let checkedId = null;\n        let checkedName = \"\";\n\n\n        /**\n         * Reports given identifier nodes if all of the nodes should be declared\n         * as const.\n         *\n         * The argument 'nodes' is an array of Identifier nodes.\n         * This node is the result of 'getIdentifierIfShouldBeConst()', so it's\n         * nullable. In simple declaration or assignment cases, the length of\n         * the array is 1. In destructuring cases, the length of the array can\n         * be 2 or more.\n         * @param {(eslint-scope.Reference|null)[]} nodes\n         *      References which are grouped by destructuring to report.\n         * @returns {void}\n         */\n        function checkGroup(nodes) {\n            const nodesToReport = nodes.filter(Boolean);\n\n            if (nodes.length && (shouldMatchAnyDestructuredVariable || nodesToReport.length === nodes.length)) {\n                const varDeclParent = findUp(nodes[0], \"VariableDeclaration\", parentNode => parentNode.type.endsWith(\"Statement\"));\n                const isVarDecParentNull = varDeclParent === null;\n\n                if (!isVarDecParentNull && varDeclParent.declarations.length > 0) {\n                    const firstDeclaration = varDeclParent.declarations[0];\n\n                    if (firstDeclaration.init) {\n                        const firstDecParent = firstDeclaration.init.parent;\n\n                        /*\n                         * First we check the declaration type and then depending on\n                         * if the type is a \"VariableDeclarator\" or its an \"ObjectPattern\"\n                         * we compare the name and id from the first identifier, if the names are different\n                         * we assign the new name, id and reset the count of reportCount and nodeCount in\n                         * order to check each block for the number of reported errors and base our fix\n                         * based on comparing nodes.length and nodesToReport.length.\n                         */\n\n                        if (firstDecParent.type === \"VariableDeclarator\") {\n\n                            if (firstDecParent.id.name !== checkedName) {\n                                checkedName = firstDecParent.id.name;\n                                reportCount = 0;\n                            }\n\n                            if (firstDecParent.id.type === \"ObjectPattern\") {\n                                if (firstDecParent.init.name !== checkedName) {\n                                    checkedName = firstDecParent.init.name;\n                                    reportCount = 0;\n                                }\n                            }\n\n                            if (firstDecParent.id !== checkedId) {\n                                checkedId = firstDecParent.id;\n                                reportCount = 0;\n                            }\n                        }\n                    }\n                }\n\n                let shouldFix = varDeclParent &&\n\n                    // Don't do a fix unless all variables in the declarations are initialized (or it's in a for-in or for-of loop)\n                    (varDeclParent.parent.type === \"ForInStatement\" || varDeclParent.parent.type === \"ForOfStatement\" ||\n                        varDeclParent.declarations.every(declaration => declaration.init)) &&\n\n                    /*\n                     * If options.destructuring is \"all\", then this warning will not occur unless\n                     * every assignment in the destructuring should be const. In that case, it's safe\n                     * to apply the fix.\n                     */\n                    nodesToReport.length === nodes.length;\n\n                if (!isVarDecParentNull && varDeclParent.declarations && varDeclParent.declarations.length !== 1) {\n\n                    if (varDeclParent && varDeclParent.declarations && varDeclParent.declarations.length >= 1) {\n\n                        /*\n                         * Add nodesToReport.length to a count, then comparing the count to the length\n                         * of the declarations in the current block.\n                         */\n\n                        reportCount += nodesToReport.length;\n\n                        shouldFix = shouldFix && (reportCount === varDeclParent.declarations.length);\n                    }\n                }\n\n                nodesToReport.forEach(node => {\n                    context.report({\n                        node,\n                        messageId: \"useConst\",\n                        data: node,\n                        fix: shouldFix\n                            ? fixer => {\n                                const letKeywordToken = sourceCode.getFirstToken(varDeclParent, t => t.value === varDeclParent.kind);\n\n                                /**\n                                 * Extend the replacement range to the whole declaration,\n                                 * in order to prevent other fixes in the same pass\n                                 * https://github.com/eslint/eslint/issues/13899\n                                 */\n                                return new FixTracker(fixer, sourceCode)\n                                    .retainRange(varDeclParent.range)\n                                    .replaceTextRange(letKeywordToken.range, \"const\");\n                            }\n                            : null\n                    });\n                });\n            }\n        }\n\n        return {\n            \"Program:exit\"() {\n                groupByDestructuring(variables, ignoreReadBeforeAssign).forEach(checkGroup);\n            },\n\n            VariableDeclaration(node) {\n                if (node.kind === \"let\" && !isInitOfForStatement(node)) {\n                    variables.push(...context.getDeclaredVariables(node));\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}