{"ast":null,"code":"/**\n * @fileoverview Translates tokens between Acorn format and Esprima format.\n * @author Nicholas C. Zakas\n */\n/* eslint no-underscore-dangle: 0 */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\n// none!\n\n//------------------------------------------------------------------------------\n// Private\n//------------------------------------------------------------------------------\n\n// Esprima Token Types\nrequire(\"core-js/modules/es.regexp.flags.js\");\nrequire(\"core-js/modules/es.array.push.js\");\nconst Token = {\n  Boolean: \"Boolean\",\n  EOF: \"<end>\",\n  Identifier: \"Identifier\",\n  Keyword: \"Keyword\",\n  Null: \"Null\",\n  Numeric: \"Numeric\",\n  Punctuator: \"Punctuator\",\n  String: \"String\",\n  RegularExpression: \"RegularExpression\",\n  Template: \"Template\",\n  JSXIdentifier: \"JSXIdentifier\",\n  JSXText: \"JSXText\"\n};\n\n/**\n * Converts part of a template into an Esprima token.\n * @param {AcornToken[]} tokens The Acorn tokens representing the template.\n * @param {string} code The source code.\n * @returns {EsprimaToken} The Esprima equivalent of the template token.\n * @private\n */\nfunction convertTemplatePart(tokens, code) {\n  const firstToken = tokens[0],\n    lastTemplateToken = tokens[tokens.length - 1];\n  const token = {\n    type: Token.Template,\n    value: code.slice(firstToken.start, lastTemplateToken.end)\n  };\n  if (firstToken.loc) {\n    token.loc = {\n      start: firstToken.loc.start,\n      end: lastTemplateToken.loc.end\n    };\n  }\n  if (firstToken.range) {\n    token.start = firstToken.range[0];\n    token.end = lastTemplateToken.range[1];\n    token.range = [token.start, token.end];\n  }\n  return token;\n}\n\n/**\n * Contains logic to translate Acorn tokens into Esprima tokens.\n * @param {Object} acornTokTypes The Acorn token types.\n * @param {string} code The source code Acorn is parsing. This is necessary\n *      to correct the \"value\" property of some tokens.\n * @constructor\n */\nfunction TokenTranslator(acornTokTypes, code) {\n  // token types\n  this._acornTokTypes = acornTokTypes;\n\n  // token buffer for templates\n  this._tokens = [];\n\n  // track the last curly brace\n  this._curlyBrace = null;\n\n  // the source code\n  this._code = code;\n}\nTokenTranslator.prototype = {\n  constructor: TokenTranslator,\n  /**\n   * Translates a single Esprima token to a single Acorn token. This may be\n   * inaccurate due to how templates are handled differently in Esprima and\n   * Acorn, but should be accurate for all other tokens.\n   * @param {AcornToken} token The Acorn token to translate.\n   * @param {Object} extra Espree extra object.\n   * @returns {EsprimaToken} The Esprima version of the token.\n   */\n  translate(token, extra) {\n    const type = token.type,\n      tt = this._acornTokTypes;\n    if (type === tt.name) {\n      token.type = Token.Identifier;\n\n      // TODO: See if this is an Acorn bug\n      if (token.value === \"static\") {\n        token.type = Token.Keyword;\n      }\n      if (extra.ecmaVersion > 5 && (token.value === \"yield\" || token.value === \"let\")) {\n        token.type = Token.Keyword;\n      }\n    } else if (type === tt.semi || type === tt.comma || type === tt.parenL || type === tt.parenR || type === tt.braceL || type === tt.braceR || type === tt.dot || type === tt.bracketL || type === tt.colon || type === tt.question || type === tt.bracketR || type === tt.ellipsis || type === tt.arrow || type === tt.jsxTagStart || type === tt.incDec || type === tt.starstar || type === tt.jsxTagEnd || type === tt.prefix || type === tt.questionDot || type.binop && !type.keyword || type.isAssign) {\n      token.type = Token.Punctuator;\n      token.value = this._code.slice(token.start, token.end);\n    } else if (type === tt.jsxName) {\n      token.type = Token.JSXIdentifier;\n    } else if (type.label === \"jsxText\" || type === tt.jsxAttrValueToken) {\n      token.type = Token.JSXText;\n    } else if (type.keyword) {\n      if (type.keyword === \"true\" || type.keyword === \"false\") {\n        token.type = Token.Boolean;\n      } else if (type.keyword === \"null\") {\n        token.type = Token.Null;\n      } else {\n        token.type = Token.Keyword;\n      }\n    } else if (type === tt.num) {\n      token.type = Token.Numeric;\n      token.value = this._code.slice(token.start, token.end);\n    } else if (type === tt.string) {\n      if (extra.jsxAttrValueToken) {\n        extra.jsxAttrValueToken = false;\n        token.type = Token.JSXText;\n      } else {\n        token.type = Token.String;\n      }\n      token.value = this._code.slice(token.start, token.end);\n    } else if (type === tt.regexp) {\n      token.type = Token.RegularExpression;\n      const value = token.value;\n      token.regex = {\n        flags: value.flags,\n        pattern: value.pattern\n      };\n      token.value = `/${value.pattern}/${value.flags}`;\n    }\n    return token;\n  },\n  /**\n   * Function to call during Acorn's onToken handler.\n   * @param {AcornToken} token The Acorn token.\n   * @param {Object} extra The Espree extra object.\n   * @returns {void}\n   */\n  onToken(token, extra) {\n    const that = this,\n      tt = this._acornTokTypes,\n      tokens = extra.tokens,\n      templateTokens = this._tokens;\n\n    /**\n     * Flushes the buffered template tokens and resets the template\n     * tracking.\n     * @returns {void}\n     * @private\n     */\n    function translateTemplateTokens() {\n      tokens.push(convertTemplatePart(that._tokens, that._code));\n      that._tokens = [];\n    }\n    if (token.type === tt.eof) {\n      // might be one last curlyBrace\n      if (this._curlyBrace) {\n        tokens.push(this.translate(this._curlyBrace, extra));\n      }\n      return;\n    }\n    if (token.type === tt.backQuote) {\n      // if there's already a curly, it's not part of the template\n      if (this._curlyBrace) {\n        tokens.push(this.translate(this._curlyBrace, extra));\n        this._curlyBrace = null;\n      }\n      templateTokens.push(token);\n\n      // it's the end\n      if (templateTokens.length > 1) {\n        translateTemplateTokens();\n      }\n      return;\n    }\n    if (token.type === tt.dollarBraceL) {\n      templateTokens.push(token);\n      translateTemplateTokens();\n      return;\n    }\n    if (token.type === tt.braceR) {\n      // if there's already a curly, it's not part of the template\n      if (this._curlyBrace) {\n        tokens.push(this.translate(this._curlyBrace, extra));\n      }\n\n      // store new curly for later\n      this._curlyBrace = token;\n      return;\n    }\n    if (token.type === tt.template || token.type === tt.invalidTemplate) {\n      if (this._curlyBrace) {\n        templateTokens.push(this._curlyBrace);\n        this._curlyBrace = null;\n      }\n      templateTokens.push(token);\n      return;\n    }\n    if (this._curlyBrace) {\n      tokens.push(this.translate(this._curlyBrace, extra));\n      this._curlyBrace = null;\n    }\n    tokens.push(this.translate(token, extra));\n  }\n};\n\n//------------------------------------------------------------------------------\n// Public\n//------------------------------------------------------------------------------\n\nmodule.exports = TokenTranslator;","map":{"version":3,"names":["require","Token","Boolean","EOF","Identifier","Keyword","Null","Numeric","Punctuator","String","RegularExpression","Template","JSXIdentifier","JSXText","convertTemplatePart","tokens","code","firstToken","lastTemplateToken","length","token","type","value","slice","start","end","loc","range","TokenTranslator","acornTokTypes","_acornTokTypes","_tokens","_curlyBrace","_code","prototype","constructor","translate","extra","tt","name","ecmaVersion","semi","comma","parenL","parenR","braceL","braceR","dot","bracketL","colon","question","bracketR","ellipsis","arrow","jsxTagStart","incDec","starstar","jsxTagEnd","prefix","questionDot","binop","keyword","isAssign","jsxName","label","jsxAttrValueToken","num","string","regexp","regex","flags","pattern","onToken","that","templateTokens","translateTemplateTokens","push","eof","backQuote","dollarBraceL","template","invalidTemplate","module","exports"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/espree/lib/token-translator.js"],"sourcesContent":["/**\n * @fileoverview Translates tokens between Acorn format and Esprima format.\n * @author Nicholas C. Zakas\n */\n/* eslint no-underscore-dangle: 0 */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\n// none!\n\n//------------------------------------------------------------------------------\n// Private\n//------------------------------------------------------------------------------\n\n\n// Esprima Token Types\nconst Token = {\n    Boolean: \"Boolean\",\n    EOF: \"<end>\",\n    Identifier: \"Identifier\",\n    Keyword: \"Keyword\",\n    Null: \"Null\",\n    Numeric: \"Numeric\",\n    Punctuator: \"Punctuator\",\n    String: \"String\",\n    RegularExpression: \"RegularExpression\",\n    Template: \"Template\",\n    JSXIdentifier: \"JSXIdentifier\",\n    JSXText: \"JSXText\"\n};\n\n/**\n * Converts part of a template into an Esprima token.\n * @param {AcornToken[]} tokens The Acorn tokens representing the template.\n * @param {string} code The source code.\n * @returns {EsprimaToken} The Esprima equivalent of the template token.\n * @private\n */\nfunction convertTemplatePart(tokens, code) {\n    const firstToken = tokens[0],\n        lastTemplateToken = tokens[tokens.length - 1];\n\n    const token = {\n        type: Token.Template,\n        value: code.slice(firstToken.start, lastTemplateToken.end)\n    };\n\n    if (firstToken.loc) {\n        token.loc = {\n            start: firstToken.loc.start,\n            end: lastTemplateToken.loc.end\n        };\n    }\n\n    if (firstToken.range) {\n        token.start = firstToken.range[0];\n        token.end = lastTemplateToken.range[1];\n        token.range = [token.start, token.end];\n    }\n\n    return token;\n}\n\n/**\n * Contains logic to translate Acorn tokens into Esprima tokens.\n * @param {Object} acornTokTypes The Acorn token types.\n * @param {string} code The source code Acorn is parsing. This is necessary\n *      to correct the \"value\" property of some tokens.\n * @constructor\n */\nfunction TokenTranslator(acornTokTypes, code) {\n\n    // token types\n    this._acornTokTypes = acornTokTypes;\n\n    // token buffer for templates\n    this._tokens = [];\n\n    // track the last curly brace\n    this._curlyBrace = null;\n\n    // the source code\n    this._code = code;\n\n}\n\nTokenTranslator.prototype = {\n    constructor: TokenTranslator,\n\n    /**\n     * Translates a single Esprima token to a single Acorn token. This may be\n     * inaccurate due to how templates are handled differently in Esprima and\n     * Acorn, but should be accurate for all other tokens.\n     * @param {AcornToken} token The Acorn token to translate.\n     * @param {Object} extra Espree extra object.\n     * @returns {EsprimaToken} The Esprima version of the token.\n     */\n    translate(token, extra) {\n\n        const type = token.type,\n            tt = this._acornTokTypes;\n\n        if (type === tt.name) {\n            token.type = Token.Identifier;\n\n            // TODO: See if this is an Acorn bug\n            if (token.value === \"static\") {\n                token.type = Token.Keyword;\n            }\n\n            if (extra.ecmaVersion > 5 && (token.value === \"yield\" || token.value === \"let\")) {\n                token.type = Token.Keyword;\n            }\n\n        } else if (type === tt.semi || type === tt.comma ||\n                 type === tt.parenL || type === tt.parenR ||\n                 type === tt.braceL || type === tt.braceR ||\n                 type === tt.dot || type === tt.bracketL ||\n                 type === tt.colon || type === tt.question ||\n                 type === tt.bracketR || type === tt.ellipsis ||\n                 type === tt.arrow || type === tt.jsxTagStart ||\n                 type === tt.incDec || type === tt.starstar ||\n                 type === tt.jsxTagEnd || type === tt.prefix ||\n                 type === tt.questionDot ||\n                 (type.binop && !type.keyword) ||\n                 type.isAssign) {\n\n            token.type = Token.Punctuator;\n            token.value = this._code.slice(token.start, token.end);\n        } else if (type === tt.jsxName) {\n            token.type = Token.JSXIdentifier;\n        } else if (type.label === \"jsxText\" || type === tt.jsxAttrValueToken) {\n            token.type = Token.JSXText;\n        } else if (type.keyword) {\n            if (type.keyword === \"true\" || type.keyword === \"false\") {\n                token.type = Token.Boolean;\n            } else if (type.keyword === \"null\") {\n                token.type = Token.Null;\n            } else {\n                token.type = Token.Keyword;\n            }\n        } else if (type === tt.num) {\n            token.type = Token.Numeric;\n            token.value = this._code.slice(token.start, token.end);\n        } else if (type === tt.string) {\n\n            if (extra.jsxAttrValueToken) {\n                extra.jsxAttrValueToken = false;\n                token.type = Token.JSXText;\n            } else {\n                token.type = Token.String;\n            }\n\n            token.value = this._code.slice(token.start, token.end);\n        } else if (type === tt.regexp) {\n            token.type = Token.RegularExpression;\n            const value = token.value;\n\n            token.regex = {\n                flags: value.flags,\n                pattern: value.pattern\n            };\n            token.value = `/${value.pattern}/${value.flags}`;\n        }\n\n        return token;\n    },\n\n    /**\n     * Function to call during Acorn's onToken handler.\n     * @param {AcornToken} token The Acorn token.\n     * @param {Object} extra The Espree extra object.\n     * @returns {void}\n     */\n    onToken(token, extra) {\n\n        const that = this,\n            tt = this._acornTokTypes,\n            tokens = extra.tokens,\n            templateTokens = this._tokens;\n\n        /**\n         * Flushes the buffered template tokens and resets the template\n         * tracking.\n         * @returns {void}\n         * @private\n         */\n        function translateTemplateTokens() {\n            tokens.push(convertTemplatePart(that._tokens, that._code));\n            that._tokens = [];\n        }\n\n        if (token.type === tt.eof) {\n\n            // might be one last curlyBrace\n            if (this._curlyBrace) {\n                tokens.push(this.translate(this._curlyBrace, extra));\n            }\n\n            return;\n        }\n\n        if (token.type === tt.backQuote) {\n\n            // if there's already a curly, it's not part of the template\n            if (this._curlyBrace) {\n                tokens.push(this.translate(this._curlyBrace, extra));\n                this._curlyBrace = null;\n            }\n\n            templateTokens.push(token);\n\n            // it's the end\n            if (templateTokens.length > 1) {\n                translateTemplateTokens();\n            }\n\n            return;\n        }\n        if (token.type === tt.dollarBraceL) {\n            templateTokens.push(token);\n            translateTemplateTokens();\n            return;\n        }\n        if (token.type === tt.braceR) {\n\n            // if there's already a curly, it's not part of the template\n            if (this._curlyBrace) {\n                tokens.push(this.translate(this._curlyBrace, extra));\n            }\n\n            // store new curly for later\n            this._curlyBrace = token;\n            return;\n        }\n        if (token.type === tt.template || token.type === tt.invalidTemplate) {\n            if (this._curlyBrace) {\n                templateTokens.push(this._curlyBrace);\n                this._curlyBrace = null;\n            }\n\n            templateTokens.push(token);\n            return;\n        }\n\n        if (this._curlyBrace) {\n            tokens.push(this.translate(this._curlyBrace, extra));\n            this._curlyBrace = null;\n        }\n\n        tokens.push(this.translate(token, extra));\n    }\n};\n\n//------------------------------------------------------------------------------\n// Public\n//------------------------------------------------------------------------------\n\nmodule.exports = TokenTranslator;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}