{"ast":null,"code":"/**\n * @fileoverview `OverrideTester` class.\n *\n * `OverrideTester` class handles `files` property and `excludedFiles` property\n * of `overrides` config.\n *\n * It provides one method.\n *\n * - `test(filePath)`\n *      Test if a file path matches the pair of `files` property and\n *      `excludedFiles` property. The `filePath` argument must be an absolute\n *      path.\n *\n * `ConfigArrayFactory` creates `OverrideTester` objects when it processes\n * `overrides` properties.\n *\n * @author Toru Nagashima <https://github.com/mysticatea>\n */\n\"use strict\";\n\nconst assert = require(\"assert\");\nconst path = require(\"path\");\nconst util = require(\"util\");\nconst {\n  Minimatch\n} = require(\"minimatch\");\nconst minimatchOpts = {\n  dot: true,\n  matchBase: true\n};\n\n/**\n * @typedef {Object} Pattern\n * @property {InstanceType<Minimatch>[] | null} includes The positive matchers.\n * @property {InstanceType<Minimatch>[] | null} excludes The negative matchers.\n */\n\n/**\n * Normalize a given pattern to an array.\n * @param {string|string[]|undefined} patterns A glob pattern or an array of glob patterns.\n * @returns {string[]|null} Normalized patterns.\n * @private\n */\nfunction normalizePatterns(patterns) {\n  if (Array.isArray(patterns)) {\n    return patterns.filter(Boolean);\n  }\n  if (typeof patterns === \"string\" && patterns) {\n    return [patterns];\n  }\n  return [];\n}\n\n/**\n * Create the matchers of given patterns.\n * @param {string[]} patterns The patterns.\n * @returns {InstanceType<Minimatch>[] | null} The matchers.\n */\nfunction toMatcher(patterns) {\n  if (patterns.length === 0) {\n    return null;\n  }\n  return patterns.map(pattern => {\n    if (/^\\.[/\\\\]/u.test(pattern)) {\n      return new Minimatch(pattern.slice(2),\n      // `./*.js` should not match with `subdir/foo.js`\n      {\n        ...minimatchOpts,\n        matchBase: false\n      });\n    }\n    return new Minimatch(pattern, minimatchOpts);\n  });\n}\n\n/**\n * Convert a given matcher to string.\n * @param {Pattern} matchers The matchers.\n * @returns {string} The string expression of the matcher.\n */\nfunction patternToJson({\n  includes,\n  excludes\n}) {\n  return {\n    includes: includes && includes.map(m => m.pattern),\n    excludes: excludes && excludes.map(m => m.pattern)\n  };\n}\n\n/**\n * The class to test given paths are matched by the patterns.\n */\nclass OverrideTester {\n  /**\n   * Create a tester with given criteria.\n   * If there are no criteria, returns `null`.\n   * @param {string|string[]} files The glob patterns for included files.\n   * @param {string|string[]} excludedFiles The glob patterns for excluded files.\n   * @param {string} basePath The path to the base directory to test paths.\n   * @returns {OverrideTester|null} The created instance or `null`.\n   */\n  static create(files, excludedFiles, basePath) {\n    const includePatterns = normalizePatterns(files);\n    const excludePatterns = normalizePatterns(excludedFiles);\n    let endsWithWildcard = false;\n    if (includePatterns.length === 0) {\n      return null;\n    }\n\n    // Rejects absolute paths or relative paths to parents.\n    for (const pattern of includePatterns) {\n      if (path.isAbsolute(pattern) || pattern.includes(\"..\")) {\n        throw new Error(`Invalid override pattern (expected relative path not containing '..'): ${pattern}`);\n      }\n      if (pattern.endsWith(\"*\")) {\n        endsWithWildcard = true;\n      }\n    }\n    for (const pattern of excludePatterns) {\n      if (path.isAbsolute(pattern) || pattern.includes(\"..\")) {\n        throw new Error(`Invalid override pattern (expected relative path not containing '..'): ${pattern}`);\n      }\n    }\n    const includes = toMatcher(includePatterns);\n    const excludes = toMatcher(excludePatterns);\n    return new OverrideTester([{\n      includes,\n      excludes\n    }], basePath, endsWithWildcard);\n  }\n\n  /**\n   * Combine two testers by logical and.\n   * If either of the testers was `null`, returns the other tester.\n   * The `basePath` property of the two must be the same value.\n   * @param {OverrideTester|null} a A tester.\n   * @param {OverrideTester|null} b Another tester.\n   * @returns {OverrideTester|null} Combined tester.\n   */\n  static and(a, b) {\n    if (!b) {\n      return a && new OverrideTester(a.patterns, a.basePath, a.endsWithWildcard);\n    }\n    if (!a) {\n      return new OverrideTester(b.patterns, b.basePath, b.endsWithWildcard);\n    }\n    assert.strictEqual(a.basePath, b.basePath);\n    return new OverrideTester(a.patterns.concat(b.patterns), a.basePath, a.endsWithWildcard || b.endsWithWildcard);\n  }\n\n  /**\n   * Initialize this instance.\n   * @param {Pattern[]} patterns The matchers.\n   * @param {string} basePath The base path.\n   * @param {boolean} endsWithWildcard If `true` then a pattern ends with `*`.\n   */\n  constructor(patterns, basePath, endsWithWildcard = false) {\n    /** @type {Pattern[]} */\n    this.patterns = patterns;\n\n    /** @type {string} */\n    this.basePath = basePath;\n\n    /** @type {boolean} */\n    this.endsWithWildcard = endsWithWildcard;\n  }\n\n  /**\n   * Test if a given path is matched or not.\n   * @param {string} filePath The absolute path to the target file.\n   * @returns {boolean} `true` if the path was matched.\n   */\n  test(filePath) {\n    if (typeof filePath !== \"string\" || !path.isAbsolute(filePath)) {\n      throw new Error(`'filePath' should be an absolute path, but got ${filePath}.`);\n    }\n    const relativePath = path.relative(this.basePath, filePath);\n    return this.patterns.every(({\n      includes,\n      excludes\n    }) => (!includes || includes.some(m => m.match(relativePath))) && (!excludes || !excludes.some(m => m.match(relativePath))));\n  }\n\n  // eslint-disable-next-line jsdoc/require-description\n  /**\n   * @returns {Object} a JSON compatible object.\n   */\n  toJSON() {\n    if (this.patterns.length === 1) {\n      return {\n        ...patternToJson(this.patterns[0]),\n        basePath: this.basePath\n      };\n    }\n    return {\n      AND: this.patterns.map(patternToJson),\n      basePath: this.basePath\n    };\n  }\n\n  // eslint-disable-next-line jsdoc/require-description\n  /**\n   * @returns {Object} an object to display by `console.log()`.\n   */\n  [util.inspect.custom]() {\n    return this.toJSON();\n  }\n}\nmodule.exports = {\n  OverrideTester\n};","map":{"version":3,"names":["assert","require","path","util","Minimatch","minimatchOpts","dot","matchBase","normalizePatterns","patterns","Array","isArray","filter","Boolean","toMatcher","length","map","pattern","test","slice","patternToJson","includes","excludes","m","OverrideTester","create","files","excludedFiles","basePath","includePatterns","excludePatterns","endsWithWildcard","isAbsolute","Error","endsWith","and","a","b","strictEqual","concat","constructor","filePath","relativePath","relative","every","some","match","toJSON","AND","inspect","custom","module","exports"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/@eslint/eslintrc/lib/config-array/override-tester.js"],"sourcesContent":["/**\n * @fileoverview `OverrideTester` class.\n *\n * `OverrideTester` class handles `files` property and `excludedFiles` property\n * of `overrides` config.\n *\n * It provides one method.\n *\n * - `test(filePath)`\n *      Test if a file path matches the pair of `files` property and\n *      `excludedFiles` property. The `filePath` argument must be an absolute\n *      path.\n *\n * `ConfigArrayFactory` creates `OverrideTester` objects when it processes\n * `overrides` properties.\n *\n * @author Toru Nagashima <https://github.com/mysticatea>\n */\n\"use strict\";\n\nconst assert = require(\"assert\");\nconst path = require(\"path\");\nconst util = require(\"util\");\nconst { Minimatch } = require(\"minimatch\");\nconst minimatchOpts = { dot: true, matchBase: true };\n\n/**\n * @typedef {Object} Pattern\n * @property {InstanceType<Minimatch>[] | null} includes The positive matchers.\n * @property {InstanceType<Minimatch>[] | null} excludes The negative matchers.\n */\n\n/**\n * Normalize a given pattern to an array.\n * @param {string|string[]|undefined} patterns A glob pattern or an array of glob patterns.\n * @returns {string[]|null} Normalized patterns.\n * @private\n */\nfunction normalizePatterns(patterns) {\n    if (Array.isArray(patterns)) {\n        return patterns.filter(Boolean);\n    }\n    if (typeof patterns === \"string\" && patterns) {\n        return [patterns];\n    }\n    return [];\n}\n\n/**\n * Create the matchers of given patterns.\n * @param {string[]} patterns The patterns.\n * @returns {InstanceType<Minimatch>[] | null} The matchers.\n */\nfunction toMatcher(patterns) {\n    if (patterns.length === 0) {\n        return null;\n    }\n    return patterns.map(pattern => {\n        if (/^\\.[/\\\\]/u.test(pattern)) {\n            return new Minimatch(\n                pattern.slice(2),\n\n                // `./*.js` should not match with `subdir/foo.js`\n                { ...minimatchOpts, matchBase: false }\n            );\n        }\n        return new Minimatch(pattern, minimatchOpts);\n    });\n}\n\n/**\n * Convert a given matcher to string.\n * @param {Pattern} matchers The matchers.\n * @returns {string} The string expression of the matcher.\n */\nfunction patternToJson({ includes, excludes }) {\n    return {\n        includes: includes && includes.map(m => m.pattern),\n        excludes: excludes && excludes.map(m => m.pattern)\n    };\n}\n\n/**\n * The class to test given paths are matched by the patterns.\n */\nclass OverrideTester {\n\n    /**\n     * Create a tester with given criteria.\n     * If there are no criteria, returns `null`.\n     * @param {string|string[]} files The glob patterns for included files.\n     * @param {string|string[]} excludedFiles The glob patterns for excluded files.\n     * @param {string} basePath The path to the base directory to test paths.\n     * @returns {OverrideTester|null} The created instance or `null`.\n     */\n    static create(files, excludedFiles, basePath) {\n        const includePatterns = normalizePatterns(files);\n        const excludePatterns = normalizePatterns(excludedFiles);\n        let endsWithWildcard = false;\n\n        if (includePatterns.length === 0) {\n            return null;\n        }\n\n        // Rejects absolute paths or relative paths to parents.\n        for (const pattern of includePatterns) {\n            if (path.isAbsolute(pattern) || pattern.includes(\"..\")) {\n                throw new Error(`Invalid override pattern (expected relative path not containing '..'): ${pattern}`);\n            }\n            if (pattern.endsWith(\"*\")) {\n                endsWithWildcard = true;\n            }\n        }\n        for (const pattern of excludePatterns) {\n            if (path.isAbsolute(pattern) || pattern.includes(\"..\")) {\n                throw new Error(`Invalid override pattern (expected relative path not containing '..'): ${pattern}`);\n            }\n        }\n\n        const includes = toMatcher(includePatterns);\n        const excludes = toMatcher(excludePatterns);\n\n        return new OverrideTester(\n            [{ includes, excludes }],\n            basePath,\n            endsWithWildcard\n        );\n    }\n\n    /**\n     * Combine two testers by logical and.\n     * If either of the testers was `null`, returns the other tester.\n     * The `basePath` property of the two must be the same value.\n     * @param {OverrideTester|null} a A tester.\n     * @param {OverrideTester|null} b Another tester.\n     * @returns {OverrideTester|null} Combined tester.\n     */\n    static and(a, b) {\n        if (!b) {\n            return a && new OverrideTester(\n                a.patterns,\n                a.basePath,\n                a.endsWithWildcard\n            );\n        }\n        if (!a) {\n            return new OverrideTester(\n                b.patterns,\n                b.basePath,\n                b.endsWithWildcard\n            );\n        }\n\n        assert.strictEqual(a.basePath, b.basePath);\n        return new OverrideTester(\n            a.patterns.concat(b.patterns),\n            a.basePath,\n            a.endsWithWildcard || b.endsWithWildcard\n        );\n    }\n\n    /**\n     * Initialize this instance.\n     * @param {Pattern[]} patterns The matchers.\n     * @param {string} basePath The base path.\n     * @param {boolean} endsWithWildcard If `true` then a pattern ends with `*`.\n     */\n    constructor(patterns, basePath, endsWithWildcard = false) {\n\n        /** @type {Pattern[]} */\n        this.patterns = patterns;\n\n        /** @type {string} */\n        this.basePath = basePath;\n\n        /** @type {boolean} */\n        this.endsWithWildcard = endsWithWildcard;\n    }\n\n    /**\n     * Test if a given path is matched or not.\n     * @param {string} filePath The absolute path to the target file.\n     * @returns {boolean} `true` if the path was matched.\n     */\n    test(filePath) {\n        if (typeof filePath !== \"string\" || !path.isAbsolute(filePath)) {\n            throw new Error(`'filePath' should be an absolute path, but got ${filePath}.`);\n        }\n        const relativePath = path.relative(this.basePath, filePath);\n\n        return this.patterns.every(({ includes, excludes }) => (\n            (!includes || includes.some(m => m.match(relativePath))) &&\n            (!excludes || !excludes.some(m => m.match(relativePath)))\n        ));\n    }\n\n    // eslint-disable-next-line jsdoc/require-description\n    /**\n     * @returns {Object} a JSON compatible object.\n     */\n    toJSON() {\n        if (this.patterns.length === 1) {\n            return {\n                ...patternToJson(this.patterns[0]),\n                basePath: this.basePath\n            };\n        }\n        return {\n            AND: this.patterns.map(patternToJson),\n            basePath: this.basePath\n        };\n    }\n\n    // eslint-disable-next-line jsdoc/require-description\n    /**\n     * @returns {Object} an object to display by `console.log()`.\n     */\n    [util.inspect.custom]() {\n        return this.toJSON();\n    }\n}\n\nmodule.exports = { OverrideTester };\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}