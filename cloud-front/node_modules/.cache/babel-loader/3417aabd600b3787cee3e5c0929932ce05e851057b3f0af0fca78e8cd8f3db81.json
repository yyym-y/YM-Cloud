{"ast":null,"code":"/**\n * @fileoverview Flag expressions in statement position that do not side effect\n * @author Michael Ficarra\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/**\n * Returns `true`.\n * @returns {boolean} `true`.\n */\nfunction alwaysTrue() {\n  return true;\n}\n\n/**\n * Returns `false`.\n * @returns {boolean} `false`.\n */\nfunction alwaysFalse() {\n  return false;\n}\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow unused expressions\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-unused-expressions\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        allowShortCircuit: {\n          type: \"boolean\",\n          default: false\n        },\n        allowTernary: {\n          type: \"boolean\",\n          default: false\n        },\n        allowTaggedTemplates: {\n          type: \"boolean\",\n          default: false\n        },\n        enforceForJSX: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unusedExpression: \"Expected an assignment or function call and instead saw an expression.\"\n    }\n  },\n  create(context) {\n    const config = context.options[0] || {},\n      allowShortCircuit = config.allowShortCircuit || false,\n      allowTernary = config.allowTernary || false,\n      allowTaggedTemplates = config.allowTaggedTemplates || false,\n      enforceForJSX = config.enforceForJSX || false;\n\n    // eslint-disable-next-line jsdoc/require-description\n    /**\n     * @param {ASTNode} node any node\n     * @returns {boolean} whether the given node structurally represents a directive\n     */\n    function looksLikeDirective(node) {\n      return node.type === \"ExpressionStatement\" && node.expression.type === \"Literal\" && typeof node.expression.value === \"string\";\n    }\n\n    // eslint-disable-next-line jsdoc/require-description\n    /**\n     * @param {Function} predicate ([a] -> Boolean) the function used to make the determination\n     * @param {a[]} list the input list\n     * @returns {a[]} the leading sequence of members in the given list that pass the given predicate\n     */\n    function takeWhile(predicate, list) {\n      for (let i = 0; i < list.length; ++i) {\n        if (!predicate(list[i])) {\n          return list.slice(0, i);\n        }\n      }\n      return list.slice();\n    }\n\n    // eslint-disable-next-line jsdoc/require-description\n    /**\n     * @param {ASTNode} node a Program or BlockStatement node\n     * @returns {ASTNode[]} the leading sequence of directive nodes in the given node's body\n     */\n    function directives(node) {\n      return takeWhile(looksLikeDirective, node.body);\n    }\n\n    // eslint-disable-next-line jsdoc/require-description\n    /**\n     * @param {ASTNode} node any node\n     * @param {ASTNode[]} ancestors the given node's ancestors\n     * @returns {boolean} whether the given node is considered a directive in its current position\n     */\n    function isDirective(node, ancestors) {\n      const parent = ancestors[ancestors.length - 1],\n        grandparent = ancestors[ancestors.length - 2];\n      return (parent.type === \"Program\" || parent.type === \"BlockStatement\" && /Function/u.test(grandparent.type)) && directives(parent).indexOf(node) >= 0;\n    }\n\n    /**\n     * The member functions return `true` if the type has no side-effects.\n     * Unknown nodes are handled as `false`, then this rule ignores those.\n     */\n    const Checker = Object.assign(Object.create(null), {\n      isDisallowed(node) {\n        return (Checker[node.type] || alwaysFalse)(node);\n      },\n      ArrayExpression: alwaysTrue,\n      ArrowFunctionExpression: alwaysTrue,\n      BinaryExpression: alwaysTrue,\n      ChainExpression(node) {\n        return Checker.isDisallowed(node.expression);\n      },\n      ClassExpression: alwaysTrue,\n      ConditionalExpression(node) {\n        if (allowTernary) {\n          return Checker.isDisallowed(node.consequent) || Checker.isDisallowed(node.alternate);\n        }\n        return true;\n      },\n      FunctionExpression: alwaysTrue,\n      Identifier: alwaysTrue,\n      JSXElement() {\n        return enforceForJSX;\n      },\n      JSXFragment() {\n        return enforceForJSX;\n      },\n      Literal: alwaysTrue,\n      LogicalExpression(node) {\n        if (allowShortCircuit) {\n          return Checker.isDisallowed(node.right);\n        }\n        return true;\n      },\n      MemberExpression: alwaysTrue,\n      MetaProperty: alwaysTrue,\n      ObjectExpression: alwaysTrue,\n      SequenceExpression: alwaysTrue,\n      TaggedTemplateExpression() {\n        return !allowTaggedTemplates;\n      },\n      TemplateLiteral: alwaysTrue,\n      ThisExpression: alwaysTrue,\n      UnaryExpression(node) {\n        return node.operator !== \"void\" && node.operator !== \"delete\";\n      }\n    });\n    return {\n      ExpressionStatement(node) {\n        if (Checker.isDisallowed(node.expression) && !isDirective(node, context.getAncestors())) {\n          context.report({\n            node,\n            messageId: \"unusedExpression\"\n          });\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["alwaysTrue","alwaysFalse","module","exports","meta","type","docs","description","category","recommended","url","schema","properties","allowShortCircuit","default","allowTernary","allowTaggedTemplates","enforceForJSX","additionalProperties","messages","unusedExpression","create","context","config","options","looksLikeDirective","node","expression","value","takeWhile","predicate","list","i","length","slice","directives","body","isDirective","ancestors","parent","grandparent","test","indexOf","Checker","Object","assign","isDisallowed","ArrayExpression","ArrowFunctionExpression","BinaryExpression","ChainExpression","ClassExpression","ConditionalExpression","consequent","alternate","FunctionExpression","Identifier","JSXElement","JSXFragment","Literal","LogicalExpression","right","MemberExpression","MetaProperty","ObjectExpression","SequenceExpression","TaggedTemplateExpression","TemplateLiteral","ThisExpression","UnaryExpression","operator","ExpressionStatement","getAncestors","report","messageId"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/no-unused-expressions.js"],"sourcesContent":["/**\n * @fileoverview Flag expressions in statement position that do not side effect\n * @author Michael Ficarra\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/**\n * Returns `true`.\n * @returns {boolean} `true`.\n */\nfunction alwaysTrue() {\n    return true;\n}\n\n/**\n * Returns `false`.\n * @returns {boolean} `false`.\n */\nfunction alwaysFalse() {\n    return false;\n}\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow unused expressions\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-unused-expressions\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allowShortCircuit: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    allowTernary: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    allowTaggedTemplates: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    enforceForJSX: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            unusedExpression: \"Expected an assignment or function call and instead saw an expression.\"\n        }\n    },\n\n    create(context) {\n        const config = context.options[0] || {},\n            allowShortCircuit = config.allowShortCircuit || false,\n            allowTernary = config.allowTernary || false,\n            allowTaggedTemplates = config.allowTaggedTemplates || false,\n            enforceForJSX = config.enforceForJSX || false;\n\n        // eslint-disable-next-line jsdoc/require-description\n        /**\n         * @param {ASTNode} node any node\n         * @returns {boolean} whether the given node structurally represents a directive\n         */\n        function looksLikeDirective(node) {\n            return node.type === \"ExpressionStatement\" &&\n                node.expression.type === \"Literal\" && typeof node.expression.value === \"string\";\n        }\n\n        // eslint-disable-next-line jsdoc/require-description\n        /**\n         * @param {Function} predicate ([a] -> Boolean) the function used to make the determination\n         * @param {a[]} list the input list\n         * @returns {a[]} the leading sequence of members in the given list that pass the given predicate\n         */\n        function takeWhile(predicate, list) {\n            for (let i = 0; i < list.length; ++i) {\n                if (!predicate(list[i])) {\n                    return list.slice(0, i);\n                }\n            }\n            return list.slice();\n        }\n\n        // eslint-disable-next-line jsdoc/require-description\n        /**\n         * @param {ASTNode} node a Program or BlockStatement node\n         * @returns {ASTNode[]} the leading sequence of directive nodes in the given node's body\n         */\n        function directives(node) {\n            return takeWhile(looksLikeDirective, node.body);\n        }\n\n        // eslint-disable-next-line jsdoc/require-description\n        /**\n         * @param {ASTNode} node any node\n         * @param {ASTNode[]} ancestors the given node's ancestors\n         * @returns {boolean} whether the given node is considered a directive in its current position\n         */\n        function isDirective(node, ancestors) {\n            const parent = ancestors[ancestors.length - 1],\n                grandparent = ancestors[ancestors.length - 2];\n\n            return (parent.type === \"Program\" || parent.type === \"BlockStatement\" &&\n                    (/Function/u.test(grandparent.type))) &&\n                    directives(parent).indexOf(node) >= 0;\n        }\n\n        /**\n         * The member functions return `true` if the type has no side-effects.\n         * Unknown nodes are handled as `false`, then this rule ignores those.\n         */\n        const Checker = Object.assign(Object.create(null), {\n            isDisallowed(node) {\n                return (Checker[node.type] || alwaysFalse)(node);\n            },\n\n            ArrayExpression: alwaysTrue,\n            ArrowFunctionExpression: alwaysTrue,\n            BinaryExpression: alwaysTrue,\n            ChainExpression(node) {\n                return Checker.isDisallowed(node.expression);\n            },\n            ClassExpression: alwaysTrue,\n            ConditionalExpression(node) {\n                if (allowTernary) {\n                    return Checker.isDisallowed(node.consequent) || Checker.isDisallowed(node.alternate);\n                }\n                return true;\n            },\n            FunctionExpression: alwaysTrue,\n            Identifier: alwaysTrue,\n            JSXElement() {\n                return enforceForJSX;\n            },\n            JSXFragment() {\n                return enforceForJSX;\n            },\n            Literal: alwaysTrue,\n            LogicalExpression(node) {\n                if (allowShortCircuit) {\n                    return Checker.isDisallowed(node.right);\n                }\n                return true;\n            },\n            MemberExpression: alwaysTrue,\n            MetaProperty: alwaysTrue,\n            ObjectExpression: alwaysTrue,\n            SequenceExpression: alwaysTrue,\n            TaggedTemplateExpression() {\n                return !allowTaggedTemplates;\n            },\n            TemplateLiteral: alwaysTrue,\n            ThisExpression: alwaysTrue,\n            UnaryExpression(node) {\n                return node.operator !== \"void\" && node.operator !== \"delete\";\n            }\n        });\n\n        return {\n            ExpressionStatement(node) {\n                if (Checker.isDisallowed(node.expression) && !isDirective(node, context.getAncestors())) {\n                    context.report({ node, messageId: \"unusedExpression\" });\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}