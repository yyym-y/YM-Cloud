{"ast":null,"code":"/**\n * @fileoverview Abstraction of JavaScript source code.\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nrequire(\"core-js/modules/es.array.push.js\");\nconst {\n    isCommentToken\n  } = require(\"eslint-utils\"),\n  TokenStore = require(\"./token-store\"),\n  astUtils = require(\"../shared/ast-utils\"),\n  Traverser = require(\"../shared/traverser\");\n\n//------------------------------------------------------------------------------\n// Private\n//------------------------------------------------------------------------------\n\n/**\n * Validates that the given AST has the required information.\n * @param {ASTNode} ast The Program node of the AST to check.\n * @throws {Error} If the AST doesn't contain the correct information.\n * @returns {void}\n * @private\n */\nfunction validate(ast) {\n  if (!ast.tokens) {\n    throw new Error(\"AST is missing the tokens array.\");\n  }\n  if (!ast.comments) {\n    throw new Error(\"AST is missing the comments array.\");\n  }\n  if (!ast.loc) {\n    throw new Error(\"AST is missing location information.\");\n  }\n  if (!ast.range) {\n    throw new Error(\"AST is missing range information\");\n  }\n}\n\n/**\n * Check to see if its a ES6 export declaration.\n * @param {ASTNode} astNode An AST node.\n * @returns {boolean} whether the given node represents an export declaration.\n * @private\n */\nfunction looksLikeExport(astNode) {\n  return astNode.type === \"ExportDefaultDeclaration\" || astNode.type === \"ExportNamedDeclaration\" || astNode.type === \"ExportAllDeclaration\" || astNode.type === \"ExportSpecifier\";\n}\n\n/**\n * Merges two sorted lists into a larger sorted list in O(n) time.\n * @param {Token[]} tokens The list of tokens.\n * @param {Token[]} comments The list of comments.\n * @returns {Token[]} A sorted list of tokens and comments.\n * @private\n */\nfunction sortedMerge(tokens, comments) {\n  const result = [];\n  let tokenIndex = 0;\n  let commentIndex = 0;\n  while (tokenIndex < tokens.length || commentIndex < comments.length) {\n    if (commentIndex >= comments.length || tokenIndex < tokens.length && tokens[tokenIndex].range[0] < comments[commentIndex].range[0]) {\n      result.push(tokens[tokenIndex++]);\n    } else {\n      result.push(comments[commentIndex++]);\n    }\n  }\n  return result;\n}\n\n/**\n * Determines if two nodes or tokens overlap.\n * @param {ASTNode|Token} first The first node or token to check.\n * @param {ASTNode|Token} second The second node or token to check.\n * @returns {boolean} True if the two nodes or tokens overlap.\n * @private\n */\nfunction nodesOrTokensOverlap(first, second) {\n  return first.range[0] <= second.range[0] && first.range[1] >= second.range[0] || second.range[0] <= first.range[0] && second.range[1] >= first.range[0];\n}\n\n/**\n * Determines if two nodes or tokens have at least one whitespace character\n * between them. Order does not matter. Returns false if the given nodes or\n * tokens overlap.\n * @param {SourceCode} sourceCode The source code object.\n * @param {ASTNode|Token} first The first node or token to check between.\n * @param {ASTNode|Token} second The second node or token to check between.\n * @param {boolean} checkInsideOfJSXText If `true` is present, check inside of JSXText tokens for backward compatibility.\n * @returns {boolean} True if there is a whitespace character between\n * any of the tokens found between the two given nodes or tokens.\n * @public\n */\nfunction isSpaceBetween(sourceCode, first, second, checkInsideOfJSXText) {\n  if (nodesOrTokensOverlap(first, second)) {\n    return false;\n  }\n  const [startingNodeOrToken, endingNodeOrToken] = first.range[1] <= second.range[0] ? [first, second] : [second, first];\n  const firstToken = sourceCode.getLastToken(startingNodeOrToken) || startingNodeOrToken;\n  const finalToken = sourceCode.getFirstToken(endingNodeOrToken) || endingNodeOrToken;\n  let currentToken = firstToken;\n  while (currentToken !== finalToken) {\n    const nextToken = sourceCode.getTokenAfter(currentToken, {\n      includeComments: true\n    });\n    if (currentToken.range[1] !== nextToken.range[0] ||\n    /*\n     * For backward compatibility, check spaces in JSXText.\n     * https://github.com/eslint/eslint/issues/12614\n     */\n\n    checkInsideOfJSXText && nextToken !== finalToken && nextToken.type === \"JSXText\" && /\\s/u.test(nextToken.value)) {\n      return true;\n    }\n    currentToken = nextToken;\n  }\n  return false;\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nclass SourceCode extends TokenStore {\n  /**\n   * Represents parsed source code.\n   * @param {string|Object} textOrConfig The source code text or config object.\n   * @param {string} textOrConfig.text The source code text.\n   * @param {ASTNode} textOrConfig.ast The Program node of the AST representing the code. This AST should be created from the text that BOM was stripped.\n   * @param {Object|null} textOrConfig.parserServices The parser services.\n   * @param {ScopeManager|null} textOrConfig.scopeManager The scope of this source code.\n   * @param {Object|null} textOrConfig.visitorKeys The visitor keys to traverse AST.\n   * @param {ASTNode} [astIfNoConfig] The Program node of the AST representing the code. This AST should be created from the text that BOM was stripped.\n   */\n  constructor(textOrConfig, astIfNoConfig) {\n    let text, ast, parserServices, scopeManager, visitorKeys;\n\n    // Process overloading.\n    if (typeof textOrConfig === \"string\") {\n      text = textOrConfig;\n      ast = astIfNoConfig;\n    } else if (typeof textOrConfig === \"object\" && textOrConfig !== null) {\n      text = textOrConfig.text;\n      ast = textOrConfig.ast;\n      parserServices = textOrConfig.parserServices;\n      scopeManager = textOrConfig.scopeManager;\n      visitorKeys = textOrConfig.visitorKeys;\n    }\n    validate(ast);\n    super(ast.tokens, ast.comments);\n\n    /**\n     * The flag to indicate that the source code has Unicode BOM.\n     * @type boolean\n     */\n    this.hasBOM = text.charCodeAt(0) === 0xFEFF;\n\n    /**\n     * The original text source code.\n     * BOM was stripped from this text.\n     * @type string\n     */\n    this.text = this.hasBOM ? text.slice(1) : text;\n\n    /**\n     * The parsed AST for the source code.\n     * @type ASTNode\n     */\n    this.ast = ast;\n\n    /**\n     * The parser services of this source code.\n     * @type {Object}\n     */\n    this.parserServices = parserServices || {};\n\n    /**\n     * The scope of this source code.\n     * @type {ScopeManager|null}\n     */\n    this.scopeManager = scopeManager || null;\n\n    /**\n     * The visitor keys to traverse AST.\n     * @type {Object}\n     */\n    this.visitorKeys = visitorKeys || Traverser.DEFAULT_VISITOR_KEYS;\n\n    // Check the source text for the presence of a shebang since it is parsed as a standard line comment.\n    const shebangMatched = this.text.match(astUtils.shebangPattern);\n    const hasShebang = shebangMatched && ast.comments.length && ast.comments[0].value === shebangMatched[1];\n    if (hasShebang) {\n      ast.comments[0].type = \"Shebang\";\n    }\n    this.tokensAndComments = sortedMerge(ast.tokens, ast.comments);\n\n    /**\n     * The source code split into lines according to ECMA-262 specification.\n     * This is done to avoid each rule needing to do so separately.\n     * @type string[]\n     */\n    this.lines = [];\n    this.lineStartIndices = [0];\n    const lineEndingPattern = astUtils.createGlobalLinebreakMatcher();\n    let match;\n\n    /*\n     * Previously, this was implemented using a regex that\n     * matched a sequence of non-linebreak characters followed by a\n     * linebreak, then adding the lengths of the matches. However,\n     * this caused a catastrophic backtracking issue when the end\n     * of a file contained a large number of non-newline characters.\n     * To avoid this, the current implementation just matches newlines\n     * and uses match.index to get the correct line start indices.\n     */\n    while (match = lineEndingPattern.exec(this.text)) {\n      this.lines.push(this.text.slice(this.lineStartIndices[this.lineStartIndices.length - 1], match.index));\n      this.lineStartIndices.push(match.index + match[0].length);\n    }\n    this.lines.push(this.text.slice(this.lineStartIndices[this.lineStartIndices.length - 1]));\n\n    // Cache for comments found using getComments().\n    this._commentCache = new WeakMap();\n\n    // don't allow modification of this object\n    Object.freeze(this);\n    Object.freeze(this.lines);\n  }\n\n  /**\n   * Split the source code into multiple lines based on the line delimiters.\n   * @param {string} text Source code as a string.\n   * @returns {string[]} Array of source code lines.\n   * @public\n   */\n  static splitLines(text) {\n    return text.split(astUtils.createGlobalLinebreakMatcher());\n  }\n\n  /**\n   * Gets the source code for the given node.\n   * @param {ASTNode} [node] The AST node to get the text for.\n   * @param {int} [beforeCount] The number of characters before the node to retrieve.\n   * @param {int} [afterCount] The number of characters after the node to retrieve.\n   * @returns {string} The text representing the AST node.\n   * @public\n   */\n  getText(node, beforeCount, afterCount) {\n    if (node) {\n      return this.text.slice(Math.max(node.range[0] - (beforeCount || 0), 0), node.range[1] + (afterCount || 0));\n    }\n    return this.text;\n  }\n\n  /**\n   * Gets the entire source text split into an array of lines.\n   * @returns {Array} The source text as an array of lines.\n   * @public\n   */\n  getLines() {\n    return this.lines;\n  }\n\n  /**\n   * Retrieves an array containing all comments in the source code.\n   * @returns {ASTNode[]} An array of comment nodes.\n   * @public\n   */\n  getAllComments() {\n    return this.ast.comments;\n  }\n\n  /**\n   * Gets all comments for the given node.\n   * @param {ASTNode} node The AST node to get the comments for.\n   * @returns {Object} An object containing a leading and trailing array\n   *      of comments indexed by their position.\n   * @public\n   * @deprecated replaced by getCommentsBefore(), getCommentsAfter(), and getCommentsInside().\n   */\n  getComments(node) {\n    if (this._commentCache.has(node)) {\n      return this._commentCache.get(node);\n    }\n    const comments = {\n      leading: [],\n      trailing: []\n    };\n\n    /*\n     * Return all comments as leading comments of the Program node when\n     * there is no executable code.\n     */\n    if (node.type === \"Program\") {\n      if (node.body.length === 0) {\n        comments.leading = node.comments;\n      }\n    } else {\n      /*\n       * Return comments as trailing comments of nodes that only contain\n       * comments (to mimic the comment attachment behavior present in Espree).\n       */\n      if ((node.type === \"BlockStatement\" || node.type === \"ClassBody\") && node.body.length === 0 || node.type === \"ObjectExpression\" && node.properties.length === 0 || node.type === \"ArrayExpression\" && node.elements.length === 0 || node.type === \"SwitchStatement\" && node.cases.length === 0) {\n        comments.trailing = this.getTokens(node, {\n          includeComments: true,\n          filter: isCommentToken\n        });\n      }\n\n      /*\n       * Iterate over tokens before and after node and collect comment tokens.\n       * Do not include comments that exist outside of the parent node\n       * to avoid duplication.\n       */\n      let currentToken = this.getTokenBefore(node, {\n        includeComments: true\n      });\n      while (currentToken && isCommentToken(currentToken)) {\n        if (node.parent && node.parent.type !== \"Program\" && currentToken.start < node.parent.start) {\n          break;\n        }\n        comments.leading.push(currentToken);\n        currentToken = this.getTokenBefore(currentToken, {\n          includeComments: true\n        });\n      }\n      comments.leading.reverse();\n      currentToken = this.getTokenAfter(node, {\n        includeComments: true\n      });\n      while (currentToken && isCommentToken(currentToken)) {\n        if (node.parent && node.parent.type !== \"Program\" && currentToken.end > node.parent.end) {\n          break;\n        }\n        comments.trailing.push(currentToken);\n        currentToken = this.getTokenAfter(currentToken, {\n          includeComments: true\n        });\n      }\n    }\n    this._commentCache.set(node, comments);\n    return comments;\n  }\n\n  /**\n   * Retrieves the JSDoc comment for a given node.\n   * @param {ASTNode} node The AST node to get the comment for.\n   * @returns {Token|null} The Block comment token containing the JSDoc comment\n   *      for the given node or null if not found.\n   * @public\n   * @deprecated\n   */\n  getJSDocComment(node) {\n    /**\n     * Checks for the presence of a JSDoc comment for the given node and returns it.\n     * @param {ASTNode} astNode The AST node to get the comment for.\n     * @returns {Token|null} The Block comment token containing the JSDoc comment\n     *      for the given node or null if not found.\n     * @private\n     */\n    const findJSDocComment = astNode => {\n      const tokenBefore = this.getTokenBefore(astNode, {\n        includeComments: true\n      });\n      if (tokenBefore && isCommentToken(tokenBefore) && tokenBefore.type === \"Block\" && tokenBefore.value.charAt(0) === \"*\" && astNode.loc.start.line - tokenBefore.loc.end.line <= 1) {\n        return tokenBefore;\n      }\n      return null;\n    };\n    let parent = node.parent;\n    switch (node.type) {\n      case \"ClassDeclaration\":\n      case \"FunctionDeclaration\":\n        return findJSDocComment(looksLikeExport(parent) ? parent : node);\n      case \"ClassExpression\":\n        return findJSDocComment(parent.parent);\n      case \"ArrowFunctionExpression\":\n      case \"FunctionExpression\":\n        if (parent.type !== \"CallExpression\" && parent.type !== \"NewExpression\") {\n          while (!this.getCommentsBefore(parent).length && !/Function/u.test(parent.type) && parent.type !== \"MethodDefinition\" && parent.type !== \"Property\") {\n            parent = parent.parent;\n            if (!parent) {\n              break;\n            }\n          }\n          if (parent && parent.type !== \"FunctionDeclaration\" && parent.type !== \"Program\") {\n            return findJSDocComment(parent);\n          }\n        }\n        return findJSDocComment(node);\n\n      // falls through\n      default:\n        return null;\n    }\n  }\n\n  /**\n   * Gets the deepest node containing a range index.\n   * @param {int} index Range index of the desired node.\n   * @returns {ASTNode} The node if found or null if not found.\n   * @public\n   */\n  getNodeByRangeIndex(index) {\n    let result = null;\n    Traverser.traverse(this.ast, {\n      visitorKeys: this.visitorKeys,\n      enter(node) {\n        if (node.range[0] <= index && index < node.range[1]) {\n          result = node;\n        } else {\n          this.skip();\n        }\n      },\n      leave(node) {\n        if (node === result) {\n          this.break();\n        }\n      }\n    });\n    return result;\n  }\n\n  /**\n   * Determines if two nodes or tokens have at least one whitespace character\n   * between them. Order does not matter. Returns false if the given nodes or\n   * tokens overlap.\n   * @param {ASTNode|Token} first The first node or token to check between.\n   * @param {ASTNode|Token} second The second node or token to check between.\n   * @returns {boolean} True if there is a whitespace character between\n   * any of the tokens found between the two given nodes or tokens.\n   * @public\n   */\n  isSpaceBetween(first, second) {\n    return isSpaceBetween(this, first, second, false);\n  }\n\n  /**\n   * Determines if two nodes or tokens have at least one whitespace character\n   * between them. Order does not matter. Returns false if the given nodes or\n   * tokens overlap.\n   * For backward compatibility, this method returns true if there are\n   * `JSXText` tokens that contain whitespaces between the two.\n   * @param {ASTNode|Token} first The first node or token to check between.\n   * @param {ASTNode|Token} second The second node or token to check between.\n   * @returns {boolean} True if there is a whitespace character between\n   * any of the tokens found between the two given nodes or tokens.\n   * @deprecated in favor of isSpaceBetween().\n   * @public\n   */\n  isSpaceBetweenTokens(first, second) {\n    return isSpaceBetween(this, first, second, true);\n  }\n\n  /**\n   * Converts a source text index into a (line, column) pair.\n   * @param {number} index The index of a character in a file\n   * @returns {Object} A {line, column} location object with a 0-indexed column\n   * @public\n   */\n  getLocFromIndex(index) {\n    if (typeof index !== \"number\") {\n      throw new TypeError(\"Expected `index` to be a number.\");\n    }\n    if (index < 0 || index > this.text.length) {\n      throw new RangeError(`Index out of range (requested index ${index}, but source text has length ${this.text.length}).`);\n    }\n\n    /*\n     * For an argument of this.text.length, return the location one \"spot\" past the last character\n     * of the file. If the last character is a linebreak, the location will be column 0 of the next\n     * line; otherwise, the location will be in the next column on the same line.\n     *\n     * See getIndexFromLoc for the motivation for this special case.\n     */\n    if (index === this.text.length) {\n      return {\n        line: this.lines.length,\n        column: this.lines[this.lines.length - 1].length\n      };\n    }\n\n    /*\n     * To figure out which line index is on, determine the last place at which index could\n     * be inserted into lineStartIndices to keep the list sorted.\n     */\n    const lineNumber = index >= this.lineStartIndices[this.lineStartIndices.length - 1] ? this.lineStartIndices.length : this.lineStartIndices.findIndex(el => index < el);\n    return {\n      line: lineNumber,\n      column: index - this.lineStartIndices[lineNumber - 1]\n    };\n  }\n\n  /**\n   * Converts a (line, column) pair into a range index.\n   * @param {Object} loc A line/column location\n   * @param {number} loc.line The line number of the location (1-indexed)\n   * @param {number} loc.column The column number of the location (0-indexed)\n   * @returns {number} The range index of the location in the file.\n   * @public\n   */\n  getIndexFromLoc(loc) {\n    if (typeof loc !== \"object\" || typeof loc.line !== \"number\" || typeof loc.column !== \"number\") {\n      throw new TypeError(\"Expected `loc` to be an object with numeric `line` and `column` properties.\");\n    }\n    if (loc.line <= 0) {\n      throw new RangeError(`Line number out of range (line ${loc.line} requested). Line numbers should be 1-based.`);\n    }\n    if (loc.line > this.lineStartIndices.length) {\n      throw new RangeError(`Line number out of range (line ${loc.line} requested, but only ${this.lineStartIndices.length} lines present).`);\n    }\n    const lineStartIndex = this.lineStartIndices[loc.line - 1];\n    const lineEndIndex = loc.line === this.lineStartIndices.length ? this.text.length : this.lineStartIndices[loc.line];\n    const positionIndex = lineStartIndex + loc.column;\n\n    /*\n     * By design, getIndexFromLoc({ line: lineNum, column: 0 }) should return the start index of\n     * the given line, provided that the line number is valid element of this.lines. Since the\n     * last element of this.lines is an empty string for files with trailing newlines, add a\n     * special case where getting the index for the first location after the end of the file\n     * will return the length of the file, rather than throwing an error. This allows rules to\n     * use getIndexFromLoc consistently without worrying about edge cases at the end of a file.\n     */\n    if (loc.line === this.lineStartIndices.length && positionIndex > lineEndIndex || loc.line < this.lineStartIndices.length && positionIndex >= lineEndIndex) {\n      throw new RangeError(`Column number out of range (column ${loc.column} requested, but the length of line ${loc.line} is ${lineEndIndex - lineStartIndex}).`);\n    }\n    return positionIndex;\n  }\n}\nmodule.exports = SourceCode;","map":{"version":3,"names":["require","isCommentToken","TokenStore","astUtils","Traverser","validate","ast","tokens","Error","comments","loc","range","looksLikeExport","astNode","type","sortedMerge","result","tokenIndex","commentIndex","length","push","nodesOrTokensOverlap","first","second","isSpaceBetween","sourceCode","checkInsideOfJSXText","startingNodeOrToken","endingNodeOrToken","firstToken","getLastToken","finalToken","getFirstToken","currentToken","nextToken","getTokenAfter","includeComments","test","value","SourceCode","constructor","textOrConfig","astIfNoConfig","text","parserServices","scopeManager","visitorKeys","hasBOM","charCodeAt","slice","DEFAULT_VISITOR_KEYS","shebangMatched","match","shebangPattern","hasShebang","tokensAndComments","lines","lineStartIndices","lineEndingPattern","createGlobalLinebreakMatcher","exec","index","_commentCache","WeakMap","Object","freeze","splitLines","split","getText","node","beforeCount","afterCount","Math","max","getLines","getAllComments","getComments","has","get","leading","trailing","body","properties","elements","cases","getTokens","filter","getTokenBefore","parent","start","reverse","end","set","getJSDocComment","findJSDocComment","tokenBefore","charAt","line","getCommentsBefore","getNodeByRangeIndex","traverse","enter","skip","leave","break","isSpaceBetweenTokens","getLocFromIndex","TypeError","RangeError","column","lineNumber","findIndex","el","getIndexFromLoc","lineStartIndex","lineEndIndex","positionIndex","module","exports"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/source-code/source-code.js"],"sourcesContent":["/**\n * @fileoverview Abstraction of JavaScript source code.\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst\n    { isCommentToken } = require(\"eslint-utils\"),\n    TokenStore = require(\"./token-store\"),\n    astUtils = require(\"../shared/ast-utils\"),\n    Traverser = require(\"../shared/traverser\");\n\n//------------------------------------------------------------------------------\n// Private\n//------------------------------------------------------------------------------\n\n/**\n * Validates that the given AST has the required information.\n * @param {ASTNode} ast The Program node of the AST to check.\n * @throws {Error} If the AST doesn't contain the correct information.\n * @returns {void}\n * @private\n */\nfunction validate(ast) {\n    if (!ast.tokens) {\n        throw new Error(\"AST is missing the tokens array.\");\n    }\n\n    if (!ast.comments) {\n        throw new Error(\"AST is missing the comments array.\");\n    }\n\n    if (!ast.loc) {\n        throw new Error(\"AST is missing location information.\");\n    }\n\n    if (!ast.range) {\n        throw new Error(\"AST is missing range information\");\n    }\n}\n\n/**\n * Check to see if its a ES6 export declaration.\n * @param {ASTNode} astNode An AST node.\n * @returns {boolean} whether the given node represents an export declaration.\n * @private\n */\nfunction looksLikeExport(astNode) {\n    return astNode.type === \"ExportDefaultDeclaration\" || astNode.type === \"ExportNamedDeclaration\" ||\n        astNode.type === \"ExportAllDeclaration\" || astNode.type === \"ExportSpecifier\";\n}\n\n/**\n * Merges two sorted lists into a larger sorted list in O(n) time.\n * @param {Token[]} tokens The list of tokens.\n * @param {Token[]} comments The list of comments.\n * @returns {Token[]} A sorted list of tokens and comments.\n * @private\n */\nfunction sortedMerge(tokens, comments) {\n    const result = [];\n    let tokenIndex = 0;\n    let commentIndex = 0;\n\n    while (tokenIndex < tokens.length || commentIndex < comments.length) {\n        if (commentIndex >= comments.length || tokenIndex < tokens.length && tokens[tokenIndex].range[0] < comments[commentIndex].range[0]) {\n            result.push(tokens[tokenIndex++]);\n        } else {\n            result.push(comments[commentIndex++]);\n        }\n    }\n\n    return result;\n}\n\n/**\n * Determines if two nodes or tokens overlap.\n * @param {ASTNode|Token} first The first node or token to check.\n * @param {ASTNode|Token} second The second node or token to check.\n * @returns {boolean} True if the two nodes or tokens overlap.\n * @private\n */\nfunction nodesOrTokensOverlap(first, second) {\n    return (first.range[0] <= second.range[0] && first.range[1] >= second.range[0]) ||\n        (second.range[0] <= first.range[0] && second.range[1] >= first.range[0]);\n}\n\n/**\n * Determines if two nodes or tokens have at least one whitespace character\n * between them. Order does not matter. Returns false if the given nodes or\n * tokens overlap.\n * @param {SourceCode} sourceCode The source code object.\n * @param {ASTNode|Token} first The first node or token to check between.\n * @param {ASTNode|Token} second The second node or token to check between.\n * @param {boolean} checkInsideOfJSXText If `true` is present, check inside of JSXText tokens for backward compatibility.\n * @returns {boolean} True if there is a whitespace character between\n * any of the tokens found between the two given nodes or tokens.\n * @public\n */\nfunction isSpaceBetween(sourceCode, first, second, checkInsideOfJSXText) {\n    if (nodesOrTokensOverlap(first, second)) {\n        return false;\n    }\n\n    const [startingNodeOrToken, endingNodeOrToken] = first.range[1] <= second.range[0]\n        ? [first, second]\n        : [second, first];\n    const firstToken = sourceCode.getLastToken(startingNodeOrToken) || startingNodeOrToken;\n    const finalToken = sourceCode.getFirstToken(endingNodeOrToken) || endingNodeOrToken;\n    let currentToken = firstToken;\n\n    while (currentToken !== finalToken) {\n        const nextToken = sourceCode.getTokenAfter(currentToken, { includeComments: true });\n\n        if (\n            currentToken.range[1] !== nextToken.range[0] ||\n\n                /*\n                 * For backward compatibility, check spaces in JSXText.\n                 * https://github.com/eslint/eslint/issues/12614\n                 */\n                (\n                    checkInsideOfJSXText &&\n                    nextToken !== finalToken &&\n                    nextToken.type === \"JSXText\" &&\n                    /\\s/u.test(nextToken.value)\n                )\n        ) {\n            return true;\n        }\n\n        currentToken = nextToken;\n    }\n\n    return false;\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nclass SourceCode extends TokenStore {\n\n    /**\n     * Represents parsed source code.\n     * @param {string|Object} textOrConfig The source code text or config object.\n     * @param {string} textOrConfig.text The source code text.\n     * @param {ASTNode} textOrConfig.ast The Program node of the AST representing the code. This AST should be created from the text that BOM was stripped.\n     * @param {Object|null} textOrConfig.parserServices The parser services.\n     * @param {ScopeManager|null} textOrConfig.scopeManager The scope of this source code.\n     * @param {Object|null} textOrConfig.visitorKeys The visitor keys to traverse AST.\n     * @param {ASTNode} [astIfNoConfig] The Program node of the AST representing the code. This AST should be created from the text that BOM was stripped.\n     */\n    constructor(textOrConfig, astIfNoConfig) {\n        let text, ast, parserServices, scopeManager, visitorKeys;\n\n        // Process overloading.\n        if (typeof textOrConfig === \"string\") {\n            text = textOrConfig;\n            ast = astIfNoConfig;\n        } else if (typeof textOrConfig === \"object\" && textOrConfig !== null) {\n            text = textOrConfig.text;\n            ast = textOrConfig.ast;\n            parserServices = textOrConfig.parserServices;\n            scopeManager = textOrConfig.scopeManager;\n            visitorKeys = textOrConfig.visitorKeys;\n        }\n\n        validate(ast);\n        super(ast.tokens, ast.comments);\n\n        /**\n         * The flag to indicate that the source code has Unicode BOM.\n         * @type boolean\n         */\n        this.hasBOM = (text.charCodeAt(0) === 0xFEFF);\n\n        /**\n         * The original text source code.\n         * BOM was stripped from this text.\n         * @type string\n         */\n        this.text = (this.hasBOM ? text.slice(1) : text);\n\n        /**\n         * The parsed AST for the source code.\n         * @type ASTNode\n         */\n        this.ast = ast;\n\n        /**\n         * The parser services of this source code.\n         * @type {Object}\n         */\n        this.parserServices = parserServices || {};\n\n        /**\n         * The scope of this source code.\n         * @type {ScopeManager|null}\n         */\n        this.scopeManager = scopeManager || null;\n\n        /**\n         * The visitor keys to traverse AST.\n         * @type {Object}\n         */\n        this.visitorKeys = visitorKeys || Traverser.DEFAULT_VISITOR_KEYS;\n\n        // Check the source text for the presence of a shebang since it is parsed as a standard line comment.\n        const shebangMatched = this.text.match(astUtils.shebangPattern);\n        const hasShebang = shebangMatched && ast.comments.length && ast.comments[0].value === shebangMatched[1];\n\n        if (hasShebang) {\n            ast.comments[0].type = \"Shebang\";\n        }\n\n        this.tokensAndComments = sortedMerge(ast.tokens, ast.comments);\n\n        /**\n         * The source code split into lines according to ECMA-262 specification.\n         * This is done to avoid each rule needing to do so separately.\n         * @type string[]\n         */\n        this.lines = [];\n        this.lineStartIndices = [0];\n\n        const lineEndingPattern = astUtils.createGlobalLinebreakMatcher();\n        let match;\n\n        /*\n         * Previously, this was implemented using a regex that\n         * matched a sequence of non-linebreak characters followed by a\n         * linebreak, then adding the lengths of the matches. However,\n         * this caused a catastrophic backtracking issue when the end\n         * of a file contained a large number of non-newline characters.\n         * To avoid this, the current implementation just matches newlines\n         * and uses match.index to get the correct line start indices.\n         */\n        while ((match = lineEndingPattern.exec(this.text))) {\n            this.lines.push(this.text.slice(this.lineStartIndices[this.lineStartIndices.length - 1], match.index));\n            this.lineStartIndices.push(match.index + match[0].length);\n        }\n        this.lines.push(this.text.slice(this.lineStartIndices[this.lineStartIndices.length - 1]));\n\n        // Cache for comments found using getComments().\n        this._commentCache = new WeakMap();\n\n        // don't allow modification of this object\n        Object.freeze(this);\n        Object.freeze(this.lines);\n    }\n\n    /**\n     * Split the source code into multiple lines based on the line delimiters.\n     * @param {string} text Source code as a string.\n     * @returns {string[]} Array of source code lines.\n     * @public\n     */\n    static splitLines(text) {\n        return text.split(astUtils.createGlobalLinebreakMatcher());\n    }\n\n    /**\n     * Gets the source code for the given node.\n     * @param {ASTNode} [node] The AST node to get the text for.\n     * @param {int} [beforeCount] The number of characters before the node to retrieve.\n     * @param {int} [afterCount] The number of characters after the node to retrieve.\n     * @returns {string} The text representing the AST node.\n     * @public\n     */\n    getText(node, beforeCount, afterCount) {\n        if (node) {\n            return this.text.slice(Math.max(node.range[0] - (beforeCount || 0), 0),\n                node.range[1] + (afterCount || 0));\n        }\n        return this.text;\n    }\n\n    /**\n     * Gets the entire source text split into an array of lines.\n     * @returns {Array} The source text as an array of lines.\n     * @public\n     */\n    getLines() {\n        return this.lines;\n    }\n\n    /**\n     * Retrieves an array containing all comments in the source code.\n     * @returns {ASTNode[]} An array of comment nodes.\n     * @public\n     */\n    getAllComments() {\n        return this.ast.comments;\n    }\n\n    /**\n     * Gets all comments for the given node.\n     * @param {ASTNode} node The AST node to get the comments for.\n     * @returns {Object} An object containing a leading and trailing array\n     *      of comments indexed by their position.\n     * @public\n     * @deprecated replaced by getCommentsBefore(), getCommentsAfter(), and getCommentsInside().\n     */\n    getComments(node) {\n        if (this._commentCache.has(node)) {\n            return this._commentCache.get(node);\n        }\n\n        const comments = {\n            leading: [],\n            trailing: []\n        };\n\n        /*\n         * Return all comments as leading comments of the Program node when\n         * there is no executable code.\n         */\n        if (node.type === \"Program\") {\n            if (node.body.length === 0) {\n                comments.leading = node.comments;\n            }\n        } else {\n\n            /*\n             * Return comments as trailing comments of nodes that only contain\n             * comments (to mimic the comment attachment behavior present in Espree).\n             */\n            if ((node.type === \"BlockStatement\" || node.type === \"ClassBody\") && node.body.length === 0 ||\n                node.type === \"ObjectExpression\" && node.properties.length === 0 ||\n                node.type === \"ArrayExpression\" && node.elements.length === 0 ||\n                node.type === \"SwitchStatement\" && node.cases.length === 0\n            ) {\n                comments.trailing = this.getTokens(node, {\n                    includeComments: true,\n                    filter: isCommentToken\n                });\n            }\n\n            /*\n             * Iterate over tokens before and after node and collect comment tokens.\n             * Do not include comments that exist outside of the parent node\n             * to avoid duplication.\n             */\n            let currentToken = this.getTokenBefore(node, { includeComments: true });\n\n            while (currentToken && isCommentToken(currentToken)) {\n                if (node.parent && node.parent.type !== \"Program\" && (currentToken.start < node.parent.start)) {\n                    break;\n                }\n                comments.leading.push(currentToken);\n                currentToken = this.getTokenBefore(currentToken, { includeComments: true });\n            }\n\n            comments.leading.reverse();\n\n            currentToken = this.getTokenAfter(node, { includeComments: true });\n\n            while (currentToken && isCommentToken(currentToken)) {\n                if (node.parent && node.parent.type !== \"Program\" && (currentToken.end > node.parent.end)) {\n                    break;\n                }\n                comments.trailing.push(currentToken);\n                currentToken = this.getTokenAfter(currentToken, { includeComments: true });\n            }\n        }\n\n        this._commentCache.set(node, comments);\n        return comments;\n    }\n\n    /**\n     * Retrieves the JSDoc comment for a given node.\n     * @param {ASTNode} node The AST node to get the comment for.\n     * @returns {Token|null} The Block comment token containing the JSDoc comment\n     *      for the given node or null if not found.\n     * @public\n     * @deprecated\n     */\n    getJSDocComment(node) {\n\n        /**\n         * Checks for the presence of a JSDoc comment for the given node and returns it.\n         * @param {ASTNode} astNode The AST node to get the comment for.\n         * @returns {Token|null} The Block comment token containing the JSDoc comment\n         *      for the given node or null if not found.\n         * @private\n         */\n        const findJSDocComment = astNode => {\n            const tokenBefore = this.getTokenBefore(astNode, { includeComments: true });\n\n            if (\n                tokenBefore &&\n                isCommentToken(tokenBefore) &&\n                tokenBefore.type === \"Block\" &&\n                tokenBefore.value.charAt(0) === \"*\" &&\n                astNode.loc.start.line - tokenBefore.loc.end.line <= 1\n            ) {\n                return tokenBefore;\n            }\n\n            return null;\n        };\n        let parent = node.parent;\n\n        switch (node.type) {\n            case \"ClassDeclaration\":\n            case \"FunctionDeclaration\":\n                return findJSDocComment(looksLikeExport(parent) ? parent : node);\n\n            case \"ClassExpression\":\n                return findJSDocComment(parent.parent);\n\n            case \"ArrowFunctionExpression\":\n            case \"FunctionExpression\":\n                if (parent.type !== \"CallExpression\" && parent.type !== \"NewExpression\") {\n                    while (\n                        !this.getCommentsBefore(parent).length &&\n                        !/Function/u.test(parent.type) &&\n                        parent.type !== \"MethodDefinition\" &&\n                        parent.type !== \"Property\"\n                    ) {\n                        parent = parent.parent;\n\n                        if (!parent) {\n                            break;\n                        }\n                    }\n\n                    if (parent && parent.type !== \"FunctionDeclaration\" && parent.type !== \"Program\") {\n                        return findJSDocComment(parent);\n                    }\n                }\n\n                return findJSDocComment(node);\n\n            // falls through\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * Gets the deepest node containing a range index.\n     * @param {int} index Range index of the desired node.\n     * @returns {ASTNode} The node if found or null if not found.\n     * @public\n     */\n    getNodeByRangeIndex(index) {\n        let result = null;\n\n        Traverser.traverse(this.ast, {\n            visitorKeys: this.visitorKeys,\n            enter(node) {\n                if (node.range[0] <= index && index < node.range[1]) {\n                    result = node;\n                } else {\n                    this.skip();\n                }\n            },\n            leave(node) {\n                if (node === result) {\n                    this.break();\n                }\n            }\n        });\n\n        return result;\n    }\n\n    /**\n     * Determines if two nodes or tokens have at least one whitespace character\n     * between them. Order does not matter. Returns false if the given nodes or\n     * tokens overlap.\n     * @param {ASTNode|Token} first The first node or token to check between.\n     * @param {ASTNode|Token} second The second node or token to check between.\n     * @returns {boolean} True if there is a whitespace character between\n     * any of the tokens found between the two given nodes or tokens.\n     * @public\n     */\n    isSpaceBetween(first, second) {\n        return isSpaceBetween(this, first, second, false);\n    }\n\n    /**\n     * Determines if two nodes or tokens have at least one whitespace character\n     * between them. Order does not matter. Returns false if the given nodes or\n     * tokens overlap.\n     * For backward compatibility, this method returns true if there are\n     * `JSXText` tokens that contain whitespaces between the two.\n     * @param {ASTNode|Token} first The first node or token to check between.\n     * @param {ASTNode|Token} second The second node or token to check between.\n     * @returns {boolean} True if there is a whitespace character between\n     * any of the tokens found between the two given nodes or tokens.\n     * @deprecated in favor of isSpaceBetween().\n     * @public\n     */\n    isSpaceBetweenTokens(first, second) {\n        return isSpaceBetween(this, first, second, true);\n    }\n\n    /**\n     * Converts a source text index into a (line, column) pair.\n     * @param {number} index The index of a character in a file\n     * @returns {Object} A {line, column} location object with a 0-indexed column\n     * @public\n     */\n    getLocFromIndex(index) {\n        if (typeof index !== \"number\") {\n            throw new TypeError(\"Expected `index` to be a number.\");\n        }\n\n        if (index < 0 || index > this.text.length) {\n            throw new RangeError(`Index out of range (requested index ${index}, but source text has length ${this.text.length}).`);\n        }\n\n        /*\n         * For an argument of this.text.length, return the location one \"spot\" past the last character\n         * of the file. If the last character is a linebreak, the location will be column 0 of the next\n         * line; otherwise, the location will be in the next column on the same line.\n         *\n         * See getIndexFromLoc for the motivation for this special case.\n         */\n        if (index === this.text.length) {\n            return { line: this.lines.length, column: this.lines[this.lines.length - 1].length };\n        }\n\n        /*\n         * To figure out which line index is on, determine the last place at which index could\n         * be inserted into lineStartIndices to keep the list sorted.\n         */\n        const lineNumber = index >= this.lineStartIndices[this.lineStartIndices.length - 1]\n            ? this.lineStartIndices.length\n            : this.lineStartIndices.findIndex(el => index < el);\n\n        return { line: lineNumber, column: index - this.lineStartIndices[lineNumber - 1] };\n    }\n\n    /**\n     * Converts a (line, column) pair into a range index.\n     * @param {Object} loc A line/column location\n     * @param {number} loc.line The line number of the location (1-indexed)\n     * @param {number} loc.column The column number of the location (0-indexed)\n     * @returns {number} The range index of the location in the file.\n     * @public\n     */\n    getIndexFromLoc(loc) {\n        if (typeof loc !== \"object\" || typeof loc.line !== \"number\" || typeof loc.column !== \"number\") {\n            throw new TypeError(\"Expected `loc` to be an object with numeric `line` and `column` properties.\");\n        }\n\n        if (loc.line <= 0) {\n            throw new RangeError(`Line number out of range (line ${loc.line} requested). Line numbers should be 1-based.`);\n        }\n\n        if (loc.line > this.lineStartIndices.length) {\n            throw new RangeError(`Line number out of range (line ${loc.line} requested, but only ${this.lineStartIndices.length} lines present).`);\n        }\n\n        const lineStartIndex = this.lineStartIndices[loc.line - 1];\n        const lineEndIndex = loc.line === this.lineStartIndices.length ? this.text.length : this.lineStartIndices[loc.line];\n        const positionIndex = lineStartIndex + loc.column;\n\n        /*\n         * By design, getIndexFromLoc({ line: lineNum, column: 0 }) should return the start index of\n         * the given line, provided that the line number is valid element of this.lines. Since the\n         * last element of this.lines is an empty string for files with trailing newlines, add a\n         * special case where getting the index for the first location after the end of the file\n         * will return the length of the file, rather than throwing an error. This allows rules to\n         * use getIndexFromLoc consistently without worrying about edge cases at the end of a file.\n         */\n        if (\n            loc.line === this.lineStartIndices.length && positionIndex > lineEndIndex ||\n            loc.line < this.lineStartIndices.length && positionIndex >= lineEndIndex\n        ) {\n            throw new RangeError(`Column number out of range (column ${loc.column} requested, but the length of line ${loc.line} is ${lineEndIndex - lineStartIndex}).`);\n        }\n\n        return positionIndex;\n    }\n}\n\nmodule.exports = SourceCode;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}