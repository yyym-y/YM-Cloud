{"ast":null,"code":"/**\n * @fileoverview Look for useless escapes in strings and regexes\n * @author Onur Temizkan\n */\n\n\"use strict\";\n\nrequire(\"core-js/modules/es.array.push.js\");\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/**\n * Returns the union of two sets.\n * @param {Set} setA The first set\n * @param {Set} setB The second set\n * @returns {Set} The union of the two sets\n */\nfunction union(setA, setB) {\n  return new Set(function* () {\n    yield* setA;\n    yield* setB;\n  }());\n}\nconst VALID_STRING_ESCAPES = union(new Set(\"\\\\nrvtbfux\"), astUtils.LINEBREAKS);\nconst REGEX_GENERAL_ESCAPES = new Set(\"\\\\bcdDfnpPrsStvwWxu0123456789]\");\nconst REGEX_NON_CHARCLASS_ESCAPES = union(REGEX_GENERAL_ESCAPES, new Set(\"^/.$*+?[{}|()Bk\"));\n\n/**\n * Parses a regular expression into a list of characters with character class info.\n * @param {string} regExpText The raw text used to create the regular expression\n * @returns {Object[]} A list of characters, each with info on escaping and whether they're in a character class.\n * @example\n *\n * parseRegExp('a\\\\b[cd-]')\n *\n * returns:\n * [\n *   {text: 'a', index: 0, escaped: false, inCharClass: false, startsCharClass: false, endsCharClass: false},\n *   {text: 'b', index: 2, escaped: true, inCharClass: false, startsCharClass: false, endsCharClass: false},\n *   {text: 'c', index: 4, escaped: false, inCharClass: true, startsCharClass: true, endsCharClass: false},\n *   {text: 'd', index: 5, escaped: false, inCharClass: true, startsCharClass: false, endsCharClass: false},\n *   {text: '-', index: 6, escaped: false, inCharClass: true, startsCharClass: false, endsCharClass: false}\n * ]\n */\nfunction parseRegExp(regExpText) {\n  const charList = [];\n  regExpText.split(\"\").reduce((state, char, index) => {\n    if (!state.escapeNextChar) {\n      if (char === \"\\\\\") {\n        return Object.assign(state, {\n          escapeNextChar: true\n        });\n      }\n      if (char === \"[\" && !state.inCharClass) {\n        return Object.assign(state, {\n          inCharClass: true,\n          startingCharClass: true\n        });\n      }\n      if (char === \"]\" && state.inCharClass) {\n        if (charList.length && charList[charList.length - 1].inCharClass) {\n          charList[charList.length - 1].endsCharClass = true;\n        }\n        return Object.assign(state, {\n          inCharClass: false,\n          startingCharClass: false\n        });\n      }\n    }\n    charList.push({\n      text: char,\n      index,\n      escaped: state.escapeNextChar,\n      inCharClass: state.inCharClass,\n      startsCharClass: state.startingCharClass,\n      endsCharClass: false\n    });\n    return Object.assign(state, {\n      escapeNextChar: false,\n      startingCharClass: false\n    });\n  }, {\n    escapeNextChar: false,\n    inCharClass: false,\n    startingCharClass: false\n  });\n  return charList;\n}\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow unnecessary escape characters\",\n      category: \"Best Practices\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-useless-escape\",\n      suggestion: true\n    },\n    messages: {\n      unnecessaryEscape: \"Unnecessary escape character: \\\\{{character}}.\",\n      removeEscape: \"Remove the `\\\\`. This maintains the current functionality.\",\n      escapeBackslash: \"Replace the `\\\\` with `\\\\\\\\` to include the actual backslash character.\"\n    },\n    schema: []\n  },\n  create(context) {\n    const sourceCode = context.getSourceCode();\n\n    /**\n     * Reports a node\n     * @param {ASTNode} node The node to report\n     * @param {number} startOffset The backslash's offset from the start of the node\n     * @param {string} character The uselessly escaped character (not including the backslash)\n     * @returns {void}\n     */\n    function report(node, startOffset, character) {\n      const rangeStart = node.range[0] + startOffset;\n      const range = [rangeStart, rangeStart + 1];\n      const start = sourceCode.getLocFromIndex(rangeStart);\n      context.report({\n        node,\n        loc: {\n          start,\n          end: {\n            line: start.line,\n            column: start.column + 1\n          }\n        },\n        messageId: \"unnecessaryEscape\",\n        data: {\n          character\n        },\n        suggest: [{\n          messageId: \"removeEscape\",\n          fix(fixer) {\n            return fixer.removeRange(range);\n          }\n        }, {\n          messageId: \"escapeBackslash\",\n          fix(fixer) {\n            return fixer.insertTextBeforeRange(range, \"\\\\\");\n          }\n        }]\n      });\n    }\n\n    /**\n     * Checks if the escape character in given string slice is unnecessary.\n     * @private\n     * @param {ASTNode} node node to validate.\n     * @param {string} match string slice to validate.\n     * @returns {void}\n     */\n    function validateString(node, match) {\n      const isTemplateElement = node.type === \"TemplateElement\";\n      const escapedChar = match[0][1];\n      let isUnnecessaryEscape = !VALID_STRING_ESCAPES.has(escapedChar);\n      let isQuoteEscape;\n      if (isTemplateElement) {\n        isQuoteEscape = escapedChar === \"`\";\n        if (escapedChar === \"$\") {\n          // Warn if `\\$` is not followed by `{`\n          isUnnecessaryEscape = match.input[match.index + 2] !== \"{\";\n        } else if (escapedChar === \"{\") {\n          /*\n           * Warn if `\\{` is not preceded by `$`. If preceded by `$`, escaping\n           * is necessary and the rule should not warn. If preceded by `/$`, the rule\n           * will warn for the `/$` instead, as it is the first unnecessarily escaped character.\n           */\n          isUnnecessaryEscape = match.input[match.index - 1] !== \"$\";\n        }\n      } else {\n        isQuoteEscape = escapedChar === node.raw[0];\n      }\n      if (isUnnecessaryEscape && !isQuoteEscape) {\n        report(node, match.index, match[0].slice(1));\n      }\n    }\n\n    /**\n     * Checks if a node has an escape.\n     * @param {ASTNode} node node to check.\n     * @returns {void}\n     */\n    function check(node) {\n      const isTemplateElement = node.type === \"TemplateElement\";\n      if (isTemplateElement && node.parent && node.parent.parent && node.parent.parent.type === \"TaggedTemplateExpression\" && node.parent === node.parent.parent.quasi) {\n        // Don't report tagged template literals, because the backslash character is accessible to the tag function.\n        return;\n      }\n      if (typeof node.value === \"string\" || isTemplateElement) {\n        /*\n         * JSXAttribute doesn't have any escape sequence: https://facebook.github.io/jsx/.\n         * In addition, backticks are not supported by JSX yet: https://github.com/facebook/jsx/issues/25.\n         */\n        if (node.parent.type === \"JSXAttribute\" || node.parent.type === \"JSXElement\" || node.parent.type === \"JSXFragment\") {\n          return;\n        }\n        const value = isTemplateElement ? sourceCode.getText(node) : node.raw;\n        const pattern = /\\\\[^\\d]/gu;\n        let match;\n        while (match = pattern.exec(value)) {\n          validateString(node, match);\n        }\n      } else if (node.regex) {\n        parseRegExp(node.regex.pattern)\n\n        /*\n         * The '-' character is a special case, because it's only valid to escape it if it's in a character\n         * class, and is not at either edge of the character class. To account for this, don't consider '-'\n         * characters to be valid in general, and filter out '-' characters that appear in the middle of a\n         * character class.\n         */.filter(charInfo => !(charInfo.text === \"-\" && charInfo.inCharClass && !charInfo.startsCharClass && !charInfo.endsCharClass))\n\n        /*\n         * The '^' character is also a special case; it must always be escaped outside of character classes, but\n         * it only needs to be escaped in character classes if it's at the beginning of the character class. To\n         * account for this, consider it to be a valid escape character outside of character classes, and filter\n         * out '^' characters that appear at the start of a character class.\n         */.filter(charInfo => !(charInfo.text === \"^\" && charInfo.startsCharClass))\n\n        // Filter out characters that aren't escaped.\n        .filter(charInfo => charInfo.escaped)\n\n        // Filter out characters that are valid to escape, based on their position in the regular expression.\n        .filter(charInfo => !(charInfo.inCharClass ? REGEX_GENERAL_ESCAPES : REGEX_NON_CHARCLASS_ESCAPES).has(charInfo.text))\n\n        // Report all the remaining characters.\n        .forEach(charInfo => report(node, charInfo.index, charInfo.text));\n      }\n    }\n    return {\n      Literal: check,\n      TemplateElement: check\n    };\n  }\n};","map":{"version":3,"names":["require","astUtils","union","setA","setB","Set","VALID_STRING_ESCAPES","LINEBREAKS","REGEX_GENERAL_ESCAPES","REGEX_NON_CHARCLASS_ESCAPES","parseRegExp","regExpText","charList","split","reduce","state","char","index","escapeNextChar","Object","assign","inCharClass","startingCharClass","length","endsCharClass","push","text","escaped","startsCharClass","module","exports","meta","type","docs","description","category","recommended","url","suggestion","messages","unnecessaryEscape","removeEscape","escapeBackslash","schema","create","context","sourceCode","getSourceCode","report","node","startOffset","character","rangeStart","range","start","getLocFromIndex","loc","end","line","column","messageId","data","suggest","fix","fixer","removeRange","insertTextBeforeRange","validateString","match","isTemplateElement","escapedChar","isUnnecessaryEscape","has","isQuoteEscape","input","raw","slice","check","parent","quasi","value","getText","pattern","exec","regex","filter","charInfo","forEach","Literal","TemplateElement"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/no-useless-escape.js"],"sourcesContent":["/**\n * @fileoverview Look for useless escapes in strings and regexes\n * @author Onur Temizkan\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/**\n * Returns the union of two sets.\n * @param {Set} setA The first set\n * @param {Set} setB The second set\n * @returns {Set} The union of the two sets\n */\nfunction union(setA, setB) {\n    return new Set(function *() {\n        yield* setA;\n        yield* setB;\n    }());\n}\n\nconst VALID_STRING_ESCAPES = union(new Set(\"\\\\nrvtbfux\"), astUtils.LINEBREAKS);\nconst REGEX_GENERAL_ESCAPES = new Set(\"\\\\bcdDfnpPrsStvwWxu0123456789]\");\nconst REGEX_NON_CHARCLASS_ESCAPES = union(REGEX_GENERAL_ESCAPES, new Set(\"^/.$*+?[{}|()Bk\"));\n\n/**\n * Parses a regular expression into a list of characters with character class info.\n * @param {string} regExpText The raw text used to create the regular expression\n * @returns {Object[]} A list of characters, each with info on escaping and whether they're in a character class.\n * @example\n *\n * parseRegExp('a\\\\b[cd-]')\n *\n * returns:\n * [\n *   {text: 'a', index: 0, escaped: false, inCharClass: false, startsCharClass: false, endsCharClass: false},\n *   {text: 'b', index: 2, escaped: true, inCharClass: false, startsCharClass: false, endsCharClass: false},\n *   {text: 'c', index: 4, escaped: false, inCharClass: true, startsCharClass: true, endsCharClass: false},\n *   {text: 'd', index: 5, escaped: false, inCharClass: true, startsCharClass: false, endsCharClass: false},\n *   {text: '-', index: 6, escaped: false, inCharClass: true, startsCharClass: false, endsCharClass: false}\n * ]\n */\nfunction parseRegExp(regExpText) {\n    const charList = [];\n\n    regExpText.split(\"\").reduce((state, char, index) => {\n        if (!state.escapeNextChar) {\n            if (char === \"\\\\\") {\n                return Object.assign(state, { escapeNextChar: true });\n            }\n            if (char === \"[\" && !state.inCharClass) {\n                return Object.assign(state, { inCharClass: true, startingCharClass: true });\n            }\n            if (char === \"]\" && state.inCharClass) {\n                if (charList.length && charList[charList.length - 1].inCharClass) {\n                    charList[charList.length - 1].endsCharClass = true;\n                }\n                return Object.assign(state, { inCharClass: false, startingCharClass: false });\n            }\n        }\n        charList.push({\n            text: char,\n            index,\n            escaped: state.escapeNextChar,\n            inCharClass: state.inCharClass,\n            startsCharClass: state.startingCharClass,\n            endsCharClass: false\n        });\n        return Object.assign(state, { escapeNextChar: false, startingCharClass: false });\n    }, { escapeNextChar: false, inCharClass: false, startingCharClass: false });\n\n    return charList;\n}\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow unnecessary escape characters\",\n            category: \"Best Practices\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-useless-escape\",\n            suggestion: true\n        },\n\n        messages: {\n            unnecessaryEscape: \"Unnecessary escape character: \\\\{{character}}.\",\n            removeEscape: \"Remove the `\\\\`. This maintains the current functionality.\",\n            escapeBackslash: \"Replace the `\\\\` with `\\\\\\\\` to include the actual backslash character.\"\n        },\n\n        schema: []\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Reports a node\n         * @param {ASTNode} node The node to report\n         * @param {number} startOffset The backslash's offset from the start of the node\n         * @param {string} character The uselessly escaped character (not including the backslash)\n         * @returns {void}\n         */\n        function report(node, startOffset, character) {\n            const rangeStart = node.range[0] + startOffset;\n            const range = [rangeStart, rangeStart + 1];\n            const start = sourceCode.getLocFromIndex(rangeStart);\n\n            context.report({\n                node,\n                loc: {\n                    start,\n                    end: { line: start.line, column: start.column + 1 }\n                },\n                messageId: \"unnecessaryEscape\",\n                data: { character },\n                suggest: [\n                    {\n                        messageId: \"removeEscape\",\n                        fix(fixer) {\n                            return fixer.removeRange(range);\n                        }\n                    },\n                    {\n                        messageId: \"escapeBackslash\",\n                        fix(fixer) {\n                            return fixer.insertTextBeforeRange(range, \"\\\\\");\n                        }\n                    }\n                ]\n            });\n        }\n\n        /**\n         * Checks if the escape character in given string slice is unnecessary.\n         * @private\n         * @param {ASTNode} node node to validate.\n         * @param {string} match string slice to validate.\n         * @returns {void}\n         */\n        function validateString(node, match) {\n            const isTemplateElement = node.type === \"TemplateElement\";\n            const escapedChar = match[0][1];\n            let isUnnecessaryEscape = !VALID_STRING_ESCAPES.has(escapedChar);\n            let isQuoteEscape;\n\n            if (isTemplateElement) {\n                isQuoteEscape = escapedChar === \"`\";\n\n                if (escapedChar === \"$\") {\n\n                    // Warn if `\\$` is not followed by `{`\n                    isUnnecessaryEscape = match.input[match.index + 2] !== \"{\";\n                } else if (escapedChar === \"{\") {\n\n                    /*\n                     * Warn if `\\{` is not preceded by `$`. If preceded by `$`, escaping\n                     * is necessary and the rule should not warn. If preceded by `/$`, the rule\n                     * will warn for the `/$` instead, as it is the first unnecessarily escaped character.\n                     */\n                    isUnnecessaryEscape = match.input[match.index - 1] !== \"$\";\n                }\n            } else {\n                isQuoteEscape = escapedChar === node.raw[0];\n            }\n\n            if (isUnnecessaryEscape && !isQuoteEscape) {\n                report(node, match.index, match[0].slice(1));\n            }\n        }\n\n        /**\n         * Checks if a node has an escape.\n         * @param {ASTNode} node node to check.\n         * @returns {void}\n         */\n        function check(node) {\n            const isTemplateElement = node.type === \"TemplateElement\";\n\n            if (\n                isTemplateElement &&\n                node.parent &&\n                node.parent.parent &&\n                node.parent.parent.type === \"TaggedTemplateExpression\" &&\n                node.parent === node.parent.parent.quasi\n            ) {\n\n                // Don't report tagged template literals, because the backslash character is accessible to the tag function.\n                return;\n            }\n\n            if (typeof node.value === \"string\" || isTemplateElement) {\n\n                /*\n                 * JSXAttribute doesn't have any escape sequence: https://facebook.github.io/jsx/.\n                 * In addition, backticks are not supported by JSX yet: https://github.com/facebook/jsx/issues/25.\n                 */\n                if (node.parent.type === \"JSXAttribute\" || node.parent.type === \"JSXElement\" || node.parent.type === \"JSXFragment\") {\n                    return;\n                }\n\n                const value = isTemplateElement ? sourceCode.getText(node) : node.raw;\n                const pattern = /\\\\[^\\d]/gu;\n                let match;\n\n                while ((match = pattern.exec(value))) {\n                    validateString(node, match);\n                }\n            } else if (node.regex) {\n                parseRegExp(node.regex.pattern)\n\n                    /*\n                     * The '-' character is a special case, because it's only valid to escape it if it's in a character\n                     * class, and is not at either edge of the character class. To account for this, don't consider '-'\n                     * characters to be valid in general, and filter out '-' characters that appear in the middle of a\n                     * character class.\n                     */\n                    .filter(charInfo => !(charInfo.text === \"-\" && charInfo.inCharClass && !charInfo.startsCharClass && !charInfo.endsCharClass))\n\n                    /*\n                     * The '^' character is also a special case; it must always be escaped outside of character classes, but\n                     * it only needs to be escaped in character classes if it's at the beginning of the character class. To\n                     * account for this, consider it to be a valid escape character outside of character classes, and filter\n                     * out '^' characters that appear at the start of a character class.\n                     */\n                    .filter(charInfo => !(charInfo.text === \"^\" && charInfo.startsCharClass))\n\n                    // Filter out characters that aren't escaped.\n                    .filter(charInfo => charInfo.escaped)\n\n                    // Filter out characters that are valid to escape, based on their position in the regular expression.\n                    .filter(charInfo => !(charInfo.inCharClass ? REGEX_GENERAL_ESCAPES : REGEX_NON_CHARCLASS_ESCAPES).has(charInfo.text))\n\n                    // Report all the remaining characters.\n                    .forEach(charInfo => report(node, charInfo.index, charInfo.text));\n            }\n\n        }\n\n        return {\n            Literal: check,\n            TemplateElement: check\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}