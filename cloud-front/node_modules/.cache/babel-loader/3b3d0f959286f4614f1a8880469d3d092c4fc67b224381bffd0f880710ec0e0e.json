{"ast":null,"code":"/**\n * @fileoverview Operator linebreak - enforces operator linebreak style of two types: after and before\n * @author Benoît Zugmeyer\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce consistent linebreak style for operators\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/operator-linebreak\"\n    },\n    schema: [{\n      enum: [\"after\", \"before\", \"none\", null]\n    }, {\n      type: \"object\",\n      properties: {\n        overrides: {\n          type: \"object\",\n          additionalProperties: {\n            enum: [\"after\", \"before\", \"none\", \"ignore\"]\n          }\n        }\n      },\n      additionalProperties: false\n    }],\n    fixable: \"code\",\n    messages: {\n      operatorAtBeginning: \"'{{operator}}' should be placed at the beginning of the line.\",\n      operatorAtEnd: \"'{{operator}}' should be placed at the end of the line.\",\n      badLinebreak: \"Bad line breaking before and after '{{operator}}'.\",\n      noLinebreak: \"There should be no line break before or after '{{operator}}'.\"\n    }\n  },\n  create(context) {\n    const usedDefaultGlobal = !context.options[0];\n    const globalStyle = context.options[0] || \"after\";\n    const options = context.options[1] || {};\n    const styleOverrides = options.overrides ? Object.assign({}, options.overrides) : {};\n    if (usedDefaultGlobal && !styleOverrides[\"?\"]) {\n      styleOverrides[\"?\"] = \"before\";\n    }\n    if (usedDefaultGlobal && !styleOverrides[\":\"]) {\n      styleOverrides[\":\"] = \"before\";\n    }\n    const sourceCode = context.getSourceCode();\n\n    //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    /**\n     * Gets a fixer function to fix rule issues\n     * @param {Token} operatorToken The operator token of an expression\n     * @param {string} desiredStyle The style for the rule. One of 'before', 'after', 'none'\n     * @returns {Function} A fixer function\n     */\n    function getFixer(operatorToken, desiredStyle) {\n      return fixer => {\n        const tokenBefore = sourceCode.getTokenBefore(operatorToken);\n        const tokenAfter = sourceCode.getTokenAfter(operatorToken);\n        const textBefore = sourceCode.text.slice(tokenBefore.range[1], operatorToken.range[0]);\n        const textAfter = sourceCode.text.slice(operatorToken.range[1], tokenAfter.range[0]);\n        const hasLinebreakBefore = !astUtils.isTokenOnSameLine(tokenBefore, operatorToken);\n        const hasLinebreakAfter = !astUtils.isTokenOnSameLine(operatorToken, tokenAfter);\n        let newTextBefore, newTextAfter;\n        if (hasLinebreakBefore !== hasLinebreakAfter && desiredStyle !== \"none\") {\n          // If there is a comment before and after the operator, don't do a fix.\n          if (sourceCode.getTokenBefore(operatorToken, {\n            includeComments: true\n          }) !== tokenBefore && sourceCode.getTokenAfter(operatorToken, {\n            includeComments: true\n          }) !== tokenAfter) {\n            return null;\n          }\n\n          /*\n           * If there is only one linebreak and it's on the wrong side of the operator, swap the text before and after the operator.\n           * foo &&\n           *           bar\n           * would get fixed to\n           * foo\n           *        && bar\n           */\n          newTextBefore = textAfter;\n          newTextAfter = textBefore;\n        } else {\n          const LINEBREAK_REGEX = astUtils.createGlobalLinebreakMatcher();\n\n          // Otherwise, if no linebreak is desired and no comments interfere, replace the linebreaks with empty strings.\n          newTextBefore = desiredStyle === \"before\" || textBefore.trim() ? textBefore : textBefore.replace(LINEBREAK_REGEX, \"\");\n          newTextAfter = desiredStyle === \"after\" || textAfter.trim() ? textAfter : textAfter.replace(LINEBREAK_REGEX, \"\");\n\n          // If there was no change (due to interfering comments), don't output a fix.\n          if (newTextBefore === textBefore && newTextAfter === textAfter) {\n            return null;\n          }\n        }\n        if (newTextAfter === \"\" && tokenAfter.type === \"Punctuator\" && \"+-\".includes(operatorToken.value) && tokenAfter.value === operatorToken.value) {\n          // To avoid accidentally creating a ++ or -- operator, insert a space if the operator is a +/- and the following token is a unary +/-.\n          newTextAfter += \" \";\n        }\n        return fixer.replaceTextRange([tokenBefore.range[1], tokenAfter.range[0]], newTextBefore + operatorToken.value + newTextAfter);\n      };\n    }\n\n    /**\n     * Checks the operator placement\n     * @param {ASTNode} node The node to check\n     * @param {ASTNode} leftSide The node that comes before the operator in `node`\n     * @private\n     * @returns {void}\n     */\n    function validateNode(node, leftSide) {\n      /*\n       * When the left part of a binary expression is a single expression wrapped in\n       * parentheses (ex: `(a) + b`), leftToken will be the last token of the expression\n       * and operatorToken will be the closing parenthesis.\n       * The leftToken should be the last closing parenthesis, and the operatorToken\n       * should be the token right after that.\n       */\n      const operatorToken = sourceCode.getTokenAfter(leftSide, astUtils.isNotClosingParenToken);\n      const leftToken = sourceCode.getTokenBefore(operatorToken);\n      const rightToken = sourceCode.getTokenAfter(operatorToken);\n      const operator = operatorToken.value;\n      const operatorStyleOverride = styleOverrides[operator];\n      const style = operatorStyleOverride || globalStyle;\n      const fix = getFixer(operatorToken, style);\n\n      // if single line\n      if (astUtils.isTokenOnSameLine(leftToken, operatorToken) && astUtils.isTokenOnSameLine(operatorToken, rightToken)) {\n\n        // do nothing.\n      } else if (operatorStyleOverride !== \"ignore\" && !astUtils.isTokenOnSameLine(leftToken, operatorToken) && !astUtils.isTokenOnSameLine(operatorToken, rightToken)) {\n        // lone operator\n        context.report({\n          node,\n          loc: operatorToken.loc,\n          messageId: \"badLinebreak\",\n          data: {\n            operator\n          },\n          fix\n        });\n      } else if (style === \"before\" && astUtils.isTokenOnSameLine(leftToken, operatorToken)) {\n        context.report({\n          node,\n          loc: operatorToken.loc,\n          messageId: \"operatorAtBeginning\",\n          data: {\n            operator\n          },\n          fix\n        });\n      } else if (style === \"after\" && astUtils.isTokenOnSameLine(operatorToken, rightToken)) {\n        context.report({\n          node,\n          loc: operatorToken.loc,\n          messageId: \"operatorAtEnd\",\n          data: {\n            operator\n          },\n          fix\n        });\n      } else if (style === \"none\") {\n        context.report({\n          node,\n          loc: operatorToken.loc,\n          messageId: \"noLinebreak\",\n          data: {\n            operator\n          },\n          fix\n        });\n      }\n    }\n\n    /**\n     * Validates a binary expression using `validateNode`\n     * @param {BinaryExpression|LogicalExpression|AssignmentExpression} node node to be validated\n     * @returns {void}\n     */\n    function validateBinaryExpression(node) {\n      validateNode(node, node.left);\n    }\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    return {\n      BinaryExpression: validateBinaryExpression,\n      LogicalExpression: validateBinaryExpression,\n      AssignmentExpression: validateBinaryExpression,\n      VariableDeclarator(node) {\n        if (node.init) {\n          validateNode(node, node.id);\n        }\n      },\n      ConditionalExpression(node) {\n        validateNode(node, node.test);\n        validateNode(node, node.consequent);\n      }\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","module","exports","meta","type","docs","description","category","recommended","url","schema","enum","properties","overrides","additionalProperties","fixable","messages","operatorAtBeginning","operatorAtEnd","badLinebreak","noLinebreak","create","context","usedDefaultGlobal","options","globalStyle","styleOverrides","Object","assign","sourceCode","getSourceCode","getFixer","operatorToken","desiredStyle","fixer","tokenBefore","getTokenBefore","tokenAfter","getTokenAfter","textBefore","text","slice","range","textAfter","hasLinebreakBefore","isTokenOnSameLine","hasLinebreakAfter","newTextBefore","newTextAfter","includeComments","LINEBREAK_REGEX","createGlobalLinebreakMatcher","trim","replace","includes","value","replaceTextRange","validateNode","node","leftSide","isNotClosingParenToken","leftToken","rightToken","operator","operatorStyleOverride","style","fix","report","loc","messageId","data","validateBinaryExpression","left","BinaryExpression","LogicalExpression","AssignmentExpression","VariableDeclarator","init","id","ConditionalExpression","test","consequent"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/operator-linebreak.js"],"sourcesContent":["/**\n * @fileoverview Operator linebreak - enforces operator linebreak style of two types: after and before\n * @author Benoît Zugmeyer\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce consistent linebreak style for operators\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/operator-linebreak\"\n        },\n\n        schema: [\n            {\n                enum: [\"after\", \"before\", \"none\", null]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    overrides: {\n                        type: \"object\",\n                        additionalProperties: {\n                            enum: [\"after\", \"before\", \"none\", \"ignore\"]\n                        }\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: \"code\",\n\n        messages: {\n            operatorAtBeginning: \"'{{operator}}' should be placed at the beginning of the line.\",\n            operatorAtEnd: \"'{{operator}}' should be placed at the end of the line.\",\n            badLinebreak: \"Bad line breaking before and after '{{operator}}'.\",\n            noLinebreak: \"There should be no line break before or after '{{operator}}'.\"\n        }\n    },\n\n    create(context) {\n\n        const usedDefaultGlobal = !context.options[0];\n        const globalStyle = context.options[0] || \"after\";\n        const options = context.options[1] || {};\n        const styleOverrides = options.overrides ? Object.assign({}, options.overrides) : {};\n\n        if (usedDefaultGlobal && !styleOverrides[\"?\"]) {\n            styleOverrides[\"?\"] = \"before\";\n        }\n\n        if (usedDefaultGlobal && !styleOverrides[\":\"]) {\n            styleOverrides[\":\"] = \"before\";\n        }\n\n        const sourceCode = context.getSourceCode();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Gets a fixer function to fix rule issues\n         * @param {Token} operatorToken The operator token of an expression\n         * @param {string} desiredStyle The style for the rule. One of 'before', 'after', 'none'\n         * @returns {Function} A fixer function\n         */\n        function getFixer(operatorToken, desiredStyle) {\n            return fixer => {\n                const tokenBefore = sourceCode.getTokenBefore(operatorToken);\n                const tokenAfter = sourceCode.getTokenAfter(operatorToken);\n                const textBefore = sourceCode.text.slice(tokenBefore.range[1], operatorToken.range[0]);\n                const textAfter = sourceCode.text.slice(operatorToken.range[1], tokenAfter.range[0]);\n                const hasLinebreakBefore = !astUtils.isTokenOnSameLine(tokenBefore, operatorToken);\n                const hasLinebreakAfter = !astUtils.isTokenOnSameLine(operatorToken, tokenAfter);\n                let newTextBefore, newTextAfter;\n\n                if (hasLinebreakBefore !== hasLinebreakAfter && desiredStyle !== \"none\") {\n\n                    // If there is a comment before and after the operator, don't do a fix.\n                    if (sourceCode.getTokenBefore(operatorToken, { includeComments: true }) !== tokenBefore &&\n                        sourceCode.getTokenAfter(operatorToken, { includeComments: true }) !== tokenAfter) {\n\n                        return null;\n                    }\n\n                    /*\n                     * If there is only one linebreak and it's on the wrong side of the operator, swap the text before and after the operator.\n                     * foo &&\n                     *           bar\n                     * would get fixed to\n                     * foo\n                     *        && bar\n                     */\n                    newTextBefore = textAfter;\n                    newTextAfter = textBefore;\n                } else {\n                    const LINEBREAK_REGEX = astUtils.createGlobalLinebreakMatcher();\n\n                    // Otherwise, if no linebreak is desired and no comments interfere, replace the linebreaks with empty strings.\n                    newTextBefore = desiredStyle === \"before\" || textBefore.trim() ? textBefore : textBefore.replace(LINEBREAK_REGEX, \"\");\n                    newTextAfter = desiredStyle === \"after\" || textAfter.trim() ? textAfter : textAfter.replace(LINEBREAK_REGEX, \"\");\n\n                    // If there was no change (due to interfering comments), don't output a fix.\n                    if (newTextBefore === textBefore && newTextAfter === textAfter) {\n                        return null;\n                    }\n                }\n\n                if (newTextAfter === \"\" && tokenAfter.type === \"Punctuator\" && \"+-\".includes(operatorToken.value) && tokenAfter.value === operatorToken.value) {\n\n                    // To avoid accidentally creating a ++ or -- operator, insert a space if the operator is a +/- and the following token is a unary +/-.\n                    newTextAfter += \" \";\n                }\n\n                return fixer.replaceTextRange([tokenBefore.range[1], tokenAfter.range[0]], newTextBefore + operatorToken.value + newTextAfter);\n            };\n        }\n\n        /**\n         * Checks the operator placement\n         * @param {ASTNode} node The node to check\n         * @param {ASTNode} leftSide The node that comes before the operator in `node`\n         * @private\n         * @returns {void}\n         */\n        function validateNode(node, leftSide) {\n\n            /*\n             * When the left part of a binary expression is a single expression wrapped in\n             * parentheses (ex: `(a) + b`), leftToken will be the last token of the expression\n             * and operatorToken will be the closing parenthesis.\n             * The leftToken should be the last closing parenthesis, and the operatorToken\n             * should be the token right after that.\n             */\n            const operatorToken = sourceCode.getTokenAfter(leftSide, astUtils.isNotClosingParenToken);\n            const leftToken = sourceCode.getTokenBefore(operatorToken);\n            const rightToken = sourceCode.getTokenAfter(operatorToken);\n            const operator = operatorToken.value;\n            const operatorStyleOverride = styleOverrides[operator];\n            const style = operatorStyleOverride || globalStyle;\n            const fix = getFixer(operatorToken, style);\n\n            // if single line\n            if (astUtils.isTokenOnSameLine(leftToken, operatorToken) &&\n                    astUtils.isTokenOnSameLine(operatorToken, rightToken)) {\n\n                // do nothing.\n\n            } else if (operatorStyleOverride !== \"ignore\" && !astUtils.isTokenOnSameLine(leftToken, operatorToken) &&\n                    !astUtils.isTokenOnSameLine(operatorToken, rightToken)) {\n\n                // lone operator\n                context.report({\n                    node,\n                    loc: operatorToken.loc,\n                    messageId: \"badLinebreak\",\n                    data: {\n                        operator\n                    },\n                    fix\n                });\n\n            } else if (style === \"before\" && astUtils.isTokenOnSameLine(leftToken, operatorToken)) {\n\n                context.report({\n                    node,\n                    loc: operatorToken.loc,\n                    messageId: \"operatorAtBeginning\",\n                    data: {\n                        operator\n                    },\n                    fix\n                });\n\n            } else if (style === \"after\" && astUtils.isTokenOnSameLine(operatorToken, rightToken)) {\n\n                context.report({\n                    node,\n                    loc: operatorToken.loc,\n                    messageId: \"operatorAtEnd\",\n                    data: {\n                        operator\n                    },\n                    fix\n                });\n\n            } else if (style === \"none\") {\n\n                context.report({\n                    node,\n                    loc: operatorToken.loc,\n                    messageId: \"noLinebreak\",\n                    data: {\n                        operator\n                    },\n                    fix\n                });\n\n            }\n        }\n\n        /**\n         * Validates a binary expression using `validateNode`\n         * @param {BinaryExpression|LogicalExpression|AssignmentExpression} node node to be validated\n         * @returns {void}\n         */\n        function validateBinaryExpression(node) {\n            validateNode(node, node.left);\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            BinaryExpression: validateBinaryExpression,\n            LogicalExpression: validateBinaryExpression,\n            AssignmentExpression: validateBinaryExpression,\n            VariableDeclarator(node) {\n                if (node.init) {\n                    validateNode(node, node.id);\n                }\n            },\n            ConditionalExpression(node) {\n                validateNode(node, node.test);\n                validateNode(node, node.consequent);\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}