{"ast":null,"code":"/**\n * @fileoverview Disallow trailing spaces at the end of lines.\n * @author Nodeca Team <https://github.com/nodeca>\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"disallow trailing whitespace at the end of lines\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-trailing-spaces\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      type: \"object\",\n      properties: {\n        skipBlankLines: {\n          type: \"boolean\",\n          default: false\n        },\n        ignoreComments: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      trailingSpace: \"Trailing spaces not allowed.\"\n    }\n  },\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const BLANK_CLASS = \"[ \\t\\u00a0\\u2000-\\u200b\\u3000]\",\n      SKIP_BLANK = `^${BLANK_CLASS}*$`,\n      NONBLANK = `${BLANK_CLASS}+$`;\n    const options = context.options[0] || {},\n      skipBlankLines = options.skipBlankLines || false,\n      ignoreComments = options.ignoreComments || false;\n\n    /**\n     * Report the error message\n     * @param {ASTNode} node node to report\n     * @param {int[]} location range information\n     * @param {int[]} fixRange Range based on the whole program\n     * @returns {void}\n     */\n    function report(node, location, fixRange) {\n      /*\n       * Passing node is a bit dirty, because message data will contain big\n       * text in `source`. But... who cares :) ?\n       * One more kludge will not make worse the bloody wizardry of this\n       * plugin.\n       */\n      context.report({\n        node,\n        loc: location,\n        messageId: \"trailingSpace\",\n        fix(fixer) {\n          return fixer.removeRange(fixRange);\n        }\n      });\n    }\n\n    /**\n     * Given a list of comment nodes, return the line numbers for those comments.\n     * @param {Array} comments An array of comment nodes.\n     * @returns {number[]} An array of line numbers containing comments.\n     */\n    function getCommentLineNumbers(comments) {\n      const lines = new Set();\n      comments.forEach(comment => {\n        const endLine = comment.type === \"Block\" ? comment.loc.end.line - 1 : comment.loc.end.line;\n        for (let i = comment.loc.start.line; i <= endLine; i++) {\n          lines.add(i);\n        }\n      });\n      return lines;\n    }\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    return {\n      Program: function checkTrailingSpaces(node) {\n        /*\n         * Let's hack. Since Espree does not return whitespace nodes,\n         * fetch the source code and do matching via regexps.\n         */\n\n        const re = new RegExp(NONBLANK, \"u\"),\n          skipMatch = new RegExp(SKIP_BLANK, \"u\"),\n          lines = sourceCode.lines,\n          linebreaks = sourceCode.getText().match(astUtils.createGlobalLinebreakMatcher()),\n          comments = sourceCode.getAllComments(),\n          commentLineNumbers = getCommentLineNumbers(comments);\n        let totalLength = 0,\n          fixRange = [];\n        for (let i = 0, ii = lines.length; i < ii; i++) {\n          const lineNumber = i + 1;\n\n          /*\n           * Always add linebreak length to line length to accommodate for line break (\\n or \\r\\n)\n           * Because during the fix time they also reserve one spot in the array.\n           * Usually linebreak length is 2 for \\r\\n (CRLF) and 1 for \\n (LF)\n           */\n          const linebreakLength = linebreaks && linebreaks[i] ? linebreaks[i].length : 1;\n          const lineLength = lines[i].length + linebreakLength;\n          const matches = re.exec(lines[i]);\n          if (matches) {\n            const location = {\n              start: {\n                line: lineNumber,\n                column: matches.index\n              },\n              end: {\n                line: lineNumber,\n                column: lineLength - linebreakLength\n              }\n            };\n            const rangeStart = totalLength + location.start.column;\n            const rangeEnd = totalLength + location.end.column;\n            const containingNode = sourceCode.getNodeByRangeIndex(rangeStart);\n            if (containingNode && containingNode.type === \"TemplateElement\" && rangeStart > containingNode.parent.range[0] && rangeEnd < containingNode.parent.range[1]) {\n              totalLength += lineLength;\n              continue;\n            }\n\n            /*\n             * If the line has only whitespace, and skipBlankLines\n             * is true, don't report it\n             */\n            if (skipBlankLines && skipMatch.test(lines[i])) {\n              totalLength += lineLength;\n              continue;\n            }\n            fixRange = [rangeStart, rangeEnd];\n            if (!ignoreComments || !commentLineNumbers.has(lineNumber)) {\n              report(node, location, fixRange);\n            }\n          }\n          totalLength += lineLength;\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","module","exports","meta","type","docs","description","category","recommended","url","fixable","schema","properties","skipBlankLines","default","ignoreComments","additionalProperties","messages","trailingSpace","create","context","sourceCode","getSourceCode","BLANK_CLASS","SKIP_BLANK","NONBLANK","options","report","node","location","fixRange","loc","messageId","fix","fixer","removeRange","getCommentLineNumbers","comments","lines","Set","forEach","comment","endLine","end","line","i","start","add","Program","checkTrailingSpaces","re","RegExp","skipMatch","linebreaks","getText","match","createGlobalLinebreakMatcher","getAllComments","commentLineNumbers","totalLength","ii","length","lineNumber","linebreakLength","lineLength","matches","exec","column","index","rangeStart","rangeEnd","containingNode","getNodeByRangeIndex","parent","range","test","has"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/no-trailing-spaces.js"],"sourcesContent":["/**\n * @fileoverview Disallow trailing spaces at the end of lines.\n * @author Nodeca Team <https://github.com/nodeca>\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"disallow trailing whitespace at the end of lines\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-trailing-spaces\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    skipBlankLines: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    ignoreComments: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            trailingSpace: \"Trailing spaces not allowed.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        const BLANK_CLASS = \"[ \\t\\u00a0\\u2000-\\u200b\\u3000]\",\n            SKIP_BLANK = `^${BLANK_CLASS}*$`,\n            NONBLANK = `${BLANK_CLASS}+$`;\n\n        const options = context.options[0] || {},\n            skipBlankLines = options.skipBlankLines || false,\n            ignoreComments = options.ignoreComments || false;\n\n        /**\n         * Report the error message\n         * @param {ASTNode} node node to report\n         * @param {int[]} location range information\n         * @param {int[]} fixRange Range based on the whole program\n         * @returns {void}\n         */\n        function report(node, location, fixRange) {\n\n            /*\n             * Passing node is a bit dirty, because message data will contain big\n             * text in `source`. But... who cares :) ?\n             * One more kludge will not make worse the bloody wizardry of this\n             * plugin.\n             */\n            context.report({\n                node,\n                loc: location,\n                messageId: \"trailingSpace\",\n                fix(fixer) {\n                    return fixer.removeRange(fixRange);\n                }\n            });\n        }\n\n        /**\n         * Given a list of comment nodes, return the line numbers for those comments.\n         * @param {Array} comments An array of comment nodes.\n         * @returns {number[]} An array of line numbers containing comments.\n         */\n        function getCommentLineNumbers(comments) {\n            const lines = new Set();\n\n            comments.forEach(comment => {\n                const endLine = comment.type === \"Block\"\n                    ? comment.loc.end.line - 1\n                    : comment.loc.end.line;\n\n                for (let i = comment.loc.start.line; i <= endLine; i++) {\n                    lines.add(i);\n                }\n            });\n\n            return lines;\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n\n            Program: function checkTrailingSpaces(node) {\n\n                /*\n                 * Let's hack. Since Espree does not return whitespace nodes,\n                 * fetch the source code and do matching via regexps.\n                 */\n\n                const re = new RegExp(NONBLANK, \"u\"),\n                    skipMatch = new RegExp(SKIP_BLANK, \"u\"),\n                    lines = sourceCode.lines,\n                    linebreaks = sourceCode.getText().match(astUtils.createGlobalLinebreakMatcher()),\n                    comments = sourceCode.getAllComments(),\n                    commentLineNumbers = getCommentLineNumbers(comments);\n\n                let totalLength = 0,\n                    fixRange = [];\n\n                for (let i = 0, ii = lines.length; i < ii; i++) {\n                    const lineNumber = i + 1;\n\n                    /*\n                     * Always add linebreak length to line length to accommodate for line break (\\n or \\r\\n)\n                     * Because during the fix time they also reserve one spot in the array.\n                     * Usually linebreak length is 2 for \\r\\n (CRLF) and 1 for \\n (LF)\n                     */\n                    const linebreakLength = linebreaks && linebreaks[i] ? linebreaks[i].length : 1;\n                    const lineLength = lines[i].length + linebreakLength;\n\n                    const matches = re.exec(lines[i]);\n\n                    if (matches) {\n                        const location = {\n                            start: {\n                                line: lineNumber,\n                                column: matches.index\n                            },\n                            end: {\n                                line: lineNumber,\n                                column: lineLength - linebreakLength\n                            }\n                        };\n\n                        const rangeStart = totalLength + location.start.column;\n                        const rangeEnd = totalLength + location.end.column;\n                        const containingNode = sourceCode.getNodeByRangeIndex(rangeStart);\n\n                        if (containingNode && containingNode.type === \"TemplateElement\" &&\n                          rangeStart > containingNode.parent.range[0] &&\n                          rangeEnd < containingNode.parent.range[1]) {\n                            totalLength += lineLength;\n                            continue;\n                        }\n\n                        /*\n                         * If the line has only whitespace, and skipBlankLines\n                         * is true, don't report it\n                         */\n                        if (skipBlankLines && skipMatch.test(lines[i])) {\n                            totalLength += lineLength;\n                            continue;\n                        }\n\n                        fixRange = [rangeStart, rangeEnd];\n\n                        if (!ignoreComments || !commentLineNumbers.has(lineNumber)) {\n                            report(node, location, fixRange);\n                        }\n                    }\n\n                    totalLength += lineLength;\n                }\n            }\n\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}