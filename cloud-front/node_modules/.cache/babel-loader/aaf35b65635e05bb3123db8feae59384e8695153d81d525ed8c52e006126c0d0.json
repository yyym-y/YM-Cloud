{"ast":null,"code":"/**\n * @fileoverview Rule to flag non-quoted property names in object literals.\n * @author Mathias Bynens <http://mathiasbynens.be/>\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nrequire(\"core-js/modules/es.array.push.js\");\nconst espree = require(\"espree\");\nconst astUtils = require(\"./utils/ast-utils\");\nconst keywords = require(\"./utils/keywords\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require quotes around object literal property names\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/quote-props\"\n    },\n    schema: {\n      anyOf: [{\n        type: \"array\",\n        items: [{\n          enum: [\"always\", \"as-needed\", \"consistent\", \"consistent-as-needed\"]\n        }],\n        minItems: 0,\n        maxItems: 1\n      }, {\n        type: \"array\",\n        items: [{\n          enum: [\"always\", \"as-needed\", \"consistent\", \"consistent-as-needed\"]\n        }, {\n          type: \"object\",\n          properties: {\n            keywords: {\n              type: \"boolean\"\n            },\n            unnecessary: {\n              type: \"boolean\"\n            },\n            numbers: {\n              type: \"boolean\"\n            }\n          },\n          additionalProperties: false\n        }],\n        minItems: 0,\n        maxItems: 2\n      }]\n    },\n    fixable: \"code\",\n    messages: {\n      requireQuotesDueToReservedWord: \"Properties should be quoted as '{{property}}' is a reserved word.\",\n      inconsistentlyQuotedProperty: \"Inconsistently quoted property '{{key}}' found.\",\n      unnecessarilyQuotedProperty: \"Unnecessarily quoted property '{{property}}' found.\",\n      unquotedReservedProperty: \"Unquoted reserved word '{{property}}' used as key.\",\n      unquotedNumericProperty: \"Unquoted number literal '{{property}}' used as key.\",\n      unquotedPropertyFound: \"Unquoted property '{{property}}' found.\",\n      redundantQuoting: \"Properties shouldn't be quoted as all quotes are redundant.\"\n    }\n  },\n  create(context) {\n    const MODE = context.options[0],\n      KEYWORDS = context.options[1] && context.options[1].keywords,\n      CHECK_UNNECESSARY = !context.options[1] || context.options[1].unnecessary !== false,\n      NUMBERS = context.options[1] && context.options[1].numbers,\n      sourceCode = context.getSourceCode();\n\n    /**\n     * Checks whether a certain string constitutes an ES3 token\n     * @param   {string} tokenStr The string to be checked.\n     * @returns {boolean} `true` if it is an ES3 token.\n     */\n    function isKeyword(tokenStr) {\n      return keywords.indexOf(tokenStr) >= 0;\n    }\n\n    /**\n     * Checks if an espree-tokenized key has redundant quotes (i.e. whether quotes are unnecessary)\n     * @param   {string} rawKey The raw key value from the source\n     * @param   {espreeTokens} tokens The espree-tokenized node key\n     * @param   {boolean} [skipNumberLiterals=false] Indicates whether number literals should be checked\n     * @returns {boolean} Whether or not a key has redundant quotes.\n     * @private\n     */\n    function areQuotesRedundant(rawKey, tokens, skipNumberLiterals) {\n      return tokens.length === 1 && tokens[0].start === 0 && tokens[0].end === rawKey.length && ([\"Identifier\", \"Keyword\", \"Null\", \"Boolean\"].indexOf(tokens[0].type) >= 0 || tokens[0].type === \"Numeric\" && !skipNumberLiterals && String(+tokens[0].value) === tokens[0].value);\n    }\n\n    /**\n     * Returns a string representation of a property node with quotes removed\n     * @param {ASTNode} key Key AST Node, which may or may not be quoted\n     * @returns {string} A replacement string for this property\n     */\n    function getUnquotedKey(key) {\n      return key.type === \"Identifier\" ? key.name : key.value;\n    }\n\n    /**\n     * Returns a string representation of a property node with quotes added\n     * @param {ASTNode} key Key AST Node, which may or may not be quoted\n     * @returns {string} A replacement string for this property\n     */\n    function getQuotedKey(key) {\n      if (key.type === \"Literal\" && typeof key.value === \"string\") {\n        // If the key is already a string literal, don't replace the quotes with double quotes.\n        return sourceCode.getText(key);\n      }\n\n      // Otherwise, the key is either an identifier or a number literal.\n      return `\"${key.type === \"Identifier\" ? key.name : key.value}\"`;\n    }\n\n    /**\n     * Ensures that a property's key is quoted only when necessary\n     * @param   {ASTNode} node Property AST node\n     * @returns {void}\n     */\n    function checkUnnecessaryQuotes(node) {\n      const key = node.key;\n      if (node.method || node.computed || node.shorthand) {\n        return;\n      }\n      if (key.type === \"Literal\" && typeof key.value === \"string\") {\n        let tokens;\n        try {\n          tokens = espree.tokenize(key.value);\n        } catch {\n          return;\n        }\n        if (tokens.length !== 1) {\n          return;\n        }\n        const isKeywordToken = isKeyword(tokens[0].value);\n        if (isKeywordToken && KEYWORDS) {\n          return;\n        }\n        if (CHECK_UNNECESSARY && areQuotesRedundant(key.value, tokens, NUMBERS)) {\n          context.report({\n            node,\n            messageId: \"unnecessarilyQuotedProperty\",\n            data: {\n              property: key.value\n            },\n            fix: fixer => fixer.replaceText(key, getUnquotedKey(key))\n          });\n        }\n      } else if (KEYWORDS && key.type === \"Identifier\" && isKeyword(key.name)) {\n        context.report({\n          node,\n          messageId: \"unquotedReservedProperty\",\n          data: {\n            property: key.name\n          },\n          fix: fixer => fixer.replaceText(key, getQuotedKey(key))\n        });\n      } else if (NUMBERS && key.type === \"Literal\" && astUtils.isNumericLiteral(key)) {\n        context.report({\n          node,\n          messageId: \"unquotedNumericProperty\",\n          data: {\n            property: key.value\n          },\n          fix: fixer => fixer.replaceText(key, getQuotedKey(key))\n        });\n      }\n    }\n\n    /**\n     * Ensures that a property's key is quoted\n     * @param   {ASTNode} node Property AST node\n     * @returns {void}\n     */\n    function checkOmittedQuotes(node) {\n      const key = node.key;\n      if (!node.method && !node.computed && !node.shorthand && !(key.type === \"Literal\" && typeof key.value === \"string\")) {\n        context.report({\n          node,\n          messageId: \"unquotedPropertyFound\",\n          data: {\n            property: key.name || key.value\n          },\n          fix: fixer => fixer.replaceText(key, getQuotedKey(key))\n        });\n      }\n    }\n\n    /**\n     * Ensures that an object's keys are consistently quoted, optionally checks for redundancy of quotes\n     * @param   {ASTNode} node Property AST node\n     * @param   {boolean} checkQuotesRedundancy Whether to check quotes' redundancy\n     * @returns {void}\n     */\n    function checkConsistency(node, checkQuotesRedundancy) {\n      const quotedProps = [],\n        unquotedProps = [];\n      let keywordKeyName = null,\n        necessaryQuotes = false;\n      node.properties.forEach(property => {\n        const key = property.key;\n        if (!key || property.method || property.computed || property.shorthand) {\n          return;\n        }\n        if (key.type === \"Literal\" && typeof key.value === \"string\") {\n          quotedProps.push(property);\n          if (checkQuotesRedundancy) {\n            let tokens;\n            try {\n              tokens = espree.tokenize(key.value);\n            } catch {\n              necessaryQuotes = true;\n              return;\n            }\n            necessaryQuotes = necessaryQuotes || !areQuotesRedundant(key.value, tokens) || KEYWORDS && isKeyword(tokens[0].value);\n          }\n        } else if (KEYWORDS && checkQuotesRedundancy && key.type === \"Identifier\" && isKeyword(key.name)) {\n          unquotedProps.push(property);\n          necessaryQuotes = true;\n          keywordKeyName = key.name;\n        } else {\n          unquotedProps.push(property);\n        }\n      });\n      if (checkQuotesRedundancy && quotedProps.length && !necessaryQuotes) {\n        quotedProps.forEach(property => {\n          context.report({\n            node: property,\n            messageId: \"redundantQuoting\",\n            fix: fixer => fixer.replaceText(property.key, getUnquotedKey(property.key))\n          });\n        });\n      } else if (unquotedProps.length && keywordKeyName) {\n        unquotedProps.forEach(property => {\n          context.report({\n            node: property,\n            messageId: \"requireQuotesDueToReservedWord\",\n            data: {\n              property: keywordKeyName\n            },\n            fix: fixer => fixer.replaceText(property.key, getQuotedKey(property.key))\n          });\n        });\n      } else if (quotedProps.length && unquotedProps.length) {\n        unquotedProps.forEach(property => {\n          context.report({\n            node: property,\n            messageId: \"inconsistentlyQuotedProperty\",\n            data: {\n              key: property.key.name || property.key.value\n            },\n            fix: fixer => fixer.replaceText(property.key, getQuotedKey(property.key))\n          });\n        });\n      }\n    }\n    return {\n      Property(node) {\n        if (MODE === \"always\" || !MODE) {\n          checkOmittedQuotes(node);\n        }\n        if (MODE === \"as-needed\") {\n          checkUnnecessaryQuotes(node);\n        }\n      },\n      ObjectExpression(node) {\n        if (MODE === \"consistent\") {\n          checkConsistency(node, false);\n        }\n        if (MODE === \"consistent-as-needed\") {\n          checkConsistency(node, true);\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["require","espree","astUtils","keywords","module","exports","meta","type","docs","description","category","recommended","url","schema","anyOf","items","enum","minItems","maxItems","properties","unnecessary","numbers","additionalProperties","fixable","messages","requireQuotesDueToReservedWord","inconsistentlyQuotedProperty","unnecessarilyQuotedProperty","unquotedReservedProperty","unquotedNumericProperty","unquotedPropertyFound","redundantQuoting","create","context","MODE","options","KEYWORDS","CHECK_UNNECESSARY","NUMBERS","sourceCode","getSourceCode","isKeyword","tokenStr","indexOf","areQuotesRedundant","rawKey","tokens","skipNumberLiterals","length","start","end","String","value","getUnquotedKey","key","name","getQuotedKey","getText","checkUnnecessaryQuotes","node","method","computed","shorthand","tokenize","isKeywordToken","report","messageId","data","property","fix","fixer","replaceText","isNumericLiteral","checkOmittedQuotes","checkConsistency","checkQuotesRedundancy","quotedProps","unquotedProps","keywordKeyName","necessaryQuotes","forEach","push","Property","ObjectExpression"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/quote-props.js"],"sourcesContent":["/**\n * @fileoverview Rule to flag non-quoted property names in object literals.\n * @author Mathias Bynens <http://mathiasbynens.be/>\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst espree = require(\"espree\");\nconst astUtils = require(\"./utils/ast-utils\");\nconst keywords = require(\"./utils/keywords\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require quotes around object literal property names\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/quote-props\"\n        },\n\n        schema: {\n            anyOf: [\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"always\", \"as-needed\", \"consistent\", \"consistent-as-needed\"]\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 1\n                },\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"always\", \"as-needed\", \"consistent\", \"consistent-as-needed\"]\n                        },\n                        {\n                            type: \"object\",\n                            properties: {\n                                keywords: {\n                                    type: \"boolean\"\n                                },\n                                unnecessary: {\n                                    type: \"boolean\"\n                                },\n                                numbers: {\n                                    type: \"boolean\"\n                                }\n                            },\n                            additionalProperties: false\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 2\n                }\n            ]\n        },\n\n        fixable: \"code\",\n        messages: {\n            requireQuotesDueToReservedWord: \"Properties should be quoted as '{{property}}' is a reserved word.\",\n            inconsistentlyQuotedProperty: \"Inconsistently quoted property '{{key}}' found.\",\n            unnecessarilyQuotedProperty: \"Unnecessarily quoted property '{{property}}' found.\",\n            unquotedReservedProperty: \"Unquoted reserved word '{{property}}' used as key.\",\n            unquotedNumericProperty: \"Unquoted number literal '{{property}}' used as key.\",\n            unquotedPropertyFound: \"Unquoted property '{{property}}' found.\",\n            redundantQuoting: \"Properties shouldn't be quoted as all quotes are redundant.\"\n        }\n    },\n\n    create(context) {\n\n        const MODE = context.options[0],\n            KEYWORDS = context.options[1] && context.options[1].keywords,\n            CHECK_UNNECESSARY = !context.options[1] || context.options[1].unnecessary !== false,\n            NUMBERS = context.options[1] && context.options[1].numbers,\n\n            sourceCode = context.getSourceCode();\n\n\n        /**\n         * Checks whether a certain string constitutes an ES3 token\n         * @param   {string} tokenStr The string to be checked.\n         * @returns {boolean} `true` if it is an ES3 token.\n         */\n        function isKeyword(tokenStr) {\n            return keywords.indexOf(tokenStr) >= 0;\n        }\n\n        /**\n         * Checks if an espree-tokenized key has redundant quotes (i.e. whether quotes are unnecessary)\n         * @param   {string} rawKey The raw key value from the source\n         * @param   {espreeTokens} tokens The espree-tokenized node key\n         * @param   {boolean} [skipNumberLiterals=false] Indicates whether number literals should be checked\n         * @returns {boolean} Whether or not a key has redundant quotes.\n         * @private\n         */\n        function areQuotesRedundant(rawKey, tokens, skipNumberLiterals) {\n            return tokens.length === 1 && tokens[0].start === 0 && tokens[0].end === rawKey.length &&\n                ([\"Identifier\", \"Keyword\", \"Null\", \"Boolean\"].indexOf(tokens[0].type) >= 0 ||\n                (tokens[0].type === \"Numeric\" && !skipNumberLiterals && String(+tokens[0].value) === tokens[0].value));\n        }\n\n        /**\n         * Returns a string representation of a property node with quotes removed\n         * @param {ASTNode} key Key AST Node, which may or may not be quoted\n         * @returns {string} A replacement string for this property\n         */\n        function getUnquotedKey(key) {\n            return key.type === \"Identifier\" ? key.name : key.value;\n        }\n\n        /**\n         * Returns a string representation of a property node with quotes added\n         * @param {ASTNode} key Key AST Node, which may or may not be quoted\n         * @returns {string} A replacement string for this property\n         */\n        function getQuotedKey(key) {\n            if (key.type === \"Literal\" && typeof key.value === \"string\") {\n\n                // If the key is already a string literal, don't replace the quotes with double quotes.\n                return sourceCode.getText(key);\n            }\n\n            // Otherwise, the key is either an identifier or a number literal.\n            return `\"${key.type === \"Identifier\" ? key.name : key.value}\"`;\n        }\n\n        /**\n         * Ensures that a property's key is quoted only when necessary\n         * @param   {ASTNode} node Property AST node\n         * @returns {void}\n         */\n        function checkUnnecessaryQuotes(node) {\n            const key = node.key;\n\n            if (node.method || node.computed || node.shorthand) {\n                return;\n            }\n\n            if (key.type === \"Literal\" && typeof key.value === \"string\") {\n                let tokens;\n\n                try {\n                    tokens = espree.tokenize(key.value);\n                } catch {\n                    return;\n                }\n\n                if (tokens.length !== 1) {\n                    return;\n                }\n\n                const isKeywordToken = isKeyword(tokens[0].value);\n\n                if (isKeywordToken && KEYWORDS) {\n                    return;\n                }\n\n                if (CHECK_UNNECESSARY && areQuotesRedundant(key.value, tokens, NUMBERS)) {\n                    context.report({\n                        node,\n                        messageId: \"unnecessarilyQuotedProperty\",\n                        data: { property: key.value },\n                        fix: fixer => fixer.replaceText(key, getUnquotedKey(key))\n                    });\n                }\n            } else if (KEYWORDS && key.type === \"Identifier\" && isKeyword(key.name)) {\n                context.report({\n                    node,\n                    messageId: \"unquotedReservedProperty\",\n                    data: { property: key.name },\n                    fix: fixer => fixer.replaceText(key, getQuotedKey(key))\n                });\n            } else if (NUMBERS && key.type === \"Literal\" && astUtils.isNumericLiteral(key)) {\n                context.report({\n                    node,\n                    messageId: \"unquotedNumericProperty\",\n                    data: { property: key.value },\n                    fix: fixer => fixer.replaceText(key, getQuotedKey(key))\n                });\n            }\n        }\n\n        /**\n         * Ensures that a property's key is quoted\n         * @param   {ASTNode} node Property AST node\n         * @returns {void}\n         */\n        function checkOmittedQuotes(node) {\n            const key = node.key;\n\n            if (!node.method && !node.computed && !node.shorthand && !(key.type === \"Literal\" && typeof key.value === \"string\")) {\n                context.report({\n                    node,\n                    messageId: \"unquotedPropertyFound\",\n                    data: { property: key.name || key.value },\n                    fix: fixer => fixer.replaceText(key, getQuotedKey(key))\n                });\n            }\n        }\n\n        /**\n         * Ensures that an object's keys are consistently quoted, optionally checks for redundancy of quotes\n         * @param   {ASTNode} node Property AST node\n         * @param   {boolean} checkQuotesRedundancy Whether to check quotes' redundancy\n         * @returns {void}\n         */\n        function checkConsistency(node, checkQuotesRedundancy) {\n            const quotedProps = [],\n                unquotedProps = [];\n            let keywordKeyName = null,\n                necessaryQuotes = false;\n\n            node.properties.forEach(property => {\n                const key = property.key;\n\n                if (!key || property.method || property.computed || property.shorthand) {\n                    return;\n                }\n\n                if (key.type === \"Literal\" && typeof key.value === \"string\") {\n\n                    quotedProps.push(property);\n\n                    if (checkQuotesRedundancy) {\n                        let tokens;\n\n                        try {\n                            tokens = espree.tokenize(key.value);\n                        } catch {\n                            necessaryQuotes = true;\n                            return;\n                        }\n\n                        necessaryQuotes = necessaryQuotes || !areQuotesRedundant(key.value, tokens) || KEYWORDS && isKeyword(tokens[0].value);\n                    }\n                } else if (KEYWORDS && checkQuotesRedundancy && key.type === \"Identifier\" && isKeyword(key.name)) {\n                    unquotedProps.push(property);\n                    necessaryQuotes = true;\n                    keywordKeyName = key.name;\n                } else {\n                    unquotedProps.push(property);\n                }\n            });\n\n            if (checkQuotesRedundancy && quotedProps.length && !necessaryQuotes) {\n                quotedProps.forEach(property => {\n                    context.report({\n                        node: property,\n                        messageId: \"redundantQuoting\",\n                        fix: fixer => fixer.replaceText(property.key, getUnquotedKey(property.key))\n                    });\n                });\n            } else if (unquotedProps.length && keywordKeyName) {\n                unquotedProps.forEach(property => {\n                    context.report({\n                        node: property,\n                        messageId: \"requireQuotesDueToReservedWord\",\n                        data: { property: keywordKeyName },\n                        fix: fixer => fixer.replaceText(property.key, getQuotedKey(property.key))\n                    });\n                });\n            } else if (quotedProps.length && unquotedProps.length) {\n                unquotedProps.forEach(property => {\n                    context.report({\n                        node: property,\n                        messageId: \"inconsistentlyQuotedProperty\",\n                        data: { key: property.key.name || property.key.value },\n                        fix: fixer => fixer.replaceText(property.key, getQuotedKey(property.key))\n                    });\n                });\n            }\n        }\n\n        return {\n            Property(node) {\n                if (MODE === \"always\" || !MODE) {\n                    checkOmittedQuotes(node);\n                }\n                if (MODE === \"as-needed\") {\n                    checkUnnecessaryQuotes(node);\n                }\n            },\n            ObjectExpression(node) {\n                if (MODE === \"consistent\") {\n                    checkConsistency(node, false);\n                }\n                if (MODE === \"consistent-as-needed\") {\n                    checkConsistency(node, true);\n                }\n            }\n        };\n\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}