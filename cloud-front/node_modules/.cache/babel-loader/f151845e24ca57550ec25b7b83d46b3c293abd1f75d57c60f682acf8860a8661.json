{"ast":null,"code":"/**\n * @fileoverview A class to manage state of generating a code path.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nrequire(\"core-js/modules/es.array.push.js\");\nconst CodePathSegment = require(\"./code-path-segment\"),\n  ForkContext = require(\"./fork-context\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Adds given segments into the `dest` array.\n * If the `others` array does not includes the given segments, adds to the `all`\n * array as well.\n *\n * This adds only reachable and used segments.\n * @param {CodePathSegment[]} dest A destination array (`returnedSegments` or `thrownSegments`).\n * @param {CodePathSegment[]} others Another destination array (`returnedSegments` or `thrownSegments`).\n * @param {CodePathSegment[]} all The unified destination array (`finalSegments`).\n * @param {CodePathSegment[]} segments Segments to add.\n * @returns {void}\n */\nfunction addToReturnedOrThrown(dest, others, all, segments) {\n  for (let i = 0; i < segments.length; ++i) {\n    const segment = segments[i];\n    dest.push(segment);\n    if (others.indexOf(segment) === -1) {\n      all.push(segment);\n    }\n  }\n}\n\n/**\n * Gets a loop-context for a `continue` statement.\n * @param {CodePathState} state A state to get.\n * @param {string} label The label of a `continue` statement.\n * @returns {LoopContext} A loop-context for a `continue` statement.\n */\nfunction getContinueContext(state, label) {\n  if (!label) {\n    return state.loopContext;\n  }\n  let context = state.loopContext;\n  while (context) {\n    if (context.label === label) {\n      return context;\n    }\n    context = context.upper;\n  }\n\n  /* istanbul ignore next: foolproof (syntax error) */\n  return null;\n}\n\n/**\n * Gets a context for a `break` statement.\n * @param {CodePathState} state A state to get.\n * @param {string} label The label of a `break` statement.\n * @returns {LoopContext|SwitchContext} A context for a `break` statement.\n */\nfunction getBreakContext(state, label) {\n  let context = state.breakContext;\n  while (context) {\n    if (label ? context.label === label : context.breakable) {\n      return context;\n    }\n    context = context.upper;\n  }\n\n  /* istanbul ignore next: foolproof (syntax error) */\n  return null;\n}\n\n/**\n * Gets a context for a `return` statement.\n * @param {CodePathState} state A state to get.\n * @returns {TryContext|CodePathState} A context for a `return` statement.\n */\nfunction getReturnContext(state) {\n  let context = state.tryContext;\n  while (context) {\n    if (context.hasFinalizer && context.position !== \"finally\") {\n      return context;\n    }\n    context = context.upper;\n  }\n  return state;\n}\n\n/**\n * Gets a context for a `throw` statement.\n * @param {CodePathState} state A state to get.\n * @returns {TryContext|CodePathState} A context for a `throw` statement.\n */\nfunction getThrowContext(state) {\n  let context = state.tryContext;\n  while (context) {\n    if (context.position === \"try\" || context.hasFinalizer && context.position === \"catch\") {\n      return context;\n    }\n    context = context.upper;\n  }\n  return state;\n}\n\n/**\n * Removes a given element from a given array.\n * @param {any[]} xs An array to remove the specific element.\n * @param {any} x An element to be removed.\n * @returns {void}\n */\nfunction remove(xs, x) {\n  xs.splice(xs.indexOf(x), 1);\n}\n\n/**\n * Disconnect given segments.\n *\n * This is used in a process for switch statements.\n * If there is the \"default\" chunk before other cases, the order is different\n * between node's and running's.\n * @param {CodePathSegment[]} prevSegments Forward segments to disconnect.\n * @param {CodePathSegment[]} nextSegments Backward segments to disconnect.\n * @returns {void}\n */\nfunction removeConnection(prevSegments, nextSegments) {\n  for (let i = 0; i < prevSegments.length; ++i) {\n    const prevSegment = prevSegments[i];\n    const nextSegment = nextSegments[i];\n    remove(prevSegment.nextSegments, nextSegment);\n    remove(prevSegment.allNextSegments, nextSegment);\n    remove(nextSegment.prevSegments, prevSegment);\n    remove(nextSegment.allPrevSegments, prevSegment);\n  }\n}\n\n/**\n * Creates looping path.\n * @param {CodePathState} state The instance.\n * @param {CodePathSegment[]} unflattenedFromSegments Segments which are source.\n * @param {CodePathSegment[]} unflattenedToSegments Segments which are destination.\n * @returns {void}\n */\nfunction makeLooped(state, unflattenedFromSegments, unflattenedToSegments) {\n  const fromSegments = CodePathSegment.flattenUnusedSegments(unflattenedFromSegments);\n  const toSegments = CodePathSegment.flattenUnusedSegments(unflattenedToSegments);\n  const end = Math.min(fromSegments.length, toSegments.length);\n  for (let i = 0; i < end; ++i) {\n    const fromSegment = fromSegments[i];\n    const toSegment = toSegments[i];\n    if (toSegment.reachable) {\n      fromSegment.nextSegments.push(toSegment);\n    }\n    if (fromSegment.reachable) {\n      toSegment.prevSegments.push(fromSegment);\n    }\n    fromSegment.allNextSegments.push(toSegment);\n    toSegment.allPrevSegments.push(fromSegment);\n    if (toSegment.allPrevSegments.length >= 2) {\n      CodePathSegment.markPrevSegmentAsLooped(toSegment, fromSegment);\n    }\n    state.notifyLooped(fromSegment, toSegment);\n  }\n}\n\n/**\n * Finalizes segments of `test` chunk of a ForStatement.\n *\n * - Adds `false` paths to paths which are leaving from the loop.\n * - Sets `true` paths to paths which go to the body.\n * @param {LoopContext} context A loop context to modify.\n * @param {ChoiceContext} choiceContext A choice context of this loop.\n * @param {CodePathSegment[]} head The current head paths.\n * @returns {void}\n */\nfunction finalizeTestSegmentsOfFor(context, choiceContext, head) {\n  if (!choiceContext.processed) {\n    choiceContext.trueForkContext.add(head);\n    choiceContext.falseForkContext.add(head);\n    choiceContext.qqForkContext.add(head);\n  }\n  if (context.test !== true) {\n    context.brokenForkContext.addAll(choiceContext.falseForkContext);\n  }\n  context.endOfTestSegments = choiceContext.trueForkContext.makeNext(0, -1);\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * A class which manages state to analyze code paths.\n */\nclass CodePathState {\n  // eslint-disable-next-line jsdoc/require-description\n  /**\n   * @param {IdGenerator} idGenerator An id generator to generate id for code\n   *   path segments.\n   * @param {Function} onLooped A callback function to notify looping.\n   */\n  constructor(idGenerator, onLooped) {\n    this.idGenerator = idGenerator;\n    this.notifyLooped = onLooped;\n    this.forkContext = ForkContext.newRoot(idGenerator);\n    this.choiceContext = null;\n    this.switchContext = null;\n    this.tryContext = null;\n    this.loopContext = null;\n    this.breakContext = null;\n    this.chainContext = null;\n    this.currentSegments = [];\n    this.initialSegment = this.forkContext.head[0];\n\n    // returnedSegments and thrownSegments push elements into finalSegments also.\n    const final = this.finalSegments = [];\n    const returned = this.returnedForkContext = [];\n    const thrown = this.thrownForkContext = [];\n    returned.add = addToReturnedOrThrown.bind(null, returned, thrown, final);\n    thrown.add = addToReturnedOrThrown.bind(null, thrown, returned, final);\n  }\n\n  /**\n   * The head segments.\n   * @type {CodePathSegment[]}\n   */\n  get headSegments() {\n    return this.forkContext.head;\n  }\n\n  /**\n   * The parent forking context.\n   * This is used for the root of new forks.\n   * @type {ForkContext}\n   */\n  get parentForkContext() {\n    const current = this.forkContext;\n    return current && current.upper;\n  }\n\n  /**\n   * Creates and stacks new forking context.\n   * @param {boolean} forkLeavingPath A flag which shows being in a\n   *   \"finally\" block.\n   * @returns {ForkContext} The created context.\n   */\n  pushForkContext(forkLeavingPath) {\n    this.forkContext = ForkContext.newEmpty(this.forkContext, forkLeavingPath);\n    return this.forkContext;\n  }\n\n  /**\n   * Pops and merges the last forking context.\n   * @returns {ForkContext} The last context.\n   */\n  popForkContext() {\n    const lastContext = this.forkContext;\n    this.forkContext = lastContext.upper;\n    this.forkContext.replaceHead(lastContext.makeNext(0, -1));\n    return lastContext;\n  }\n\n  /**\n   * Creates a new path.\n   * @returns {void}\n   */\n  forkPath() {\n    this.forkContext.add(this.parentForkContext.makeNext(-1, -1));\n  }\n\n  /**\n   * Creates a bypass path.\n   * This is used for such as IfStatement which does not have \"else\" chunk.\n   * @returns {void}\n   */\n  forkBypassPath() {\n    this.forkContext.add(this.parentForkContext.head);\n  }\n\n  //--------------------------------------------------------------------------\n  // ConditionalExpression, LogicalExpression, IfStatement\n  //--------------------------------------------------------------------------\n\n  /**\n   * Creates a context for ConditionalExpression, LogicalExpression, AssignmentExpression (logical assignments only),\n   * IfStatement, WhileStatement, DoWhileStatement, or ForStatement.\n   *\n   * LogicalExpressions have cases that it goes different paths between the\n   * `true` case and the `false` case.\n   *\n   * For Example:\n   *\n   *     if (a || b) {\n   *         foo();\n   *     } else {\n   *         bar();\n   *     }\n   *\n   * In this case, `b` is evaluated always in the code path of the `else`\n   * block, but it's not so in the code path of the `if` block.\n   * So there are 3 paths.\n   *\n   *     a -> foo();\n   *     a -> b -> foo();\n   *     a -> b -> bar();\n   * @param {string} kind A kind string.\n   *   If the new context is LogicalExpression's or AssignmentExpression's, this is `\"&&\"` or `\"||\"` or `\"??\"`.\n   *   If it's IfStatement's or ConditionalExpression's, this is `\"test\"`.\n   *   Otherwise, this is `\"loop\"`.\n   * @param {boolean} isForkingAsResult A flag that shows that goes different\n   *   paths between `true` and `false`.\n   * @returns {void}\n   */\n  pushChoiceContext(kind, isForkingAsResult) {\n    this.choiceContext = {\n      upper: this.choiceContext,\n      kind,\n      isForkingAsResult,\n      trueForkContext: ForkContext.newEmpty(this.forkContext),\n      falseForkContext: ForkContext.newEmpty(this.forkContext),\n      qqForkContext: ForkContext.newEmpty(this.forkContext),\n      processed: false\n    };\n  }\n\n  /**\n   * Pops the last choice context and finalizes it.\n   * @returns {ChoiceContext} The popped context.\n   */\n  popChoiceContext() {\n    const context = this.choiceContext;\n    this.choiceContext = context.upper;\n    const forkContext = this.forkContext;\n    const headSegments = forkContext.head;\n    switch (context.kind) {\n      case \"&&\":\n      case \"||\":\n      case \"??\":\n        /*\n         * If any result were not transferred from child contexts,\n         * this sets the head segments to both cases.\n         * The head segments are the path of the right-hand operand.\n         */\n        if (!context.processed) {\n          context.trueForkContext.add(headSegments);\n          context.falseForkContext.add(headSegments);\n          context.qqForkContext.add(headSegments);\n        }\n\n        /*\n         * Transfers results to upper context if this context is in\n         * test chunk.\n         */\n        if (context.isForkingAsResult) {\n          const parentContext = this.choiceContext;\n          parentContext.trueForkContext.addAll(context.trueForkContext);\n          parentContext.falseForkContext.addAll(context.falseForkContext);\n          parentContext.qqForkContext.addAll(context.qqForkContext);\n          parentContext.processed = true;\n          return context;\n        }\n        break;\n      case \"test\":\n        if (!context.processed) {\n          /*\n           * The head segments are the path of the `if` block here.\n           * Updates the `true` path with the end of the `if` block.\n           */\n          context.trueForkContext.clear();\n          context.trueForkContext.add(headSegments);\n        } else {\n          /*\n           * The head segments are the path of the `else` block here.\n           * Updates the `false` path with the end of the `else`\n           * block.\n           */\n          context.falseForkContext.clear();\n          context.falseForkContext.add(headSegments);\n        }\n        break;\n      case \"loop\":\n        /*\n         * Loops are addressed in popLoopContext().\n         * This is called from popLoopContext().\n         */\n        return context;\n\n      /* istanbul ignore next */\n      default:\n        throw new Error(\"unreachable\");\n    }\n\n    // Merges all paths.\n    const prevForkContext = context.trueForkContext;\n    prevForkContext.addAll(context.falseForkContext);\n    forkContext.replaceHead(prevForkContext.makeNext(0, -1));\n    return context;\n  }\n\n  /**\n   * Makes a code path segment of the right-hand operand of a logical\n   * expression.\n   * @returns {void}\n   */\n  makeLogicalRight() {\n    const context = this.choiceContext;\n    const forkContext = this.forkContext;\n    if (context.processed) {\n      /*\n       * This got segments already from the child choice context.\n       * Creates the next path from own true/false fork context.\n       */\n      let prevForkContext;\n      switch (context.kind) {\n        case \"&&\":\n          // if true then go to the right-hand side.\n          prevForkContext = context.trueForkContext;\n          break;\n        case \"||\":\n          // if false then go to the right-hand side.\n          prevForkContext = context.falseForkContext;\n          break;\n        case \"??\":\n          // Both true/false can short-circuit, so needs the third path to go to the right-hand side. That's qqForkContext.\n          prevForkContext = context.qqForkContext;\n          break;\n        default:\n          throw new Error(\"unreachable\");\n      }\n      forkContext.replaceHead(prevForkContext.makeNext(0, -1));\n      prevForkContext.clear();\n      context.processed = false;\n    } else {\n      /*\n       * This did not get segments from the child choice context.\n       * So addresses the head segments.\n       * The head segments are the path of the left-hand operand.\n       */\n      switch (context.kind) {\n        case \"&&\":\n          // the false path can short-circuit.\n          context.falseForkContext.add(forkContext.head);\n          break;\n        case \"||\":\n          // the true path can short-circuit.\n          context.trueForkContext.add(forkContext.head);\n          break;\n        case \"??\":\n          // both can short-circuit.\n          context.trueForkContext.add(forkContext.head);\n          context.falseForkContext.add(forkContext.head);\n          break;\n        default:\n          throw new Error(\"unreachable\");\n      }\n      forkContext.replaceHead(forkContext.makeNext(-1, -1));\n    }\n  }\n\n  /**\n   * Makes a code path segment of the `if` block.\n   * @returns {void}\n   */\n  makeIfConsequent() {\n    const context = this.choiceContext;\n    const forkContext = this.forkContext;\n\n    /*\n     * If any result were not transferred from child contexts,\n     * this sets the head segments to both cases.\n     * The head segments are the path of the test expression.\n     */\n    if (!context.processed) {\n      context.trueForkContext.add(forkContext.head);\n      context.falseForkContext.add(forkContext.head);\n      context.qqForkContext.add(forkContext.head);\n    }\n    context.processed = false;\n\n    // Creates new path from the `true` case.\n    forkContext.replaceHead(context.trueForkContext.makeNext(0, -1));\n  }\n\n  /**\n   * Makes a code path segment of the `else` block.\n   * @returns {void}\n   */\n  makeIfAlternate() {\n    const context = this.choiceContext;\n    const forkContext = this.forkContext;\n\n    /*\n     * The head segments are the path of the `if` block.\n     * Updates the `true` path with the end of the `if` block.\n     */\n    context.trueForkContext.clear();\n    context.trueForkContext.add(forkContext.head);\n    context.processed = true;\n\n    // Creates new path from the `false` case.\n    forkContext.replaceHead(context.falseForkContext.makeNext(0, -1));\n  }\n\n  //--------------------------------------------------------------------------\n  // ChainExpression\n  //--------------------------------------------------------------------------\n\n  /**\n   * Push a new `ChainExpression` context to the stack.\n   * This method is called on entering to each `ChainExpression` node.\n   * This context is used to count forking in the optional chain then merge them on the exiting from the `ChainExpression` node.\n   * @returns {void}\n   */\n  pushChainContext() {\n    this.chainContext = {\n      upper: this.chainContext,\n      countChoiceContexts: 0\n    };\n  }\n\n  /**\n   * Pop a `ChainExpression` context from the stack.\n   * This method is called on exiting from each `ChainExpression` node.\n   * This merges all forks of the last optional chaining.\n   * @returns {void}\n   */\n  popChainContext() {\n    const context = this.chainContext;\n    this.chainContext = context.upper;\n\n    // pop all choice contexts of this.\n    for (let i = context.countChoiceContexts; i > 0; --i) {\n      this.popChoiceContext();\n    }\n  }\n\n  /**\n   * Create a choice context for optional access.\n   * This method is called on entering to each `(Call|Member)Expression[optional=true]` node.\n   * This creates a choice context as similar to `LogicalExpression[operator=\"??\"]` node.\n   * @returns {void}\n   */\n  makeOptionalNode() {\n    if (this.chainContext) {\n      this.chainContext.countChoiceContexts += 1;\n      this.pushChoiceContext(\"??\", false);\n    }\n  }\n\n  /**\n   * Create a fork.\n   * This method is called on entering to the `arguments|property` property of each `(Call|Member)Expression` node.\n   * @returns {void}\n   */\n  makeOptionalRight() {\n    if (this.chainContext) {\n      this.makeLogicalRight();\n    }\n  }\n\n  //--------------------------------------------------------------------------\n  // SwitchStatement\n  //--------------------------------------------------------------------------\n\n  /**\n   * Creates a context object of SwitchStatement and stacks it.\n   * @param {boolean} hasCase `true` if the switch statement has one or more\n   *   case parts.\n   * @param {string|null} label The label text.\n   * @returns {void}\n   */\n  pushSwitchContext(hasCase, label) {\n    this.switchContext = {\n      upper: this.switchContext,\n      hasCase,\n      defaultSegments: null,\n      defaultBodySegments: null,\n      foundDefault: false,\n      lastIsDefault: false,\n      countForks: 0\n    };\n    this.pushBreakContext(true, label);\n  }\n\n  /**\n   * Pops the last context of SwitchStatement and finalizes it.\n   *\n   * - Disposes all forking stack for `case` and `default`.\n   * - Creates the next code path segment from `context.brokenForkContext`.\n   * - If the last `SwitchCase` node is not a `default` part, creates a path\n   *   to the `default` body.\n   * @returns {void}\n   */\n  popSwitchContext() {\n    const context = this.switchContext;\n    this.switchContext = context.upper;\n    const forkContext = this.forkContext;\n    const brokenForkContext = this.popBreakContext().brokenForkContext;\n    if (context.countForks === 0) {\n      /*\n       * When there is only one `default` chunk and there is one or more\n       * `break` statements, even if forks are nothing, it needs to merge\n       * those.\n       */\n      if (!brokenForkContext.empty) {\n        brokenForkContext.add(forkContext.makeNext(-1, -1));\n        forkContext.replaceHead(brokenForkContext.makeNext(0, -1));\n      }\n      return;\n    }\n    const lastSegments = forkContext.head;\n    this.forkBypassPath();\n    const lastCaseSegments = forkContext.head;\n\n    /*\n     * `brokenForkContext` is used to make the next segment.\n     * It must add the last segment into `brokenForkContext`.\n     */\n    brokenForkContext.add(lastSegments);\n\n    /*\n     * A path which is failed in all case test should be connected to path\n     * of `default` chunk.\n     */\n    if (!context.lastIsDefault) {\n      if (context.defaultBodySegments) {\n        /*\n         * Remove a link from `default` label to its chunk.\n         * It's false route.\n         */\n        removeConnection(context.defaultSegments, context.defaultBodySegments);\n        makeLooped(this, lastCaseSegments, context.defaultBodySegments);\n      } else {\n        /*\n         * It handles the last case body as broken if `default` chunk\n         * does not exist.\n         */\n        brokenForkContext.add(lastCaseSegments);\n      }\n    }\n\n    // Pops the segment context stack until the entry segment.\n    for (let i = 0; i < context.countForks; ++i) {\n      this.forkContext = this.forkContext.upper;\n    }\n\n    /*\n     * Creates a path from all brokenForkContext paths.\n     * This is a path after switch statement.\n     */\n    this.forkContext.replaceHead(brokenForkContext.makeNext(0, -1));\n  }\n\n  /**\n   * Makes a code path segment for a `SwitchCase` node.\n   * @param {boolean} isEmpty `true` if the body is empty.\n   * @param {boolean} isDefault `true` if the body is the default case.\n   * @returns {void}\n   */\n  makeSwitchCaseBody(isEmpty, isDefault) {\n    const context = this.switchContext;\n    if (!context.hasCase) {\n      return;\n    }\n\n    /*\n     * Merge forks.\n     * The parent fork context has two segments.\n     * Those are from the current case and the body of the previous case.\n     */\n    const parentForkContext = this.forkContext;\n    const forkContext = this.pushForkContext();\n    forkContext.add(parentForkContext.makeNext(0, -1));\n\n    /*\n     * Save `default` chunk info.\n     * If the `default` label is not at the last, we must make a path from\n     * the last `case` to the `default` chunk.\n     */\n    if (isDefault) {\n      context.defaultSegments = parentForkContext.head;\n      if (isEmpty) {\n        context.foundDefault = true;\n      } else {\n        context.defaultBodySegments = forkContext.head;\n      }\n    } else {\n      if (!isEmpty && context.foundDefault) {\n        context.foundDefault = false;\n        context.defaultBodySegments = forkContext.head;\n      }\n    }\n    context.lastIsDefault = isDefault;\n    context.countForks += 1;\n  }\n\n  //--------------------------------------------------------------------------\n  // TryStatement\n  //--------------------------------------------------------------------------\n\n  /**\n   * Creates a context object of TryStatement and stacks it.\n   * @param {boolean} hasFinalizer `true` if the try statement has a\n   *   `finally` block.\n   * @returns {void}\n   */\n  pushTryContext(hasFinalizer) {\n    this.tryContext = {\n      upper: this.tryContext,\n      position: \"try\",\n      hasFinalizer,\n      returnedForkContext: hasFinalizer ? ForkContext.newEmpty(this.forkContext) : null,\n      thrownForkContext: ForkContext.newEmpty(this.forkContext),\n      lastOfTryIsReachable: false,\n      lastOfCatchIsReachable: false\n    };\n  }\n\n  /**\n   * Pops the last context of TryStatement and finalizes it.\n   * @returns {void}\n   */\n  popTryContext() {\n    const context = this.tryContext;\n    this.tryContext = context.upper;\n    if (context.position === \"catch\") {\n      // Merges two paths from the `try` block and `catch` block merely.\n      this.popForkContext();\n      return;\n    }\n\n    /*\n     * The following process is executed only when there is the `finally`\n     * block.\n     */\n\n    const returned = context.returnedForkContext;\n    const thrown = context.thrownForkContext;\n    if (returned.empty && thrown.empty) {\n      return;\n    }\n\n    // Separate head to normal paths and leaving paths.\n    const headSegments = this.forkContext.head;\n    this.forkContext = this.forkContext.upper;\n    const normalSegments = headSegments.slice(0, headSegments.length / 2 | 0);\n    const leavingSegments = headSegments.slice(headSegments.length / 2 | 0);\n\n    // Forwards the leaving path to upper contexts.\n    if (!returned.empty) {\n      getReturnContext(this).returnedForkContext.add(leavingSegments);\n    }\n    if (!thrown.empty) {\n      getThrowContext(this).thrownForkContext.add(leavingSegments);\n    }\n\n    // Sets the normal path as the next.\n    this.forkContext.replaceHead(normalSegments);\n\n    /*\n     * If both paths of the `try` block and the `catch` block are\n     * unreachable, the next path becomes unreachable as well.\n     */\n    if (!context.lastOfTryIsReachable && !context.lastOfCatchIsReachable) {\n      this.forkContext.makeUnreachable();\n    }\n  }\n\n  /**\n   * Makes a code path segment for a `catch` block.\n   * @returns {void}\n   */\n  makeCatchBlock() {\n    const context = this.tryContext;\n    const forkContext = this.forkContext;\n    const thrown = context.thrownForkContext;\n\n    // Update state.\n    context.position = \"catch\";\n    context.thrownForkContext = ForkContext.newEmpty(forkContext);\n    context.lastOfTryIsReachable = forkContext.reachable;\n\n    // Merge thrown paths.\n    thrown.add(forkContext.head);\n    const thrownSegments = thrown.makeNext(0, -1);\n\n    // Fork to a bypass and the merged thrown path.\n    this.pushForkContext();\n    this.forkBypassPath();\n    this.forkContext.add(thrownSegments);\n  }\n\n  /**\n   * Makes a code path segment for a `finally` block.\n   *\n   * In the `finally` block, parallel paths are created. The parallel paths\n   * are used as leaving-paths. The leaving-paths are paths from `return`\n   * statements and `throw` statements in a `try` block or a `catch` block.\n   * @returns {void}\n   */\n  makeFinallyBlock() {\n    const context = this.tryContext;\n    let forkContext = this.forkContext;\n    const returned = context.returnedForkContext;\n    const thrown = context.thrownForkContext;\n    const headOfLeavingSegments = forkContext.head;\n\n    // Update state.\n    if (context.position === \"catch\") {\n      // Merges two paths from the `try` block and `catch` block.\n      this.popForkContext();\n      forkContext = this.forkContext;\n      context.lastOfCatchIsReachable = forkContext.reachable;\n    } else {\n      context.lastOfTryIsReachable = forkContext.reachable;\n    }\n    context.position = \"finally\";\n    if (returned.empty && thrown.empty) {\n      // This path does not leave.\n      return;\n    }\n\n    /*\n     * Create a parallel segment from merging returned and thrown.\n     * This segment will leave at the end of this finally block.\n     */\n    const segments = forkContext.makeNext(-1, -1);\n    for (let i = 0; i < forkContext.count; ++i) {\n      const prevSegsOfLeavingSegment = [headOfLeavingSegments[i]];\n      for (let j = 0; j < returned.segmentsList.length; ++j) {\n        prevSegsOfLeavingSegment.push(returned.segmentsList[j][i]);\n      }\n      for (let j = 0; j < thrown.segmentsList.length; ++j) {\n        prevSegsOfLeavingSegment.push(thrown.segmentsList[j][i]);\n      }\n      segments.push(CodePathSegment.newNext(this.idGenerator.next(), prevSegsOfLeavingSegment));\n    }\n    this.pushForkContext(true);\n    this.forkContext.add(segments);\n  }\n\n  /**\n   * Makes a code path segment from the first throwable node to the `catch`\n   * block or the `finally` block.\n   * @returns {void}\n   */\n  makeFirstThrowablePathInTryBlock() {\n    const forkContext = this.forkContext;\n    if (!forkContext.reachable) {\n      return;\n    }\n    const context = getThrowContext(this);\n    if (context === this || context.position !== \"try\" || !context.thrownForkContext.empty) {\n      return;\n    }\n    context.thrownForkContext.add(forkContext.head);\n    forkContext.replaceHead(forkContext.makeNext(-1, -1));\n  }\n\n  //--------------------------------------------------------------------------\n  // Loop Statements\n  //--------------------------------------------------------------------------\n\n  /**\n   * Creates a context object of a loop statement and stacks it.\n   * @param {string} type The type of the node which was triggered. One of\n   *   `WhileStatement`, `DoWhileStatement`, `ForStatement`, `ForInStatement`,\n   *   and `ForStatement`.\n   * @param {string|null} label A label of the node which was triggered.\n   * @returns {void}\n   */\n  pushLoopContext(type, label) {\n    const forkContext = this.forkContext;\n    const breakContext = this.pushBreakContext(true, label);\n    switch (type) {\n      case \"WhileStatement\":\n        this.pushChoiceContext(\"loop\", false);\n        this.loopContext = {\n          upper: this.loopContext,\n          type,\n          label,\n          test: void 0,\n          continueDestSegments: null,\n          brokenForkContext: breakContext.brokenForkContext\n        };\n        break;\n      case \"DoWhileStatement\":\n        this.pushChoiceContext(\"loop\", false);\n        this.loopContext = {\n          upper: this.loopContext,\n          type,\n          label,\n          test: void 0,\n          entrySegments: null,\n          continueForkContext: ForkContext.newEmpty(forkContext),\n          brokenForkContext: breakContext.brokenForkContext\n        };\n        break;\n      case \"ForStatement\":\n        this.pushChoiceContext(\"loop\", false);\n        this.loopContext = {\n          upper: this.loopContext,\n          type,\n          label,\n          test: void 0,\n          endOfInitSegments: null,\n          testSegments: null,\n          endOfTestSegments: null,\n          updateSegments: null,\n          endOfUpdateSegments: null,\n          continueDestSegments: null,\n          brokenForkContext: breakContext.brokenForkContext\n        };\n        break;\n      case \"ForInStatement\":\n      case \"ForOfStatement\":\n        this.loopContext = {\n          upper: this.loopContext,\n          type,\n          label,\n          prevSegments: null,\n          leftSegments: null,\n          endOfLeftSegments: null,\n          continueDestSegments: null,\n          brokenForkContext: breakContext.brokenForkContext\n        };\n        break;\n\n      /* istanbul ignore next */\n      default:\n        throw new Error(`unknown type: \"${type}\"`);\n    }\n  }\n\n  /**\n   * Pops the last context of a loop statement and finalizes it.\n   * @returns {void}\n   */\n  popLoopContext() {\n    const context = this.loopContext;\n    this.loopContext = context.upper;\n    const forkContext = this.forkContext;\n    const brokenForkContext = this.popBreakContext().brokenForkContext;\n\n    // Creates a looped path.\n    switch (context.type) {\n      case \"WhileStatement\":\n      case \"ForStatement\":\n        this.popChoiceContext();\n        makeLooped(this, forkContext.head, context.continueDestSegments);\n        break;\n      case \"DoWhileStatement\":\n        {\n          const choiceContext = this.popChoiceContext();\n          if (!choiceContext.processed) {\n            choiceContext.trueForkContext.add(forkContext.head);\n            choiceContext.falseForkContext.add(forkContext.head);\n          }\n          if (context.test !== true) {\n            brokenForkContext.addAll(choiceContext.falseForkContext);\n          }\n\n          // `true` paths go to looping.\n          const segmentsList = choiceContext.trueForkContext.segmentsList;\n          for (let i = 0; i < segmentsList.length; ++i) {\n            makeLooped(this, segmentsList[i], context.entrySegments);\n          }\n          break;\n        }\n      case \"ForInStatement\":\n      case \"ForOfStatement\":\n        brokenForkContext.add(forkContext.head);\n        makeLooped(this, forkContext.head, context.leftSegments);\n        break;\n\n      /* istanbul ignore next */\n      default:\n        throw new Error(\"unreachable\");\n    }\n\n    // Go next.\n    if (brokenForkContext.empty) {\n      forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));\n    } else {\n      forkContext.replaceHead(brokenForkContext.makeNext(0, -1));\n    }\n  }\n\n  /**\n   * Makes a code path segment for the test part of a WhileStatement.\n   * @param {boolean|undefined} test The test value (only when constant).\n   * @returns {void}\n   */\n  makeWhileTest(test) {\n    const context = this.loopContext;\n    const forkContext = this.forkContext;\n    const testSegments = forkContext.makeNext(0, -1);\n\n    // Update state.\n    context.test = test;\n    context.continueDestSegments = testSegments;\n    forkContext.replaceHead(testSegments);\n  }\n\n  /**\n   * Makes a code path segment for the body part of a WhileStatement.\n   * @returns {void}\n   */\n  makeWhileBody() {\n    const context = this.loopContext;\n    const choiceContext = this.choiceContext;\n    const forkContext = this.forkContext;\n    if (!choiceContext.processed) {\n      choiceContext.trueForkContext.add(forkContext.head);\n      choiceContext.falseForkContext.add(forkContext.head);\n    }\n\n    // Update state.\n    if (context.test !== true) {\n      context.brokenForkContext.addAll(choiceContext.falseForkContext);\n    }\n    forkContext.replaceHead(choiceContext.trueForkContext.makeNext(0, -1));\n  }\n\n  /**\n   * Makes a code path segment for the body part of a DoWhileStatement.\n   * @returns {void}\n   */\n  makeDoWhileBody() {\n    const context = this.loopContext;\n    const forkContext = this.forkContext;\n    const bodySegments = forkContext.makeNext(-1, -1);\n\n    // Update state.\n    context.entrySegments = bodySegments;\n    forkContext.replaceHead(bodySegments);\n  }\n\n  /**\n   * Makes a code path segment for the test part of a DoWhileStatement.\n   * @param {boolean|undefined} test The test value (only when constant).\n   * @returns {void}\n   */\n  makeDoWhileTest(test) {\n    const context = this.loopContext;\n    const forkContext = this.forkContext;\n    context.test = test;\n\n    // Creates paths of `continue` statements.\n    if (!context.continueForkContext.empty) {\n      context.continueForkContext.add(forkContext.head);\n      const testSegments = context.continueForkContext.makeNext(0, -1);\n      forkContext.replaceHead(testSegments);\n    }\n  }\n\n  /**\n   * Makes a code path segment for the test part of a ForStatement.\n   * @param {boolean|undefined} test The test value (only when constant).\n   * @returns {void}\n   */\n  makeForTest(test) {\n    const context = this.loopContext;\n    const forkContext = this.forkContext;\n    const endOfInitSegments = forkContext.head;\n    const testSegments = forkContext.makeNext(-1, -1);\n\n    // Update state.\n    context.test = test;\n    context.endOfInitSegments = endOfInitSegments;\n    context.continueDestSegments = context.testSegments = testSegments;\n    forkContext.replaceHead(testSegments);\n  }\n\n  /**\n   * Makes a code path segment for the update part of a ForStatement.\n   * @returns {void}\n   */\n  makeForUpdate() {\n    const context = this.loopContext;\n    const choiceContext = this.choiceContext;\n    const forkContext = this.forkContext;\n\n    // Make the next paths of the test.\n    if (context.testSegments) {\n      finalizeTestSegmentsOfFor(context, choiceContext, forkContext.head);\n    } else {\n      context.endOfInitSegments = forkContext.head;\n    }\n\n    // Update state.\n    const updateSegments = forkContext.makeDisconnected(-1, -1);\n    context.continueDestSegments = context.updateSegments = updateSegments;\n    forkContext.replaceHead(updateSegments);\n  }\n\n  /**\n   * Makes a code path segment for the body part of a ForStatement.\n   * @returns {void}\n   */\n  makeForBody() {\n    const context = this.loopContext;\n    const choiceContext = this.choiceContext;\n    const forkContext = this.forkContext;\n\n    // Update state.\n    if (context.updateSegments) {\n      context.endOfUpdateSegments = forkContext.head;\n\n      // `update` -> `test`\n      if (context.testSegments) {\n        makeLooped(this, context.endOfUpdateSegments, context.testSegments);\n      }\n    } else if (context.testSegments) {\n      finalizeTestSegmentsOfFor(context, choiceContext, forkContext.head);\n    } else {\n      context.endOfInitSegments = forkContext.head;\n    }\n    let bodySegments = context.endOfTestSegments;\n    if (!bodySegments) {\n      /*\n       * If there is not the `test` part, the `body` path comes from the\n       * `init` part and the `update` part.\n       */\n      const prevForkContext = ForkContext.newEmpty(forkContext);\n      prevForkContext.add(context.endOfInitSegments);\n      if (context.endOfUpdateSegments) {\n        prevForkContext.add(context.endOfUpdateSegments);\n      }\n      bodySegments = prevForkContext.makeNext(0, -1);\n    }\n    context.continueDestSegments = context.continueDestSegments || bodySegments;\n    forkContext.replaceHead(bodySegments);\n  }\n\n  /**\n   * Makes a code path segment for the left part of a ForInStatement and a\n   * ForOfStatement.\n   * @returns {void}\n   */\n  makeForInOfLeft() {\n    const context = this.loopContext;\n    const forkContext = this.forkContext;\n    const leftSegments = forkContext.makeDisconnected(-1, -1);\n\n    // Update state.\n    context.prevSegments = forkContext.head;\n    context.leftSegments = context.continueDestSegments = leftSegments;\n    forkContext.replaceHead(leftSegments);\n  }\n\n  /**\n   * Makes a code path segment for the right part of a ForInStatement and a\n   * ForOfStatement.\n   * @returns {void}\n   */\n  makeForInOfRight() {\n    const context = this.loopContext;\n    const forkContext = this.forkContext;\n    const temp = ForkContext.newEmpty(forkContext);\n    temp.add(context.prevSegments);\n    const rightSegments = temp.makeNext(-1, -1);\n\n    // Update state.\n    context.endOfLeftSegments = forkContext.head;\n    forkContext.replaceHead(rightSegments);\n  }\n\n  /**\n   * Makes a code path segment for the body part of a ForInStatement and a\n   * ForOfStatement.\n   * @returns {void}\n   */\n  makeForInOfBody() {\n    const context = this.loopContext;\n    const forkContext = this.forkContext;\n    const temp = ForkContext.newEmpty(forkContext);\n    temp.add(context.endOfLeftSegments);\n    const bodySegments = temp.makeNext(-1, -1);\n\n    // Make a path: `right` -> `left`.\n    makeLooped(this, forkContext.head, context.leftSegments);\n\n    // Update state.\n    context.brokenForkContext.add(forkContext.head);\n    forkContext.replaceHead(bodySegments);\n  }\n\n  //--------------------------------------------------------------------------\n  // Control Statements\n  //--------------------------------------------------------------------------\n\n  /**\n   * Creates new context for BreakStatement.\n   * @param {boolean} breakable The flag to indicate it can break by\n   *      an unlabeled BreakStatement.\n   * @param {string|null} label The label of this context.\n   * @returns {Object} The new context.\n   */\n  pushBreakContext(breakable, label) {\n    this.breakContext = {\n      upper: this.breakContext,\n      breakable,\n      label,\n      brokenForkContext: ForkContext.newEmpty(this.forkContext)\n    };\n    return this.breakContext;\n  }\n\n  /**\n   * Removes the top item of the break context stack.\n   * @returns {Object} The removed context.\n   */\n  popBreakContext() {\n    const context = this.breakContext;\n    const forkContext = this.forkContext;\n    this.breakContext = context.upper;\n\n    // Process this context here for other than switches and loops.\n    if (!context.breakable) {\n      const brokenForkContext = context.brokenForkContext;\n      if (!brokenForkContext.empty) {\n        brokenForkContext.add(forkContext.head);\n        forkContext.replaceHead(brokenForkContext.makeNext(0, -1));\n      }\n    }\n    return context;\n  }\n\n  /**\n   * Makes a path for a `break` statement.\n   *\n   * It registers the head segment to a context of `break`.\n   * It makes new unreachable segment, then it set the head with the segment.\n   * @param {string} label A label of the break statement.\n   * @returns {void}\n   */\n  makeBreak(label) {\n    const forkContext = this.forkContext;\n    if (!forkContext.reachable) {\n      return;\n    }\n    const context = getBreakContext(this, label);\n\n    /* istanbul ignore else: foolproof (syntax error) */\n    if (context) {\n      context.brokenForkContext.add(forkContext.head);\n    }\n    forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));\n  }\n\n  /**\n   * Makes a path for a `continue` statement.\n   *\n   * It makes a looping path.\n   * It makes new unreachable segment, then it set the head with the segment.\n   * @param {string} label A label of the continue statement.\n   * @returns {void}\n   */\n  makeContinue(label) {\n    const forkContext = this.forkContext;\n    if (!forkContext.reachable) {\n      return;\n    }\n    const context = getContinueContext(this, label);\n\n    /* istanbul ignore else: foolproof (syntax error) */\n    if (context) {\n      if (context.continueDestSegments) {\n        makeLooped(this, forkContext.head, context.continueDestSegments);\n\n        // If the context is a for-in/of loop, this effects a break also.\n        if (context.type === \"ForInStatement\" || context.type === \"ForOfStatement\") {\n          context.brokenForkContext.add(forkContext.head);\n        }\n      } else {\n        context.continueForkContext.add(forkContext.head);\n      }\n    }\n    forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));\n  }\n\n  /**\n   * Makes a path for a `return` statement.\n   *\n   * It registers the head segment to a context of `return`.\n   * It makes new unreachable segment, then it set the head with the segment.\n   * @returns {void}\n   */\n  makeReturn() {\n    const forkContext = this.forkContext;\n    if (forkContext.reachable) {\n      getReturnContext(this).returnedForkContext.add(forkContext.head);\n      forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));\n    }\n  }\n\n  /**\n   * Makes a path for a `throw` statement.\n   *\n   * It registers the head segment to a context of `throw`.\n   * It makes new unreachable segment, then it set the head with the segment.\n   * @returns {void}\n   */\n  makeThrow() {\n    const forkContext = this.forkContext;\n    if (forkContext.reachable) {\n      getThrowContext(this).thrownForkContext.add(forkContext.head);\n      forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));\n    }\n  }\n\n  /**\n   * Makes the final path.\n   * @returns {void}\n   */\n  makeFinal() {\n    const segments = this.currentSegments;\n    if (segments.length > 0 && segments[0].reachable) {\n      this.returnedForkContext.add(segments);\n    }\n  }\n}\nmodule.exports = CodePathState;","map":{"version":3,"names":["require","CodePathSegment","ForkContext","addToReturnedOrThrown","dest","others","all","segments","i","length","segment","push","indexOf","getContinueContext","state","label","loopContext","context","upper","getBreakContext","breakContext","breakable","getReturnContext","tryContext","hasFinalizer","position","getThrowContext","remove","xs","x","splice","removeConnection","prevSegments","nextSegments","prevSegment","nextSegment","allNextSegments","allPrevSegments","makeLooped","unflattenedFromSegments","unflattenedToSegments","fromSegments","flattenUnusedSegments","toSegments","end","Math","min","fromSegment","toSegment","reachable","markPrevSegmentAsLooped","notifyLooped","finalizeTestSegmentsOfFor","choiceContext","head","processed","trueForkContext","add","falseForkContext","qqForkContext","test","brokenForkContext","addAll","endOfTestSegments","makeNext","CodePathState","constructor","idGenerator","onLooped","forkContext","newRoot","switchContext","chainContext","currentSegments","initialSegment","final","finalSegments","returned","returnedForkContext","thrown","thrownForkContext","bind","headSegments","parentForkContext","current","pushForkContext","forkLeavingPath","newEmpty","popForkContext","lastContext","replaceHead","forkPath","forkBypassPath","pushChoiceContext","kind","isForkingAsResult","popChoiceContext","parentContext","clear","Error","prevForkContext","makeLogicalRight","makeIfConsequent","makeIfAlternate","pushChainContext","countChoiceContexts","popChainContext","makeOptionalNode","makeOptionalRight","pushSwitchContext","hasCase","defaultSegments","defaultBodySegments","foundDefault","lastIsDefault","countForks","pushBreakContext","popSwitchContext","popBreakContext","empty","lastSegments","lastCaseSegments","makeSwitchCaseBody","isEmpty","isDefault","pushTryContext","lastOfTryIsReachable","lastOfCatchIsReachable","popTryContext","normalSegments","slice","leavingSegments","makeUnreachable","makeCatchBlock","thrownSegments","makeFinallyBlock","headOfLeavingSegments","count","prevSegsOfLeavingSegment","j","segmentsList","newNext","next","makeFirstThrowablePathInTryBlock","pushLoopContext","type","continueDestSegments","entrySegments","continueForkContext","endOfInitSegments","testSegments","updateSegments","endOfUpdateSegments","leftSegments","endOfLeftSegments","popLoopContext","makeWhileTest","makeWhileBody","makeDoWhileBody","bodySegments","makeDoWhileTest","makeForTest","makeForUpdate","makeDisconnected","makeForBody","makeForInOfLeft","makeForInOfRight","temp","rightSegments","makeForInOfBody","makeBreak","makeContinue","makeReturn","makeThrow","makeFinal","module","exports"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/linter/code-path-analysis/code-path-state.js"],"sourcesContent":["/**\n * @fileoverview A class to manage state of generating a code path.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst CodePathSegment = require(\"./code-path-segment\"),\n    ForkContext = require(\"./fork-context\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Adds given segments into the `dest` array.\n * If the `others` array does not includes the given segments, adds to the `all`\n * array as well.\n *\n * This adds only reachable and used segments.\n * @param {CodePathSegment[]} dest A destination array (`returnedSegments` or `thrownSegments`).\n * @param {CodePathSegment[]} others Another destination array (`returnedSegments` or `thrownSegments`).\n * @param {CodePathSegment[]} all The unified destination array (`finalSegments`).\n * @param {CodePathSegment[]} segments Segments to add.\n * @returns {void}\n */\nfunction addToReturnedOrThrown(dest, others, all, segments) {\n    for (let i = 0; i < segments.length; ++i) {\n        const segment = segments[i];\n\n        dest.push(segment);\n        if (others.indexOf(segment) === -1) {\n            all.push(segment);\n        }\n    }\n}\n\n/**\n * Gets a loop-context for a `continue` statement.\n * @param {CodePathState} state A state to get.\n * @param {string} label The label of a `continue` statement.\n * @returns {LoopContext} A loop-context for a `continue` statement.\n */\nfunction getContinueContext(state, label) {\n    if (!label) {\n        return state.loopContext;\n    }\n\n    let context = state.loopContext;\n\n    while (context) {\n        if (context.label === label) {\n            return context;\n        }\n        context = context.upper;\n    }\n\n    /* istanbul ignore next: foolproof (syntax error) */\n    return null;\n}\n\n/**\n * Gets a context for a `break` statement.\n * @param {CodePathState} state A state to get.\n * @param {string} label The label of a `break` statement.\n * @returns {LoopContext|SwitchContext} A context for a `break` statement.\n */\nfunction getBreakContext(state, label) {\n    let context = state.breakContext;\n\n    while (context) {\n        if (label ? context.label === label : context.breakable) {\n            return context;\n        }\n        context = context.upper;\n    }\n\n    /* istanbul ignore next: foolproof (syntax error) */\n    return null;\n}\n\n/**\n * Gets a context for a `return` statement.\n * @param {CodePathState} state A state to get.\n * @returns {TryContext|CodePathState} A context for a `return` statement.\n */\nfunction getReturnContext(state) {\n    let context = state.tryContext;\n\n    while (context) {\n        if (context.hasFinalizer && context.position !== \"finally\") {\n            return context;\n        }\n        context = context.upper;\n    }\n\n    return state;\n}\n\n/**\n * Gets a context for a `throw` statement.\n * @param {CodePathState} state A state to get.\n * @returns {TryContext|CodePathState} A context for a `throw` statement.\n */\nfunction getThrowContext(state) {\n    let context = state.tryContext;\n\n    while (context) {\n        if (context.position === \"try\" ||\n            (context.hasFinalizer && context.position === \"catch\")\n        ) {\n            return context;\n        }\n        context = context.upper;\n    }\n\n    return state;\n}\n\n/**\n * Removes a given element from a given array.\n * @param {any[]} xs An array to remove the specific element.\n * @param {any} x An element to be removed.\n * @returns {void}\n */\nfunction remove(xs, x) {\n    xs.splice(xs.indexOf(x), 1);\n}\n\n/**\n * Disconnect given segments.\n *\n * This is used in a process for switch statements.\n * If there is the \"default\" chunk before other cases, the order is different\n * between node's and running's.\n * @param {CodePathSegment[]} prevSegments Forward segments to disconnect.\n * @param {CodePathSegment[]} nextSegments Backward segments to disconnect.\n * @returns {void}\n */\nfunction removeConnection(prevSegments, nextSegments) {\n    for (let i = 0; i < prevSegments.length; ++i) {\n        const prevSegment = prevSegments[i];\n        const nextSegment = nextSegments[i];\n\n        remove(prevSegment.nextSegments, nextSegment);\n        remove(prevSegment.allNextSegments, nextSegment);\n        remove(nextSegment.prevSegments, prevSegment);\n        remove(nextSegment.allPrevSegments, prevSegment);\n    }\n}\n\n/**\n * Creates looping path.\n * @param {CodePathState} state The instance.\n * @param {CodePathSegment[]} unflattenedFromSegments Segments which are source.\n * @param {CodePathSegment[]} unflattenedToSegments Segments which are destination.\n * @returns {void}\n */\nfunction makeLooped(state, unflattenedFromSegments, unflattenedToSegments) {\n    const fromSegments = CodePathSegment.flattenUnusedSegments(unflattenedFromSegments);\n    const toSegments = CodePathSegment.flattenUnusedSegments(unflattenedToSegments);\n\n    const end = Math.min(fromSegments.length, toSegments.length);\n\n    for (let i = 0; i < end; ++i) {\n        const fromSegment = fromSegments[i];\n        const toSegment = toSegments[i];\n\n        if (toSegment.reachable) {\n            fromSegment.nextSegments.push(toSegment);\n        }\n        if (fromSegment.reachable) {\n            toSegment.prevSegments.push(fromSegment);\n        }\n        fromSegment.allNextSegments.push(toSegment);\n        toSegment.allPrevSegments.push(fromSegment);\n\n        if (toSegment.allPrevSegments.length >= 2) {\n            CodePathSegment.markPrevSegmentAsLooped(toSegment, fromSegment);\n        }\n\n        state.notifyLooped(fromSegment, toSegment);\n    }\n}\n\n/**\n * Finalizes segments of `test` chunk of a ForStatement.\n *\n * - Adds `false` paths to paths which are leaving from the loop.\n * - Sets `true` paths to paths which go to the body.\n * @param {LoopContext} context A loop context to modify.\n * @param {ChoiceContext} choiceContext A choice context of this loop.\n * @param {CodePathSegment[]} head The current head paths.\n * @returns {void}\n */\nfunction finalizeTestSegmentsOfFor(context, choiceContext, head) {\n    if (!choiceContext.processed) {\n        choiceContext.trueForkContext.add(head);\n        choiceContext.falseForkContext.add(head);\n        choiceContext.qqForkContext.add(head);\n    }\n\n    if (context.test !== true) {\n        context.brokenForkContext.addAll(choiceContext.falseForkContext);\n    }\n    context.endOfTestSegments = choiceContext.trueForkContext.makeNext(0, -1);\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * A class which manages state to analyze code paths.\n */\nclass CodePathState {\n\n    // eslint-disable-next-line jsdoc/require-description\n    /**\n     * @param {IdGenerator} idGenerator An id generator to generate id for code\n     *   path segments.\n     * @param {Function} onLooped A callback function to notify looping.\n     */\n    constructor(idGenerator, onLooped) {\n        this.idGenerator = idGenerator;\n        this.notifyLooped = onLooped;\n        this.forkContext = ForkContext.newRoot(idGenerator);\n        this.choiceContext = null;\n        this.switchContext = null;\n        this.tryContext = null;\n        this.loopContext = null;\n        this.breakContext = null;\n        this.chainContext = null;\n\n        this.currentSegments = [];\n        this.initialSegment = this.forkContext.head[0];\n\n        // returnedSegments and thrownSegments push elements into finalSegments also.\n        const final = this.finalSegments = [];\n        const returned = this.returnedForkContext = [];\n        const thrown = this.thrownForkContext = [];\n\n        returned.add = addToReturnedOrThrown.bind(null, returned, thrown, final);\n        thrown.add = addToReturnedOrThrown.bind(null, thrown, returned, final);\n    }\n\n    /**\n     * The head segments.\n     * @type {CodePathSegment[]}\n     */\n    get headSegments() {\n        return this.forkContext.head;\n    }\n\n    /**\n     * The parent forking context.\n     * This is used for the root of new forks.\n     * @type {ForkContext}\n     */\n    get parentForkContext() {\n        const current = this.forkContext;\n\n        return current && current.upper;\n    }\n\n    /**\n     * Creates and stacks new forking context.\n     * @param {boolean} forkLeavingPath A flag which shows being in a\n     *   \"finally\" block.\n     * @returns {ForkContext} The created context.\n     */\n    pushForkContext(forkLeavingPath) {\n        this.forkContext = ForkContext.newEmpty(\n            this.forkContext,\n            forkLeavingPath\n        );\n\n        return this.forkContext;\n    }\n\n    /**\n     * Pops and merges the last forking context.\n     * @returns {ForkContext} The last context.\n     */\n    popForkContext() {\n        const lastContext = this.forkContext;\n\n        this.forkContext = lastContext.upper;\n        this.forkContext.replaceHead(lastContext.makeNext(0, -1));\n\n        return lastContext;\n    }\n\n    /**\n     * Creates a new path.\n     * @returns {void}\n     */\n    forkPath() {\n        this.forkContext.add(this.parentForkContext.makeNext(-1, -1));\n    }\n\n    /**\n     * Creates a bypass path.\n     * This is used for such as IfStatement which does not have \"else\" chunk.\n     * @returns {void}\n     */\n    forkBypassPath() {\n        this.forkContext.add(this.parentForkContext.head);\n    }\n\n    //--------------------------------------------------------------------------\n    // ConditionalExpression, LogicalExpression, IfStatement\n    //--------------------------------------------------------------------------\n\n    /**\n     * Creates a context for ConditionalExpression, LogicalExpression, AssignmentExpression (logical assignments only),\n     * IfStatement, WhileStatement, DoWhileStatement, or ForStatement.\n     *\n     * LogicalExpressions have cases that it goes different paths between the\n     * `true` case and the `false` case.\n     *\n     * For Example:\n     *\n     *     if (a || b) {\n     *         foo();\n     *     } else {\n     *         bar();\n     *     }\n     *\n     * In this case, `b` is evaluated always in the code path of the `else`\n     * block, but it's not so in the code path of the `if` block.\n     * So there are 3 paths.\n     *\n     *     a -> foo();\n     *     a -> b -> foo();\n     *     a -> b -> bar();\n     * @param {string} kind A kind string.\n     *   If the new context is LogicalExpression's or AssignmentExpression's, this is `\"&&\"` or `\"||\"` or `\"??\"`.\n     *   If it's IfStatement's or ConditionalExpression's, this is `\"test\"`.\n     *   Otherwise, this is `\"loop\"`.\n     * @param {boolean} isForkingAsResult A flag that shows that goes different\n     *   paths between `true` and `false`.\n     * @returns {void}\n     */\n    pushChoiceContext(kind, isForkingAsResult) {\n        this.choiceContext = {\n            upper: this.choiceContext,\n            kind,\n            isForkingAsResult,\n            trueForkContext: ForkContext.newEmpty(this.forkContext),\n            falseForkContext: ForkContext.newEmpty(this.forkContext),\n            qqForkContext: ForkContext.newEmpty(this.forkContext),\n            processed: false\n        };\n    }\n\n    /**\n     * Pops the last choice context and finalizes it.\n     * @returns {ChoiceContext} The popped context.\n     */\n    popChoiceContext() {\n        const context = this.choiceContext;\n\n        this.choiceContext = context.upper;\n\n        const forkContext = this.forkContext;\n        const headSegments = forkContext.head;\n\n        switch (context.kind) {\n            case \"&&\":\n            case \"||\":\n            case \"??\":\n\n                /*\n                 * If any result were not transferred from child contexts,\n                 * this sets the head segments to both cases.\n                 * The head segments are the path of the right-hand operand.\n                 */\n                if (!context.processed) {\n                    context.trueForkContext.add(headSegments);\n                    context.falseForkContext.add(headSegments);\n                    context.qqForkContext.add(headSegments);\n                }\n\n                /*\n                 * Transfers results to upper context if this context is in\n                 * test chunk.\n                 */\n                if (context.isForkingAsResult) {\n                    const parentContext = this.choiceContext;\n\n                    parentContext.trueForkContext.addAll(context.trueForkContext);\n                    parentContext.falseForkContext.addAll(context.falseForkContext);\n                    parentContext.qqForkContext.addAll(context.qqForkContext);\n                    parentContext.processed = true;\n\n                    return context;\n                }\n\n                break;\n\n            case \"test\":\n                if (!context.processed) {\n\n                    /*\n                     * The head segments are the path of the `if` block here.\n                     * Updates the `true` path with the end of the `if` block.\n                     */\n                    context.trueForkContext.clear();\n                    context.trueForkContext.add(headSegments);\n                } else {\n\n                    /*\n                     * The head segments are the path of the `else` block here.\n                     * Updates the `false` path with the end of the `else`\n                     * block.\n                     */\n                    context.falseForkContext.clear();\n                    context.falseForkContext.add(headSegments);\n                }\n\n                break;\n\n            case \"loop\":\n\n                /*\n                 * Loops are addressed in popLoopContext().\n                 * This is called from popLoopContext().\n                 */\n                return context;\n\n            /* istanbul ignore next */\n            default:\n                throw new Error(\"unreachable\");\n        }\n\n        // Merges all paths.\n        const prevForkContext = context.trueForkContext;\n\n        prevForkContext.addAll(context.falseForkContext);\n        forkContext.replaceHead(prevForkContext.makeNext(0, -1));\n\n        return context;\n    }\n\n    /**\n     * Makes a code path segment of the right-hand operand of a logical\n     * expression.\n     * @returns {void}\n     */\n    makeLogicalRight() {\n        const context = this.choiceContext;\n        const forkContext = this.forkContext;\n\n        if (context.processed) {\n\n            /*\n             * This got segments already from the child choice context.\n             * Creates the next path from own true/false fork context.\n             */\n            let prevForkContext;\n\n            switch (context.kind) {\n                case \"&&\": // if true then go to the right-hand side.\n                    prevForkContext = context.trueForkContext;\n                    break;\n                case \"||\": // if false then go to the right-hand side.\n                    prevForkContext = context.falseForkContext;\n                    break;\n                case \"??\": // Both true/false can short-circuit, so needs the third path to go to the right-hand side. That's qqForkContext.\n                    prevForkContext = context.qqForkContext;\n                    break;\n                default:\n                    throw new Error(\"unreachable\");\n            }\n\n            forkContext.replaceHead(prevForkContext.makeNext(0, -1));\n            prevForkContext.clear();\n            context.processed = false;\n        } else {\n\n            /*\n             * This did not get segments from the child choice context.\n             * So addresses the head segments.\n             * The head segments are the path of the left-hand operand.\n             */\n            switch (context.kind) {\n                case \"&&\": // the false path can short-circuit.\n                    context.falseForkContext.add(forkContext.head);\n                    break;\n                case \"||\": // the true path can short-circuit.\n                    context.trueForkContext.add(forkContext.head);\n                    break;\n                case \"??\": // both can short-circuit.\n                    context.trueForkContext.add(forkContext.head);\n                    context.falseForkContext.add(forkContext.head);\n                    break;\n                default:\n                    throw new Error(\"unreachable\");\n            }\n\n            forkContext.replaceHead(forkContext.makeNext(-1, -1));\n        }\n    }\n\n    /**\n     * Makes a code path segment of the `if` block.\n     * @returns {void}\n     */\n    makeIfConsequent() {\n        const context = this.choiceContext;\n        const forkContext = this.forkContext;\n\n        /*\n         * If any result were not transferred from child contexts,\n         * this sets the head segments to both cases.\n         * The head segments are the path of the test expression.\n         */\n        if (!context.processed) {\n            context.trueForkContext.add(forkContext.head);\n            context.falseForkContext.add(forkContext.head);\n            context.qqForkContext.add(forkContext.head);\n        }\n\n        context.processed = false;\n\n        // Creates new path from the `true` case.\n        forkContext.replaceHead(\n            context.trueForkContext.makeNext(0, -1)\n        );\n    }\n\n    /**\n     * Makes a code path segment of the `else` block.\n     * @returns {void}\n     */\n    makeIfAlternate() {\n        const context = this.choiceContext;\n        const forkContext = this.forkContext;\n\n        /*\n         * The head segments are the path of the `if` block.\n         * Updates the `true` path with the end of the `if` block.\n         */\n        context.trueForkContext.clear();\n        context.trueForkContext.add(forkContext.head);\n        context.processed = true;\n\n        // Creates new path from the `false` case.\n        forkContext.replaceHead(\n            context.falseForkContext.makeNext(0, -1)\n        );\n    }\n\n    //--------------------------------------------------------------------------\n    // ChainExpression\n    //--------------------------------------------------------------------------\n\n    /**\n     * Push a new `ChainExpression` context to the stack.\n     * This method is called on entering to each `ChainExpression` node.\n     * This context is used to count forking in the optional chain then merge them on the exiting from the `ChainExpression` node.\n     * @returns {void}\n     */\n    pushChainContext() {\n        this.chainContext = {\n            upper: this.chainContext,\n            countChoiceContexts: 0\n        };\n    }\n\n    /**\n     * Pop a `ChainExpression` context from the stack.\n     * This method is called on exiting from each `ChainExpression` node.\n     * This merges all forks of the last optional chaining.\n     * @returns {void}\n     */\n    popChainContext() {\n        const context = this.chainContext;\n\n        this.chainContext = context.upper;\n\n        // pop all choice contexts of this.\n        for (let i = context.countChoiceContexts; i > 0; --i) {\n            this.popChoiceContext();\n        }\n    }\n\n    /**\n     * Create a choice context for optional access.\n     * This method is called on entering to each `(Call|Member)Expression[optional=true]` node.\n     * This creates a choice context as similar to `LogicalExpression[operator=\"??\"]` node.\n     * @returns {void}\n     */\n    makeOptionalNode() {\n        if (this.chainContext) {\n            this.chainContext.countChoiceContexts += 1;\n            this.pushChoiceContext(\"??\", false);\n        }\n    }\n\n    /**\n     * Create a fork.\n     * This method is called on entering to the `arguments|property` property of each `(Call|Member)Expression` node.\n     * @returns {void}\n     */\n    makeOptionalRight() {\n        if (this.chainContext) {\n            this.makeLogicalRight();\n        }\n    }\n\n    //--------------------------------------------------------------------------\n    // SwitchStatement\n    //--------------------------------------------------------------------------\n\n    /**\n     * Creates a context object of SwitchStatement and stacks it.\n     * @param {boolean} hasCase `true` if the switch statement has one or more\n     *   case parts.\n     * @param {string|null} label The label text.\n     * @returns {void}\n     */\n    pushSwitchContext(hasCase, label) {\n        this.switchContext = {\n            upper: this.switchContext,\n            hasCase,\n            defaultSegments: null,\n            defaultBodySegments: null,\n            foundDefault: false,\n            lastIsDefault: false,\n            countForks: 0\n        };\n\n        this.pushBreakContext(true, label);\n    }\n\n    /**\n     * Pops the last context of SwitchStatement and finalizes it.\n     *\n     * - Disposes all forking stack for `case` and `default`.\n     * - Creates the next code path segment from `context.brokenForkContext`.\n     * - If the last `SwitchCase` node is not a `default` part, creates a path\n     *   to the `default` body.\n     * @returns {void}\n     */\n    popSwitchContext() {\n        const context = this.switchContext;\n\n        this.switchContext = context.upper;\n\n        const forkContext = this.forkContext;\n        const brokenForkContext = this.popBreakContext().brokenForkContext;\n\n        if (context.countForks === 0) {\n\n            /*\n             * When there is only one `default` chunk and there is one or more\n             * `break` statements, even if forks are nothing, it needs to merge\n             * those.\n             */\n            if (!brokenForkContext.empty) {\n                brokenForkContext.add(forkContext.makeNext(-1, -1));\n                forkContext.replaceHead(brokenForkContext.makeNext(0, -1));\n            }\n\n            return;\n        }\n\n        const lastSegments = forkContext.head;\n\n        this.forkBypassPath();\n        const lastCaseSegments = forkContext.head;\n\n        /*\n         * `brokenForkContext` is used to make the next segment.\n         * It must add the last segment into `brokenForkContext`.\n         */\n        brokenForkContext.add(lastSegments);\n\n        /*\n         * A path which is failed in all case test should be connected to path\n         * of `default` chunk.\n         */\n        if (!context.lastIsDefault) {\n            if (context.defaultBodySegments) {\n\n                /*\n                 * Remove a link from `default` label to its chunk.\n                 * It's false route.\n                 */\n                removeConnection(context.defaultSegments, context.defaultBodySegments);\n                makeLooped(this, lastCaseSegments, context.defaultBodySegments);\n            } else {\n\n                /*\n                 * It handles the last case body as broken if `default` chunk\n                 * does not exist.\n                 */\n                brokenForkContext.add(lastCaseSegments);\n            }\n        }\n\n        // Pops the segment context stack until the entry segment.\n        for (let i = 0; i < context.countForks; ++i) {\n            this.forkContext = this.forkContext.upper;\n        }\n\n        /*\n         * Creates a path from all brokenForkContext paths.\n         * This is a path after switch statement.\n         */\n        this.forkContext.replaceHead(brokenForkContext.makeNext(0, -1));\n    }\n\n    /**\n     * Makes a code path segment for a `SwitchCase` node.\n     * @param {boolean} isEmpty `true` if the body is empty.\n     * @param {boolean} isDefault `true` if the body is the default case.\n     * @returns {void}\n     */\n    makeSwitchCaseBody(isEmpty, isDefault) {\n        const context = this.switchContext;\n\n        if (!context.hasCase) {\n            return;\n        }\n\n        /*\n         * Merge forks.\n         * The parent fork context has two segments.\n         * Those are from the current case and the body of the previous case.\n         */\n        const parentForkContext = this.forkContext;\n        const forkContext = this.pushForkContext();\n\n        forkContext.add(parentForkContext.makeNext(0, -1));\n\n        /*\n         * Save `default` chunk info.\n         * If the `default` label is not at the last, we must make a path from\n         * the last `case` to the `default` chunk.\n         */\n        if (isDefault) {\n            context.defaultSegments = parentForkContext.head;\n            if (isEmpty) {\n                context.foundDefault = true;\n            } else {\n                context.defaultBodySegments = forkContext.head;\n            }\n        } else {\n            if (!isEmpty && context.foundDefault) {\n                context.foundDefault = false;\n                context.defaultBodySegments = forkContext.head;\n            }\n        }\n\n        context.lastIsDefault = isDefault;\n        context.countForks += 1;\n    }\n\n    //--------------------------------------------------------------------------\n    // TryStatement\n    //--------------------------------------------------------------------------\n\n    /**\n     * Creates a context object of TryStatement and stacks it.\n     * @param {boolean} hasFinalizer `true` if the try statement has a\n     *   `finally` block.\n     * @returns {void}\n     */\n    pushTryContext(hasFinalizer) {\n        this.tryContext = {\n            upper: this.tryContext,\n            position: \"try\",\n            hasFinalizer,\n\n            returnedForkContext: hasFinalizer\n                ? ForkContext.newEmpty(this.forkContext)\n                : null,\n\n            thrownForkContext: ForkContext.newEmpty(this.forkContext),\n            lastOfTryIsReachable: false,\n            lastOfCatchIsReachable: false\n        };\n    }\n\n    /**\n     * Pops the last context of TryStatement and finalizes it.\n     * @returns {void}\n     */\n    popTryContext() {\n        const context = this.tryContext;\n\n        this.tryContext = context.upper;\n\n        if (context.position === \"catch\") {\n\n            // Merges two paths from the `try` block and `catch` block merely.\n            this.popForkContext();\n            return;\n        }\n\n        /*\n         * The following process is executed only when there is the `finally`\n         * block.\n         */\n\n        const returned = context.returnedForkContext;\n        const thrown = context.thrownForkContext;\n\n        if (returned.empty && thrown.empty) {\n            return;\n        }\n\n        // Separate head to normal paths and leaving paths.\n        const headSegments = this.forkContext.head;\n\n        this.forkContext = this.forkContext.upper;\n        const normalSegments = headSegments.slice(0, headSegments.length / 2 | 0);\n        const leavingSegments = headSegments.slice(headSegments.length / 2 | 0);\n\n        // Forwards the leaving path to upper contexts.\n        if (!returned.empty) {\n            getReturnContext(this).returnedForkContext.add(leavingSegments);\n        }\n        if (!thrown.empty) {\n            getThrowContext(this).thrownForkContext.add(leavingSegments);\n        }\n\n        // Sets the normal path as the next.\n        this.forkContext.replaceHead(normalSegments);\n\n        /*\n         * If both paths of the `try` block and the `catch` block are\n         * unreachable, the next path becomes unreachable as well.\n         */\n        if (!context.lastOfTryIsReachable && !context.lastOfCatchIsReachable) {\n            this.forkContext.makeUnreachable();\n        }\n    }\n\n    /**\n     * Makes a code path segment for a `catch` block.\n     * @returns {void}\n     */\n    makeCatchBlock() {\n        const context = this.tryContext;\n        const forkContext = this.forkContext;\n        const thrown = context.thrownForkContext;\n\n        // Update state.\n        context.position = \"catch\";\n        context.thrownForkContext = ForkContext.newEmpty(forkContext);\n        context.lastOfTryIsReachable = forkContext.reachable;\n\n        // Merge thrown paths.\n        thrown.add(forkContext.head);\n        const thrownSegments = thrown.makeNext(0, -1);\n\n        // Fork to a bypass and the merged thrown path.\n        this.pushForkContext();\n        this.forkBypassPath();\n        this.forkContext.add(thrownSegments);\n    }\n\n    /**\n     * Makes a code path segment for a `finally` block.\n     *\n     * In the `finally` block, parallel paths are created. The parallel paths\n     * are used as leaving-paths. The leaving-paths are paths from `return`\n     * statements and `throw` statements in a `try` block or a `catch` block.\n     * @returns {void}\n     */\n    makeFinallyBlock() {\n        const context = this.tryContext;\n        let forkContext = this.forkContext;\n        const returned = context.returnedForkContext;\n        const thrown = context.thrownForkContext;\n        const headOfLeavingSegments = forkContext.head;\n\n        // Update state.\n        if (context.position === \"catch\") {\n\n            // Merges two paths from the `try` block and `catch` block.\n            this.popForkContext();\n            forkContext = this.forkContext;\n\n            context.lastOfCatchIsReachable = forkContext.reachable;\n        } else {\n            context.lastOfTryIsReachable = forkContext.reachable;\n        }\n        context.position = \"finally\";\n\n        if (returned.empty && thrown.empty) {\n\n            // This path does not leave.\n            return;\n        }\n\n        /*\n         * Create a parallel segment from merging returned and thrown.\n         * This segment will leave at the end of this finally block.\n         */\n        const segments = forkContext.makeNext(-1, -1);\n\n        for (let i = 0; i < forkContext.count; ++i) {\n            const prevSegsOfLeavingSegment = [headOfLeavingSegments[i]];\n\n            for (let j = 0; j < returned.segmentsList.length; ++j) {\n                prevSegsOfLeavingSegment.push(returned.segmentsList[j][i]);\n            }\n            for (let j = 0; j < thrown.segmentsList.length; ++j) {\n                prevSegsOfLeavingSegment.push(thrown.segmentsList[j][i]);\n            }\n\n            segments.push(\n                CodePathSegment.newNext(\n                    this.idGenerator.next(),\n                    prevSegsOfLeavingSegment\n                )\n            );\n        }\n\n        this.pushForkContext(true);\n        this.forkContext.add(segments);\n    }\n\n    /**\n     * Makes a code path segment from the first throwable node to the `catch`\n     * block or the `finally` block.\n     * @returns {void}\n     */\n    makeFirstThrowablePathInTryBlock() {\n        const forkContext = this.forkContext;\n\n        if (!forkContext.reachable) {\n            return;\n        }\n\n        const context = getThrowContext(this);\n\n        if (context === this ||\n            context.position !== \"try\" ||\n            !context.thrownForkContext.empty\n        ) {\n            return;\n        }\n\n        context.thrownForkContext.add(forkContext.head);\n        forkContext.replaceHead(forkContext.makeNext(-1, -1));\n    }\n\n    //--------------------------------------------------------------------------\n    // Loop Statements\n    //--------------------------------------------------------------------------\n\n    /**\n     * Creates a context object of a loop statement and stacks it.\n     * @param {string} type The type of the node which was triggered. One of\n     *   `WhileStatement`, `DoWhileStatement`, `ForStatement`, `ForInStatement`,\n     *   and `ForStatement`.\n     * @param {string|null} label A label of the node which was triggered.\n     * @returns {void}\n     */\n    pushLoopContext(type, label) {\n        const forkContext = this.forkContext;\n        const breakContext = this.pushBreakContext(true, label);\n\n        switch (type) {\n            case \"WhileStatement\":\n                this.pushChoiceContext(\"loop\", false);\n                this.loopContext = {\n                    upper: this.loopContext,\n                    type,\n                    label,\n                    test: void 0,\n                    continueDestSegments: null,\n                    brokenForkContext: breakContext.brokenForkContext\n                };\n                break;\n\n            case \"DoWhileStatement\":\n                this.pushChoiceContext(\"loop\", false);\n                this.loopContext = {\n                    upper: this.loopContext,\n                    type,\n                    label,\n                    test: void 0,\n                    entrySegments: null,\n                    continueForkContext: ForkContext.newEmpty(forkContext),\n                    brokenForkContext: breakContext.brokenForkContext\n                };\n                break;\n\n            case \"ForStatement\":\n                this.pushChoiceContext(\"loop\", false);\n                this.loopContext = {\n                    upper: this.loopContext,\n                    type,\n                    label,\n                    test: void 0,\n                    endOfInitSegments: null,\n                    testSegments: null,\n                    endOfTestSegments: null,\n                    updateSegments: null,\n                    endOfUpdateSegments: null,\n                    continueDestSegments: null,\n                    brokenForkContext: breakContext.brokenForkContext\n                };\n                break;\n\n            case \"ForInStatement\":\n            case \"ForOfStatement\":\n                this.loopContext = {\n                    upper: this.loopContext,\n                    type,\n                    label,\n                    prevSegments: null,\n                    leftSegments: null,\n                    endOfLeftSegments: null,\n                    continueDestSegments: null,\n                    brokenForkContext: breakContext.brokenForkContext\n                };\n                break;\n\n            /* istanbul ignore next */\n            default:\n                throw new Error(`unknown type: \"${type}\"`);\n        }\n    }\n\n    /**\n     * Pops the last context of a loop statement and finalizes it.\n     * @returns {void}\n     */\n    popLoopContext() {\n        const context = this.loopContext;\n\n        this.loopContext = context.upper;\n\n        const forkContext = this.forkContext;\n        const brokenForkContext = this.popBreakContext().brokenForkContext;\n\n        // Creates a looped path.\n        switch (context.type) {\n            case \"WhileStatement\":\n            case \"ForStatement\":\n                this.popChoiceContext();\n                makeLooped(\n                    this,\n                    forkContext.head,\n                    context.continueDestSegments\n                );\n                break;\n\n            case \"DoWhileStatement\": {\n                const choiceContext = this.popChoiceContext();\n\n                if (!choiceContext.processed) {\n                    choiceContext.trueForkContext.add(forkContext.head);\n                    choiceContext.falseForkContext.add(forkContext.head);\n                }\n                if (context.test !== true) {\n                    brokenForkContext.addAll(choiceContext.falseForkContext);\n                }\n\n                // `true` paths go to looping.\n                const segmentsList = choiceContext.trueForkContext.segmentsList;\n\n                for (let i = 0; i < segmentsList.length; ++i) {\n                    makeLooped(\n                        this,\n                        segmentsList[i],\n                        context.entrySegments\n                    );\n                }\n                break;\n            }\n\n            case \"ForInStatement\":\n            case \"ForOfStatement\":\n                brokenForkContext.add(forkContext.head);\n                makeLooped(\n                    this,\n                    forkContext.head,\n                    context.leftSegments\n                );\n                break;\n\n            /* istanbul ignore next */\n            default:\n                throw new Error(\"unreachable\");\n        }\n\n        // Go next.\n        if (brokenForkContext.empty) {\n            forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));\n        } else {\n            forkContext.replaceHead(brokenForkContext.makeNext(0, -1));\n        }\n    }\n\n    /**\n     * Makes a code path segment for the test part of a WhileStatement.\n     * @param {boolean|undefined} test The test value (only when constant).\n     * @returns {void}\n     */\n    makeWhileTest(test) {\n        const context = this.loopContext;\n        const forkContext = this.forkContext;\n        const testSegments = forkContext.makeNext(0, -1);\n\n        // Update state.\n        context.test = test;\n        context.continueDestSegments = testSegments;\n        forkContext.replaceHead(testSegments);\n    }\n\n    /**\n     * Makes a code path segment for the body part of a WhileStatement.\n     * @returns {void}\n     */\n    makeWhileBody() {\n        const context = this.loopContext;\n        const choiceContext = this.choiceContext;\n        const forkContext = this.forkContext;\n\n        if (!choiceContext.processed) {\n            choiceContext.trueForkContext.add(forkContext.head);\n            choiceContext.falseForkContext.add(forkContext.head);\n        }\n\n        // Update state.\n        if (context.test !== true) {\n            context.brokenForkContext.addAll(choiceContext.falseForkContext);\n        }\n        forkContext.replaceHead(choiceContext.trueForkContext.makeNext(0, -1));\n    }\n\n    /**\n     * Makes a code path segment for the body part of a DoWhileStatement.\n     * @returns {void}\n     */\n    makeDoWhileBody() {\n        const context = this.loopContext;\n        const forkContext = this.forkContext;\n        const bodySegments = forkContext.makeNext(-1, -1);\n\n        // Update state.\n        context.entrySegments = bodySegments;\n        forkContext.replaceHead(bodySegments);\n    }\n\n    /**\n     * Makes a code path segment for the test part of a DoWhileStatement.\n     * @param {boolean|undefined} test The test value (only when constant).\n     * @returns {void}\n     */\n    makeDoWhileTest(test) {\n        const context = this.loopContext;\n        const forkContext = this.forkContext;\n\n        context.test = test;\n\n        // Creates paths of `continue` statements.\n        if (!context.continueForkContext.empty) {\n            context.continueForkContext.add(forkContext.head);\n            const testSegments = context.continueForkContext.makeNext(0, -1);\n\n            forkContext.replaceHead(testSegments);\n        }\n    }\n\n    /**\n     * Makes a code path segment for the test part of a ForStatement.\n     * @param {boolean|undefined} test The test value (only when constant).\n     * @returns {void}\n     */\n    makeForTest(test) {\n        const context = this.loopContext;\n        const forkContext = this.forkContext;\n        const endOfInitSegments = forkContext.head;\n        const testSegments = forkContext.makeNext(-1, -1);\n\n        // Update state.\n        context.test = test;\n        context.endOfInitSegments = endOfInitSegments;\n        context.continueDestSegments = context.testSegments = testSegments;\n        forkContext.replaceHead(testSegments);\n    }\n\n    /**\n     * Makes a code path segment for the update part of a ForStatement.\n     * @returns {void}\n     */\n    makeForUpdate() {\n        const context = this.loopContext;\n        const choiceContext = this.choiceContext;\n        const forkContext = this.forkContext;\n\n        // Make the next paths of the test.\n        if (context.testSegments) {\n            finalizeTestSegmentsOfFor(\n                context,\n                choiceContext,\n                forkContext.head\n            );\n        } else {\n            context.endOfInitSegments = forkContext.head;\n        }\n\n        // Update state.\n        const updateSegments = forkContext.makeDisconnected(-1, -1);\n\n        context.continueDestSegments = context.updateSegments = updateSegments;\n        forkContext.replaceHead(updateSegments);\n    }\n\n    /**\n     * Makes a code path segment for the body part of a ForStatement.\n     * @returns {void}\n     */\n    makeForBody() {\n        const context = this.loopContext;\n        const choiceContext = this.choiceContext;\n        const forkContext = this.forkContext;\n\n        // Update state.\n        if (context.updateSegments) {\n            context.endOfUpdateSegments = forkContext.head;\n\n            // `update` -> `test`\n            if (context.testSegments) {\n                makeLooped(\n                    this,\n                    context.endOfUpdateSegments,\n                    context.testSegments\n                );\n            }\n        } else if (context.testSegments) {\n            finalizeTestSegmentsOfFor(\n                context,\n                choiceContext,\n                forkContext.head\n            );\n        } else {\n            context.endOfInitSegments = forkContext.head;\n        }\n\n        let bodySegments = context.endOfTestSegments;\n\n        if (!bodySegments) {\n\n            /*\n             * If there is not the `test` part, the `body` path comes from the\n             * `init` part and the `update` part.\n             */\n            const prevForkContext = ForkContext.newEmpty(forkContext);\n\n            prevForkContext.add(context.endOfInitSegments);\n            if (context.endOfUpdateSegments) {\n                prevForkContext.add(context.endOfUpdateSegments);\n            }\n\n            bodySegments = prevForkContext.makeNext(0, -1);\n        }\n        context.continueDestSegments = context.continueDestSegments || bodySegments;\n        forkContext.replaceHead(bodySegments);\n    }\n\n    /**\n     * Makes a code path segment for the left part of a ForInStatement and a\n     * ForOfStatement.\n     * @returns {void}\n     */\n    makeForInOfLeft() {\n        const context = this.loopContext;\n        const forkContext = this.forkContext;\n        const leftSegments = forkContext.makeDisconnected(-1, -1);\n\n        // Update state.\n        context.prevSegments = forkContext.head;\n        context.leftSegments = context.continueDestSegments = leftSegments;\n        forkContext.replaceHead(leftSegments);\n    }\n\n    /**\n     * Makes a code path segment for the right part of a ForInStatement and a\n     * ForOfStatement.\n     * @returns {void}\n     */\n    makeForInOfRight() {\n        const context = this.loopContext;\n        const forkContext = this.forkContext;\n        const temp = ForkContext.newEmpty(forkContext);\n\n        temp.add(context.prevSegments);\n        const rightSegments = temp.makeNext(-1, -1);\n\n        // Update state.\n        context.endOfLeftSegments = forkContext.head;\n        forkContext.replaceHead(rightSegments);\n    }\n\n    /**\n     * Makes a code path segment for the body part of a ForInStatement and a\n     * ForOfStatement.\n     * @returns {void}\n     */\n    makeForInOfBody() {\n        const context = this.loopContext;\n        const forkContext = this.forkContext;\n        const temp = ForkContext.newEmpty(forkContext);\n\n        temp.add(context.endOfLeftSegments);\n        const bodySegments = temp.makeNext(-1, -1);\n\n        // Make a path: `right` -> `left`.\n        makeLooped(this, forkContext.head, context.leftSegments);\n\n        // Update state.\n        context.brokenForkContext.add(forkContext.head);\n        forkContext.replaceHead(bodySegments);\n    }\n\n    //--------------------------------------------------------------------------\n    // Control Statements\n    //--------------------------------------------------------------------------\n\n    /**\n     * Creates new context for BreakStatement.\n     * @param {boolean} breakable The flag to indicate it can break by\n     *      an unlabeled BreakStatement.\n     * @param {string|null} label The label of this context.\n     * @returns {Object} The new context.\n     */\n    pushBreakContext(breakable, label) {\n        this.breakContext = {\n            upper: this.breakContext,\n            breakable,\n            label,\n            brokenForkContext: ForkContext.newEmpty(this.forkContext)\n        };\n        return this.breakContext;\n    }\n\n    /**\n     * Removes the top item of the break context stack.\n     * @returns {Object} The removed context.\n     */\n    popBreakContext() {\n        const context = this.breakContext;\n        const forkContext = this.forkContext;\n\n        this.breakContext = context.upper;\n\n        // Process this context here for other than switches and loops.\n        if (!context.breakable) {\n            const brokenForkContext = context.brokenForkContext;\n\n            if (!brokenForkContext.empty) {\n                brokenForkContext.add(forkContext.head);\n                forkContext.replaceHead(brokenForkContext.makeNext(0, -1));\n            }\n        }\n\n        return context;\n    }\n\n    /**\n     * Makes a path for a `break` statement.\n     *\n     * It registers the head segment to a context of `break`.\n     * It makes new unreachable segment, then it set the head with the segment.\n     * @param {string} label A label of the break statement.\n     * @returns {void}\n     */\n    makeBreak(label) {\n        const forkContext = this.forkContext;\n\n        if (!forkContext.reachable) {\n            return;\n        }\n\n        const context = getBreakContext(this, label);\n\n        /* istanbul ignore else: foolproof (syntax error) */\n        if (context) {\n            context.brokenForkContext.add(forkContext.head);\n        }\n\n        forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));\n    }\n\n    /**\n     * Makes a path for a `continue` statement.\n     *\n     * It makes a looping path.\n     * It makes new unreachable segment, then it set the head with the segment.\n     * @param {string} label A label of the continue statement.\n     * @returns {void}\n     */\n    makeContinue(label) {\n        const forkContext = this.forkContext;\n\n        if (!forkContext.reachable) {\n            return;\n        }\n\n        const context = getContinueContext(this, label);\n\n        /* istanbul ignore else: foolproof (syntax error) */\n        if (context) {\n            if (context.continueDestSegments) {\n                makeLooped(this, forkContext.head, context.continueDestSegments);\n\n                // If the context is a for-in/of loop, this effects a break also.\n                if (context.type === \"ForInStatement\" ||\n                    context.type === \"ForOfStatement\"\n                ) {\n                    context.brokenForkContext.add(forkContext.head);\n                }\n            } else {\n                context.continueForkContext.add(forkContext.head);\n            }\n        }\n        forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));\n    }\n\n    /**\n     * Makes a path for a `return` statement.\n     *\n     * It registers the head segment to a context of `return`.\n     * It makes new unreachable segment, then it set the head with the segment.\n     * @returns {void}\n     */\n    makeReturn() {\n        const forkContext = this.forkContext;\n\n        if (forkContext.reachable) {\n            getReturnContext(this).returnedForkContext.add(forkContext.head);\n            forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));\n        }\n    }\n\n    /**\n     * Makes a path for a `throw` statement.\n     *\n     * It registers the head segment to a context of `throw`.\n     * It makes new unreachable segment, then it set the head with the segment.\n     * @returns {void}\n     */\n    makeThrow() {\n        const forkContext = this.forkContext;\n\n        if (forkContext.reachable) {\n            getThrowContext(this).thrownForkContext.add(forkContext.head);\n            forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));\n        }\n    }\n\n    /**\n     * Makes the final path.\n     * @returns {void}\n     */\n    makeFinal() {\n        const segments = this.currentSegments;\n\n        if (segments.length > 0 && segments[0].reachable) {\n            this.returnedForkContext.add(segments);\n        }\n    }\n}\n\nmodule.exports = CodePathState;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}