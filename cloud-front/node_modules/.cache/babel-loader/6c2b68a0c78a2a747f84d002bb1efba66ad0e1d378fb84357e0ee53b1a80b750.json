{"ast":null,"code":"/**\n * @fileoverview A rule to set the maximum number of line of code in a function.\n * @author Pete Ward <peteward44@gmail.com>\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils\");\nconst {\n  upperCaseFirst\n} = require(\"../shared/string-utils\");\n\n//------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\n\nconst OPTIONS_SCHEMA = {\n  type: \"object\",\n  properties: {\n    max: {\n      type: \"integer\",\n      minimum: 0\n    },\n    skipComments: {\n      type: \"boolean\"\n    },\n    skipBlankLines: {\n      type: \"boolean\"\n    },\n    IIFEs: {\n      type: \"boolean\"\n    }\n  },\n  additionalProperties: false\n};\nconst OPTIONS_OR_INTEGER_SCHEMA = {\n  oneOf: [OPTIONS_SCHEMA, {\n    type: \"integer\",\n    minimum: 1\n  }]\n};\n\n/**\n * Given a list of comment nodes, return a map with numeric keys (source code line numbers) and comment token values.\n * @param {Array} comments An array of comment nodes.\n * @returns {Map.<string,Node>} A map with numeric keys (source code line numbers) and comment token values.\n */\nfunction getCommentLineNumbers(comments) {\n  const map = new Map();\n  comments.forEach(comment => {\n    for (let i = comment.loc.start.line; i <= comment.loc.end.line; i++) {\n      map.set(i, comment);\n    }\n  });\n  return map;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"enforce a maximum number of lines of code in a function\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/max-lines-per-function\"\n    },\n    schema: [OPTIONS_OR_INTEGER_SCHEMA],\n    messages: {\n      exceed: \"{{name}} has too many lines ({{lineCount}}). Maximum allowed is {{maxLines}}.\"\n    }\n  },\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const lines = sourceCode.lines;\n    const option = context.options[0];\n    let maxLines = 50;\n    let skipComments = false;\n    let skipBlankLines = false;\n    let IIFEs = false;\n    if (typeof option === \"object\") {\n      maxLines = typeof option.max === \"number\" ? option.max : 50;\n      skipComments = !!option.skipComments;\n      skipBlankLines = !!option.skipBlankLines;\n      IIFEs = !!option.IIFEs;\n    } else if (typeof option === \"number\") {\n      maxLines = option;\n    }\n    const commentLineNumbers = getCommentLineNumbers(sourceCode.getAllComments());\n\n    //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    /**\n     * Tells if a comment encompasses the entire line.\n     * @param {string} line The source line with a trailing comment\n     * @param {number} lineNumber The one-indexed line number this is on\n     * @param {ASTNode} comment The comment to remove\n     * @returns {boolean} If the comment covers the entire line\n     */\n    function isFullLineComment(line, lineNumber, comment) {\n      const start = comment.loc.start,\n        end = comment.loc.end,\n        isFirstTokenOnLine = start.line === lineNumber && !line.slice(0, start.column).trim(),\n        isLastTokenOnLine = end.line === lineNumber && !line.slice(end.column).trim();\n      return comment && (start.line < lineNumber || isFirstTokenOnLine) && (end.line > lineNumber || isLastTokenOnLine);\n    }\n\n    /**\n     * Identifies is a node is a FunctionExpression which is part of an IIFE\n     * @param {ASTNode} node Node to test\n     * @returns {boolean} True if it's an IIFE\n     */\n    function isIIFE(node) {\n      return (node.type === \"FunctionExpression\" || node.type === \"ArrowFunctionExpression\") && node.parent && node.parent.type === \"CallExpression\" && node.parent.callee === node;\n    }\n\n    /**\n     * Identifies is a node is a FunctionExpression which is embedded within a MethodDefinition or Property\n     * @param {ASTNode} node Node to test\n     * @returns {boolean} True if it's a FunctionExpression embedded within a MethodDefinition or Property\n     */\n    function isEmbedded(node) {\n      if (!node.parent) {\n        return false;\n      }\n      if (node !== node.parent.value) {\n        return false;\n      }\n      if (node.parent.type === \"MethodDefinition\") {\n        return true;\n      }\n      if (node.parent.type === \"Property\") {\n        return node.parent.method === true || node.parent.kind === \"get\" || node.parent.kind === \"set\";\n      }\n      return false;\n    }\n\n    /**\n     * Count the lines in the function\n     * @param {ASTNode} funcNode Function AST node\n     * @returns {void}\n     * @private\n     */\n    function processFunction(funcNode) {\n      const node = isEmbedded(funcNode) ? funcNode.parent : funcNode;\n      if (!IIFEs && isIIFE(node)) {\n        return;\n      }\n      let lineCount = 0;\n      for (let i = node.loc.start.line - 1; i < node.loc.end.line; ++i) {\n        const line = lines[i];\n        if (skipComments) {\n          if (commentLineNumbers.has(i + 1) && isFullLineComment(line, i + 1, commentLineNumbers.get(i + 1))) {\n            continue;\n          }\n        }\n        if (skipBlankLines) {\n          if (line.match(/^\\s*$/u)) {\n            continue;\n          }\n        }\n        lineCount++;\n      }\n      if (lineCount > maxLines) {\n        const name = upperCaseFirst(astUtils.getFunctionNameWithKind(funcNode));\n        context.report({\n          node,\n          messageId: \"exceed\",\n          data: {\n            name,\n            lineCount,\n            maxLines\n          }\n        });\n      }\n    }\n\n    //--------------------------------------------------------------------------\n    // Public API\n    //--------------------------------------------------------------------------\n\n    return {\n      FunctionDeclaration: processFunction,\n      FunctionExpression: processFunction,\n      ArrowFunctionExpression: processFunction\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","upperCaseFirst","OPTIONS_SCHEMA","type","properties","max","minimum","skipComments","skipBlankLines","IIFEs","additionalProperties","OPTIONS_OR_INTEGER_SCHEMA","oneOf","getCommentLineNumbers","comments","map","Map","forEach","comment","i","loc","start","line","end","set","module","exports","meta","docs","description","category","recommended","url","schema","messages","exceed","create","context","sourceCode","getSourceCode","lines","option","options","maxLines","commentLineNumbers","getAllComments","isFullLineComment","lineNumber","isFirstTokenOnLine","slice","column","trim","isLastTokenOnLine","isIIFE","node","parent","callee","isEmbedded","value","method","kind","processFunction","funcNode","lineCount","has","get","match","name","getFunctionNameWithKind","report","messageId","data","FunctionDeclaration","FunctionExpression","ArrowFunctionExpression"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/max-lines-per-function.js"],"sourcesContent":["/**\n * @fileoverview A rule to set the maximum number of line of code in a function.\n * @author Pete Ward <peteward44@gmail.com>\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\nconst { upperCaseFirst } = require(\"../shared/string-utils\");\n\n//------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\n\nconst OPTIONS_SCHEMA = {\n    type: \"object\",\n    properties: {\n        max: {\n            type: \"integer\",\n            minimum: 0\n        },\n        skipComments: {\n            type: \"boolean\"\n        },\n        skipBlankLines: {\n            type: \"boolean\"\n        },\n        IIFEs: {\n            type: \"boolean\"\n        }\n    },\n    additionalProperties: false\n};\n\nconst OPTIONS_OR_INTEGER_SCHEMA = {\n    oneOf: [\n        OPTIONS_SCHEMA,\n        {\n            type: \"integer\",\n            minimum: 1\n        }\n    ]\n};\n\n/**\n * Given a list of comment nodes, return a map with numeric keys (source code line numbers) and comment token values.\n * @param {Array} comments An array of comment nodes.\n * @returns {Map.<string,Node>} A map with numeric keys (source code line numbers) and comment token values.\n */\nfunction getCommentLineNumbers(comments) {\n    const map = new Map();\n\n    comments.forEach(comment => {\n        for (let i = comment.loc.start.line; i <= comment.loc.end.line; i++) {\n            map.set(i, comment);\n        }\n    });\n    return map;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce a maximum number of lines of code in a function\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/max-lines-per-function\"\n        },\n\n        schema: [\n            OPTIONS_OR_INTEGER_SCHEMA\n        ],\n        messages: {\n            exceed: \"{{name}} has too many lines ({{lineCount}}). Maximum allowed is {{maxLines}}.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const lines = sourceCode.lines;\n\n        const option = context.options[0];\n        let maxLines = 50;\n        let skipComments = false;\n        let skipBlankLines = false;\n        let IIFEs = false;\n\n        if (typeof option === \"object\") {\n            maxLines = typeof option.max === \"number\" ? option.max : 50;\n            skipComments = !!option.skipComments;\n            skipBlankLines = !!option.skipBlankLines;\n            IIFEs = !!option.IIFEs;\n        } else if (typeof option === \"number\") {\n            maxLines = option;\n        }\n\n        const commentLineNumbers = getCommentLineNumbers(sourceCode.getAllComments());\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Tells if a comment encompasses the entire line.\n         * @param {string} line The source line with a trailing comment\n         * @param {number} lineNumber The one-indexed line number this is on\n         * @param {ASTNode} comment The comment to remove\n         * @returns {boolean} If the comment covers the entire line\n         */\n        function isFullLineComment(line, lineNumber, comment) {\n            const start = comment.loc.start,\n                end = comment.loc.end,\n                isFirstTokenOnLine = start.line === lineNumber && !line.slice(0, start.column).trim(),\n                isLastTokenOnLine = end.line === lineNumber && !line.slice(end.column).trim();\n\n            return comment &&\n                (start.line < lineNumber || isFirstTokenOnLine) &&\n                (end.line > lineNumber || isLastTokenOnLine);\n        }\n\n        /**\n         * Identifies is a node is a FunctionExpression which is part of an IIFE\n         * @param {ASTNode} node Node to test\n         * @returns {boolean} True if it's an IIFE\n         */\n        function isIIFE(node) {\n            return (node.type === \"FunctionExpression\" || node.type === \"ArrowFunctionExpression\") && node.parent && node.parent.type === \"CallExpression\" && node.parent.callee === node;\n        }\n\n        /**\n         * Identifies is a node is a FunctionExpression which is embedded within a MethodDefinition or Property\n         * @param {ASTNode} node Node to test\n         * @returns {boolean} True if it's a FunctionExpression embedded within a MethodDefinition or Property\n         */\n        function isEmbedded(node) {\n            if (!node.parent) {\n                return false;\n            }\n            if (node !== node.parent.value) {\n                return false;\n            }\n            if (node.parent.type === \"MethodDefinition\") {\n                return true;\n            }\n            if (node.parent.type === \"Property\") {\n                return node.parent.method === true || node.parent.kind === \"get\" || node.parent.kind === \"set\";\n            }\n            return false;\n        }\n\n        /**\n         * Count the lines in the function\n         * @param {ASTNode} funcNode Function AST node\n         * @returns {void}\n         * @private\n         */\n        function processFunction(funcNode) {\n            const node = isEmbedded(funcNode) ? funcNode.parent : funcNode;\n\n            if (!IIFEs && isIIFE(node)) {\n                return;\n            }\n            let lineCount = 0;\n\n            for (let i = node.loc.start.line - 1; i < node.loc.end.line; ++i) {\n                const line = lines[i];\n\n                if (skipComments) {\n                    if (commentLineNumbers.has(i + 1) && isFullLineComment(line, i + 1, commentLineNumbers.get(i + 1))) {\n                        continue;\n                    }\n                }\n\n                if (skipBlankLines) {\n                    if (line.match(/^\\s*$/u)) {\n                        continue;\n                    }\n                }\n\n                lineCount++;\n            }\n\n            if (lineCount > maxLines) {\n                const name = upperCaseFirst(astUtils.getFunctionNameWithKind(funcNode));\n\n                context.report({\n                    node,\n                    messageId: \"exceed\",\n                    data: { name, lineCount, maxLines }\n                });\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n            FunctionDeclaration: processFunction,\n            FunctionExpression: processFunction,\n            ArrowFunctionExpression: processFunction\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}