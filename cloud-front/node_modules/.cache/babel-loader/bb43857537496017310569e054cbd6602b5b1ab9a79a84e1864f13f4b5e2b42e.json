{"ast":null,"code":"/**\n * @fileoverview Restrict usage of duplicate imports.\n * @author Simen Bekkhus\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\nrequire(\"core-js/modules/es.array.push.js\");\nconst NAMED_TYPES = [\"ImportSpecifier\", \"ExportSpecifier\"];\nconst NAMESPACE_TYPES = [\"ImportNamespaceSpecifier\", \"ExportNamespaceSpecifier\"];\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/**\n * Check if an import/export type belongs to (ImportSpecifier|ExportSpecifier) or (ImportNamespaceSpecifier|ExportNamespaceSpecifier).\n * @param {string} importExportType An import/export type to check.\n * @param {string} type Can be \"named\" or \"namespace\"\n * @returns {boolean} True if import/export type belongs to (ImportSpecifier|ExportSpecifier) or (ImportNamespaceSpecifier|ExportNamespaceSpecifier) and false if it doesn't.\n */\nfunction isImportExportSpecifier(importExportType, type) {\n  const arrayToCheck = type === \"named\" ? NAMED_TYPES : NAMESPACE_TYPES;\n  return arrayToCheck.includes(importExportType);\n}\n\n/**\n * Return the type of (import|export).\n * @param {ASTNode} node A node to get.\n * @returns {string} The type of the (import|export).\n */\nfunction getImportExportType(node) {\n  if (node.specifiers && node.specifiers.length > 0) {\n    const nodeSpecifiers = node.specifiers;\n    const index = nodeSpecifiers.findIndex(({\n      type\n    }) => isImportExportSpecifier(type, \"named\") || isImportExportSpecifier(type, \"namespace\"));\n    const i = index > -1 ? index : 0;\n    return nodeSpecifiers[i].type;\n  }\n  if (node.type === \"ExportAllDeclaration\") {\n    if (node.exported) {\n      return \"ExportNamespaceSpecifier\";\n    }\n    return \"ExportAll\";\n  }\n  return \"SideEffectImport\";\n}\n\n/**\n * Returns a boolean indicates if two (import|export) can be merged\n * @param {ASTNode} node1 A node to check.\n * @param {ASTNode} node2 A node to check.\n * @returns {boolean} True if two (import|export) can be merged, false if they can't.\n */\nfunction isImportExportCanBeMerged(node1, node2) {\n  const importExportType1 = getImportExportType(node1);\n  const importExportType2 = getImportExportType(node2);\n  if (importExportType1 === \"ExportAll\" && importExportType2 !== \"ExportAll\" && importExportType2 !== \"SideEffectImport\" || importExportType1 !== \"ExportAll\" && importExportType1 !== \"SideEffectImport\" && importExportType2 === \"ExportAll\") {\n    return false;\n  }\n  if (isImportExportSpecifier(importExportType1, \"namespace\") && isImportExportSpecifier(importExportType2, \"named\") || isImportExportSpecifier(importExportType2, \"namespace\") && isImportExportSpecifier(importExportType1, \"named\")) {\n    return false;\n  }\n  return true;\n}\n\n/**\n * Returns a boolean if we should report (import|export).\n * @param {ASTNode} node A node to be reported or not.\n * @param {[ASTNode]} previousNodes An array contains previous nodes of the module imported or exported.\n * @returns {boolean} True if the (import|export) should be reported.\n */\nfunction shouldReportImportExport(node, previousNodes) {\n  let i = 0;\n  while (i < previousNodes.length) {\n    if (isImportExportCanBeMerged(node, previousNodes[i])) {\n      return true;\n    }\n    i++;\n  }\n  return false;\n}\n\n/**\n * Returns array contains only nodes with declarations types equal to type.\n * @param {[{node: ASTNode, declarationType: string}]} nodes An array contains objects, each object contains a node and a declaration type.\n * @param {string} type Declaration type.\n * @returns {[ASTNode]} An array contains only nodes with declarations types equal to type.\n */\nfunction getNodesByDeclarationType(nodes, type) {\n  return nodes.filter(({\n    declarationType\n  }) => declarationType === type).map(({\n    node\n  }) => node);\n}\n\n/**\n * Returns the name of the module imported or re-exported.\n * @param {ASTNode} node A node to get.\n * @returns {string} The name of the module, or empty string if no name.\n */\nfunction getModule(node) {\n  if (node && node.source && node.source.value) {\n    return node.source.value.trim();\n  }\n  return \"\";\n}\n\n/**\n * Checks if the (import|export) can be merged with at least one import or one export, and reports if so.\n * @param {RuleContext} context The ESLint rule context object.\n * @param {ASTNode} node A node to get.\n * @param {Map} modules A Map object contains as a key a module name and as value an array contains objects, each object contains a node and a declaration type.\n * @param {string} declarationType A declaration type can be an import or export.\n * @param {boolean} includeExports Whether or not to check for exports in addition to imports.\n * @returns {void} No return value.\n */\nfunction checkAndReport(context, node, modules, declarationType, includeExports) {\n  const module = getModule(node);\n  if (modules.has(module)) {\n    const previousNodes = modules.get(module);\n    const messagesIds = [];\n    const importNodes = getNodesByDeclarationType(previousNodes, \"import\");\n    let exportNodes;\n    if (includeExports) {\n      exportNodes = getNodesByDeclarationType(previousNodes, \"export\");\n    }\n    if (declarationType === \"import\") {\n      if (shouldReportImportExport(node, importNodes)) {\n        messagesIds.push(\"import\");\n      }\n      if (includeExports) {\n        if (shouldReportImportExport(node, exportNodes)) {\n          messagesIds.push(\"importAs\");\n        }\n      }\n    } else if (declarationType === \"export\") {\n      if (shouldReportImportExport(node, exportNodes)) {\n        messagesIds.push(\"export\");\n      }\n      if (shouldReportImportExport(node, importNodes)) {\n        messagesIds.push(\"exportAs\");\n      }\n    }\n    messagesIds.forEach(messageId => context.report({\n      node,\n      messageId,\n      data: {\n        module\n      }\n    }));\n  }\n}\n\n/**\n * @callback nodeCallback\n * @param {ASTNode} node A node to handle.\n */\n\n/**\n * Returns a function handling the (imports|exports) of a given file\n * @param {RuleContext} context The ESLint rule context object.\n * @param {Map} modules A Map object contains as a key a module name and as value an array contains objects, each object contains a node and a declaration type.\n * @param {string} declarationType A declaration type can be an import or export.\n * @param {boolean} includeExports Whether or not to check for exports in addition to imports.\n * @returns {nodeCallback} A function passed to ESLint to handle the statement.\n */\nfunction handleImportsExports(context, modules, declarationType, includeExports) {\n  return function (node) {\n    const module = getModule(node);\n    if (module) {\n      checkAndReport(context, node, modules, declarationType, includeExports);\n      const currentNode = {\n        node,\n        declarationType\n      };\n      let nodes = [currentNode];\n      if (modules.has(module)) {\n        const previousNodes = modules.get(module);\n        nodes = [...previousNodes, currentNode];\n      }\n      modules.set(module, nodes);\n    }\n  };\n}\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow duplicate module imports\",\n      category: \"ECMAScript 6\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-duplicate-imports\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        includeExports: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      import: \"'{{module}}' import is duplicated.\",\n      importAs: \"'{{module}}' import is duplicated as export.\",\n      export: \"'{{module}}' export is duplicated.\",\n      exportAs: \"'{{module}}' export is duplicated as import.\"\n    }\n  },\n  create(context) {\n    const includeExports = (context.options[0] || {}).includeExports,\n      modules = new Map();\n    const handlers = {\n      ImportDeclaration: handleImportsExports(context, modules, \"import\", includeExports)\n    };\n    if (includeExports) {\n      handlers.ExportNamedDeclaration = handleImportsExports(context, modules, \"export\", includeExports);\n      handlers.ExportAllDeclaration = handleImportsExports(context, modules, \"export\", includeExports);\n    }\n    return handlers;\n  }\n};","map":{"version":3,"names":["require","NAMED_TYPES","NAMESPACE_TYPES","isImportExportSpecifier","importExportType","type","arrayToCheck","includes","getImportExportType","node","specifiers","length","nodeSpecifiers","index","findIndex","i","exported","isImportExportCanBeMerged","node1","node2","importExportType1","importExportType2","shouldReportImportExport","previousNodes","getNodesByDeclarationType","nodes","filter","declarationType","map","getModule","source","value","trim","checkAndReport","context","modules","includeExports","module","has","get","messagesIds","importNodes","exportNodes","push","forEach","messageId","report","data","handleImportsExports","currentNode","set","exports","meta","docs","description","category","recommended","url","schema","properties","default","additionalProperties","messages","import","importAs","export","exportAs","create","options","Map","handlers","ImportDeclaration","ExportNamedDeclaration","ExportAllDeclaration"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/no-duplicate-imports.js"],"sourcesContent":["/**\n * @fileoverview Restrict usage of duplicate imports.\n * @author Simen Bekkhus\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst NAMED_TYPES = [\"ImportSpecifier\", \"ExportSpecifier\"];\nconst NAMESPACE_TYPES = [\n    \"ImportNamespaceSpecifier\",\n    \"ExportNamespaceSpecifier\"\n];\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/**\n * Check if an import/export type belongs to (ImportSpecifier|ExportSpecifier) or (ImportNamespaceSpecifier|ExportNamespaceSpecifier).\n * @param {string} importExportType An import/export type to check.\n * @param {string} type Can be \"named\" or \"namespace\"\n * @returns {boolean} True if import/export type belongs to (ImportSpecifier|ExportSpecifier) or (ImportNamespaceSpecifier|ExportNamespaceSpecifier) and false if it doesn't.\n */\nfunction isImportExportSpecifier(importExportType, type) {\n    const arrayToCheck = type === \"named\" ? NAMED_TYPES : NAMESPACE_TYPES;\n\n    return arrayToCheck.includes(importExportType);\n}\n\n/**\n * Return the type of (import|export).\n * @param {ASTNode} node A node to get.\n * @returns {string} The type of the (import|export).\n */\nfunction getImportExportType(node) {\n    if (node.specifiers && node.specifiers.length > 0) {\n        const nodeSpecifiers = node.specifiers;\n        const index = nodeSpecifiers.findIndex(\n            ({ type }) =>\n                isImportExportSpecifier(type, \"named\") ||\n                isImportExportSpecifier(type, \"namespace\")\n        );\n        const i = index > -1 ? index : 0;\n\n        return nodeSpecifiers[i].type;\n    }\n    if (node.type === \"ExportAllDeclaration\") {\n        if (node.exported) {\n            return \"ExportNamespaceSpecifier\";\n        }\n        return \"ExportAll\";\n    }\n    return \"SideEffectImport\";\n}\n\n/**\n * Returns a boolean indicates if two (import|export) can be merged\n * @param {ASTNode} node1 A node to check.\n * @param {ASTNode} node2 A node to check.\n * @returns {boolean} True if two (import|export) can be merged, false if they can't.\n */\nfunction isImportExportCanBeMerged(node1, node2) {\n    const importExportType1 = getImportExportType(node1);\n    const importExportType2 = getImportExportType(node2);\n\n    if (\n        (importExportType1 === \"ExportAll\" &&\n            importExportType2 !== \"ExportAll\" &&\n            importExportType2 !== \"SideEffectImport\") ||\n        (importExportType1 !== \"ExportAll\" &&\n            importExportType1 !== \"SideEffectImport\" &&\n            importExportType2 === \"ExportAll\")\n    ) {\n        return false;\n    }\n    if (\n        (isImportExportSpecifier(importExportType1, \"namespace\") &&\n            isImportExportSpecifier(importExportType2, \"named\")) ||\n        (isImportExportSpecifier(importExportType2, \"namespace\") &&\n            isImportExportSpecifier(importExportType1, \"named\"))\n    ) {\n        return false;\n    }\n    return true;\n}\n\n/**\n * Returns a boolean if we should report (import|export).\n * @param {ASTNode} node A node to be reported or not.\n * @param {[ASTNode]} previousNodes An array contains previous nodes of the module imported or exported.\n * @returns {boolean} True if the (import|export) should be reported.\n */\nfunction shouldReportImportExport(node, previousNodes) {\n    let i = 0;\n\n    while (i < previousNodes.length) {\n        if (isImportExportCanBeMerged(node, previousNodes[i])) {\n            return true;\n        }\n        i++;\n    }\n    return false;\n}\n\n/**\n * Returns array contains only nodes with declarations types equal to type.\n * @param {[{node: ASTNode, declarationType: string}]} nodes An array contains objects, each object contains a node and a declaration type.\n * @param {string} type Declaration type.\n * @returns {[ASTNode]} An array contains only nodes with declarations types equal to type.\n */\nfunction getNodesByDeclarationType(nodes, type) {\n    return nodes\n        .filter(({ declarationType }) => declarationType === type)\n        .map(({ node }) => node);\n}\n\n/**\n * Returns the name of the module imported or re-exported.\n * @param {ASTNode} node A node to get.\n * @returns {string} The name of the module, or empty string if no name.\n */\nfunction getModule(node) {\n    if (node && node.source && node.source.value) {\n        return node.source.value.trim();\n    }\n    return \"\";\n}\n\n/**\n * Checks if the (import|export) can be merged with at least one import or one export, and reports if so.\n * @param {RuleContext} context The ESLint rule context object.\n * @param {ASTNode} node A node to get.\n * @param {Map} modules A Map object contains as a key a module name and as value an array contains objects, each object contains a node and a declaration type.\n * @param {string} declarationType A declaration type can be an import or export.\n * @param {boolean} includeExports Whether or not to check for exports in addition to imports.\n * @returns {void} No return value.\n */\nfunction checkAndReport(\n    context,\n    node,\n    modules,\n    declarationType,\n    includeExports\n) {\n    const module = getModule(node);\n\n    if (modules.has(module)) {\n        const previousNodes = modules.get(module);\n        const messagesIds = [];\n        const importNodes = getNodesByDeclarationType(previousNodes, \"import\");\n        let exportNodes;\n\n        if (includeExports) {\n            exportNodes = getNodesByDeclarationType(previousNodes, \"export\");\n        }\n        if (declarationType === \"import\") {\n            if (shouldReportImportExport(node, importNodes)) {\n                messagesIds.push(\"import\");\n            }\n            if (includeExports) {\n                if (shouldReportImportExport(node, exportNodes)) {\n                    messagesIds.push(\"importAs\");\n                }\n            }\n        } else if (declarationType === \"export\") {\n            if (shouldReportImportExport(node, exportNodes)) {\n                messagesIds.push(\"export\");\n            }\n            if (shouldReportImportExport(node, importNodes)) {\n                messagesIds.push(\"exportAs\");\n            }\n        }\n        messagesIds.forEach(messageId =>\n            context.report({\n                node,\n                messageId,\n                data: {\n                    module\n                }\n            }));\n    }\n}\n\n/**\n * @callback nodeCallback\n * @param {ASTNode} node A node to handle.\n */\n\n/**\n * Returns a function handling the (imports|exports) of a given file\n * @param {RuleContext} context The ESLint rule context object.\n * @param {Map} modules A Map object contains as a key a module name and as value an array contains objects, each object contains a node and a declaration type.\n * @param {string} declarationType A declaration type can be an import or export.\n * @param {boolean} includeExports Whether or not to check for exports in addition to imports.\n * @returns {nodeCallback} A function passed to ESLint to handle the statement.\n */\nfunction handleImportsExports(\n    context,\n    modules,\n    declarationType,\n    includeExports\n) {\n    return function(node) {\n        const module = getModule(node);\n\n        if (module) {\n            checkAndReport(\n                context,\n                node,\n                modules,\n                declarationType,\n                includeExports\n            );\n            const currentNode = { node, declarationType };\n            let nodes = [currentNode];\n\n            if (modules.has(module)) {\n                const previousNodes = modules.get(module);\n\n                nodes = [...previousNodes, currentNode];\n            }\n            modules.set(module, nodes);\n        }\n    };\n}\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow duplicate module imports\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-duplicate-imports\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    includeExports: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            import: \"'{{module}}' import is duplicated.\",\n            importAs: \"'{{module}}' import is duplicated as export.\",\n            export: \"'{{module}}' export is duplicated.\",\n            exportAs: \"'{{module}}' export is duplicated as import.\"\n        }\n    },\n\n    create(context) {\n        const includeExports = (context.options[0] || {}).includeExports,\n            modules = new Map();\n        const handlers = {\n            ImportDeclaration: handleImportsExports(\n                context,\n                modules,\n                \"import\",\n                includeExports\n            )\n        };\n\n        if (includeExports) {\n            handlers.ExportNamedDeclaration = handleImportsExports(\n                context,\n                modules,\n                \"export\",\n                includeExports\n            );\n            handlers.ExportAllDeclaration = handleImportsExports(\n                context,\n                modules,\n                \"export\",\n                includeExports\n            );\n        }\n        return handlers;\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}