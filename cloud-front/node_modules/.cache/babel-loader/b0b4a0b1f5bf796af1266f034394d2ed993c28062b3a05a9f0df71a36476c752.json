{"ast":null,"code":"/**\n * @fileoverview Rule to disallow whitespace that is not a tab or space, whitespace inside strings and comments are allowed\n * @author Jonathan Kingston\n * @author Christophe Porteneuve\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nrequire(\"core-js/modules/es.array.push.js\");\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\n\nconst ALL_IRREGULARS = /[\\f\\v\\u0085\\ufeff\\u00a0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u200b\\u202f\\u205f\\u3000\\u2028\\u2029]/u;\nconst IRREGULAR_WHITESPACE = /[\\f\\v\\u0085\\ufeff\\u00a0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u200b\\u202f\\u205f\\u3000]+/mgu;\nconst IRREGULAR_LINE_TERMINATORS = /[\\u2028\\u2029]/mgu;\nconst LINE_BREAK = astUtils.createGlobalLinebreakMatcher();\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow irregular whitespace\",\n      category: \"Possible Errors\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-irregular-whitespace\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        skipComments: {\n          type: \"boolean\",\n          default: false\n        },\n        skipStrings: {\n          type: \"boolean\",\n          default: true\n        },\n        skipTemplates: {\n          type: \"boolean\",\n          default: false\n        },\n        skipRegExps: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      noIrregularWhitespace: \"Irregular whitespace not allowed.\"\n    }\n  },\n  create(context) {\n    // Module store of errors that we have found\n    let errors = [];\n\n    // Lookup the `skipComments` option, which defaults to `false`.\n    const options = context.options[0] || {};\n    const skipComments = !!options.skipComments;\n    const skipStrings = options.skipStrings !== false;\n    const skipRegExps = !!options.skipRegExps;\n    const skipTemplates = !!options.skipTemplates;\n    const sourceCode = context.getSourceCode();\n    const commentNodes = sourceCode.getAllComments();\n\n    /**\n     * Removes errors that occur inside the given node\n     * @param {ASTNode} node to check for matching errors.\n     * @returns {void}\n     * @private\n     */\n    function removeWhitespaceError(node) {\n      const locStart = node.loc.start;\n      const locEnd = node.loc.end;\n      errors = errors.filter(({\n        loc: {\n          start: errorLocStart\n        }\n      }) => errorLocStart.line < locStart.line || errorLocStart.line === locStart.line && errorLocStart.column < locStart.column || errorLocStart.line === locEnd.line && errorLocStart.column >= locEnd.column || errorLocStart.line > locEnd.line);\n    }\n\n    /**\n     * Checks identifier or literal nodes for errors that we are choosing to ignore and calls the relevant methods to remove the errors\n     * @param {ASTNode} node to check for matching errors.\n     * @returns {void}\n     * @private\n     */\n    function removeInvalidNodeErrorsInIdentifierOrLiteral(node) {\n      const shouldCheckStrings = skipStrings && typeof node.value === \"string\";\n      const shouldCheckRegExps = skipRegExps && Boolean(node.regex);\n      if (shouldCheckStrings || shouldCheckRegExps) {\n        // If we have irregular characters remove them from the errors list\n        if (ALL_IRREGULARS.test(node.raw)) {\n          removeWhitespaceError(node);\n        }\n      }\n    }\n\n    /**\n     * Checks template string literal nodes for errors that we are choosing to ignore and calls the relevant methods to remove the errors\n     * @param {ASTNode} node to check for matching errors.\n     * @returns {void}\n     * @private\n     */\n    function removeInvalidNodeErrorsInTemplateLiteral(node) {\n      if (typeof node.value.raw === \"string\") {\n        if (ALL_IRREGULARS.test(node.value.raw)) {\n          removeWhitespaceError(node);\n        }\n      }\n    }\n\n    /**\n     * Checks comment nodes for errors that we are choosing to ignore and calls the relevant methods to remove the errors\n     * @param {ASTNode} node to check for matching errors.\n     * @returns {void}\n     * @private\n     */\n    function removeInvalidNodeErrorsInComment(node) {\n      if (ALL_IRREGULARS.test(node.value)) {\n        removeWhitespaceError(node);\n      }\n    }\n\n    /**\n     * Checks the program source for irregular whitespace\n     * @param {ASTNode} node The program node\n     * @returns {void}\n     * @private\n     */\n    function checkForIrregularWhitespace(node) {\n      const sourceLines = sourceCode.lines;\n      sourceLines.forEach((sourceLine, lineIndex) => {\n        const lineNumber = lineIndex + 1;\n        let match;\n        while ((match = IRREGULAR_WHITESPACE.exec(sourceLine)) !== null) {\n          errors.push({\n            node,\n            messageId: \"noIrregularWhitespace\",\n            loc: {\n              start: {\n                line: lineNumber,\n                column: match.index\n              },\n              end: {\n                line: lineNumber,\n                column: match.index + match[0].length\n              }\n            }\n          });\n        }\n      });\n    }\n\n    /**\n     * Checks the program source for irregular line terminators\n     * @param {ASTNode} node The program node\n     * @returns {void}\n     * @private\n     */\n    function checkForIrregularLineTerminators(node) {\n      const source = sourceCode.getText(),\n        sourceLines = sourceCode.lines,\n        linebreaks = source.match(LINE_BREAK);\n      let lastLineIndex = -1,\n        match;\n      while ((match = IRREGULAR_LINE_TERMINATORS.exec(source)) !== null) {\n        const lineIndex = linebreaks.indexOf(match[0], lastLineIndex + 1) || 0;\n        errors.push({\n          node,\n          messageId: \"noIrregularWhitespace\",\n          loc: {\n            start: {\n              line: lineIndex + 1,\n              column: sourceLines[lineIndex].length\n            },\n            end: {\n              line: lineIndex + 2,\n              column: 0\n            }\n          }\n        });\n        lastLineIndex = lineIndex;\n      }\n    }\n\n    /**\n     * A no-op function to act as placeholder for comment accumulation when the `skipComments` option is `false`.\n     * @returns {void}\n     * @private\n     */\n    function noop() {}\n    const nodes = {};\n    if (ALL_IRREGULARS.test(sourceCode.getText())) {\n      nodes.Program = function (node) {\n        /*\n         * As we can easily fire warnings for all white space issues with\n         * all the source its simpler to fire them here.\n         * This means we can check all the application code without having\n         * to worry about issues caused in the parser tokens.\n         * When writing this code also evaluating per node was missing out\n         * connecting tokens in some cases.\n         * We can later filter the errors when they are found to be not an\n         * issue in nodes we don't care about.\n         */\n        checkForIrregularWhitespace(node);\n        checkForIrregularLineTerminators(node);\n      };\n      nodes.Identifier = removeInvalidNodeErrorsInIdentifierOrLiteral;\n      nodes.Literal = removeInvalidNodeErrorsInIdentifierOrLiteral;\n      nodes.TemplateElement = skipTemplates ? removeInvalidNodeErrorsInTemplateLiteral : noop;\n      nodes[\"Program:exit\"] = function () {\n        if (skipComments) {\n          // First strip errors occurring in comment nodes.\n          commentNodes.forEach(removeInvalidNodeErrorsInComment);\n        }\n\n        // If we have any errors remaining report on them\n        errors.forEach(error => context.report(error));\n      };\n    } else {\n      nodes.Program = noop;\n    }\n    return nodes;\n  }\n};","map":{"version":3,"names":["require","astUtils","ALL_IRREGULARS","IRREGULAR_WHITESPACE","IRREGULAR_LINE_TERMINATORS","LINE_BREAK","createGlobalLinebreakMatcher","module","exports","meta","type","docs","description","category","recommended","url","schema","properties","skipComments","default","skipStrings","skipTemplates","skipRegExps","additionalProperties","messages","noIrregularWhitespace","create","context","errors","options","sourceCode","getSourceCode","commentNodes","getAllComments","removeWhitespaceError","node","locStart","loc","start","locEnd","end","filter","errorLocStart","line","column","removeInvalidNodeErrorsInIdentifierOrLiteral","shouldCheckStrings","value","shouldCheckRegExps","Boolean","regex","test","raw","removeInvalidNodeErrorsInTemplateLiteral","removeInvalidNodeErrorsInComment","checkForIrregularWhitespace","sourceLines","lines","forEach","sourceLine","lineIndex","lineNumber","match","exec","push","messageId","index","length","checkForIrregularLineTerminators","source","getText","linebreaks","lastLineIndex","indexOf","noop","nodes","Program","Identifier","Literal","TemplateElement","error","report"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/no-irregular-whitespace.js"],"sourcesContent":["/**\n * @fileoverview Rule to disallow whitespace that is not a tab or space, whitespace inside strings and comments are allowed\n * @author Jonathan Kingston\n * @author Christophe Porteneuve\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\n\nconst ALL_IRREGULARS = /[\\f\\v\\u0085\\ufeff\\u00a0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u200b\\u202f\\u205f\\u3000\\u2028\\u2029]/u;\nconst IRREGULAR_WHITESPACE = /[\\f\\v\\u0085\\ufeff\\u00a0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u200b\\u202f\\u205f\\u3000]+/mgu;\nconst IRREGULAR_LINE_TERMINATORS = /[\\u2028\\u2029]/mgu;\nconst LINE_BREAK = astUtils.createGlobalLinebreakMatcher();\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow irregular whitespace\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-irregular-whitespace\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    skipComments: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    skipStrings: {\n                        type: \"boolean\",\n                        default: true\n                    },\n                    skipTemplates: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    skipRegExps: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            noIrregularWhitespace: \"Irregular whitespace not allowed.\"\n        }\n    },\n\n    create(context) {\n\n        // Module store of errors that we have found\n        let errors = [];\n\n        // Lookup the `skipComments` option, which defaults to `false`.\n        const options = context.options[0] || {};\n        const skipComments = !!options.skipComments;\n        const skipStrings = options.skipStrings !== false;\n        const skipRegExps = !!options.skipRegExps;\n        const skipTemplates = !!options.skipTemplates;\n\n        const sourceCode = context.getSourceCode();\n        const commentNodes = sourceCode.getAllComments();\n\n        /**\n         * Removes errors that occur inside the given node\n         * @param {ASTNode} node to check for matching errors.\n         * @returns {void}\n         * @private\n         */\n        function removeWhitespaceError(node) {\n            const locStart = node.loc.start;\n            const locEnd = node.loc.end;\n\n            errors = errors.filter(({ loc: { start: errorLocStart } }) => (\n                errorLocStart.line < locStart.line ||\n                errorLocStart.line === locStart.line && errorLocStart.column < locStart.column ||\n                errorLocStart.line === locEnd.line && errorLocStart.column >= locEnd.column ||\n                errorLocStart.line > locEnd.line\n            ));\n        }\n\n        /**\n         * Checks identifier or literal nodes for errors that we are choosing to ignore and calls the relevant methods to remove the errors\n         * @param {ASTNode} node to check for matching errors.\n         * @returns {void}\n         * @private\n         */\n        function removeInvalidNodeErrorsInIdentifierOrLiteral(node) {\n            const shouldCheckStrings = skipStrings && (typeof node.value === \"string\");\n            const shouldCheckRegExps = skipRegExps && Boolean(node.regex);\n\n            if (shouldCheckStrings || shouldCheckRegExps) {\n\n                // If we have irregular characters remove them from the errors list\n                if (ALL_IRREGULARS.test(node.raw)) {\n                    removeWhitespaceError(node);\n                }\n            }\n        }\n\n        /**\n         * Checks template string literal nodes for errors that we are choosing to ignore and calls the relevant methods to remove the errors\n         * @param {ASTNode} node to check for matching errors.\n         * @returns {void}\n         * @private\n         */\n        function removeInvalidNodeErrorsInTemplateLiteral(node) {\n            if (typeof node.value.raw === \"string\") {\n                if (ALL_IRREGULARS.test(node.value.raw)) {\n                    removeWhitespaceError(node);\n                }\n            }\n        }\n\n        /**\n         * Checks comment nodes for errors that we are choosing to ignore and calls the relevant methods to remove the errors\n         * @param {ASTNode} node to check for matching errors.\n         * @returns {void}\n         * @private\n         */\n        function removeInvalidNodeErrorsInComment(node) {\n            if (ALL_IRREGULARS.test(node.value)) {\n                removeWhitespaceError(node);\n            }\n        }\n\n        /**\n         * Checks the program source for irregular whitespace\n         * @param {ASTNode} node The program node\n         * @returns {void}\n         * @private\n         */\n        function checkForIrregularWhitespace(node) {\n            const sourceLines = sourceCode.lines;\n\n            sourceLines.forEach((sourceLine, lineIndex) => {\n                const lineNumber = lineIndex + 1;\n                let match;\n\n                while ((match = IRREGULAR_WHITESPACE.exec(sourceLine)) !== null) {\n                    errors.push({\n                        node,\n                        messageId: \"noIrregularWhitespace\",\n                        loc: {\n                            start: {\n                                line: lineNumber,\n                                column: match.index\n                            },\n                            end: {\n                                line: lineNumber,\n                                column: match.index + match[0].length\n                            }\n                        }\n                    });\n                }\n            });\n        }\n\n        /**\n         * Checks the program source for irregular line terminators\n         * @param {ASTNode} node The program node\n         * @returns {void}\n         * @private\n         */\n        function checkForIrregularLineTerminators(node) {\n            const source = sourceCode.getText(),\n                sourceLines = sourceCode.lines,\n                linebreaks = source.match(LINE_BREAK);\n            let lastLineIndex = -1,\n                match;\n\n            while ((match = IRREGULAR_LINE_TERMINATORS.exec(source)) !== null) {\n                const lineIndex = linebreaks.indexOf(match[0], lastLineIndex + 1) || 0;\n\n                errors.push({\n                    node,\n                    messageId: \"noIrregularWhitespace\",\n                    loc: {\n                        start: {\n                            line: lineIndex + 1,\n                            column: sourceLines[lineIndex].length\n                        },\n                        end: {\n                            line: lineIndex + 2,\n                            column: 0\n                        }\n                    }\n                });\n\n                lastLineIndex = lineIndex;\n            }\n        }\n\n        /**\n         * A no-op function to act as placeholder for comment accumulation when the `skipComments` option is `false`.\n         * @returns {void}\n         * @private\n         */\n        function noop() {}\n\n        const nodes = {};\n\n        if (ALL_IRREGULARS.test(sourceCode.getText())) {\n            nodes.Program = function(node) {\n\n                /*\n                 * As we can easily fire warnings for all white space issues with\n                 * all the source its simpler to fire them here.\n                 * This means we can check all the application code without having\n                 * to worry about issues caused in the parser tokens.\n                 * When writing this code also evaluating per node was missing out\n                 * connecting tokens in some cases.\n                 * We can later filter the errors when they are found to be not an\n                 * issue in nodes we don't care about.\n                 */\n                checkForIrregularWhitespace(node);\n                checkForIrregularLineTerminators(node);\n            };\n\n            nodes.Identifier = removeInvalidNodeErrorsInIdentifierOrLiteral;\n            nodes.Literal = removeInvalidNodeErrorsInIdentifierOrLiteral;\n            nodes.TemplateElement = skipTemplates ? removeInvalidNodeErrorsInTemplateLiteral : noop;\n            nodes[\"Program:exit\"] = function() {\n                if (skipComments) {\n\n                    // First strip errors occurring in comment nodes.\n                    commentNodes.forEach(removeInvalidNodeErrorsInComment);\n                }\n\n                // If we have any errors remaining report on them\n                errors.forEach(error => context.report(error));\n            };\n        } else {\n            nodes.Program = noop;\n        }\n\n        return nodes;\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}