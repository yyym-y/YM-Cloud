{"ast":null,"code":"/**\n * @fileoverview Rule to enforce line breaks after each array element\n * @author Jan Peer Stöcklmair <https://github.com/JPeer264>\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce line breaks after each array element\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/array-element-newline\"\n    },\n    fixable: \"whitespace\",\n    schema: {\n      definitions: {\n        basicConfig: {\n          oneOf: [{\n            enum: [\"always\", \"never\", \"consistent\"]\n          }, {\n            type: \"object\",\n            properties: {\n              multiline: {\n                type: \"boolean\"\n              },\n              minItems: {\n                type: [\"integer\", \"null\"],\n                minimum: 0\n              }\n            },\n            additionalProperties: false\n          }]\n        }\n      },\n      items: [{\n        oneOf: [{\n          $ref: \"#/definitions/basicConfig\"\n        }, {\n          type: \"object\",\n          properties: {\n            ArrayExpression: {\n              $ref: \"#/definitions/basicConfig\"\n            },\n            ArrayPattern: {\n              $ref: \"#/definitions/basicConfig\"\n            }\n          },\n          additionalProperties: false,\n          minProperties: 1\n        }]\n      }]\n    },\n    messages: {\n      unexpectedLineBreak: \"There should be no linebreak here.\",\n      missingLineBreak: \"There should be a linebreak after this element.\"\n    }\n  },\n  create(context) {\n    const sourceCode = context.getSourceCode();\n\n    //----------------------------------------------------------------------\n    // Helpers\n    //----------------------------------------------------------------------\n\n    /**\n     * Normalizes a given option value.\n     * @param {string|Object|undefined} providedOption An option value to parse.\n     * @returns {{multiline: boolean, minItems: number}} Normalized option object.\n     */\n    function normalizeOptionValue(providedOption) {\n      let consistent = false;\n      let multiline = false;\n      let minItems;\n      const option = providedOption || \"always\";\n      if (!option || option === \"always\" || option.minItems === 0) {\n        minItems = 0;\n      } else if (option === \"never\") {\n        minItems = Number.POSITIVE_INFINITY;\n      } else if (option === \"consistent\") {\n        consistent = true;\n        minItems = Number.POSITIVE_INFINITY;\n      } else {\n        multiline = Boolean(option.multiline);\n        minItems = option.minItems || Number.POSITIVE_INFINITY;\n      }\n      return {\n        consistent,\n        multiline,\n        minItems\n      };\n    }\n\n    /**\n     * Normalizes a given option value.\n     * @param {string|Object|undefined} options An option value to parse.\n     * @returns {{ArrayExpression: {multiline: boolean, minItems: number}, ArrayPattern: {multiline: boolean, minItems: number}}} Normalized option object.\n     */\n    function normalizeOptions(options) {\n      if (options && (options.ArrayExpression || options.ArrayPattern)) {\n        let expressionOptions, patternOptions;\n        if (options.ArrayExpression) {\n          expressionOptions = normalizeOptionValue(options.ArrayExpression);\n        }\n        if (options.ArrayPattern) {\n          patternOptions = normalizeOptionValue(options.ArrayPattern);\n        }\n        return {\n          ArrayExpression: expressionOptions,\n          ArrayPattern: patternOptions\n        };\n      }\n      const value = normalizeOptionValue(options);\n      return {\n        ArrayExpression: value,\n        ArrayPattern: value\n      };\n    }\n\n    /**\n     * Reports that there shouldn't be a line break after the first token\n     * @param {Token} token The token to use for the report.\n     * @returns {void}\n     */\n    function reportNoLineBreak(token) {\n      const tokenBefore = sourceCode.getTokenBefore(token, {\n        includeComments: true\n      });\n      context.report({\n        loc: {\n          start: tokenBefore.loc.end,\n          end: token.loc.start\n        },\n        messageId: \"unexpectedLineBreak\",\n        fix(fixer) {\n          if (astUtils.isCommentToken(tokenBefore)) {\n            return null;\n          }\n          if (!astUtils.isTokenOnSameLine(tokenBefore, token)) {\n            return fixer.replaceTextRange([tokenBefore.range[1], token.range[0]], \" \");\n          }\n\n          /*\n           * This will check if the comma is on the same line as the next element\n           * Following array:\n           * [\n           *     1\n           *     , 2\n           *     , 3\n           * ]\n           *\n           * will be fixed to:\n           * [\n           *     1, 2, 3\n           * ]\n           */\n          const twoTokensBefore = sourceCode.getTokenBefore(tokenBefore, {\n            includeComments: true\n          });\n          if (astUtils.isCommentToken(twoTokensBefore)) {\n            return null;\n          }\n          return fixer.replaceTextRange([twoTokensBefore.range[1], tokenBefore.range[0]], \"\");\n        }\n      });\n    }\n\n    /**\n     * Reports that there should be a line break after the first token\n     * @param {Token} token The token to use for the report.\n     * @returns {void}\n     */\n    function reportRequiredLineBreak(token) {\n      const tokenBefore = sourceCode.getTokenBefore(token, {\n        includeComments: true\n      });\n      context.report({\n        loc: {\n          start: tokenBefore.loc.end,\n          end: token.loc.start\n        },\n        messageId: \"missingLineBreak\",\n        fix(fixer) {\n          return fixer.replaceTextRange([tokenBefore.range[1], token.range[0]], \"\\n\");\n        }\n      });\n    }\n\n    /**\n     * Reports a given node if it violated this rule.\n     * @param {ASTNode} node A node to check. This is an ObjectExpression node or an ObjectPattern node.\n     * @returns {void}\n     */\n    function check(node) {\n      const elements = node.elements;\n      const normalizedOptions = normalizeOptions(context.options[0]);\n      const options = normalizedOptions[node.type];\n      if (!options) {\n        return;\n      }\n      let elementBreak = false;\n\n      /*\n       * MULTILINE: true\n       * loop through every element and check\n       * if at least one element has linebreaks inside\n       * this ensures that following is not valid (due to elements are on the same line):\n       *\n       * [\n       *      1,\n       *      2,\n       *      3\n       * ]\n       */\n      if (options.multiline) {\n        elementBreak = elements.filter(element => element !== null).some(element => element.loc.start.line !== element.loc.end.line);\n      }\n      const linebreaksCount = node.elements.map((element, i) => {\n        const previousElement = elements[i - 1];\n        if (i === 0 || element === null || previousElement === null) {\n          return false;\n        }\n        const commaToken = sourceCode.getFirstTokenBetween(previousElement, element, astUtils.isCommaToken);\n        const lastTokenOfPreviousElement = sourceCode.getTokenBefore(commaToken);\n        const firstTokenOfCurrentElement = sourceCode.getTokenAfter(commaToken);\n        return !astUtils.isTokenOnSameLine(lastTokenOfPreviousElement, firstTokenOfCurrentElement);\n      }).filter(isBreak => isBreak === true).length;\n      const needsLinebreaks = elements.length >= options.minItems || options.multiline && elementBreak || options.consistent && linebreaksCount > 0 && linebreaksCount < node.elements.length;\n      elements.forEach((element, i) => {\n        const previousElement = elements[i - 1];\n        if (i === 0 || element === null || previousElement === null) {\n          return;\n        }\n        const commaToken = sourceCode.getFirstTokenBetween(previousElement, element, astUtils.isCommaToken);\n        const lastTokenOfPreviousElement = sourceCode.getTokenBefore(commaToken);\n        const firstTokenOfCurrentElement = sourceCode.getTokenAfter(commaToken);\n        if (needsLinebreaks) {\n          if (astUtils.isTokenOnSameLine(lastTokenOfPreviousElement, firstTokenOfCurrentElement)) {\n            reportRequiredLineBreak(firstTokenOfCurrentElement);\n          }\n        } else {\n          if (!astUtils.isTokenOnSameLine(lastTokenOfPreviousElement, firstTokenOfCurrentElement)) {\n            reportNoLineBreak(firstTokenOfCurrentElement);\n          }\n        }\n      });\n    }\n\n    //----------------------------------------------------------------------\n    // Public\n    //----------------------------------------------------------------------\n\n    return {\n      ArrayPattern: check,\n      ArrayExpression: check\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","module","exports","meta","type","docs","description","category","recommended","url","fixable","schema","definitions","basicConfig","oneOf","enum","properties","multiline","minItems","minimum","additionalProperties","items","$ref","ArrayExpression","ArrayPattern","minProperties","messages","unexpectedLineBreak","missingLineBreak","create","context","sourceCode","getSourceCode","normalizeOptionValue","providedOption","consistent","option","Number","POSITIVE_INFINITY","Boolean","normalizeOptions","options","expressionOptions","patternOptions","value","reportNoLineBreak","token","tokenBefore","getTokenBefore","includeComments","report","loc","start","end","messageId","fix","fixer","isCommentToken","isTokenOnSameLine","replaceTextRange","range","twoTokensBefore","reportRequiredLineBreak","check","node","elements","normalizedOptions","elementBreak","filter","element","some","line","linebreaksCount","map","i","previousElement","commaToken","getFirstTokenBetween","isCommaToken","lastTokenOfPreviousElement","firstTokenOfCurrentElement","getTokenAfter","isBreak","length","needsLinebreaks","forEach"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/array-element-newline.js"],"sourcesContent":["/**\n * @fileoverview Rule to enforce line breaks after each array element\n * @author Jan Peer Stöcklmair <https://github.com/JPeer264>\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce line breaks after each array element\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/array-element-newline\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: {\n            definitions: {\n                basicConfig: {\n                    oneOf: [\n                        {\n                            enum: [\"always\", \"never\", \"consistent\"]\n                        },\n                        {\n                            type: \"object\",\n                            properties: {\n                                multiline: {\n                                    type: \"boolean\"\n                                },\n                                minItems: {\n                                    type: [\"integer\", \"null\"],\n                                    minimum: 0\n                                }\n                            },\n                            additionalProperties: false\n                        }\n                    ]\n                }\n            },\n            items: [\n                {\n                    oneOf: [\n                        {\n                            $ref: \"#/definitions/basicConfig\"\n                        },\n                        {\n                            type: \"object\",\n                            properties: {\n                                ArrayExpression: {\n                                    $ref: \"#/definitions/basicConfig\"\n                                },\n                                ArrayPattern: {\n                                    $ref: \"#/definitions/basicConfig\"\n                                }\n                            },\n                            additionalProperties: false,\n                            minProperties: 1\n                        }\n                    ]\n                }\n            ]\n        },\n\n        messages: {\n            unexpectedLineBreak: \"There should be no linebreak here.\",\n            missingLineBreak: \"There should be a linebreak after this element.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        //----------------------------------------------------------------------\n        // Helpers\n        //----------------------------------------------------------------------\n\n        /**\n         * Normalizes a given option value.\n         * @param {string|Object|undefined} providedOption An option value to parse.\n         * @returns {{multiline: boolean, minItems: number}} Normalized option object.\n         */\n        function normalizeOptionValue(providedOption) {\n            let consistent = false;\n            let multiline = false;\n            let minItems;\n\n            const option = providedOption || \"always\";\n\n            if (!option || option === \"always\" || option.minItems === 0) {\n                minItems = 0;\n            } else if (option === \"never\") {\n                minItems = Number.POSITIVE_INFINITY;\n            } else if (option === \"consistent\") {\n                consistent = true;\n                minItems = Number.POSITIVE_INFINITY;\n            } else {\n                multiline = Boolean(option.multiline);\n                minItems = option.minItems || Number.POSITIVE_INFINITY;\n            }\n\n            return { consistent, multiline, minItems };\n        }\n\n        /**\n         * Normalizes a given option value.\n         * @param {string|Object|undefined} options An option value to parse.\n         * @returns {{ArrayExpression: {multiline: boolean, minItems: number}, ArrayPattern: {multiline: boolean, minItems: number}}} Normalized option object.\n         */\n        function normalizeOptions(options) {\n            if (options && (options.ArrayExpression || options.ArrayPattern)) {\n                let expressionOptions, patternOptions;\n\n                if (options.ArrayExpression) {\n                    expressionOptions = normalizeOptionValue(options.ArrayExpression);\n                }\n\n                if (options.ArrayPattern) {\n                    patternOptions = normalizeOptionValue(options.ArrayPattern);\n                }\n\n                return { ArrayExpression: expressionOptions, ArrayPattern: patternOptions };\n            }\n\n            const value = normalizeOptionValue(options);\n\n            return { ArrayExpression: value, ArrayPattern: value };\n        }\n\n        /**\n         * Reports that there shouldn't be a line break after the first token\n         * @param {Token} token The token to use for the report.\n         * @returns {void}\n         */\n        function reportNoLineBreak(token) {\n            const tokenBefore = sourceCode.getTokenBefore(token, { includeComments: true });\n\n            context.report({\n                loc: {\n                    start: tokenBefore.loc.end,\n                    end: token.loc.start\n                },\n                messageId: \"unexpectedLineBreak\",\n                fix(fixer) {\n                    if (astUtils.isCommentToken(tokenBefore)) {\n                        return null;\n                    }\n\n                    if (!astUtils.isTokenOnSameLine(tokenBefore, token)) {\n                        return fixer.replaceTextRange([tokenBefore.range[1], token.range[0]], \" \");\n                    }\n\n                    /*\n                     * This will check if the comma is on the same line as the next element\n                     * Following array:\n                     * [\n                     *     1\n                     *     , 2\n                     *     , 3\n                     * ]\n                     *\n                     * will be fixed to:\n                     * [\n                     *     1, 2, 3\n                     * ]\n                     */\n                    const twoTokensBefore = sourceCode.getTokenBefore(tokenBefore, { includeComments: true });\n\n                    if (astUtils.isCommentToken(twoTokensBefore)) {\n                        return null;\n                    }\n\n                    return fixer.replaceTextRange([twoTokensBefore.range[1], tokenBefore.range[0]], \"\");\n\n                }\n            });\n        }\n\n        /**\n         * Reports that there should be a line break after the first token\n         * @param {Token} token The token to use for the report.\n         * @returns {void}\n         */\n        function reportRequiredLineBreak(token) {\n            const tokenBefore = sourceCode.getTokenBefore(token, { includeComments: true });\n\n            context.report({\n                loc: {\n                    start: tokenBefore.loc.end,\n                    end: token.loc.start\n                },\n                messageId: \"missingLineBreak\",\n                fix(fixer) {\n                    return fixer.replaceTextRange([tokenBefore.range[1], token.range[0]], \"\\n\");\n                }\n            });\n        }\n\n        /**\n         * Reports a given node if it violated this rule.\n         * @param {ASTNode} node A node to check. This is an ObjectExpression node or an ObjectPattern node.\n         * @returns {void}\n         */\n        function check(node) {\n            const elements = node.elements;\n            const normalizedOptions = normalizeOptions(context.options[0]);\n            const options = normalizedOptions[node.type];\n\n            if (!options) {\n                return;\n            }\n\n            let elementBreak = false;\n\n            /*\n             * MULTILINE: true\n             * loop through every element and check\n             * if at least one element has linebreaks inside\n             * this ensures that following is not valid (due to elements are on the same line):\n             *\n             * [\n             *      1,\n             *      2,\n             *      3\n             * ]\n             */\n            if (options.multiline) {\n                elementBreak = elements\n                    .filter(element => element !== null)\n                    .some(element => element.loc.start.line !== element.loc.end.line);\n            }\n\n            const linebreaksCount = node.elements.map((element, i) => {\n                const previousElement = elements[i - 1];\n\n                if (i === 0 || element === null || previousElement === null) {\n                    return false;\n                }\n\n                const commaToken = sourceCode.getFirstTokenBetween(previousElement, element, astUtils.isCommaToken);\n                const lastTokenOfPreviousElement = sourceCode.getTokenBefore(commaToken);\n                const firstTokenOfCurrentElement = sourceCode.getTokenAfter(commaToken);\n\n                return !astUtils.isTokenOnSameLine(lastTokenOfPreviousElement, firstTokenOfCurrentElement);\n            }).filter(isBreak => isBreak === true).length;\n\n            const needsLinebreaks = (\n                elements.length >= options.minItems ||\n                (\n                    options.multiline &&\n                    elementBreak\n                ) ||\n                (\n                    options.consistent &&\n                    linebreaksCount > 0 &&\n                    linebreaksCount < node.elements.length\n                )\n            );\n\n            elements.forEach((element, i) => {\n                const previousElement = elements[i - 1];\n\n                if (i === 0 || element === null || previousElement === null) {\n                    return;\n                }\n\n                const commaToken = sourceCode.getFirstTokenBetween(previousElement, element, astUtils.isCommaToken);\n                const lastTokenOfPreviousElement = sourceCode.getTokenBefore(commaToken);\n                const firstTokenOfCurrentElement = sourceCode.getTokenAfter(commaToken);\n\n                if (needsLinebreaks) {\n                    if (astUtils.isTokenOnSameLine(lastTokenOfPreviousElement, firstTokenOfCurrentElement)) {\n                        reportRequiredLineBreak(firstTokenOfCurrentElement);\n                    }\n                } else {\n                    if (!astUtils.isTokenOnSameLine(lastTokenOfPreviousElement, firstTokenOfCurrentElement)) {\n                        reportNoLineBreak(firstTokenOfCurrentElement);\n                    }\n                }\n            });\n        }\n\n        //----------------------------------------------------------------------\n        // Public\n        //----------------------------------------------------------------------\n\n        return {\n            ArrayPattern: check,\n            ArrayExpression: check\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}