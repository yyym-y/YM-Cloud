{"ast":null,"code":"/**\n * @fileoverview Rule to enforce line breaks between arguments of a function call\n * @author Alexey Gonchar <https://github.com/finico>\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce line breaks between arguments of a function call\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/function-call-argument-newline\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      enum: [\"always\", \"never\", \"consistent\"]\n    }],\n    messages: {\n      unexpectedLineBreak: \"There should be no line break here.\",\n      missingLineBreak: \"There should be a line break after this argument.\"\n    }\n  },\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const checkers = {\n      unexpected: {\n        messageId: \"unexpectedLineBreak\",\n        check: (prevToken, currentToken) => prevToken.loc.end.line !== currentToken.loc.start.line,\n        createFix: (token, tokenBefore) => fixer => fixer.replaceTextRange([tokenBefore.range[1], token.range[0]], \" \")\n      },\n      missing: {\n        messageId: \"missingLineBreak\",\n        check: (prevToken, currentToken) => prevToken.loc.end.line === currentToken.loc.start.line,\n        createFix: (token, tokenBefore) => fixer => fixer.replaceTextRange([tokenBefore.range[1], token.range[0]], \"\\n\")\n      }\n    };\n\n    /**\n     * Check all arguments for line breaks in the CallExpression\n     * @param {CallExpression} node node to evaluate\n     * @param {{ messageId: string, check: Function }} checker selected checker\n     * @returns {void}\n     * @private\n     */\n    function checkArguments(node, checker) {\n      for (let i = 1; i < node.arguments.length; i++) {\n        const prevArgToken = sourceCode.getLastToken(node.arguments[i - 1]);\n        const currentArgToken = sourceCode.getFirstToken(node.arguments[i]);\n        if (checker.check(prevArgToken, currentArgToken)) {\n          const tokenBefore = sourceCode.getTokenBefore(currentArgToken, {\n            includeComments: true\n          });\n          const hasLineCommentBefore = tokenBefore.type === \"Line\";\n          context.report({\n            node,\n            loc: {\n              start: tokenBefore.loc.end,\n              end: currentArgToken.loc.start\n            },\n            messageId: checker.messageId,\n            fix: hasLineCommentBefore ? null : checker.createFix(currentArgToken, tokenBefore)\n          });\n        }\n      }\n    }\n\n    /**\n     * Check if open space is present in a function name\n     * @param {CallExpression} node node to evaluate\n     * @returns {void}\n     * @private\n     */\n    function check(node) {\n      if (node.arguments.length < 2) {\n        return;\n      }\n      const option = context.options[0] || \"always\";\n      if (option === \"never\") {\n        checkArguments(node, checkers.unexpected);\n      } else if (option === \"always\") {\n        checkArguments(node, checkers.missing);\n      } else if (option === \"consistent\") {\n        const firstArgToken = sourceCode.getLastToken(node.arguments[0]);\n        const secondArgToken = sourceCode.getFirstToken(node.arguments[1]);\n        if (firstArgToken.loc.end.line === secondArgToken.loc.start.line) {\n          checkArguments(node, checkers.unexpected);\n        } else {\n          checkArguments(node, checkers.missing);\n        }\n      }\n    }\n    return {\n      CallExpression: check,\n      NewExpression: check\n    };\n  }\n};","map":{"version":3,"names":["module","exports","meta","type","docs","description","category","recommended","url","fixable","schema","enum","messages","unexpectedLineBreak","missingLineBreak","create","context","sourceCode","getSourceCode","checkers","unexpected","messageId","check","prevToken","currentToken","loc","end","line","start","createFix","token","tokenBefore","fixer","replaceTextRange","range","missing","checkArguments","node","checker","i","arguments","length","prevArgToken","getLastToken","currentArgToken","getFirstToken","getTokenBefore","includeComments","hasLineCommentBefore","report","fix","option","options","firstArgToken","secondArgToken","CallExpression","NewExpression"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/function-call-argument-newline.js"],"sourcesContent":["/**\n * @fileoverview Rule to enforce line breaks between arguments of a function call\n * @author Alexey Gonchar <https://github.com/finico>\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce line breaks between arguments of a function call\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/function-call-argument-newline\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                enum: [\"always\", \"never\", \"consistent\"]\n            }\n        ],\n\n        messages: {\n            unexpectedLineBreak: \"There should be no line break here.\",\n            missingLineBreak: \"There should be a line break after this argument.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        const checkers = {\n            unexpected: {\n                messageId: \"unexpectedLineBreak\",\n                check: (prevToken, currentToken) => prevToken.loc.end.line !== currentToken.loc.start.line,\n                createFix: (token, tokenBefore) => fixer =>\n                    fixer.replaceTextRange([tokenBefore.range[1], token.range[0]], \" \")\n            },\n            missing: {\n                messageId: \"missingLineBreak\",\n                check: (prevToken, currentToken) => prevToken.loc.end.line === currentToken.loc.start.line,\n                createFix: (token, tokenBefore) => fixer =>\n                    fixer.replaceTextRange([tokenBefore.range[1], token.range[0]], \"\\n\")\n            }\n        };\n\n        /**\n         * Check all arguments for line breaks in the CallExpression\n         * @param {CallExpression} node node to evaluate\n         * @param {{ messageId: string, check: Function }} checker selected checker\n         * @returns {void}\n         * @private\n         */\n        function checkArguments(node, checker) {\n            for (let i = 1; i < node.arguments.length; i++) {\n                const prevArgToken = sourceCode.getLastToken(node.arguments[i - 1]);\n                const currentArgToken = sourceCode.getFirstToken(node.arguments[i]);\n\n                if (checker.check(prevArgToken, currentArgToken)) {\n                    const tokenBefore = sourceCode.getTokenBefore(\n                        currentArgToken,\n                        { includeComments: true }\n                    );\n\n                    const hasLineCommentBefore = tokenBefore.type === \"Line\";\n\n                    context.report({\n                        node,\n                        loc: {\n                            start: tokenBefore.loc.end,\n                            end: currentArgToken.loc.start\n                        },\n                        messageId: checker.messageId,\n                        fix: hasLineCommentBefore ? null : checker.createFix(currentArgToken, tokenBefore)\n                    });\n                }\n            }\n        }\n\n        /**\n         * Check if open space is present in a function name\n         * @param {CallExpression} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function check(node) {\n            if (node.arguments.length < 2) {\n                return;\n            }\n\n            const option = context.options[0] || \"always\";\n\n            if (option === \"never\") {\n                checkArguments(node, checkers.unexpected);\n            } else if (option === \"always\") {\n                checkArguments(node, checkers.missing);\n            } else if (option === \"consistent\") {\n                const firstArgToken = sourceCode.getLastToken(node.arguments[0]);\n                const secondArgToken = sourceCode.getFirstToken(node.arguments[1]);\n\n                if (firstArgToken.loc.end.line === secondArgToken.loc.start.line) {\n                    checkArguments(node, checkers.unexpected);\n                } else {\n                    checkArguments(node, checkers.missing);\n                }\n            }\n        }\n\n        return {\n            CallExpression: check,\n            NewExpression: check\n        };\n    }\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA,YAAY;;AAEZ;AACA;AACA;AAEAA,MAAM,CAACC,OAAO,GAAG;EACbC,IAAI,EAAE;IACFC,IAAI,EAAE,QAAQ;IAEdC,IAAI,EAAE;MACFC,WAAW,EAAE,0DAA0D;MACvEC,QAAQ,EAAE,kBAAkB;MAC5BC,WAAW,EAAE,KAAK;MAClBC,GAAG,EAAE;IACT,CAAC;IAEDC,OAAO,EAAE,YAAY;IAErBC,MAAM,EAAE,CACJ;MACIC,IAAI,EAAE,CAAC,QAAQ,EAAE,OAAO,EAAE,YAAY;IAC1C,CAAC,CACJ;IAEDC,QAAQ,EAAE;MACNC,mBAAmB,EAAE,qCAAqC;MAC1DC,gBAAgB,EAAE;IACtB;EACJ,CAAC;EAEDC,MAAMA,CAACC,OAAO,EAAE;IACZ,MAAMC,UAAU,GAAGD,OAAO,CAACE,aAAa,CAAC,CAAC;IAE1C,MAAMC,QAAQ,GAAG;MACbC,UAAU,EAAE;QACRC,SAAS,EAAE,qBAAqB;QAChCC,KAAK,EAAEA,CAACC,SAAS,EAAEC,YAAY,KAAKD,SAAS,CAACE,GAAG,CAACC,GAAG,CAACC,IAAI,KAAKH,YAAY,CAACC,GAAG,CAACG,KAAK,CAACD,IAAI;QAC1FE,SAAS,EAAEA,CAACC,KAAK,EAAEC,WAAW,KAAKC,KAAK,IACpCA,KAAK,CAACC,gBAAgB,CAAC,CAACF,WAAW,CAACG,KAAK,CAAC,CAAC,CAAC,EAAEJ,KAAK,CAACI,KAAK,CAAC,CAAC,CAAC,CAAC,EAAE,GAAG;MAC1E,CAAC;MACDC,OAAO,EAAE;QACLd,SAAS,EAAE,kBAAkB;QAC7BC,KAAK,EAAEA,CAACC,SAAS,EAAEC,YAAY,KAAKD,SAAS,CAACE,GAAG,CAACC,GAAG,CAACC,IAAI,KAAKH,YAAY,CAACC,GAAG,CAACG,KAAK,CAACD,IAAI;QAC1FE,SAAS,EAAEA,CAACC,KAAK,EAAEC,WAAW,KAAKC,KAAK,IACpCA,KAAK,CAACC,gBAAgB,CAAC,CAACF,WAAW,CAACG,KAAK,CAAC,CAAC,CAAC,EAAEJ,KAAK,CAACI,KAAK,CAAC,CAAC,CAAC,CAAC,EAAE,IAAI;MAC3E;IACJ,CAAC;;IAED;AACR;AACA;AACA;AACA;AACA;AACA;IACQ,SAASE,cAAcA,CAACC,IAAI,EAAEC,OAAO,EAAE;MACnC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,IAAI,CAACG,SAAS,CAACC,MAAM,EAAEF,CAAC,EAAE,EAAE;QAC5C,MAAMG,YAAY,GAAGzB,UAAU,CAAC0B,YAAY,CAACN,IAAI,CAACG,SAAS,CAACD,CAAC,GAAG,CAAC,CAAC,CAAC;QACnE,MAAMK,eAAe,GAAG3B,UAAU,CAAC4B,aAAa,CAACR,IAAI,CAACG,SAAS,CAACD,CAAC,CAAC,CAAC;QAEnE,IAAID,OAAO,CAAChB,KAAK,CAACoB,YAAY,EAAEE,eAAe,CAAC,EAAE;UAC9C,MAAMb,WAAW,GAAGd,UAAU,CAAC6B,cAAc,CACzCF,eAAe,EACf;YAAEG,eAAe,EAAE;UAAK,CAC5B,CAAC;UAED,MAAMC,oBAAoB,GAAGjB,WAAW,CAAC5B,IAAI,KAAK,MAAM;UAExDa,OAAO,CAACiC,MAAM,CAAC;YACXZ,IAAI;YACJZ,GAAG,EAAE;cACDG,KAAK,EAAEG,WAAW,CAACN,GAAG,CAACC,GAAG;cAC1BA,GAAG,EAAEkB,eAAe,CAACnB,GAAG,CAACG;YAC7B,CAAC;YACDP,SAAS,EAAEiB,OAAO,CAACjB,SAAS;YAC5B6B,GAAG,EAAEF,oBAAoB,GAAG,IAAI,GAAGV,OAAO,CAACT,SAAS,CAACe,eAAe,EAAEb,WAAW;UACrF,CAAC,CAAC;QACN;MACJ;IACJ;;IAEA;AACR;AACA;AACA;AACA;AACA;IACQ,SAAST,KAAKA,CAACe,IAAI,EAAE;MACjB,IAAIA,IAAI,CAACG,SAAS,CAACC,MAAM,GAAG,CAAC,EAAE;QAC3B;MACJ;MAEA,MAAMU,MAAM,GAAGnC,OAAO,CAACoC,OAAO,CAAC,CAAC,CAAC,IAAI,QAAQ;MAE7C,IAAID,MAAM,KAAK,OAAO,EAAE;QACpBf,cAAc,CAACC,IAAI,EAAElB,QAAQ,CAACC,UAAU,CAAC;MAC7C,CAAC,MAAM,IAAI+B,MAAM,KAAK,QAAQ,EAAE;QAC5Bf,cAAc,CAACC,IAAI,EAAElB,QAAQ,CAACgB,OAAO,CAAC;MAC1C,CAAC,MAAM,IAAIgB,MAAM,KAAK,YAAY,EAAE;QAChC,MAAME,aAAa,GAAGpC,UAAU,CAAC0B,YAAY,CAACN,IAAI,CAACG,SAAS,CAAC,CAAC,CAAC,CAAC;QAChE,MAAMc,cAAc,GAAGrC,UAAU,CAAC4B,aAAa,CAACR,IAAI,CAACG,SAAS,CAAC,CAAC,CAAC,CAAC;QAElE,IAAIa,aAAa,CAAC5B,GAAG,CAACC,GAAG,CAACC,IAAI,KAAK2B,cAAc,CAAC7B,GAAG,CAACG,KAAK,CAACD,IAAI,EAAE;UAC9DS,cAAc,CAACC,IAAI,EAAElB,QAAQ,CAACC,UAAU,CAAC;QAC7C,CAAC,MAAM;UACHgB,cAAc,CAACC,IAAI,EAAElB,QAAQ,CAACgB,OAAO,CAAC;QAC1C;MACJ;IACJ;IAEA,OAAO;MACHoB,cAAc,EAAEjC,KAAK;MACrBkC,aAAa,EAAElC;IACnB,CAAC;EACL;AACJ,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}