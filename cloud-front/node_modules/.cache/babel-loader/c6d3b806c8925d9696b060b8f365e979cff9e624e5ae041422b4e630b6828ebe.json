{"ast":null,"code":"/**\n * @fileoverview Require spaces around infix operators\n * @author Michael Ficarra\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"require spacing around infix operators\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/space-infix-ops\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      type: \"object\",\n      properties: {\n        int32Hint: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      missingSpace: \"Operator '{{operator}}' must be spaced.\"\n    }\n  },\n  create(context) {\n    const int32Hint = context.options[0] ? context.options[0].int32Hint === true : false;\n    const sourceCode = context.getSourceCode();\n\n    /**\n     * Returns the first token which violates the rule\n     * @param {ASTNode} left The left node of the main node\n     * @param {ASTNode} right The right node of the main node\n     * @param {string} op The operator of the main node\n     * @returns {Object} The violator token or null\n     * @private\n     */\n    function getFirstNonSpacedToken(left, right, op) {\n      const operator = sourceCode.getFirstTokenBetween(left, right, token => token.value === op);\n      const prev = sourceCode.getTokenBefore(operator);\n      const next = sourceCode.getTokenAfter(operator);\n      if (!sourceCode.isSpaceBetweenTokens(prev, operator) || !sourceCode.isSpaceBetweenTokens(operator, next)) {\n        return operator;\n      }\n      return null;\n    }\n\n    /**\n     * Reports an AST node as a rule violation\n     * @param {ASTNode} mainNode The node to report\n     * @param {Object} culpritToken The token which has a problem\n     * @returns {void}\n     * @private\n     */\n    function report(mainNode, culpritToken) {\n      context.report({\n        node: mainNode,\n        loc: culpritToken.loc,\n        messageId: \"missingSpace\",\n        data: {\n          operator: culpritToken.value\n        },\n        fix(fixer) {\n          const previousToken = sourceCode.getTokenBefore(culpritToken);\n          const afterToken = sourceCode.getTokenAfter(culpritToken);\n          let fixString = \"\";\n          if (culpritToken.range[0] - previousToken.range[1] === 0) {\n            fixString = \" \";\n          }\n          fixString += culpritToken.value;\n          if (afterToken.range[0] - culpritToken.range[1] === 0) {\n            fixString += \" \";\n          }\n          return fixer.replaceText(culpritToken, fixString);\n        }\n      });\n    }\n\n    /**\n     * Check if the node is binary then report\n     * @param {ASTNode} node node to evaluate\n     * @returns {void}\n     * @private\n     */\n    function checkBinary(node) {\n      const leftNode = node.left.typeAnnotation ? node.left.typeAnnotation : node.left;\n      const rightNode = node.right;\n\n      // search for = in AssignmentPattern nodes\n      const operator = node.operator || \"=\";\n      const nonSpacedNode = getFirstNonSpacedToken(leftNode, rightNode, operator);\n      if (nonSpacedNode) {\n        if (!(int32Hint && sourceCode.getText(node).endsWith(\"|0\"))) {\n          report(node, nonSpacedNode);\n        }\n      }\n    }\n\n    /**\n     * Check if the node is conditional\n     * @param {ASTNode} node node to evaluate\n     * @returns {void}\n     * @private\n     */\n    function checkConditional(node) {\n      const nonSpacedConsequentNode = getFirstNonSpacedToken(node.test, node.consequent, \"?\");\n      const nonSpacedAlternateNode = getFirstNonSpacedToken(node.consequent, node.alternate, \":\");\n      if (nonSpacedConsequentNode) {\n        report(node, nonSpacedConsequentNode);\n      }\n      if (nonSpacedAlternateNode) {\n        report(node, nonSpacedAlternateNode);\n      }\n    }\n\n    /**\n     * Check if the node is a variable\n     * @param {ASTNode} node node to evaluate\n     * @returns {void}\n     * @private\n     */\n    function checkVar(node) {\n      const leftNode = node.id.typeAnnotation ? node.id.typeAnnotation : node.id;\n      const rightNode = node.init;\n      if (rightNode) {\n        const nonSpacedNode = getFirstNonSpacedToken(leftNode, rightNode, \"=\");\n        if (nonSpacedNode) {\n          report(node, nonSpacedNode);\n        }\n      }\n    }\n    return {\n      AssignmentExpression: checkBinary,\n      AssignmentPattern: checkBinary,\n      BinaryExpression: checkBinary,\n      LogicalExpression: checkBinary,\n      ConditionalExpression: checkConditional,\n      VariableDeclarator: checkVar\n    };\n  }\n};","map":{"version":3,"names":["module","exports","meta","type","docs","description","category","recommended","url","fixable","schema","properties","int32Hint","default","additionalProperties","messages","missingSpace","create","context","options","sourceCode","getSourceCode","getFirstNonSpacedToken","left","right","op","operator","getFirstTokenBetween","token","value","prev","getTokenBefore","next","getTokenAfter","isSpaceBetweenTokens","report","mainNode","culpritToken","node","loc","messageId","data","fix","fixer","previousToken","afterToken","fixString","range","replaceText","checkBinary","leftNode","typeAnnotation","rightNode","nonSpacedNode","getText","endsWith","checkConditional","nonSpacedConsequentNode","test","consequent","nonSpacedAlternateNode","alternate","checkVar","id","init","AssignmentExpression","AssignmentPattern","BinaryExpression","LogicalExpression","ConditionalExpression","VariableDeclarator"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/space-infix-ops.js"],"sourcesContent":["/**\n * @fileoverview Require spaces around infix operators\n * @author Michael Ficarra\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"require spacing around infix operators\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/space-infix-ops\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    int32Hint: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            missingSpace: \"Operator '{{operator}}' must be spaced.\"\n        }\n    },\n\n    create(context) {\n        const int32Hint = context.options[0] ? context.options[0].int32Hint === true : false;\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Returns the first token which violates the rule\n         * @param {ASTNode} left The left node of the main node\n         * @param {ASTNode} right The right node of the main node\n         * @param {string} op The operator of the main node\n         * @returns {Object} The violator token or null\n         * @private\n         */\n        function getFirstNonSpacedToken(left, right, op) {\n            const operator = sourceCode.getFirstTokenBetween(left, right, token => token.value === op);\n            const prev = sourceCode.getTokenBefore(operator);\n            const next = sourceCode.getTokenAfter(operator);\n\n            if (!sourceCode.isSpaceBetweenTokens(prev, operator) || !sourceCode.isSpaceBetweenTokens(operator, next)) {\n                return operator;\n            }\n\n            return null;\n        }\n\n        /**\n         * Reports an AST node as a rule violation\n         * @param {ASTNode} mainNode The node to report\n         * @param {Object} culpritToken The token which has a problem\n         * @returns {void}\n         * @private\n         */\n        function report(mainNode, culpritToken) {\n            context.report({\n                node: mainNode,\n                loc: culpritToken.loc,\n                messageId: \"missingSpace\",\n                data: {\n                    operator: culpritToken.value\n                },\n                fix(fixer) {\n                    const previousToken = sourceCode.getTokenBefore(culpritToken);\n                    const afterToken = sourceCode.getTokenAfter(culpritToken);\n                    let fixString = \"\";\n\n                    if (culpritToken.range[0] - previousToken.range[1] === 0) {\n                        fixString = \" \";\n                    }\n\n                    fixString += culpritToken.value;\n\n                    if (afterToken.range[0] - culpritToken.range[1] === 0) {\n                        fixString += \" \";\n                    }\n\n                    return fixer.replaceText(culpritToken, fixString);\n                }\n            });\n        }\n\n        /**\n         * Check if the node is binary then report\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function checkBinary(node) {\n            const leftNode = (node.left.typeAnnotation) ? node.left.typeAnnotation : node.left;\n            const rightNode = node.right;\n\n            // search for = in AssignmentPattern nodes\n            const operator = node.operator || \"=\";\n\n            const nonSpacedNode = getFirstNonSpacedToken(leftNode, rightNode, operator);\n\n            if (nonSpacedNode) {\n                if (!(int32Hint && sourceCode.getText(node).endsWith(\"|0\"))) {\n                    report(node, nonSpacedNode);\n                }\n            }\n        }\n\n        /**\n         * Check if the node is conditional\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function checkConditional(node) {\n            const nonSpacedConsequentNode = getFirstNonSpacedToken(node.test, node.consequent, \"?\");\n            const nonSpacedAlternateNode = getFirstNonSpacedToken(node.consequent, node.alternate, \":\");\n\n            if (nonSpacedConsequentNode) {\n                report(node, nonSpacedConsequentNode);\n            }\n\n            if (nonSpacedAlternateNode) {\n                report(node, nonSpacedAlternateNode);\n            }\n        }\n\n        /**\n         * Check if the node is a variable\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function checkVar(node) {\n            const leftNode = (node.id.typeAnnotation) ? node.id.typeAnnotation : node.id;\n            const rightNode = node.init;\n\n            if (rightNode) {\n                const nonSpacedNode = getFirstNonSpacedToken(leftNode, rightNode, \"=\");\n\n                if (nonSpacedNode) {\n                    report(node, nonSpacedNode);\n                }\n            }\n        }\n\n        return {\n            AssignmentExpression: checkBinary,\n            AssignmentPattern: checkBinary,\n            BinaryExpression: checkBinary,\n            LogicalExpression: checkBinary,\n            ConditionalExpression: checkConditional,\n            VariableDeclarator: checkVar\n        };\n\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}