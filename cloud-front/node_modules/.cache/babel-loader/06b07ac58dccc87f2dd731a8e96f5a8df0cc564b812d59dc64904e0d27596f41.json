{"ast":null,"code":"var path = require('path');\nvar fs = require('fs');\nvar utils = require('./utils');\nvar del = require('./del');\nvar writeJSON = utils.writeJSON;\nvar cache = {\n  /**\n   * Load a cache identified by the given Id. If the element does not exists, then initialize an empty\n   * cache storage. If specified `cacheDir` will be used as the directory to persist the data to. If omitted\n   * then the cache module directory `./cache` will be used instead\n   *\n   * @method load\n   * @param docId {String} the id of the cache, would also be used as the name of the file cache\n   * @param [cacheDir] {String} directory for the cache entry\n   */\n  load: function (docId, cacheDir) {\n    var me = this;\n    me._visited = {};\n    me._persisted = {};\n    me._pathToFile = cacheDir ? path.resolve(cacheDir, docId) : path.resolve(__dirname, '../.cache/', docId);\n    if (fs.existsSync(me._pathToFile)) {\n      me._persisted = utils.tryParse(me._pathToFile, {});\n    }\n  },\n  /**\n   * Load the cache from the provided file\n   * @method loadFile\n   * @param  {String} pathToFile the path to the file containing the info for the cache\n   */\n  loadFile: function (pathToFile) {\n    var me = this;\n    var dir = path.dirname(pathToFile);\n    var fName = path.basename(pathToFile);\n    me.load(fName, dir);\n  },\n  /**\n   * Returns the entire persisted object\n   * @method all\n   * @returns {*}\n   */\n  all: function () {\n    return this._persisted;\n  },\n  keys: function () {\n    return Object.keys(this._persisted);\n  },\n  /**\n   * sets a key to a given value\n   * @method setKey\n   * @param key {string} the key to set\n   * @param value {object} the value of the key. Could be any object that can be serialized with JSON.stringify\n   */\n  setKey: function (key, value) {\n    this._visited[key] = true;\n    this._persisted[key] = value;\n  },\n  /**\n   * remove a given key from the cache\n   * @method removeKey\n   * @param key {String} the key to remove from the object\n   */\n  removeKey: function (key) {\n    delete this._visited[key]; // esfmt-ignore-line\n    delete this._persisted[key]; // esfmt-ignore-line\n  },\n\n  /**\n   * Return the value of the provided key\n   * @method getKey\n   * @param key {String} the name of the key to retrieve\n   * @returns {*} the value from the key\n   */\n  getKey: function (key) {\n    this._visited[key] = true;\n    return this._persisted[key];\n  },\n  /**\n   * Remove keys that were not accessed/set since the\n   * last time the `prune` method was called.\n   * @method _prune\n   * @private\n   */\n  _prune: function () {\n    var me = this;\n    var obj = {};\n    var keys = Object.keys(me._visited);\n\n    // no keys visited for either get or set value\n    if (keys.length === 0) {\n      return;\n    }\n    keys.forEach(function (key) {\n      obj[key] = me._persisted[key];\n    });\n    me._visited = {};\n    me._persisted = obj;\n  },\n  /**\n   * Save the state of the cache identified by the docId to disk\n   * as a JSON structure\n   * @param [noPrune=false] {Boolean} whether to remove from cache the non visited files\n   * @method save\n   */\n  save: function (noPrune) {\n    var me = this;\n    !noPrune && me._prune();\n    writeJSON(me._pathToFile, me._persisted);\n  },\n  /**\n   * remove the file where the cache is persisted\n   * @method removeCacheFile\n   * @return {Boolean} true or false if the file was successfully deleted\n   */\n  removeCacheFile: function () {\n    return del(this._pathToFile);\n  },\n  /**\n   * Destroy the file cache and cache content.\n   * @method destroy\n   */\n  destroy: function () {\n    var me = this;\n    me._visited = {};\n    me._persisted = {};\n    me.removeCacheFile();\n  }\n};\nmodule.exports = {\n  /**\n   * Alias for create. Should be considered depreacted. Will be removed in next releases\n   *\n   * @method load\n   * @param docId {String} the id of the cache, would also be used as the name of the file cache\n   * @param [cacheDir] {String} directory for the cache entry\n   * @returns {cache} cache instance\n   */\n  load: function (docId, cacheDir) {\n    return this.create(docId, cacheDir);\n  },\n  /**\n   * Load a cache identified by the given Id. If the element does not exists, then initialize an empty\n   * cache storage.\n   *\n   * @method create\n   * @param docId {String} the id of the cache, would also be used as the name of the file cache\n   * @param [cacheDir] {String} directory for the cache entry\n   * @returns {cache} cache instance\n   */\n  create: function (docId, cacheDir) {\n    var obj = Object.create(cache);\n    obj.load(docId, cacheDir);\n    return obj;\n  },\n  createFromFile: function (filePath) {\n    var obj = Object.create(cache);\n    obj.loadFile(filePath);\n    return obj;\n  },\n  /**\n   * Clear the cache identified by the given id. Caches stored in a different cache directory can be deleted directly\n   *\n   * @method clearCache\n   * @param docId {String} the id of the cache, would also be used as the name of the file cache\n   * @param cacheDir {String} the directory where the cache file was written\n   * @returns {Boolean} true if the cache folder was deleted. False otherwise\n   */\n  clearCacheById: function (docId, cacheDir) {\n    var filePath = cacheDir ? path.resolve(cacheDir, docId) : path.resolve(__dirname, '../.cache/', docId);\n    return del(filePath);\n  },\n  /**\n   * Remove all cache stored in the cache directory\n   * @method clearAll\n   * @returns {Boolean} true if the cache folder was deleted. False otherwise\n   */\n  clearAll: function (cacheDir) {\n    var filePath = cacheDir ? path.resolve(cacheDir) : path.resolve(__dirname, '../.cache/');\n    return del(filePath);\n  }\n};","map":{"version":3,"names":["path","require","fs","utils","del","writeJSON","cache","load","docId","cacheDir","me","_visited","_persisted","_pathToFile","resolve","__dirname","existsSync","tryParse","loadFile","pathToFile","dir","dirname","fName","basename","all","keys","Object","setKey","key","value","removeKey","getKey","_prune","obj","length","forEach","save","noPrune","removeCacheFile","destroy","module","exports","create","createFromFile","filePath","clearCacheById","clearAll"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/flat-cache/src/cache.js"],"sourcesContent":["var path = require('path');\nvar fs = require('fs');\nvar utils = require('./utils');\nvar del = require('./del');\nvar writeJSON = utils.writeJSON;\n\nvar cache = {\n  /**\n   * Load a cache identified by the given Id. If the element does not exists, then initialize an empty\n   * cache storage. If specified `cacheDir` will be used as the directory to persist the data to. If omitted\n   * then the cache module directory `./cache` will be used instead\n   *\n   * @method load\n   * @param docId {String} the id of the cache, would also be used as the name of the file cache\n   * @param [cacheDir] {String} directory for the cache entry\n   */\n  load: function (docId, cacheDir) {\n    var me = this;\n\n    me._visited = {};\n    me._persisted = {};\n    me._pathToFile = cacheDir ? path.resolve(cacheDir, docId) : path.resolve(__dirname, '../.cache/', docId);\n\n    if (fs.existsSync(me._pathToFile)) {\n      me._persisted = utils.tryParse(me._pathToFile, {});\n    }\n  },\n\n  /**\n   * Load the cache from the provided file\n   * @method loadFile\n   * @param  {String} pathToFile the path to the file containing the info for the cache\n   */\n  loadFile: function (pathToFile) {\n    var me = this;\n    var dir = path.dirname(pathToFile);\n    var fName = path.basename(pathToFile);\n\n    me.load(fName, dir);\n  },\n\n  /**\n   * Returns the entire persisted object\n   * @method all\n   * @returns {*}\n   */\n  all: function () {\n    return this._persisted;\n  },\n\n  keys: function () {\n    return Object.keys(this._persisted);\n  },\n  /**\n   * sets a key to a given value\n   * @method setKey\n   * @param key {string} the key to set\n   * @param value {object} the value of the key. Could be any object that can be serialized with JSON.stringify\n   */\n  setKey: function (key, value) {\n    this._visited[key] = true;\n    this._persisted[key] = value;\n  },\n  /**\n   * remove a given key from the cache\n   * @method removeKey\n   * @param key {String} the key to remove from the object\n   */\n  removeKey: function (key) {\n    delete this._visited[key]; // esfmt-ignore-line\n    delete this._persisted[key]; // esfmt-ignore-line\n  },\n  /**\n   * Return the value of the provided key\n   * @method getKey\n   * @param key {String} the name of the key to retrieve\n   * @returns {*} the value from the key\n   */\n  getKey: function (key) {\n    this._visited[key] = true;\n    return this._persisted[key];\n  },\n\n  /**\n   * Remove keys that were not accessed/set since the\n   * last time the `prune` method was called.\n   * @method _prune\n   * @private\n   */\n  _prune: function () {\n    var me = this;\n    var obj = {};\n\n    var keys = Object.keys(me._visited);\n\n    // no keys visited for either get or set value\n    if (keys.length === 0) {\n      return;\n    }\n\n    keys.forEach(function (key) {\n      obj[key] = me._persisted[key];\n    });\n\n    me._visited = {};\n    me._persisted = obj;\n  },\n\n  /**\n   * Save the state of the cache identified by the docId to disk\n   * as a JSON structure\n   * @param [noPrune=false] {Boolean} whether to remove from cache the non visited files\n   * @method save\n   */\n  save: function (noPrune) {\n    var me = this;\n\n    !noPrune && me._prune();\n    writeJSON(me._pathToFile, me._persisted);\n  },\n\n  /**\n   * remove the file where the cache is persisted\n   * @method removeCacheFile\n   * @return {Boolean} true or false if the file was successfully deleted\n   */\n  removeCacheFile: function () {\n    return del(this._pathToFile);\n  },\n  /**\n   * Destroy the file cache and cache content.\n   * @method destroy\n   */\n  destroy: function () {\n    var me = this;\n    me._visited = {};\n    me._persisted = {};\n\n    me.removeCacheFile();\n  },\n};\n\nmodule.exports = {\n  /**\n   * Alias for create. Should be considered depreacted. Will be removed in next releases\n   *\n   * @method load\n   * @param docId {String} the id of the cache, would also be used as the name of the file cache\n   * @param [cacheDir] {String} directory for the cache entry\n   * @returns {cache} cache instance\n   */\n  load: function (docId, cacheDir) {\n    return this.create(docId, cacheDir);\n  },\n\n  /**\n   * Load a cache identified by the given Id. If the element does not exists, then initialize an empty\n   * cache storage.\n   *\n   * @method create\n   * @param docId {String} the id of the cache, would also be used as the name of the file cache\n   * @param [cacheDir] {String} directory for the cache entry\n   * @returns {cache} cache instance\n   */\n  create: function (docId, cacheDir) {\n    var obj = Object.create(cache);\n    obj.load(docId, cacheDir);\n    return obj;\n  },\n\n  createFromFile: function (filePath) {\n    var obj = Object.create(cache);\n    obj.loadFile(filePath);\n    return obj;\n  },\n  /**\n   * Clear the cache identified by the given id. Caches stored in a different cache directory can be deleted directly\n   *\n   * @method clearCache\n   * @param docId {String} the id of the cache, would also be used as the name of the file cache\n   * @param cacheDir {String} the directory where the cache file was written\n   * @returns {Boolean} true if the cache folder was deleted. False otherwise\n   */\n  clearCacheById: function (docId, cacheDir) {\n    var filePath = cacheDir ? path.resolve(cacheDir, docId) : path.resolve(__dirname, '../.cache/', docId);\n    return del(filePath);\n  },\n  /**\n   * Remove all cache stored in the cache directory\n   * @method clearAll\n   * @returns {Boolean} true if the cache folder was deleted. False otherwise\n   */\n  clearAll: function (cacheDir) {\n    var filePath = cacheDir ? path.resolve(cacheDir) : path.resolve(__dirname, '../.cache/');\n    return del(filePath);\n  },\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}