{"ast":null,"code":"/**\n * @fileoverview Prefer destructuring from arrays and objects\n * @author Alex LaFroscia\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst PRECEDENCE_OF_ASSIGNMENT_EXPR = astUtils.getPrecedence({\n  type: \"AssignmentExpression\"\n});\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require destructuring from arrays and/or objects\",\n      category: \"ECMAScript 6\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/prefer-destructuring\"\n    },\n    fixable: \"code\",\n    schema: [{\n      /*\n       * old support {array: Boolean, object: Boolean}\n       * new support {VariableDeclarator: {}, AssignmentExpression: {}}\n       */\n      oneOf: [{\n        type: \"object\",\n        properties: {\n          VariableDeclarator: {\n            type: \"object\",\n            properties: {\n              array: {\n                type: \"boolean\"\n              },\n              object: {\n                type: \"boolean\"\n              }\n            },\n            additionalProperties: false\n          },\n          AssignmentExpression: {\n            type: \"object\",\n            properties: {\n              array: {\n                type: \"boolean\"\n              },\n              object: {\n                type: \"boolean\"\n              }\n            },\n            additionalProperties: false\n          }\n        },\n        additionalProperties: false\n      }, {\n        type: \"object\",\n        properties: {\n          array: {\n            type: \"boolean\"\n          },\n          object: {\n            type: \"boolean\"\n          }\n        },\n        additionalProperties: false\n      }]\n    }, {\n      type: \"object\",\n      properties: {\n        enforceForRenamedProperties: {\n          type: \"boolean\"\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      preferDestructuring: \"Use {{type}} destructuring.\"\n    }\n  },\n  create(context) {\n    const enabledTypes = context.options[0];\n    const enforceForRenamedProperties = context.options[1] && context.options[1].enforceForRenamedProperties;\n    let normalizedOptions = {\n      VariableDeclarator: {\n        array: true,\n        object: true\n      },\n      AssignmentExpression: {\n        array: true,\n        object: true\n      }\n    };\n    if (enabledTypes) {\n      normalizedOptions = typeof enabledTypes.array !== \"undefined\" || typeof enabledTypes.object !== \"undefined\" ? {\n        VariableDeclarator: enabledTypes,\n        AssignmentExpression: enabledTypes\n      } : enabledTypes;\n    }\n\n    //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    // eslint-disable-next-line jsdoc/require-description\n    /**\n     * @param {string} nodeType \"AssignmentExpression\" or \"VariableDeclarator\"\n     * @param {string} destructuringType \"array\" or \"object\"\n     * @returns {boolean} `true` if the destructuring type should be checked for the given node\n     */\n    function shouldCheck(nodeType, destructuringType) {\n      return normalizedOptions && normalizedOptions[nodeType] && normalizedOptions[nodeType][destructuringType];\n    }\n\n    /**\n     * Determines if the given node is accessing an array index\n     *\n     * This is used to differentiate array index access from object property\n     * access.\n     * @param {ASTNode} node the node to evaluate\n     * @returns {boolean} whether or not the node is an integer\n     */\n    function isArrayIndexAccess(node) {\n      return Number.isInteger(node.property.value);\n    }\n\n    /**\n     * Report that the given node should use destructuring\n     * @param {ASTNode} reportNode the node to report\n     * @param {string} type the type of destructuring that should have been done\n     * @param {Function|null} fix the fix function or null to pass to context.report\n     * @returns {void}\n     */\n    function report(reportNode, type, fix) {\n      context.report({\n        node: reportNode,\n        messageId: \"preferDestructuring\",\n        data: {\n          type\n        },\n        fix\n      });\n    }\n\n    /**\n     * Determines if a node should be fixed into object destructuring\n     *\n     * The fixer only fixes the simplest case of object destructuring,\n     * like: `let x = a.x`;\n     *\n     * Assignment expression is not fixed.\n     * Array destructuring is not fixed.\n     * Renamed property is not fixed.\n     * @param {ASTNode} node the node to evaluate\n     * @returns {boolean} whether or not the node should be fixed\n     */\n    function shouldFix(node) {\n      return node.type === \"VariableDeclarator\" && node.id.type === \"Identifier\" && node.init.type === \"MemberExpression\" && !node.init.computed && node.init.property.type === \"Identifier\" && node.id.name === node.init.property.name;\n    }\n\n    /**\n     * Fix a node into object destructuring.\n     * This function only handles the simplest case of object destructuring,\n     * see {@link shouldFix}.\n     * @param {SourceCodeFixer} fixer the fixer object\n     * @param {ASTNode} node the node to be fixed.\n     * @returns {Object} a fix for the node\n     */\n    function fixIntoObjectDestructuring(fixer, node) {\n      const rightNode = node.init;\n      const sourceCode = context.getSourceCode();\n\n      // Don't fix if that would remove any comments. Only comments inside `rightNode.object` can be preserved.\n      if (sourceCode.getCommentsInside(node).length > sourceCode.getCommentsInside(rightNode.object).length) {\n        return null;\n      }\n      let objectText = sourceCode.getText(rightNode.object);\n      if (astUtils.getPrecedence(rightNode.object) < PRECEDENCE_OF_ASSIGNMENT_EXPR) {\n        objectText = `(${objectText})`;\n      }\n      return fixer.replaceText(node, `{${rightNode.property.name}} = ${objectText}`);\n    }\n\n    /**\n     * Check that the `prefer-destructuring` rules are followed based on the\n     * given left- and right-hand side of the assignment.\n     *\n     * Pulled out into a separate method so that VariableDeclarators and\n     * AssignmentExpressions can share the same verification logic.\n     * @param {ASTNode} leftNode the left-hand side of the assignment\n     * @param {ASTNode} rightNode the right-hand side of the assignment\n     * @param {ASTNode} reportNode the node to report the error on\n     * @returns {void}\n     */\n    function performCheck(leftNode, rightNode, reportNode) {\n      if (rightNode.type !== \"MemberExpression\" || rightNode.object.type === \"Super\") {\n        return;\n      }\n      if (isArrayIndexAccess(rightNode)) {\n        if (shouldCheck(reportNode.type, \"array\")) {\n          report(reportNode, \"array\", null);\n        }\n        return;\n      }\n      const fix = shouldFix(reportNode) ? fixer => fixIntoObjectDestructuring(fixer, reportNode) : null;\n      if (shouldCheck(reportNode.type, \"object\") && enforceForRenamedProperties) {\n        report(reportNode, \"object\", fix);\n        return;\n      }\n      if (shouldCheck(reportNode.type, \"object\")) {\n        const property = rightNode.property;\n        if (property.type === \"Literal\" && leftNode.name === property.value || property.type === \"Identifier\" && leftNode.name === property.name && !rightNode.computed) {\n          report(reportNode, \"object\", fix);\n        }\n      }\n    }\n\n    /**\n     * Check if a given variable declarator is coming from an property access\n     * that should be using destructuring instead\n     * @param {ASTNode} node the variable declarator to check\n     * @returns {void}\n     */\n    function checkVariableDeclarator(node) {\n      // Skip if variable is declared without assignment\n      if (!node.init) {\n        return;\n      }\n\n      // We only care about member expressions past this point\n      if (node.init.type !== \"MemberExpression\") {\n        return;\n      }\n      performCheck(node.id, node.init, node);\n    }\n\n    /**\n     * Run the `prefer-destructuring` check on an AssignmentExpression\n     * @param {ASTNode} node the AssignmentExpression node\n     * @returns {void}\n     */\n    function checkAssignmentExpression(node) {\n      if (node.operator === \"=\") {\n        performCheck(node.left, node.right, node);\n      }\n    }\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    return {\n      VariableDeclarator: checkVariableDeclarator,\n      AssignmentExpression: checkAssignmentExpression\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","PRECEDENCE_OF_ASSIGNMENT_EXPR","getPrecedence","type","module","exports","meta","docs","description","category","recommended","url","fixable","schema","oneOf","properties","VariableDeclarator","array","object","additionalProperties","AssignmentExpression","enforceForRenamedProperties","messages","preferDestructuring","create","context","enabledTypes","options","normalizedOptions","shouldCheck","nodeType","destructuringType","isArrayIndexAccess","node","Number","isInteger","property","value","report","reportNode","fix","messageId","data","shouldFix","id","init","computed","name","fixIntoObjectDestructuring","fixer","rightNode","sourceCode","getSourceCode","getCommentsInside","length","objectText","getText","replaceText","performCheck","leftNode","checkVariableDeclarator","checkAssignmentExpression","operator","left","right"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/prefer-destructuring.js"],"sourcesContent":["/**\n * @fileoverview Prefer destructuring from arrays and objects\n * @author Alex LaFroscia\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst PRECEDENCE_OF_ASSIGNMENT_EXPR = astUtils.getPrecedence({ type: \"AssignmentExpression\" });\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require destructuring from arrays and/or objects\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/prefer-destructuring\"\n        },\n\n        fixable: \"code\",\n\n        schema: [\n            {\n\n                /*\n                 * old support {array: Boolean, object: Boolean}\n                 * new support {VariableDeclarator: {}, AssignmentExpression: {}}\n                 */\n                oneOf: [\n                    {\n                        type: \"object\",\n                        properties: {\n                            VariableDeclarator: {\n                                type: \"object\",\n                                properties: {\n                                    array: {\n                                        type: \"boolean\"\n                                    },\n                                    object: {\n                                        type: \"boolean\"\n                                    }\n                                },\n                                additionalProperties: false\n                            },\n                            AssignmentExpression: {\n                                type: \"object\",\n                                properties: {\n                                    array: {\n                                        type: \"boolean\"\n                                    },\n                                    object: {\n                                        type: \"boolean\"\n                                    }\n                                },\n                                additionalProperties: false\n                            }\n                        },\n                        additionalProperties: false\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            array: {\n                                type: \"boolean\"\n                            },\n                            object: {\n                                type: \"boolean\"\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    enforceForRenamedProperties: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            preferDestructuring: \"Use {{type}} destructuring.\"\n        }\n    },\n    create(context) {\n\n        const enabledTypes = context.options[0];\n        const enforceForRenamedProperties = context.options[1] && context.options[1].enforceForRenamedProperties;\n        let normalizedOptions = {\n            VariableDeclarator: { array: true, object: true },\n            AssignmentExpression: { array: true, object: true }\n        };\n\n        if (enabledTypes) {\n            normalizedOptions = typeof enabledTypes.array !== \"undefined\" || typeof enabledTypes.object !== \"undefined\"\n                ? { VariableDeclarator: enabledTypes, AssignmentExpression: enabledTypes }\n                : enabledTypes;\n        }\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        // eslint-disable-next-line jsdoc/require-description\n        /**\n         * @param {string} nodeType \"AssignmentExpression\" or \"VariableDeclarator\"\n         * @param {string} destructuringType \"array\" or \"object\"\n         * @returns {boolean} `true` if the destructuring type should be checked for the given node\n         */\n        function shouldCheck(nodeType, destructuringType) {\n            return normalizedOptions &&\n                normalizedOptions[nodeType] &&\n                normalizedOptions[nodeType][destructuringType];\n        }\n\n        /**\n         * Determines if the given node is accessing an array index\n         *\n         * This is used to differentiate array index access from object property\n         * access.\n         * @param {ASTNode} node the node to evaluate\n         * @returns {boolean} whether or not the node is an integer\n         */\n        function isArrayIndexAccess(node) {\n            return Number.isInteger(node.property.value);\n        }\n\n        /**\n         * Report that the given node should use destructuring\n         * @param {ASTNode} reportNode the node to report\n         * @param {string} type the type of destructuring that should have been done\n         * @param {Function|null} fix the fix function or null to pass to context.report\n         * @returns {void}\n         */\n        function report(reportNode, type, fix) {\n            context.report({\n                node: reportNode,\n                messageId: \"preferDestructuring\",\n                data: { type },\n                fix\n            });\n        }\n\n        /**\n         * Determines if a node should be fixed into object destructuring\n         *\n         * The fixer only fixes the simplest case of object destructuring,\n         * like: `let x = a.x`;\n         *\n         * Assignment expression is not fixed.\n         * Array destructuring is not fixed.\n         * Renamed property is not fixed.\n         * @param {ASTNode} node the node to evaluate\n         * @returns {boolean} whether or not the node should be fixed\n         */\n        function shouldFix(node) {\n            return node.type === \"VariableDeclarator\" &&\n                node.id.type === \"Identifier\" &&\n                node.init.type === \"MemberExpression\" &&\n                !node.init.computed &&\n                node.init.property.type === \"Identifier\" &&\n                node.id.name === node.init.property.name;\n        }\n\n        /**\n         * Fix a node into object destructuring.\n         * This function only handles the simplest case of object destructuring,\n         * see {@link shouldFix}.\n         * @param {SourceCodeFixer} fixer the fixer object\n         * @param {ASTNode} node the node to be fixed.\n         * @returns {Object} a fix for the node\n         */\n        function fixIntoObjectDestructuring(fixer, node) {\n            const rightNode = node.init;\n            const sourceCode = context.getSourceCode();\n\n            // Don't fix if that would remove any comments. Only comments inside `rightNode.object` can be preserved.\n            if (sourceCode.getCommentsInside(node).length > sourceCode.getCommentsInside(rightNode.object).length) {\n                return null;\n            }\n\n            let objectText = sourceCode.getText(rightNode.object);\n\n            if (astUtils.getPrecedence(rightNode.object) < PRECEDENCE_OF_ASSIGNMENT_EXPR) {\n                objectText = `(${objectText})`;\n            }\n\n            return fixer.replaceText(\n                node,\n                `{${rightNode.property.name}} = ${objectText}`\n            );\n        }\n\n        /**\n         * Check that the `prefer-destructuring` rules are followed based on the\n         * given left- and right-hand side of the assignment.\n         *\n         * Pulled out into a separate method so that VariableDeclarators and\n         * AssignmentExpressions can share the same verification logic.\n         * @param {ASTNode} leftNode the left-hand side of the assignment\n         * @param {ASTNode} rightNode the right-hand side of the assignment\n         * @param {ASTNode} reportNode the node to report the error on\n         * @returns {void}\n         */\n        function performCheck(leftNode, rightNode, reportNode) {\n            if (rightNode.type !== \"MemberExpression\" || rightNode.object.type === \"Super\") {\n                return;\n            }\n\n            if (isArrayIndexAccess(rightNode)) {\n                if (shouldCheck(reportNode.type, \"array\")) {\n                    report(reportNode, \"array\", null);\n                }\n                return;\n            }\n\n            const fix = shouldFix(reportNode)\n                ? fixer => fixIntoObjectDestructuring(fixer, reportNode)\n                : null;\n\n            if (shouldCheck(reportNode.type, \"object\") && enforceForRenamedProperties) {\n                report(reportNode, \"object\", fix);\n                return;\n            }\n\n            if (shouldCheck(reportNode.type, \"object\")) {\n                const property = rightNode.property;\n\n                if (\n                    (property.type === \"Literal\" && leftNode.name === property.value) ||\n                    (property.type === \"Identifier\" && leftNode.name === property.name && !rightNode.computed)\n                ) {\n                    report(reportNode, \"object\", fix);\n                }\n            }\n        }\n\n        /**\n         * Check if a given variable declarator is coming from an property access\n         * that should be using destructuring instead\n         * @param {ASTNode} node the variable declarator to check\n         * @returns {void}\n         */\n        function checkVariableDeclarator(node) {\n\n            // Skip if variable is declared without assignment\n            if (!node.init) {\n                return;\n            }\n\n            // We only care about member expressions past this point\n            if (node.init.type !== \"MemberExpression\") {\n                return;\n            }\n\n            performCheck(node.id, node.init, node);\n        }\n\n        /**\n         * Run the `prefer-destructuring` check on an AssignmentExpression\n         * @param {ASTNode} node the AssignmentExpression node\n         * @returns {void}\n         */\n        function checkAssignmentExpression(node) {\n            if (node.operator === \"=\") {\n                performCheck(node.left, node.right, node);\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            VariableDeclarator: checkVariableDeclarator,\n            AssignmentExpression: checkAssignmentExpression\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}