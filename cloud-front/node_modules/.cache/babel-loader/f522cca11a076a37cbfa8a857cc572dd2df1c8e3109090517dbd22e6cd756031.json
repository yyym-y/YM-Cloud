{"ast":null,"code":"/**\n * @fileoverview Rule to disallow loops with a body that allows only one iteration\n * @author Milos Djermanovic\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\nconst allLoopTypes = [\"WhileStatement\", \"DoWhileStatement\", \"ForStatement\", \"ForInStatement\", \"ForOfStatement\"];\n\n/**\n * Determines whether the given node is the first node in the code path to which a loop statement\n * 'loops' for the next iteration.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} `true` if the node is a looping target.\n */\nfunction isLoopingTarget(node) {\n  const parent = node.parent;\n  if (parent) {\n    switch (parent.type) {\n      case \"WhileStatement\":\n        return node === parent.test;\n      case \"DoWhileStatement\":\n        return node === parent.body;\n      case \"ForStatement\":\n        return node === (parent.update || parent.test || parent.body);\n      case \"ForInStatement\":\n      case \"ForOfStatement\":\n        return node === parent.left;\n\n      // no default\n    }\n  }\n\n  return false;\n}\n\n/**\n * Creates an array with elements from the first given array that are not included in the second given array.\n * @param {Array} arrA The array to compare from.\n * @param {Array} arrB The array to compare against.\n * @returns {Array} a new array that represents `arrA \\ arrB`.\n */\nfunction getDifference(arrA, arrB) {\n  return arrA.filter(a => !arrB.includes(a));\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow loops with a body that allows only one iteration\",\n      category: \"Possible Errors\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-unreachable-loop\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        ignore: {\n          type: \"array\",\n          items: {\n            enum: allLoopTypes\n          },\n          uniqueItems: true\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      invalid: \"Invalid loop. Its body allows only one iteration.\"\n    }\n  },\n  create(context) {\n    const ignoredLoopTypes = context.options[0] && context.options[0].ignore || [],\n      loopTypesToCheck = getDifference(allLoopTypes, ignoredLoopTypes),\n      loopSelector = loopTypesToCheck.join(\",\"),\n      loopsByTargetSegments = new Map(),\n      loopsToReport = new Set();\n    let currentCodePath = null;\n    return {\n      onCodePathStart(codePath) {\n        currentCodePath = codePath;\n      },\n      onCodePathEnd() {\n        currentCodePath = currentCodePath.upper;\n      },\n      [loopSelector](node) {\n        /**\n         * Ignore unreachable loop statements to avoid unnecessary complexity in the implementation, or false positives otherwise.\n         * For unreachable segments, the code path analysis does not raise events required for this implementation.\n         */\n        if (currentCodePath.currentSegments.some(segment => segment.reachable)) {\n          loopsToReport.add(node);\n        }\n      },\n      onCodePathSegmentStart(segment, node) {\n        if (isLoopingTarget(node)) {\n          const loop = node.parent;\n          loopsByTargetSegments.set(segment, loop);\n        }\n      },\n      onCodePathSegmentLoop(_, toSegment, node) {\n        const loop = loopsByTargetSegments.get(toSegment);\n\n        /**\n         * The second iteration is reachable, meaning that the loop is valid by the logic of this rule,\n         * only if there is at least one loop event with the appropriate target (which has been already\n         * determined in the `loopsByTargetSegments` map), raised from either:\n         *\n         * - the end of the loop's body (in which case `node === loop`)\n         * - a `continue` statement\n         *\n         * This condition skips loop events raised from `ForInStatement > .right` and `ForOfStatement > .right` nodes.\n         */\n        if (node === loop || node.type === \"ContinueStatement\") {\n          // Removes loop if it exists in the set. Otherwise, `Set#delete` has no effect and doesn't throw.\n          loopsToReport.delete(loop);\n        }\n      },\n      \"Program:exit\"() {\n        loopsToReport.forEach(node => context.report({\n          node,\n          messageId: \"invalid\"\n        }));\n      }\n    };\n  }\n};","map":{"version":3,"names":["allLoopTypes","isLoopingTarget","node","parent","type","test","body","update","left","getDifference","arrA","arrB","filter","a","includes","module","exports","meta","docs","description","category","recommended","url","schema","properties","ignore","items","enum","uniqueItems","additionalProperties","messages","invalid","create","context","ignoredLoopTypes","options","loopTypesToCheck","loopSelector","join","loopsByTargetSegments","Map","loopsToReport","Set","currentCodePath","onCodePathStart","codePath","onCodePathEnd","upper","currentSegments","some","segment","reachable","add","onCodePathSegmentStart","loop","set","onCodePathSegmentLoop","_","toSegment","get","delete","Program:exit","forEach","report","messageId"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/no-unreachable-loop.js"],"sourcesContent":["/**\n * @fileoverview Rule to disallow loops with a body that allows only one iteration\n * @author Milos Djermanovic\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst allLoopTypes = [\"WhileStatement\", \"DoWhileStatement\", \"ForStatement\", \"ForInStatement\", \"ForOfStatement\"];\n\n/**\n * Determines whether the given node is the first node in the code path to which a loop statement\n * 'loops' for the next iteration.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} `true` if the node is a looping target.\n */\nfunction isLoopingTarget(node) {\n    const parent = node.parent;\n\n    if (parent) {\n        switch (parent.type) {\n            case \"WhileStatement\":\n                return node === parent.test;\n            case \"DoWhileStatement\":\n                return node === parent.body;\n            case \"ForStatement\":\n                return node === (parent.update || parent.test || parent.body);\n            case \"ForInStatement\":\n            case \"ForOfStatement\":\n                return node === parent.left;\n\n            // no default\n        }\n    }\n\n    return false;\n}\n\n/**\n * Creates an array with elements from the first given array that are not included in the second given array.\n * @param {Array} arrA The array to compare from.\n * @param {Array} arrB The array to compare against.\n * @returns {Array} a new array that represents `arrA \\ arrB`.\n */\nfunction getDifference(arrA, arrB) {\n    return arrA.filter(a => !arrB.includes(a));\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow loops with a body that allows only one iteration\",\n            category: \"Possible Errors\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-unreachable-loop\"\n        },\n\n        schema: [{\n            type: \"object\",\n            properties: {\n                ignore: {\n                    type: \"array\",\n                    items: {\n                        enum: allLoopTypes\n                    },\n                    uniqueItems: true\n                }\n            },\n            additionalProperties: false\n        }],\n\n        messages: {\n            invalid: \"Invalid loop. Its body allows only one iteration.\"\n        }\n    },\n\n    create(context) {\n        const ignoredLoopTypes = context.options[0] && context.options[0].ignore || [],\n            loopTypesToCheck = getDifference(allLoopTypes, ignoredLoopTypes),\n            loopSelector = loopTypesToCheck.join(\",\"),\n            loopsByTargetSegments = new Map(),\n            loopsToReport = new Set();\n\n        let currentCodePath = null;\n\n        return {\n            onCodePathStart(codePath) {\n                currentCodePath = codePath;\n            },\n\n            onCodePathEnd() {\n                currentCodePath = currentCodePath.upper;\n            },\n\n            [loopSelector](node) {\n\n                /**\n                 * Ignore unreachable loop statements to avoid unnecessary complexity in the implementation, or false positives otherwise.\n                 * For unreachable segments, the code path analysis does not raise events required for this implementation.\n                 */\n                if (currentCodePath.currentSegments.some(segment => segment.reachable)) {\n                    loopsToReport.add(node);\n                }\n            },\n\n            onCodePathSegmentStart(segment, node) {\n                if (isLoopingTarget(node)) {\n                    const loop = node.parent;\n\n                    loopsByTargetSegments.set(segment, loop);\n                }\n            },\n\n            onCodePathSegmentLoop(_, toSegment, node) {\n                const loop = loopsByTargetSegments.get(toSegment);\n\n                /**\n                 * The second iteration is reachable, meaning that the loop is valid by the logic of this rule,\n                 * only if there is at least one loop event with the appropriate target (which has been already\n                 * determined in the `loopsByTargetSegments` map), raised from either:\n                 *\n                 * - the end of the loop's body (in which case `node === loop`)\n                 * - a `continue` statement\n                 *\n                 * This condition skips loop events raised from `ForInStatement > .right` and `ForOfStatement > .right` nodes.\n                 */\n                if (node === loop || node.type === \"ContinueStatement\") {\n\n                    // Removes loop if it exists in the set. Otherwise, `Set#delete` has no effect and doesn't throw.\n                    loopsToReport.delete(loop);\n                }\n            },\n\n            \"Program:exit\"() {\n                loopsToReport.forEach(\n                    node => context.report({ node, messageId: \"invalid\" })\n                );\n            }\n        };\n    }\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA,YAAY;;AAEZ;AACA;AACA;AAEA,MAAMA,YAAY,GAAG,CAAC,gBAAgB,EAAE,kBAAkB,EAAE,cAAc,EAAE,gBAAgB,EAAE,gBAAgB,CAAC;;AAE/G;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,eAAeA,CAACC,IAAI,EAAE;EAC3B,MAAMC,MAAM,GAAGD,IAAI,CAACC,MAAM;EAE1B,IAAIA,MAAM,EAAE;IACR,QAAQA,MAAM,CAACC,IAAI;MACf,KAAK,gBAAgB;QACjB,OAAOF,IAAI,KAAKC,MAAM,CAACE,IAAI;MAC/B,KAAK,kBAAkB;QACnB,OAAOH,IAAI,KAAKC,MAAM,CAACG,IAAI;MAC/B,KAAK,cAAc;QACf,OAAOJ,IAAI,MAAMC,MAAM,CAACI,MAAM,IAAIJ,MAAM,CAACE,IAAI,IAAIF,MAAM,CAACG,IAAI,CAAC;MACjE,KAAK,gBAAgB;MACrB,KAAK,gBAAgB;QACjB,OAAOJ,IAAI,KAAKC,MAAM,CAACK,IAAI;;MAE/B;IACJ;EACJ;;EAEA,OAAO,KAAK;AAChB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,aAAaA,CAACC,IAAI,EAAEC,IAAI,EAAE;EAC/B,OAAOD,IAAI,CAACE,MAAM,CAACC,CAAC,IAAI,CAACF,IAAI,CAACG,QAAQ,CAACD,CAAC,CAAC,CAAC;AAC9C;;AAEA;AACA;AACA;;AAEAE,MAAM,CAACC,OAAO,GAAG;EACbC,IAAI,EAAE;IACFb,IAAI,EAAE,SAAS;IAEfc,IAAI,EAAE;MACFC,WAAW,EAAE,2DAA2D;MACxEC,QAAQ,EAAE,iBAAiB;MAC3BC,WAAW,EAAE,KAAK;MAClBC,GAAG,EAAE;IACT,CAAC;IAEDC,MAAM,EAAE,CAAC;MACLnB,IAAI,EAAE,QAAQ;MACdoB,UAAU,EAAE;QACRC,MAAM,EAAE;UACJrB,IAAI,EAAE,OAAO;UACbsB,KAAK,EAAE;YACHC,IAAI,EAAE3B;UACV,CAAC;UACD4B,WAAW,EAAE;QACjB;MACJ,CAAC;MACDC,oBAAoB,EAAE;IAC1B,CAAC,CAAC;IAEFC,QAAQ,EAAE;MACNC,OAAO,EAAE;IACb;EACJ,CAAC;EAEDC,MAAMA,CAACC,OAAO,EAAE;IACZ,MAAMC,gBAAgB,GAAGD,OAAO,CAACE,OAAO,CAAC,CAAC,CAAC,IAAIF,OAAO,CAACE,OAAO,CAAC,CAAC,CAAC,CAACV,MAAM,IAAI,EAAE;MAC1EW,gBAAgB,GAAG3B,aAAa,CAACT,YAAY,EAAEkC,gBAAgB,CAAC;MAChEG,YAAY,GAAGD,gBAAgB,CAACE,IAAI,CAAC,GAAG,CAAC;MACzCC,qBAAqB,GAAG,IAAIC,GAAG,CAAC,CAAC;MACjCC,aAAa,GAAG,IAAIC,GAAG,CAAC,CAAC;IAE7B,IAAIC,eAAe,GAAG,IAAI;IAE1B,OAAO;MACHC,eAAeA,CAACC,QAAQ,EAAE;QACtBF,eAAe,GAAGE,QAAQ;MAC9B,CAAC;MAEDC,aAAaA,CAAA,EAAG;QACZH,eAAe,GAAGA,eAAe,CAACI,KAAK;MAC3C,CAAC;MAED,CAACV,YAAY,EAAEnC,IAAI,EAAE;QAEjB;AAChB;AACA;AACA;QACgB,IAAIyC,eAAe,CAACK,eAAe,CAACC,IAAI,CAACC,OAAO,IAAIA,OAAO,CAACC,SAAS,CAAC,EAAE;UACpEV,aAAa,CAACW,GAAG,CAAClD,IAAI,CAAC;QAC3B;MACJ,CAAC;MAEDmD,sBAAsBA,CAACH,OAAO,EAAEhD,IAAI,EAAE;QAClC,IAAID,eAAe,CAACC,IAAI,CAAC,EAAE;UACvB,MAAMoD,IAAI,GAAGpD,IAAI,CAACC,MAAM;UAExBoC,qBAAqB,CAACgB,GAAG,CAACL,OAAO,EAAEI,IAAI,CAAC;QAC5C;MACJ,CAAC;MAEDE,qBAAqBA,CAACC,CAAC,EAAEC,SAAS,EAAExD,IAAI,EAAE;QACtC,MAAMoD,IAAI,GAAGf,qBAAqB,CAACoB,GAAG,CAACD,SAAS,CAAC;;QAEjD;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;QACgB,IAAIxD,IAAI,KAAKoD,IAAI,IAAIpD,IAAI,CAACE,IAAI,KAAK,mBAAmB,EAAE;UAEpD;UACAqC,aAAa,CAACmB,MAAM,CAACN,IAAI,CAAC;QAC9B;MACJ,CAAC;MAED,cAAcO,CAAA,EAAG;QACbpB,aAAa,CAACqB,OAAO,CACjB5D,IAAI,IAAI+B,OAAO,CAAC8B,MAAM,CAAC;UAAE7D,IAAI;UAAE8D,SAAS,EAAE;QAAU,CAAC,CACzD,CAAC;MACL;IACJ,CAAC;EACL;AACJ,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}