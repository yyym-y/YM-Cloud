{"ast":null,"code":"/**\n * @fileoverview Rule to disallow unsafe optional chaining\n * @author Yeon JuAn\n */\n\n\"use strict\";\n\nconst UNSAFE_ARITHMETIC_OPERATORS = new Set([\"+\", \"-\", \"/\", \"*\", \"%\", \"**\"]);\nconst UNSAFE_ASSIGNMENT_OPERATORS = new Set([\"+=\", \"-=\", \"/=\", \"*=\", \"%=\", \"**=\"]);\nconst UNSAFE_RELATIONAL_OPERATORS = new Set([\"in\", \"instanceof\"]);\n\n/**\n * Checks whether a node is a destructuring pattern or not\n * @param {ASTNode} node node to check\n * @returns {boolean} `true` if a node is a destructuring pattern, otherwise `false`\n */\nfunction isDestructuringPattern(node) {\n  return node.type === \"ObjectPattern\" || node.type === \"ArrayPattern\";\n}\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow use of optional chaining in contexts where the `undefined` value is not allowed\",\n      category: \"Possible Errors\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-unsafe-optional-chaining\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        disallowArithmeticOperators: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    fixable: null,\n    messages: {\n      unsafeOptionalChain: \"Unsafe usage of optional chaining. If it short-circuits with 'undefined' the evaluation will throw TypeError.\",\n      unsafeArithmetic: \"Unsafe arithmetic operation on optional chaining. It can result in NaN.\"\n    }\n  },\n  create(context) {\n    const options = context.options[0] || {};\n    const disallowArithmeticOperators = options.disallowArithmeticOperators || false;\n\n    /**\n     * Reports unsafe usage of optional chaining\n     * @param {ASTNode} node node to report\n     * @returns {void}\n     */\n    function reportUnsafeUsage(node) {\n      context.report({\n        messageId: \"unsafeOptionalChain\",\n        node\n      });\n    }\n\n    /**\n     * Reports unsafe arithmetic operation on optional chaining\n     * @param {ASTNode} node node to report\n     * @returns {void}\n     */\n    function reportUnsafeArithmetic(node) {\n      context.report({\n        messageId: \"unsafeArithmetic\",\n        node\n      });\n    }\n\n    /**\n     * Checks and reports if a node can short-circuit with `undefined` by optional chaining.\n     * @param {ASTNode} [node] node to check\n     * @param {Function} reportFunc report function\n     * @returns {void}\n     */\n    function checkUndefinedShortCircuit(node, reportFunc) {\n      if (!node) {\n        return;\n      }\n      switch (node.type) {\n        case \"LogicalExpression\":\n          if (node.operator === \"||\" || node.operator === \"??\") {\n            checkUndefinedShortCircuit(node.right, reportFunc);\n          } else if (node.operator === \"&&\") {\n            checkUndefinedShortCircuit(node.left, reportFunc);\n            checkUndefinedShortCircuit(node.right, reportFunc);\n          }\n          break;\n        case \"SequenceExpression\":\n          checkUndefinedShortCircuit(node.expressions[node.expressions.length - 1], reportFunc);\n          break;\n        case \"ConditionalExpression\":\n          checkUndefinedShortCircuit(node.consequent, reportFunc);\n          checkUndefinedShortCircuit(node.alternate, reportFunc);\n          break;\n        case \"AwaitExpression\":\n          checkUndefinedShortCircuit(node.argument, reportFunc);\n          break;\n        case \"ChainExpression\":\n          reportFunc(node);\n          break;\n        default:\n          break;\n      }\n    }\n\n    /**\n     * Checks unsafe usage of optional chaining\n     * @param {ASTNode} node node to check\n     * @returns {void}\n     */\n    function checkUnsafeUsage(node) {\n      checkUndefinedShortCircuit(node, reportUnsafeUsage);\n    }\n\n    /**\n     * Checks unsafe arithmetic operations on optional chaining\n     * @param {ASTNode} node node to check\n     * @returns {void}\n     */\n    function checkUnsafeArithmetic(node) {\n      checkUndefinedShortCircuit(node, reportUnsafeArithmetic);\n    }\n    return {\n      \"AssignmentExpression, AssignmentPattern\"(node) {\n        if (isDestructuringPattern(node.left)) {\n          checkUnsafeUsage(node.right);\n        }\n      },\n      \"ClassDeclaration, ClassExpression\"(node) {\n        checkUnsafeUsage(node.superClass);\n      },\n      CallExpression(node) {\n        if (!node.optional) {\n          checkUnsafeUsage(node.callee);\n        }\n      },\n      NewExpression(node) {\n        checkUnsafeUsage(node.callee);\n      },\n      VariableDeclarator(node) {\n        if (isDestructuringPattern(node.id)) {\n          checkUnsafeUsage(node.init);\n        }\n      },\n      MemberExpression(node) {\n        if (!node.optional) {\n          checkUnsafeUsage(node.object);\n        }\n      },\n      TaggedTemplateExpression(node) {\n        checkUnsafeUsage(node.tag);\n      },\n      ForOfStatement(node) {\n        checkUnsafeUsage(node.right);\n      },\n      SpreadElement(node) {\n        if (node.parent && node.parent.type !== \"ObjectExpression\") {\n          checkUnsafeUsage(node.argument);\n        }\n      },\n      BinaryExpression(node) {\n        if (UNSAFE_RELATIONAL_OPERATORS.has(node.operator)) {\n          checkUnsafeUsage(node.right);\n        }\n        if (disallowArithmeticOperators && UNSAFE_ARITHMETIC_OPERATORS.has(node.operator)) {\n          checkUnsafeArithmetic(node.right);\n          checkUnsafeArithmetic(node.left);\n        }\n      },\n      WithStatement(node) {\n        checkUnsafeUsage(node.object);\n      },\n      UnaryExpression(node) {\n        if (disallowArithmeticOperators && UNSAFE_ARITHMETIC_OPERATORS.has(node.operator)) {\n          checkUnsafeArithmetic(node.argument);\n        }\n      },\n      AssignmentExpression(node) {\n        if (disallowArithmeticOperators && UNSAFE_ASSIGNMENT_OPERATORS.has(node.operator)) {\n          checkUnsafeArithmetic(node.right);\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["UNSAFE_ARITHMETIC_OPERATORS","Set","UNSAFE_ASSIGNMENT_OPERATORS","UNSAFE_RELATIONAL_OPERATORS","isDestructuringPattern","node","type","module","exports","meta","docs","description","category","recommended","url","schema","properties","disallowArithmeticOperators","default","additionalProperties","fixable","messages","unsafeOptionalChain","unsafeArithmetic","create","context","options","reportUnsafeUsage","report","messageId","reportUnsafeArithmetic","checkUndefinedShortCircuit","reportFunc","operator","right","left","expressions","length","consequent","alternate","argument","checkUnsafeUsage","checkUnsafeArithmetic","AssignmentExpression, AssignmentPattern","ClassDeclaration, ClassExpression","superClass","CallExpression","optional","callee","NewExpression","VariableDeclarator","id","init","MemberExpression","object","TaggedTemplateExpression","tag","ForOfStatement","SpreadElement","parent","BinaryExpression","has","WithStatement","UnaryExpression","AssignmentExpression"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/no-unsafe-optional-chaining.js"],"sourcesContent":["/**\n * @fileoverview Rule to disallow unsafe optional chaining\n * @author Yeon JuAn\n */\n\n\"use strict\";\n\nconst UNSAFE_ARITHMETIC_OPERATORS = new Set([\"+\", \"-\", \"/\", \"*\", \"%\", \"**\"]);\nconst UNSAFE_ASSIGNMENT_OPERATORS = new Set([\"+=\", \"-=\", \"/=\", \"*=\", \"%=\", \"**=\"]);\nconst UNSAFE_RELATIONAL_OPERATORS = new Set([\"in\", \"instanceof\"]);\n\n/**\n * Checks whether a node is a destructuring pattern or not\n * @param {ASTNode} node node to check\n * @returns {boolean} `true` if a node is a destructuring pattern, otherwise `false`\n */\nfunction isDestructuringPattern(node) {\n    return node.type === \"ObjectPattern\" || node.type === \"ArrayPattern\";\n}\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow use of optional chaining in contexts where the `undefined` value is not allowed\",\n            category: \"Possible Errors\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-unsafe-optional-chaining\"\n        },\n        schema: [{\n            type: \"object\",\n            properties: {\n                disallowArithmeticOperators: {\n                    type: \"boolean\",\n                    default: false\n                }\n            },\n            additionalProperties: false\n        }],\n        fixable: null,\n        messages: {\n            unsafeOptionalChain: \"Unsafe usage of optional chaining. If it short-circuits with 'undefined' the evaluation will throw TypeError.\",\n            unsafeArithmetic: \"Unsafe arithmetic operation on optional chaining. It can result in NaN.\"\n        }\n    },\n\n    create(context) {\n        const options = context.options[0] || {};\n        const disallowArithmeticOperators = (options.disallowArithmeticOperators) || false;\n\n        /**\n         * Reports unsafe usage of optional chaining\n         * @param {ASTNode} node node to report\n         * @returns {void}\n         */\n        function reportUnsafeUsage(node) {\n            context.report({\n                messageId: \"unsafeOptionalChain\",\n                node\n            });\n        }\n\n        /**\n         * Reports unsafe arithmetic operation on optional chaining\n         * @param {ASTNode} node node to report\n         * @returns {void}\n         */\n        function reportUnsafeArithmetic(node) {\n            context.report({\n                messageId: \"unsafeArithmetic\",\n                node\n            });\n        }\n\n        /**\n         * Checks and reports if a node can short-circuit with `undefined` by optional chaining.\n         * @param {ASTNode} [node] node to check\n         * @param {Function} reportFunc report function\n         * @returns {void}\n         */\n        function checkUndefinedShortCircuit(node, reportFunc) {\n            if (!node) {\n                return;\n            }\n            switch (node.type) {\n                case \"LogicalExpression\":\n                    if (node.operator === \"||\" || node.operator === \"??\") {\n                        checkUndefinedShortCircuit(node.right, reportFunc);\n                    } else if (node.operator === \"&&\") {\n                        checkUndefinedShortCircuit(node.left, reportFunc);\n                        checkUndefinedShortCircuit(node.right, reportFunc);\n                    }\n                    break;\n                case \"SequenceExpression\":\n                    checkUndefinedShortCircuit(\n                        node.expressions[node.expressions.length - 1],\n                        reportFunc\n                    );\n                    break;\n                case \"ConditionalExpression\":\n                    checkUndefinedShortCircuit(node.consequent, reportFunc);\n                    checkUndefinedShortCircuit(node.alternate, reportFunc);\n                    break;\n                case \"AwaitExpression\":\n                    checkUndefinedShortCircuit(node.argument, reportFunc);\n                    break;\n                case \"ChainExpression\":\n                    reportFunc(node);\n                    break;\n                default:\n                    break;\n            }\n        }\n\n        /**\n         * Checks unsafe usage of optional chaining\n         * @param {ASTNode} node node to check\n         * @returns {void}\n         */\n        function checkUnsafeUsage(node) {\n            checkUndefinedShortCircuit(node, reportUnsafeUsage);\n        }\n\n        /**\n         * Checks unsafe arithmetic operations on optional chaining\n         * @param {ASTNode} node node to check\n         * @returns {void}\n         */\n        function checkUnsafeArithmetic(node) {\n            checkUndefinedShortCircuit(node, reportUnsafeArithmetic);\n        }\n\n        return {\n            \"AssignmentExpression, AssignmentPattern\"(node) {\n                if (isDestructuringPattern(node.left)) {\n                    checkUnsafeUsage(node.right);\n                }\n            },\n            \"ClassDeclaration, ClassExpression\"(node) {\n                checkUnsafeUsage(node.superClass);\n            },\n            CallExpression(node) {\n                if (!node.optional) {\n                    checkUnsafeUsage(node.callee);\n                }\n            },\n            NewExpression(node) {\n                checkUnsafeUsage(node.callee);\n            },\n            VariableDeclarator(node) {\n                if (isDestructuringPattern(node.id)) {\n                    checkUnsafeUsage(node.init);\n                }\n            },\n            MemberExpression(node) {\n                if (!node.optional) {\n                    checkUnsafeUsage(node.object);\n                }\n            },\n            TaggedTemplateExpression(node) {\n                checkUnsafeUsage(node.tag);\n            },\n            ForOfStatement(node) {\n                checkUnsafeUsage(node.right);\n            },\n            SpreadElement(node) {\n                if (node.parent && node.parent.type !== \"ObjectExpression\") {\n                    checkUnsafeUsage(node.argument);\n                }\n            },\n            BinaryExpression(node) {\n                if (UNSAFE_RELATIONAL_OPERATORS.has(node.operator)) {\n                    checkUnsafeUsage(node.right);\n                }\n                if (\n                    disallowArithmeticOperators &&\n                    UNSAFE_ARITHMETIC_OPERATORS.has(node.operator)\n                ) {\n                    checkUnsafeArithmetic(node.right);\n                    checkUnsafeArithmetic(node.left);\n                }\n            },\n            WithStatement(node) {\n                checkUnsafeUsage(node.object);\n            },\n            UnaryExpression(node) {\n                if (\n                    disallowArithmeticOperators &&\n                    UNSAFE_ARITHMETIC_OPERATORS.has(node.operator)\n                ) {\n                    checkUnsafeArithmetic(node.argument);\n                }\n            },\n            AssignmentExpression(node) {\n                if (\n                    disallowArithmeticOperators &&\n                    UNSAFE_ASSIGNMENT_OPERATORS.has(node.operator)\n                ) {\n                    checkUnsafeArithmetic(node.right);\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}