{"ast":null,"code":"/**\n * @fileoverview disallow assignments that can lead to race conditions due to usage of `await` or `yield`\n * @author Teddy Katz\n * @author Toru Nagashima\n */\n\"use strict\";\n\n/**\n * Make the map from identifiers to each reference.\n * @param {escope.Scope} scope The scope to get references.\n * @param {Map<Identifier, escope.Reference>} [outReferenceMap] The map from identifier nodes to each reference object.\n * @returns {Map<Identifier, escope.Reference>} `referenceMap`.\n */\nrequire(\"core-js/modules/es.array.push.js\");\nfunction createReferenceMap(scope, outReferenceMap = new Map()) {\n  for (const reference of scope.references) {\n    if (reference.resolved === null) {\n      continue;\n    }\n    outReferenceMap.set(reference.identifier, reference);\n  }\n  for (const childScope of scope.childScopes) {\n    if (childScope.type !== \"function\") {\n      createReferenceMap(childScope, outReferenceMap);\n    }\n  }\n  return outReferenceMap;\n}\n\n/**\n * Get `reference.writeExpr` of a given reference.\n * If it's the read reference of MemberExpression in LHS, returns RHS in order to address `a.b = await a`\n * @param {escope.Reference} reference The reference to get.\n * @returns {Expression|null} The `reference.writeExpr`.\n */\nfunction getWriteExpr(reference) {\n  if (reference.writeExpr) {\n    return reference.writeExpr;\n  }\n  let node = reference.identifier;\n  while (node) {\n    const t = node.parent.type;\n    if (t === \"AssignmentExpression\" && node.parent.left === node) {\n      return node.parent.right;\n    }\n    if (t === \"MemberExpression\" && node.parent.object === node) {\n      node = node.parent;\n      continue;\n    }\n    break;\n  }\n  return null;\n}\n\n/**\n * Checks if an expression is a variable that can only be observed within the given function.\n * @param {Variable|null} variable The variable to check\n * @param {boolean} isMemberAccess If `true` then this is a member access.\n * @returns {boolean} `true` if the variable is local to the given function, and is never referenced in a closure.\n */\nfunction isLocalVariableWithoutEscape(variable, isMemberAccess) {\n  if (!variable) {\n    return false; // A global variable which was not defined.\n  }\n\n  // If the reference is a property access and the variable is a parameter, it handles the variable is not local.\n  if (isMemberAccess && variable.defs.some(d => d.type === \"Parameter\")) {\n    return false;\n  }\n  const functionScope = variable.scope.variableScope;\n  return variable.references.every(reference => reference.from.variableScope === functionScope);\n}\nclass SegmentInfo {\n  constructor() {\n    this.info = new WeakMap();\n  }\n\n  /**\n   * Initialize the segment information.\n   * @param {PathSegment} segment The segment to initialize.\n   * @returns {void}\n   */\n  initialize(segment) {\n    const outdatedReadVariables = new Set();\n    const freshReadVariables = new Set();\n    for (const prevSegment of segment.prevSegments) {\n      const info = this.info.get(prevSegment);\n      if (info) {\n        info.outdatedReadVariables.forEach(Set.prototype.add, outdatedReadVariables);\n        info.freshReadVariables.forEach(Set.prototype.add, freshReadVariables);\n      }\n    }\n    this.info.set(segment, {\n      outdatedReadVariables,\n      freshReadVariables\n    });\n  }\n\n  /**\n   * Mark a given variable as read on given segments.\n   * @param {PathSegment[]} segments The segments that it read the variable on.\n   * @param {Variable} variable The variable to be read.\n   * @returns {void}\n   */\n  markAsRead(segments, variable) {\n    for (const segment of segments) {\n      const info = this.info.get(segment);\n      if (info) {\n        info.freshReadVariables.add(variable);\n\n        // If a variable is freshly read again, then it's no more out-dated.\n        info.outdatedReadVariables.delete(variable);\n      }\n    }\n  }\n\n  /**\n   * Move `freshReadVariables` to `outdatedReadVariables`.\n   * @param {PathSegment[]} segments The segments to process.\n   * @returns {void}\n   */\n  makeOutdated(segments) {\n    for (const segment of segments) {\n      const info = this.info.get(segment);\n      if (info) {\n        info.freshReadVariables.forEach(Set.prototype.add, info.outdatedReadVariables);\n        info.freshReadVariables.clear();\n      }\n    }\n  }\n\n  /**\n   * Check if a given variable is outdated on the current segments.\n   * @param {PathSegment[]} segments The current segments.\n   * @param {Variable} variable The variable to check.\n   * @returns {boolean} `true` if the variable is outdated on the segments.\n   */\n  isOutdated(segments, variable) {\n    for (const segment of segments) {\n      const info = this.info.get(segment);\n      if (info && info.outdatedReadVariables.has(variable)) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow assignments that can lead to race conditions due to usage of `await` or `yield`\",\n      category: \"Possible Errors\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/require-atomic-updates\"\n    },\n    fixable: null,\n    schema: [],\n    messages: {\n      nonAtomicUpdate: \"Possible race condition: `{{value}}` might be reassigned based on an outdated value of `{{value}}`.\"\n    }\n  },\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const assignmentReferences = new Map();\n    const segmentInfo = new SegmentInfo();\n    let stack = null;\n    return {\n      onCodePathStart(codePath) {\n        const scope = context.getScope();\n        const shouldVerify = scope.type === \"function\" && (scope.block.async || scope.block.generator);\n        stack = {\n          upper: stack,\n          codePath,\n          referenceMap: shouldVerify ? createReferenceMap(scope) : null\n        };\n      },\n      onCodePathEnd() {\n        stack = stack.upper;\n      },\n      // Initialize the segment information.\n      onCodePathSegmentStart(segment) {\n        segmentInfo.initialize(segment);\n      },\n      // Handle references to prepare verification.\n      Identifier(node) {\n        const {\n          codePath,\n          referenceMap\n        } = stack;\n        const reference = referenceMap && referenceMap.get(node);\n\n        // Ignore if this is not a valid variable reference.\n        if (!reference) {\n          return;\n        }\n        const variable = reference.resolved;\n        const writeExpr = getWriteExpr(reference);\n        const isMemberAccess = reference.identifier.parent.type === \"MemberExpression\";\n\n        // Add a fresh read variable.\n        if (reference.isRead() && !(writeExpr && writeExpr.parent.operator === \"=\")) {\n          segmentInfo.markAsRead(codePath.currentSegments, variable);\n        }\n\n        /*\n         * Register the variable to verify after ESLint traversed the `writeExpr` node\n         * if this reference is an assignment to a variable which is referred from other closure.\n         */\n        if (writeExpr && writeExpr.parent.right === writeExpr &&\n        // ← exclude variable declarations.\n        !isLocalVariableWithoutEscape(variable, isMemberAccess)) {\n          let refs = assignmentReferences.get(writeExpr);\n          if (!refs) {\n            refs = [];\n            assignmentReferences.set(writeExpr, refs);\n          }\n          refs.push(reference);\n        }\n      },\n      /*\n       * Verify assignments.\n       * If the reference exists in `outdatedReadVariables` list, report it.\n       */\n      \":expression:exit\"(node) {\n        const {\n          codePath,\n          referenceMap\n        } = stack;\n\n        // referenceMap exists if this is in a resumable function scope.\n        if (!referenceMap) {\n          return;\n        }\n\n        // Mark the read variables on this code path as outdated.\n        if (node.type === \"AwaitExpression\" || node.type === \"YieldExpression\") {\n          segmentInfo.makeOutdated(codePath.currentSegments);\n        }\n\n        // Verify.\n        const references = assignmentReferences.get(node);\n        if (references) {\n          assignmentReferences.delete(node);\n          for (const reference of references) {\n            const variable = reference.resolved;\n            if (segmentInfo.isOutdated(codePath.currentSegments, variable)) {\n              context.report({\n                node: node.parent,\n                messageId: \"nonAtomicUpdate\",\n                data: {\n                  value: sourceCode.getText(node.parent.left)\n                }\n              });\n            }\n          }\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["require","createReferenceMap","scope","outReferenceMap","Map","reference","references","resolved","set","identifier","childScope","childScopes","type","getWriteExpr","writeExpr","node","t","parent","left","right","object","isLocalVariableWithoutEscape","variable","isMemberAccess","defs","some","d","functionScope","variableScope","every","from","SegmentInfo","constructor","info","WeakMap","initialize","segment","outdatedReadVariables","Set","freshReadVariables","prevSegment","prevSegments","get","forEach","prototype","add","markAsRead","segments","delete","makeOutdated","clear","isOutdated","has","module","exports","meta","docs","description","category","recommended","url","fixable","schema","messages","nonAtomicUpdate","create","context","sourceCode","getSourceCode","assignmentReferences","segmentInfo","stack","onCodePathStart","codePath","getScope","shouldVerify","block","async","generator","upper","referenceMap","onCodePathEnd","onCodePathSegmentStart","Identifier","isRead","operator","currentSegments","refs","push",":expression:exit","report","messageId","data","value","getText"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/require-atomic-updates.js"],"sourcesContent":["/**\n * @fileoverview disallow assignments that can lead to race conditions due to usage of `await` or `yield`\n * @author Teddy Katz\n * @author Toru Nagashima\n */\n\"use strict\";\n\n/**\n * Make the map from identifiers to each reference.\n * @param {escope.Scope} scope The scope to get references.\n * @param {Map<Identifier, escope.Reference>} [outReferenceMap] The map from identifier nodes to each reference object.\n * @returns {Map<Identifier, escope.Reference>} `referenceMap`.\n */\nfunction createReferenceMap(scope, outReferenceMap = new Map()) {\n    for (const reference of scope.references) {\n        if (reference.resolved === null) {\n            continue;\n        }\n\n        outReferenceMap.set(reference.identifier, reference);\n    }\n    for (const childScope of scope.childScopes) {\n        if (childScope.type !== \"function\") {\n            createReferenceMap(childScope, outReferenceMap);\n        }\n    }\n\n    return outReferenceMap;\n}\n\n/**\n * Get `reference.writeExpr` of a given reference.\n * If it's the read reference of MemberExpression in LHS, returns RHS in order to address `a.b = await a`\n * @param {escope.Reference} reference The reference to get.\n * @returns {Expression|null} The `reference.writeExpr`.\n */\nfunction getWriteExpr(reference) {\n    if (reference.writeExpr) {\n        return reference.writeExpr;\n    }\n    let node = reference.identifier;\n\n    while (node) {\n        const t = node.parent.type;\n\n        if (t === \"AssignmentExpression\" && node.parent.left === node) {\n            return node.parent.right;\n        }\n        if (t === \"MemberExpression\" && node.parent.object === node) {\n            node = node.parent;\n            continue;\n        }\n\n        break;\n    }\n\n    return null;\n}\n\n/**\n * Checks if an expression is a variable that can only be observed within the given function.\n * @param {Variable|null} variable The variable to check\n * @param {boolean} isMemberAccess If `true` then this is a member access.\n * @returns {boolean} `true` if the variable is local to the given function, and is never referenced in a closure.\n */\nfunction isLocalVariableWithoutEscape(variable, isMemberAccess) {\n    if (!variable) {\n        return false; // A global variable which was not defined.\n    }\n\n    // If the reference is a property access and the variable is a parameter, it handles the variable is not local.\n    if (isMemberAccess && variable.defs.some(d => d.type === \"Parameter\")) {\n        return false;\n    }\n\n    const functionScope = variable.scope.variableScope;\n\n    return variable.references.every(reference =>\n        reference.from.variableScope === functionScope);\n}\n\nclass SegmentInfo {\n    constructor() {\n        this.info = new WeakMap();\n    }\n\n    /**\n     * Initialize the segment information.\n     * @param {PathSegment} segment The segment to initialize.\n     * @returns {void}\n     */\n    initialize(segment) {\n        const outdatedReadVariables = new Set();\n        const freshReadVariables = new Set();\n\n        for (const prevSegment of segment.prevSegments) {\n            const info = this.info.get(prevSegment);\n\n            if (info) {\n                info.outdatedReadVariables.forEach(Set.prototype.add, outdatedReadVariables);\n                info.freshReadVariables.forEach(Set.prototype.add, freshReadVariables);\n            }\n        }\n\n        this.info.set(segment, { outdatedReadVariables, freshReadVariables });\n    }\n\n    /**\n     * Mark a given variable as read on given segments.\n     * @param {PathSegment[]} segments The segments that it read the variable on.\n     * @param {Variable} variable The variable to be read.\n     * @returns {void}\n     */\n    markAsRead(segments, variable) {\n        for (const segment of segments) {\n            const info = this.info.get(segment);\n\n            if (info) {\n                info.freshReadVariables.add(variable);\n\n                // If a variable is freshly read again, then it's no more out-dated.\n                info.outdatedReadVariables.delete(variable);\n            }\n        }\n    }\n\n    /**\n     * Move `freshReadVariables` to `outdatedReadVariables`.\n     * @param {PathSegment[]} segments The segments to process.\n     * @returns {void}\n     */\n    makeOutdated(segments) {\n        for (const segment of segments) {\n            const info = this.info.get(segment);\n\n            if (info) {\n                info.freshReadVariables.forEach(Set.prototype.add, info.outdatedReadVariables);\n                info.freshReadVariables.clear();\n            }\n        }\n    }\n\n    /**\n     * Check if a given variable is outdated on the current segments.\n     * @param {PathSegment[]} segments The current segments.\n     * @param {Variable} variable The variable to check.\n     * @returns {boolean} `true` if the variable is outdated on the segments.\n     */\n    isOutdated(segments, variable) {\n        for (const segment of segments) {\n            const info = this.info.get(segment);\n\n            if (info && info.outdatedReadVariables.has(variable)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow assignments that can lead to race conditions due to usage of `await` or `yield`\",\n            category: \"Possible Errors\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/require-atomic-updates\"\n        },\n\n        fixable: null,\n        schema: [],\n\n        messages: {\n            nonAtomicUpdate: \"Possible race condition: `{{value}}` might be reassigned based on an outdated value of `{{value}}`.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const assignmentReferences = new Map();\n        const segmentInfo = new SegmentInfo();\n        let stack = null;\n\n        return {\n            onCodePathStart(codePath) {\n                const scope = context.getScope();\n                const shouldVerify =\n                    scope.type === \"function\" &&\n                    (scope.block.async || scope.block.generator);\n\n                stack = {\n                    upper: stack,\n                    codePath,\n                    referenceMap: shouldVerify ? createReferenceMap(scope) : null\n                };\n            },\n            onCodePathEnd() {\n                stack = stack.upper;\n            },\n\n            // Initialize the segment information.\n            onCodePathSegmentStart(segment) {\n                segmentInfo.initialize(segment);\n            },\n\n            // Handle references to prepare verification.\n            Identifier(node) {\n                const { codePath, referenceMap } = stack;\n                const reference = referenceMap && referenceMap.get(node);\n\n                // Ignore if this is not a valid variable reference.\n                if (!reference) {\n                    return;\n                }\n                const variable = reference.resolved;\n                const writeExpr = getWriteExpr(reference);\n                const isMemberAccess = reference.identifier.parent.type === \"MemberExpression\";\n\n                // Add a fresh read variable.\n                if (reference.isRead() && !(writeExpr && writeExpr.parent.operator === \"=\")) {\n                    segmentInfo.markAsRead(codePath.currentSegments, variable);\n                }\n\n                /*\n                 * Register the variable to verify after ESLint traversed the `writeExpr` node\n                 * if this reference is an assignment to a variable which is referred from other closure.\n                 */\n                if (writeExpr &&\n                    writeExpr.parent.right === writeExpr && // ← exclude variable declarations.\n                    !isLocalVariableWithoutEscape(variable, isMemberAccess)\n                ) {\n                    let refs = assignmentReferences.get(writeExpr);\n\n                    if (!refs) {\n                        refs = [];\n                        assignmentReferences.set(writeExpr, refs);\n                    }\n\n                    refs.push(reference);\n                }\n            },\n\n            /*\n             * Verify assignments.\n             * If the reference exists in `outdatedReadVariables` list, report it.\n             */\n            \":expression:exit\"(node) {\n                const { codePath, referenceMap } = stack;\n\n                // referenceMap exists if this is in a resumable function scope.\n                if (!referenceMap) {\n                    return;\n                }\n\n                // Mark the read variables on this code path as outdated.\n                if (node.type === \"AwaitExpression\" || node.type === \"YieldExpression\") {\n                    segmentInfo.makeOutdated(codePath.currentSegments);\n                }\n\n                // Verify.\n                const references = assignmentReferences.get(node);\n\n                if (references) {\n                    assignmentReferences.delete(node);\n\n                    for (const reference of references) {\n                        const variable = reference.resolved;\n\n                        if (segmentInfo.isOutdated(codePath.currentSegments, variable)) {\n                            context.report({\n                                node: node.parent,\n                                messageId: \"nonAtomicUpdate\",\n                                data: {\n                                    value: sourceCode.getText(node.parent.left)\n                                }\n                            });\n                        }\n                    }\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}