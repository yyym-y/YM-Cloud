{"ast":null,"code":"/**\n * @fileoverview Define 2 token factories; forward and backward.\n * @author Toru Nagashima\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst BackwardTokenCommentCursor = require(\"./backward-token-comment-cursor\");\nconst BackwardTokenCursor = require(\"./backward-token-cursor\");\nconst FilterCursor = require(\"./filter-cursor\");\nconst ForwardTokenCommentCursor = require(\"./forward-token-comment-cursor\");\nconst ForwardTokenCursor = require(\"./forward-token-cursor\");\nconst LimitCursor = require(\"./limit-cursor\");\nconst SkipCursor = require(\"./skip-cursor\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * The cursor factory.\n * @private\n */\nclass CursorFactory {\n  /**\n   * Initializes this cursor.\n   * @param {Function} TokenCursor The class of the cursor which iterates tokens only.\n   * @param {Function} TokenCommentCursor The class of the cursor which iterates the mix of tokens and comments.\n   */\n  constructor(TokenCursor, TokenCommentCursor) {\n    this.TokenCursor = TokenCursor;\n    this.TokenCommentCursor = TokenCommentCursor;\n  }\n\n  /**\n   * Creates a base cursor instance that can be decorated by createCursor.\n   * @param {Token[]} tokens The array of tokens.\n   * @param {Comment[]} comments The array of comments.\n   * @param {Object} indexMap The map from locations to indices in `tokens`.\n   * @param {number} startLoc The start location of the iteration range.\n   * @param {number} endLoc The end location of the iteration range.\n   * @param {boolean} includeComments The flag to iterate comments as well.\n   * @returns {Cursor} The created base cursor.\n   */\n  createBaseCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments) {\n    const Cursor = includeComments ? this.TokenCommentCursor : this.TokenCursor;\n    return new Cursor(tokens, comments, indexMap, startLoc, endLoc);\n  }\n\n  /**\n   * Creates a cursor that iterates tokens with normalized options.\n   * @param {Token[]} tokens The array of tokens.\n   * @param {Comment[]} comments The array of comments.\n   * @param {Object} indexMap The map from locations to indices in `tokens`.\n   * @param {number} startLoc The start location of the iteration range.\n   * @param {number} endLoc The end location of the iteration range.\n   * @param {boolean} includeComments The flag to iterate comments as well.\n   * @param {Function|null} filter The predicate function to choose tokens.\n   * @param {number} skip The count of tokens the cursor skips.\n   * @param {number} count The maximum count of tokens the cursor iterates. Zero is no iteration for backward compatibility.\n   * @returns {Cursor} The created cursor.\n   */\n  createCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments, filter, skip, count) {\n    let cursor = this.createBaseCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments);\n    if (filter) {\n      cursor = new FilterCursor(cursor, filter);\n    }\n    if (skip >= 1) {\n      cursor = new SkipCursor(cursor, skip);\n    }\n    if (count >= 0) {\n      cursor = new LimitCursor(cursor, count);\n    }\n    return cursor;\n  }\n}\n\n//------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\nexports.forward = new CursorFactory(ForwardTokenCursor, ForwardTokenCommentCursor);\nexports.backward = new CursorFactory(BackwardTokenCursor, BackwardTokenCommentCursor);","map":{"version":3,"names":["BackwardTokenCommentCursor","require","BackwardTokenCursor","FilterCursor","ForwardTokenCommentCursor","ForwardTokenCursor","LimitCursor","SkipCursor","CursorFactory","constructor","TokenCursor","TokenCommentCursor","createBaseCursor","tokens","comments","indexMap","startLoc","endLoc","includeComments","Cursor","createCursor","filter","skip","count","cursor","exports","forward","backward"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/source-code/token-store/cursors.js"],"sourcesContent":["/**\n * @fileoverview Define 2 token factories; forward and backward.\n * @author Toru Nagashima\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst BackwardTokenCommentCursor = require(\"./backward-token-comment-cursor\");\nconst BackwardTokenCursor = require(\"./backward-token-cursor\");\nconst FilterCursor = require(\"./filter-cursor\");\nconst ForwardTokenCommentCursor = require(\"./forward-token-comment-cursor\");\nconst ForwardTokenCursor = require(\"./forward-token-cursor\");\nconst LimitCursor = require(\"./limit-cursor\");\nconst SkipCursor = require(\"./skip-cursor\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * The cursor factory.\n * @private\n */\nclass CursorFactory {\n\n    /**\n     * Initializes this cursor.\n     * @param {Function} TokenCursor The class of the cursor which iterates tokens only.\n     * @param {Function} TokenCommentCursor The class of the cursor which iterates the mix of tokens and comments.\n     */\n    constructor(TokenCursor, TokenCommentCursor) {\n        this.TokenCursor = TokenCursor;\n        this.TokenCommentCursor = TokenCommentCursor;\n    }\n\n    /**\n     * Creates a base cursor instance that can be decorated by createCursor.\n     * @param {Token[]} tokens The array of tokens.\n     * @param {Comment[]} comments The array of comments.\n     * @param {Object} indexMap The map from locations to indices in `tokens`.\n     * @param {number} startLoc The start location of the iteration range.\n     * @param {number} endLoc The end location of the iteration range.\n     * @param {boolean} includeComments The flag to iterate comments as well.\n     * @returns {Cursor} The created base cursor.\n     */\n    createBaseCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments) {\n        const Cursor = includeComments ? this.TokenCommentCursor : this.TokenCursor;\n\n        return new Cursor(tokens, comments, indexMap, startLoc, endLoc);\n    }\n\n    /**\n     * Creates a cursor that iterates tokens with normalized options.\n     * @param {Token[]} tokens The array of tokens.\n     * @param {Comment[]} comments The array of comments.\n     * @param {Object} indexMap The map from locations to indices in `tokens`.\n     * @param {number} startLoc The start location of the iteration range.\n     * @param {number} endLoc The end location of the iteration range.\n     * @param {boolean} includeComments The flag to iterate comments as well.\n     * @param {Function|null} filter The predicate function to choose tokens.\n     * @param {number} skip The count of tokens the cursor skips.\n     * @param {number} count The maximum count of tokens the cursor iterates. Zero is no iteration for backward compatibility.\n     * @returns {Cursor} The created cursor.\n     */\n    createCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments, filter, skip, count) {\n        let cursor = this.createBaseCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments);\n\n        if (filter) {\n            cursor = new FilterCursor(cursor, filter);\n        }\n        if (skip >= 1) {\n            cursor = new SkipCursor(cursor, skip);\n        }\n        if (count >= 0) {\n            cursor = new LimitCursor(cursor, count);\n        }\n\n        return cursor;\n    }\n}\n\n//------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\nexports.forward = new CursorFactory(ForwardTokenCursor, ForwardTokenCommentCursor);\nexports.backward = new CursorFactory(BackwardTokenCursor, BackwardTokenCommentCursor);\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,YAAY;;AAEZ;AACA;AACA;AAEA,MAAMA,0BAA0B,GAAGC,OAAO,CAAC,iCAAiC,CAAC;AAC7E,MAAMC,mBAAmB,GAAGD,OAAO,CAAC,yBAAyB,CAAC;AAC9D,MAAME,YAAY,GAAGF,OAAO,CAAC,iBAAiB,CAAC;AAC/C,MAAMG,yBAAyB,GAAGH,OAAO,CAAC,gCAAgC,CAAC;AAC3E,MAAMI,kBAAkB,GAAGJ,OAAO,CAAC,wBAAwB,CAAC;AAC5D,MAAMK,WAAW,GAAGL,OAAO,CAAC,gBAAgB,CAAC;AAC7C,MAAMM,UAAU,GAAGN,OAAO,CAAC,eAAe,CAAC;;AAE3C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAMO,aAAa,CAAC;EAEhB;AACJ;AACA;AACA;AACA;EACIC,WAAWA,CAACC,WAAW,EAAEC,kBAAkB,EAAE;IACzC,IAAI,CAACD,WAAW,GAAGA,WAAW;IAC9B,IAAI,CAACC,kBAAkB,GAAGA,kBAAkB;EAChD;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,gBAAgBA,CAACC,MAAM,EAAEC,QAAQ,EAAEC,QAAQ,EAAEC,QAAQ,EAAEC,MAAM,EAAEC,eAAe,EAAE;IAC5E,MAAMC,MAAM,GAAGD,eAAe,GAAG,IAAI,CAACP,kBAAkB,GAAG,IAAI,CAACD,WAAW;IAE3E,OAAO,IAAIS,MAAM,CAACN,MAAM,EAAEC,QAAQ,EAAEC,QAAQ,EAAEC,QAAQ,EAAEC,MAAM,CAAC;EACnE;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIG,YAAYA,CAACP,MAAM,EAAEC,QAAQ,EAAEC,QAAQ,EAAEC,QAAQ,EAAEC,MAAM,EAAEC,eAAe,EAAEG,MAAM,EAAEC,IAAI,EAAEC,KAAK,EAAE;IAC7F,IAAIC,MAAM,GAAG,IAAI,CAACZ,gBAAgB,CAACC,MAAM,EAAEC,QAAQ,EAAEC,QAAQ,EAAEC,QAAQ,EAAEC,MAAM,EAAEC,eAAe,CAAC;IAEjG,IAAIG,MAAM,EAAE;MACRG,MAAM,GAAG,IAAIrB,YAAY,CAACqB,MAAM,EAAEH,MAAM,CAAC;IAC7C;IACA,IAAIC,IAAI,IAAI,CAAC,EAAE;MACXE,MAAM,GAAG,IAAIjB,UAAU,CAACiB,MAAM,EAAEF,IAAI,CAAC;IACzC;IACA,IAAIC,KAAK,IAAI,CAAC,EAAE;MACZC,MAAM,GAAG,IAAIlB,WAAW,CAACkB,MAAM,EAAED,KAAK,CAAC;IAC3C;IAEA,OAAOC,MAAM;EACjB;AACJ;;AAEA;AACA;AACA;;AAEAC,OAAO,CAACC,OAAO,GAAG,IAAIlB,aAAa,CAACH,kBAAkB,EAAED,yBAAyB,CAAC;AAClFqB,OAAO,CAACE,QAAQ,GAAG,IAAInB,aAAa,CAACN,mBAAmB,EAAEF,0BAA0B,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}