{"ast":null,"code":"/**\n * @fileoverview Restrict usage of specified node imports.\n * @author Guy Ellis\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\nrequire(\"core-js/modules/es.array.push.js\");\nconst ignore = require(\"ignore\");\nconst arrayOfStringsOrObjects = {\n  type: \"array\",\n  items: {\n    anyOf: [{\n      type: \"string\"\n    }, {\n      type: \"object\",\n      properties: {\n        name: {\n          type: \"string\"\n        },\n        message: {\n          type: \"string\",\n          minLength: 1\n        },\n        importNames: {\n          type: \"array\",\n          items: {\n            type: \"string\"\n          }\n        }\n      },\n      additionalProperties: false,\n      required: [\"name\"]\n    }]\n  },\n  uniqueItems: true\n};\nconst arrayOfStringsOrObjectPatterns = {\n  anyOf: [{\n    type: \"array\",\n    items: {\n      type: \"string\"\n    },\n    uniqueItems: true\n  }, {\n    type: \"array\",\n    items: {\n      type: \"object\",\n      properties: {\n        group: {\n          type: \"array\",\n          items: {\n            type: \"string\"\n          },\n          minItems: 1,\n          uniqueItems: true\n        },\n        message: {\n          type: \"string\",\n          minLength: 1\n        }\n      },\n      additionalProperties: false,\n      required: [\"group\"]\n    },\n    uniqueItems: true\n  }]\n};\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow specified modules when loaded by `import`\",\n      category: \"ECMAScript 6\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-restricted-imports\"\n    },\n    messages: {\n      path: \"'{{importSource}}' import is restricted from being used.\",\n      // eslint-disable-next-line eslint-plugin/report-message-format\n      pathWithCustomMessage: \"'{{importSource}}' import is restricted from being used. {{customMessage}}\",\n      patterns: \"'{{importSource}}' import is restricted from being used by a pattern.\",\n      // eslint-disable-next-line eslint-plugin/report-message-format\n      patternWithCustomMessage: \"'{{importSource}}' import is restricted from being used by a pattern. {{customMessage}}\",\n      everything: \"* import is invalid because '{{importNames}}' from '{{importSource}}' is restricted.\",\n      // eslint-disable-next-line eslint-plugin/report-message-format\n      everythingWithCustomMessage: \"* import is invalid because '{{importNames}}' from '{{importSource}}' is restricted. {{customMessage}}\",\n      importName: \"'{{importName}}' import from '{{importSource}}' is restricted.\",\n      // eslint-disable-next-line eslint-plugin/report-message-format\n      importNameWithCustomMessage: \"'{{importName}}' import from '{{importSource}}' is restricted. {{customMessage}}\"\n    },\n    schema: {\n      anyOf: [arrayOfStringsOrObjects, {\n        type: \"array\",\n        items: [{\n          type: \"object\",\n          properties: {\n            paths: arrayOfStringsOrObjects,\n            patterns: arrayOfStringsOrObjectPatterns\n          },\n          additionalProperties: false\n        }],\n        additionalItems: false\n      }]\n    }\n  },\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const options = Array.isArray(context.options) ? context.options : [];\n    const isPathAndPatternsObject = typeof options[0] === \"object\" && (Object.prototype.hasOwnProperty.call(options[0], \"paths\") || Object.prototype.hasOwnProperty.call(options[0], \"patterns\"));\n    const restrictedPaths = (isPathAndPatternsObject ? options[0].paths : context.options) || [];\n    const restrictedPathMessages = restrictedPaths.reduce((memo, importSource) => {\n      if (typeof importSource === \"string\") {\n        memo[importSource] = {\n          message: null\n        };\n      } else {\n        memo[importSource.name] = {\n          message: importSource.message,\n          importNames: importSource.importNames\n        };\n      }\n      return memo;\n    }, {});\n\n    // Handle patterns too, either as strings or groups\n    const restrictedPatterns = (isPathAndPatternsObject ? options[0].patterns : []) || [];\n    const restrictedPatternGroups = restrictedPatterns.length > 0 && typeof restrictedPatterns[0] === \"string\" ? [{\n      matcher: ignore().add(restrictedPatterns)\n    }] : restrictedPatterns.map(({\n      group,\n      message\n    }) => ({\n      matcher: ignore().add(group),\n      customMessage: message\n    }));\n\n    // if no imports are restricted we don\"t need to check\n    if (Object.keys(restrictedPaths).length === 0 && restrictedPatternGroups.length === 0) {\n      return {};\n    }\n\n    /**\n     * Report a restricted path.\n     * @param {string} importSource path of the import\n     * @param {Map<string,Object[]>} importNames Map of import names that are being imported\n     * @param {node} node representing the restricted path reference\n     * @returns {void}\n     * @private\n     */\n    function checkRestrictedPathAndReport(importSource, importNames, node) {\n      if (!Object.prototype.hasOwnProperty.call(restrictedPathMessages, importSource)) {\n        return;\n      }\n      const customMessage = restrictedPathMessages[importSource].message;\n      const restrictedImportNames = restrictedPathMessages[importSource].importNames;\n      if (restrictedImportNames) {\n        if (importNames.has(\"*\")) {\n          const specifierData = importNames.get(\"*\")[0];\n          context.report({\n            node,\n            messageId: customMessage ? \"everythingWithCustomMessage\" : \"everything\",\n            loc: specifierData.loc,\n            data: {\n              importSource,\n              importNames: restrictedImportNames,\n              customMessage\n            }\n          });\n        }\n        restrictedImportNames.forEach(importName => {\n          if (importNames.has(importName)) {\n            const specifiers = importNames.get(importName);\n            specifiers.forEach(specifier => {\n              context.report({\n                node,\n                messageId: customMessage ? \"importNameWithCustomMessage\" : \"importName\",\n                loc: specifier.loc,\n                data: {\n                  importSource,\n                  customMessage,\n                  importName\n                }\n              });\n            });\n          }\n        });\n      } else {\n        context.report({\n          node,\n          messageId: customMessage ? \"pathWithCustomMessage\" : \"path\",\n          data: {\n            importSource,\n            customMessage\n          }\n        });\n      }\n    }\n\n    /**\n     * Report a restricted path specifically for patterns.\n     * @param {node} node representing the restricted path reference\n     * @param {Object} group contains a Ignore instance for paths, and the customMessage to show if it fails\n     * @returns {void}\n     * @private\n     */\n    function reportPathForPatterns(node, group) {\n      const importSource = node.source.value.trim();\n      context.report({\n        node,\n        messageId: group.customMessage ? \"patternWithCustomMessage\" : \"patterns\",\n        data: {\n          importSource,\n          customMessage: group.customMessage\n        }\n      });\n    }\n\n    /**\n     * Check if the given importSource is restricted by a pattern.\n     * @param {string} importSource path of the import\n     * @param {Object} group contains a Ignore instance for paths, and the customMessage to show if it fails\n     * @returns {boolean} whether the variable is a restricted pattern or not\n     * @private\n     */\n    function isRestrictedPattern(importSource, group) {\n      return group.matcher.ignores(importSource);\n    }\n\n    /**\n     * Checks a node to see if any problems should be reported.\n     * @param {ASTNode} node The node to check.\n     * @returns {void}\n     * @private\n     */\n    function checkNode(node) {\n      const importSource = node.source.value.trim();\n      const importNames = new Map();\n      if (node.type === \"ExportAllDeclaration\") {\n        const starToken = sourceCode.getFirstToken(node, 1);\n        importNames.set(\"*\", [{\n          loc: starToken.loc\n        }]);\n      } else if (node.specifiers) {\n        for (const specifier of node.specifiers) {\n          let name;\n          const specifierData = {\n            loc: specifier.loc\n          };\n          if (specifier.type === \"ImportDefaultSpecifier\") {\n            name = \"default\";\n          } else if (specifier.type === \"ImportNamespaceSpecifier\") {\n            name = \"*\";\n          } else if (specifier.imported) {\n            name = specifier.imported.name;\n          } else if (specifier.local) {\n            name = specifier.local.name;\n          }\n          if (name) {\n            if (importNames.has(name)) {\n              importNames.get(name).push(specifierData);\n            } else {\n              importNames.set(name, [specifierData]);\n            }\n          }\n        }\n      }\n      checkRestrictedPathAndReport(importSource, importNames, node);\n      restrictedPatternGroups.forEach(group => {\n        if (isRestrictedPattern(importSource, group)) {\n          reportPathForPatterns(node, group);\n        }\n      });\n    }\n    return {\n      ImportDeclaration: checkNode,\n      ExportNamedDeclaration(node) {\n        if (node.source) {\n          checkNode(node);\n        }\n      },\n      ExportAllDeclaration: checkNode\n    };\n  }\n};","map":{"version":3,"names":["require","ignore","arrayOfStringsOrObjects","type","items","anyOf","properties","name","message","minLength","importNames","additionalProperties","required","uniqueItems","arrayOfStringsOrObjectPatterns","group","minItems","module","exports","meta","docs","description","category","recommended","url","messages","path","pathWithCustomMessage","patterns","patternWithCustomMessage","everything","everythingWithCustomMessage","importName","importNameWithCustomMessage","schema","paths","additionalItems","create","context","sourceCode","getSourceCode","options","Array","isArray","isPathAndPatternsObject","Object","prototype","hasOwnProperty","call","restrictedPaths","restrictedPathMessages","reduce","memo","importSource","restrictedPatterns","restrictedPatternGroups","length","matcher","add","map","customMessage","keys","checkRestrictedPathAndReport","node","restrictedImportNames","has","specifierData","get","report","messageId","loc","data","forEach","specifiers","specifier","reportPathForPatterns","source","value","trim","isRestrictedPattern","ignores","checkNode","Map","starToken","getFirstToken","set","imported","local","push","ImportDeclaration","ExportNamedDeclaration","ExportAllDeclaration"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/no-restricted-imports.js"],"sourcesContent":["/**\n * @fileoverview Restrict usage of specified node imports.\n * @author Guy Ellis\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst ignore = require(\"ignore\");\n\nconst arrayOfStringsOrObjects = {\n    type: \"array\",\n    items: {\n        anyOf: [\n            { type: \"string\" },\n            {\n                type: \"object\",\n                properties: {\n                    name: { type: \"string\" },\n                    message: {\n                        type: \"string\",\n                        minLength: 1\n                    },\n                    importNames: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        }\n                    }\n                },\n                additionalProperties: false,\n                required: [\"name\"]\n            }\n        ]\n    },\n    uniqueItems: true\n};\n\nconst arrayOfStringsOrObjectPatterns = {\n    anyOf: [\n        {\n            type: \"array\",\n            items: {\n                type: \"string\"\n            },\n            uniqueItems: true\n        },\n        {\n            type: \"array\",\n            items: {\n                type: \"object\",\n                properties: {\n                    group: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        },\n                        minItems: 1,\n                        uniqueItems: true\n                    },\n                    message: {\n                        type: \"string\",\n                        minLength: 1\n                    }\n                },\n                additionalProperties: false,\n                required: [\"group\"]\n            },\n            uniqueItems: true\n        }\n    ]\n};\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow specified modules when loaded by `import`\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-restricted-imports\"\n        },\n\n        messages: {\n            path: \"'{{importSource}}' import is restricted from being used.\",\n            // eslint-disable-next-line eslint-plugin/report-message-format\n            pathWithCustomMessage: \"'{{importSource}}' import is restricted from being used. {{customMessage}}\",\n\n            patterns: \"'{{importSource}}' import is restricted from being used by a pattern.\",\n            // eslint-disable-next-line eslint-plugin/report-message-format\n            patternWithCustomMessage: \"'{{importSource}}' import is restricted from being used by a pattern. {{customMessage}}\",\n\n            everything: \"* import is invalid because '{{importNames}}' from '{{importSource}}' is restricted.\",\n            // eslint-disable-next-line eslint-plugin/report-message-format\n            everythingWithCustomMessage: \"* import is invalid because '{{importNames}}' from '{{importSource}}' is restricted. {{customMessage}}\",\n\n            importName: \"'{{importName}}' import from '{{importSource}}' is restricted.\",\n            // eslint-disable-next-line eslint-plugin/report-message-format\n            importNameWithCustomMessage: \"'{{importName}}' import from '{{importSource}}' is restricted. {{customMessage}}\"\n        },\n\n        schema: {\n            anyOf: [\n                arrayOfStringsOrObjects,\n                {\n                    type: \"array\",\n                    items: [{\n                        type: \"object\",\n                        properties: {\n                            paths: arrayOfStringsOrObjects,\n                            patterns: arrayOfStringsOrObjectPatterns\n                        },\n                        additionalProperties: false\n                    }],\n                    additionalItems: false\n                }\n            ]\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const options = Array.isArray(context.options) ? context.options : [];\n        const isPathAndPatternsObject =\n            typeof options[0] === \"object\" &&\n            (Object.prototype.hasOwnProperty.call(options[0], \"paths\") || Object.prototype.hasOwnProperty.call(options[0], \"patterns\"));\n\n        const restrictedPaths = (isPathAndPatternsObject ? options[0].paths : context.options) || [];\n        const restrictedPathMessages = restrictedPaths.reduce((memo, importSource) => {\n            if (typeof importSource === \"string\") {\n                memo[importSource] = { message: null };\n            } else {\n                memo[importSource.name] = {\n                    message: importSource.message,\n                    importNames: importSource.importNames\n                };\n            }\n            return memo;\n        }, {});\n\n        // Handle patterns too, either as strings or groups\n        const restrictedPatterns = (isPathAndPatternsObject ? options[0].patterns : []) || [];\n        const restrictedPatternGroups = restrictedPatterns.length > 0 && typeof restrictedPatterns[0] === \"string\"\n            ? [{ matcher: ignore().add(restrictedPatterns) }]\n            : restrictedPatterns.map(({ group, message }) => ({ matcher: ignore().add(group), customMessage: message }));\n\n        // if no imports are restricted we don\"t need to check\n        if (Object.keys(restrictedPaths).length === 0 && restrictedPatternGroups.length === 0) {\n            return {};\n        }\n\n        /**\n         * Report a restricted path.\n         * @param {string} importSource path of the import\n         * @param {Map<string,Object[]>} importNames Map of import names that are being imported\n         * @param {node} node representing the restricted path reference\n         * @returns {void}\n         * @private\n         */\n        function checkRestrictedPathAndReport(importSource, importNames, node) {\n            if (!Object.prototype.hasOwnProperty.call(restrictedPathMessages, importSource)) {\n                return;\n            }\n\n            const customMessage = restrictedPathMessages[importSource].message;\n            const restrictedImportNames = restrictedPathMessages[importSource].importNames;\n\n            if (restrictedImportNames) {\n                if (importNames.has(\"*\")) {\n                    const specifierData = importNames.get(\"*\")[0];\n\n                    context.report({\n                        node,\n                        messageId: customMessage ? \"everythingWithCustomMessage\" : \"everything\",\n                        loc: specifierData.loc,\n                        data: {\n                            importSource,\n                            importNames: restrictedImportNames,\n                            customMessage\n                        }\n                    });\n                }\n\n                restrictedImportNames.forEach(importName => {\n                    if (importNames.has(importName)) {\n                        const specifiers = importNames.get(importName);\n\n                        specifiers.forEach(specifier => {\n                            context.report({\n                                node,\n                                messageId: customMessage ? \"importNameWithCustomMessage\" : \"importName\",\n                                loc: specifier.loc,\n                                data: {\n                                    importSource,\n                                    customMessage,\n                                    importName\n                                }\n                            });\n                        });\n                    }\n                });\n            } else {\n                context.report({\n                    node,\n                    messageId: customMessage ? \"pathWithCustomMessage\" : \"path\",\n                    data: {\n                        importSource,\n                        customMessage\n                    }\n                });\n            }\n        }\n\n        /**\n         * Report a restricted path specifically for patterns.\n         * @param {node} node representing the restricted path reference\n         * @param {Object} group contains a Ignore instance for paths, and the customMessage to show if it fails\n         * @returns {void}\n         * @private\n         */\n        function reportPathForPatterns(node, group) {\n            const importSource = node.source.value.trim();\n\n            context.report({\n                node,\n                messageId: group.customMessage ? \"patternWithCustomMessage\" : \"patterns\",\n                data: {\n                    importSource,\n                    customMessage: group.customMessage\n                }\n            });\n        }\n\n        /**\n         * Check if the given importSource is restricted by a pattern.\n         * @param {string} importSource path of the import\n         * @param {Object} group contains a Ignore instance for paths, and the customMessage to show if it fails\n         * @returns {boolean} whether the variable is a restricted pattern or not\n         * @private\n         */\n        function isRestrictedPattern(importSource, group) {\n            return group.matcher.ignores(importSource);\n        }\n\n        /**\n         * Checks a node to see if any problems should be reported.\n         * @param {ASTNode} node The node to check.\n         * @returns {void}\n         * @private\n         */\n        function checkNode(node) {\n            const importSource = node.source.value.trim();\n            const importNames = new Map();\n\n            if (node.type === \"ExportAllDeclaration\") {\n                const starToken = sourceCode.getFirstToken(node, 1);\n\n                importNames.set(\"*\", [{ loc: starToken.loc }]);\n            } else if (node.specifiers) {\n                for (const specifier of node.specifiers) {\n                    let name;\n                    const specifierData = { loc: specifier.loc };\n\n                    if (specifier.type === \"ImportDefaultSpecifier\") {\n                        name = \"default\";\n                    } else if (specifier.type === \"ImportNamespaceSpecifier\") {\n                        name = \"*\";\n                    } else if (specifier.imported) {\n                        name = specifier.imported.name;\n                    } else if (specifier.local) {\n                        name = specifier.local.name;\n                    }\n\n                    if (name) {\n                        if (importNames.has(name)) {\n                            importNames.get(name).push(specifierData);\n                        } else {\n                            importNames.set(name, [specifierData]);\n                        }\n                    }\n                }\n            }\n\n            checkRestrictedPathAndReport(importSource, importNames, node);\n            restrictedPatternGroups.forEach(group => {\n                if (isRestrictedPattern(importSource, group)) {\n                    reportPathForPatterns(node, group);\n                }\n            });\n        }\n\n        return {\n            ImportDeclaration: checkNode,\n            ExportNamedDeclaration(node) {\n                if (node.source) {\n                    checkNode(node);\n                }\n            },\n            ExportAllDeclaration: checkNode\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}