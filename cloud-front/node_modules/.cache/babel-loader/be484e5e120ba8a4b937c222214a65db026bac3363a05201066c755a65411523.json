{"ast":null,"code":"/**\n * @fileoverview A rule to suggest using template literals instead of string concatenation.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given node is a concatenation.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node is a concatenation.\n */\nfunction isConcatenation(node) {\n  return node.type === \"BinaryExpression\" && node.operator === \"+\";\n}\n\n/**\n * Gets the top binary expression node for concatenation in parents of a given node.\n * @param {ASTNode} node A node to get.\n * @returns {ASTNode} the top binary expression node in parents of a given node.\n */\nfunction getTopConcatBinaryExpression(node) {\n  let currentNode = node;\n  while (isConcatenation(currentNode.parent)) {\n    currentNode = currentNode.parent;\n  }\n  return currentNode;\n}\n\n/**\n * Checks whether or not a node contains a string literal with an octal or non-octal decimal escape sequence\n * @param {ASTNode} node A node to check\n * @returns {boolean} `true` if at least one string literal within the node contains\n * an octal or non-octal decimal escape sequence\n */\nfunction hasOctalOrNonOctalDecimalEscapeSequence(node) {\n  if (isConcatenation(node)) {\n    return hasOctalOrNonOctalDecimalEscapeSequence(node.left) || hasOctalOrNonOctalDecimalEscapeSequence(node.right);\n  }\n\n  // No need to check TemplateLiterals â€“ would throw parsing error\n  if (node.type === \"Literal\" && typeof node.value === \"string\") {\n    return astUtils.hasOctalOrNonOctalDecimalEscapeSequence(node.raw);\n  }\n  return false;\n}\n\n/**\n * Checks whether or not a given binary expression has string literals.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node has string literals.\n */\nfunction hasStringLiteral(node) {\n  if (isConcatenation(node)) {\n    // `left` is deeper than `right` normally.\n    return hasStringLiteral(node.right) || hasStringLiteral(node.left);\n  }\n  return astUtils.isStringLiteral(node);\n}\n\n/**\n * Checks whether or not a given binary expression has non string literals.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node has non string literals.\n */\nfunction hasNonStringLiteral(node) {\n  if (isConcatenation(node)) {\n    // `left` is deeper than `right` normally.\n    return hasNonStringLiteral(node.right) || hasNonStringLiteral(node.left);\n  }\n  return !astUtils.isStringLiteral(node);\n}\n\n/**\n * Determines whether a given node will start with a template curly expression (`${}`) when being converted to a template literal.\n * @param {ASTNode} node The node that will be fixed to a template literal\n * @returns {boolean} `true` if the node will start with a template curly.\n */\nfunction startsWithTemplateCurly(node) {\n  if (node.type === \"BinaryExpression\") {\n    return startsWithTemplateCurly(node.left);\n  }\n  if (node.type === \"TemplateLiteral\") {\n    return node.expressions.length && node.quasis.length && node.quasis[0].range[0] === node.quasis[0].range[1];\n  }\n  return node.type !== \"Literal\" || typeof node.value !== \"string\";\n}\n\n/**\n * Determines whether a given node end with a template curly expression (`${}`) when being converted to a template literal.\n * @param {ASTNode} node The node that will be fixed to a template literal\n * @returns {boolean} `true` if the node will end with a template curly.\n */\nfunction endsWithTemplateCurly(node) {\n  if (node.type === \"BinaryExpression\") {\n    return startsWithTemplateCurly(node.right);\n  }\n  if (node.type === \"TemplateLiteral\") {\n    return node.expressions.length && node.quasis.length && node.quasis[node.quasis.length - 1].range[0] === node.quasis[node.quasis.length - 1].range[1];\n  }\n  return node.type !== \"Literal\" || typeof node.value !== \"string\";\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require template literals instead of string concatenation\",\n      category: \"ECMAScript 6\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/prefer-template\"\n    },\n    schema: [],\n    fixable: \"code\",\n    messages: {\n      unexpectedStringConcatenation: \"Unexpected string concatenation.\"\n    }\n  },\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    let done = Object.create(null);\n\n    /**\n     * Gets the non-token text between two nodes, ignoring any other tokens that appear between the two tokens.\n     * @param {ASTNode} node1 The first node\n     * @param {ASTNode} node2 The second node\n     * @returns {string} The text between the nodes, excluding other tokens\n     */\n    function getTextBetween(node1, node2) {\n      const allTokens = [node1].concat(sourceCode.getTokensBetween(node1, node2)).concat(node2);\n      const sourceText = sourceCode.getText();\n      return allTokens.slice(0, -1).reduce((accumulator, token, index) => accumulator + sourceText.slice(token.range[1], allTokens[index + 1].range[0]), \"\");\n    }\n\n    /**\n     * Returns a template literal form of the given node.\n     * @param {ASTNode} currentNode A node that should be converted to a template literal\n     * @param {string} textBeforeNode Text that should appear before the node\n     * @param {string} textAfterNode Text that should appear after the node\n     * @returns {string} A string form of this node, represented as a template literal\n     */\n    function getTemplateLiteral(currentNode, textBeforeNode, textAfterNode) {\n      if (currentNode.type === \"Literal\" && typeof currentNode.value === \"string\") {\n        /*\n         * If the current node is a string literal, escape any instances of ${ or ` to prevent them from being interpreted\n         * as a template placeholder. However, if the code already contains a backslash before the ${ or `\n         * for some reason, don't add another backslash, because that would change the meaning of the code (it would cause\n         * an actual backslash character to appear before the dollar sign).\n         */\n        return `\\`${currentNode.raw.slice(1, -1).replace(/\\\\*(\\$\\{|`)/gu, matched => {\n          if (matched.lastIndexOf(\"\\\\\") % 2) {\n            return `\\\\${matched}`;\n          }\n          return matched;\n\n          // Unescape any quotes that appear in the original Literal that no longer need to be escaped.\n        }).replace(new RegExp(`\\\\\\\\${currentNode.raw[0]}`, \"gu\"), currentNode.raw[0])}\\``;\n      }\n      if (currentNode.type === \"TemplateLiteral\") {\n        return sourceCode.getText(currentNode);\n      }\n      if (isConcatenation(currentNode) && hasStringLiteral(currentNode) && hasNonStringLiteral(currentNode)) {\n        const plusSign = sourceCode.getFirstTokenBetween(currentNode.left, currentNode.right, token => token.value === \"+\");\n        const textBeforePlus = getTextBetween(currentNode.left, plusSign);\n        const textAfterPlus = getTextBetween(plusSign, currentNode.right);\n        const leftEndsWithCurly = endsWithTemplateCurly(currentNode.left);\n        const rightStartsWithCurly = startsWithTemplateCurly(currentNode.right);\n        if (leftEndsWithCurly) {\n          // If the left side of the expression ends with a template curly, add the extra text to the end of the curly bracket.\n          // `foo${bar}` /* comment */ + 'baz' --> `foo${bar /* comment */  }${baz}`\n          return getTemplateLiteral(currentNode.left, textBeforeNode, textBeforePlus + textAfterPlus).slice(0, -1) + getTemplateLiteral(currentNode.right, null, textAfterNode).slice(1);\n        }\n        if (rightStartsWithCurly) {\n          // Otherwise, if the right side of the expression starts with a template curly, add the text there.\n          // 'foo' /* comment */ + `${bar}baz` --> `foo${ /* comment */  bar}baz`\n          return getTemplateLiteral(currentNode.left, textBeforeNode, null).slice(0, -1) + getTemplateLiteral(currentNode.right, textBeforePlus + textAfterPlus, textAfterNode).slice(1);\n        }\n\n        /*\n         * Otherwise, these nodes should not be combined into a template curly, since there is nowhere to put\n         * the text between them.\n         */\n        return `${getTemplateLiteral(currentNode.left, textBeforeNode, null)}${textBeforePlus}+${textAfterPlus}${getTemplateLiteral(currentNode.right, textAfterNode, null)}`;\n      }\n      return `\\`\\${${textBeforeNode || \"\"}${sourceCode.getText(currentNode)}${textAfterNode || \"\"}}\\``;\n    }\n\n    /**\n     * Returns a fixer object that converts a non-string binary expression to a template literal\n     * @param {SourceCodeFixer} fixer The fixer object\n     * @param {ASTNode} node A node that should be converted to a template literal\n     * @returns {Object} A fix for this binary expression\n     */\n    function fixNonStringBinaryExpression(fixer, node) {\n      const topBinaryExpr = getTopConcatBinaryExpression(node.parent);\n      if (hasOctalOrNonOctalDecimalEscapeSequence(topBinaryExpr)) {\n        return null;\n      }\n      return fixer.replaceText(topBinaryExpr, getTemplateLiteral(topBinaryExpr, null, null));\n    }\n\n    /**\n     * Reports if a given node is string concatenation with non string literals.\n     * @param {ASTNode} node A node to check.\n     * @returns {void}\n     */\n    function checkForStringConcat(node) {\n      if (!astUtils.isStringLiteral(node) || !isConcatenation(node.parent)) {\n        return;\n      }\n      const topBinaryExpr = getTopConcatBinaryExpression(node.parent);\n\n      // Checks whether or not this node had been checked already.\n      if (done[topBinaryExpr.range[0]]) {\n        return;\n      }\n      done[topBinaryExpr.range[0]] = true;\n      if (hasNonStringLiteral(topBinaryExpr)) {\n        context.report({\n          node: topBinaryExpr,\n          messageId: \"unexpectedStringConcatenation\",\n          fix: fixer => fixNonStringBinaryExpression(fixer, node)\n        });\n      }\n    }\n    return {\n      Program() {\n        done = Object.create(null);\n      },\n      Literal: checkForStringConcat,\n      TemplateLiteral: checkForStringConcat\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","isConcatenation","node","type","operator","getTopConcatBinaryExpression","currentNode","parent","hasOctalOrNonOctalDecimalEscapeSequence","left","right","value","raw","hasStringLiteral","isStringLiteral","hasNonStringLiteral","startsWithTemplateCurly","expressions","length","quasis","range","endsWithTemplateCurly","module","exports","meta","docs","description","category","recommended","url","schema","fixable","messages","unexpectedStringConcatenation","create","context","sourceCode","getSourceCode","done","Object","getTextBetween","node1","node2","allTokens","concat","getTokensBetween","sourceText","getText","slice","reduce","accumulator","token","index","getTemplateLiteral","textBeforeNode","textAfterNode","replace","matched","lastIndexOf","RegExp","plusSign","getFirstTokenBetween","textBeforePlus","textAfterPlus","leftEndsWithCurly","rightStartsWithCurly","fixNonStringBinaryExpression","fixer","topBinaryExpr","replaceText","checkForStringConcat","report","messageId","fix","Program","Literal","TemplateLiteral"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/prefer-template.js"],"sourcesContent":["/**\n * @fileoverview A rule to suggest using template literals instead of string concatenation.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given node is a concatenation.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node is a concatenation.\n */\nfunction isConcatenation(node) {\n    return node.type === \"BinaryExpression\" && node.operator === \"+\";\n}\n\n/**\n * Gets the top binary expression node for concatenation in parents of a given node.\n * @param {ASTNode} node A node to get.\n * @returns {ASTNode} the top binary expression node in parents of a given node.\n */\nfunction getTopConcatBinaryExpression(node) {\n    let currentNode = node;\n\n    while (isConcatenation(currentNode.parent)) {\n        currentNode = currentNode.parent;\n    }\n    return currentNode;\n}\n\n/**\n * Checks whether or not a node contains a string literal with an octal or non-octal decimal escape sequence\n * @param {ASTNode} node A node to check\n * @returns {boolean} `true` if at least one string literal within the node contains\n * an octal or non-octal decimal escape sequence\n */\nfunction hasOctalOrNonOctalDecimalEscapeSequence(node) {\n    if (isConcatenation(node)) {\n        return (\n            hasOctalOrNonOctalDecimalEscapeSequence(node.left) ||\n            hasOctalOrNonOctalDecimalEscapeSequence(node.right)\n        );\n    }\n\n    // No need to check TemplateLiterals â€“ would throw parsing error\n    if (node.type === \"Literal\" && typeof node.value === \"string\") {\n        return astUtils.hasOctalOrNonOctalDecimalEscapeSequence(node.raw);\n    }\n\n    return false;\n}\n\n/**\n * Checks whether or not a given binary expression has string literals.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node has string literals.\n */\nfunction hasStringLiteral(node) {\n    if (isConcatenation(node)) {\n\n        // `left` is deeper than `right` normally.\n        return hasStringLiteral(node.right) || hasStringLiteral(node.left);\n    }\n    return astUtils.isStringLiteral(node);\n}\n\n/**\n * Checks whether or not a given binary expression has non string literals.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node has non string literals.\n */\nfunction hasNonStringLiteral(node) {\n    if (isConcatenation(node)) {\n\n        // `left` is deeper than `right` normally.\n        return hasNonStringLiteral(node.right) || hasNonStringLiteral(node.left);\n    }\n    return !astUtils.isStringLiteral(node);\n}\n\n/**\n * Determines whether a given node will start with a template curly expression (`${}`) when being converted to a template literal.\n * @param {ASTNode} node The node that will be fixed to a template literal\n * @returns {boolean} `true` if the node will start with a template curly.\n */\nfunction startsWithTemplateCurly(node) {\n    if (node.type === \"BinaryExpression\") {\n        return startsWithTemplateCurly(node.left);\n    }\n    if (node.type === \"TemplateLiteral\") {\n        return node.expressions.length && node.quasis.length && node.quasis[0].range[0] === node.quasis[0].range[1];\n    }\n    return node.type !== \"Literal\" || typeof node.value !== \"string\";\n}\n\n/**\n * Determines whether a given node end with a template curly expression (`${}`) when being converted to a template literal.\n * @param {ASTNode} node The node that will be fixed to a template literal\n * @returns {boolean} `true` if the node will end with a template curly.\n */\nfunction endsWithTemplateCurly(node) {\n    if (node.type === \"BinaryExpression\") {\n        return startsWithTemplateCurly(node.right);\n    }\n    if (node.type === \"TemplateLiteral\") {\n        return node.expressions.length && node.quasis.length && node.quasis[node.quasis.length - 1].range[0] === node.quasis[node.quasis.length - 1].range[1];\n    }\n    return node.type !== \"Literal\" || typeof node.value !== \"string\";\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require template literals instead of string concatenation\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/prefer-template\"\n        },\n\n        schema: [],\n        fixable: \"code\",\n\n        messages: {\n            unexpectedStringConcatenation: \"Unexpected string concatenation.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        let done = Object.create(null);\n\n        /**\n         * Gets the non-token text between two nodes, ignoring any other tokens that appear between the two tokens.\n         * @param {ASTNode} node1 The first node\n         * @param {ASTNode} node2 The second node\n         * @returns {string} The text between the nodes, excluding other tokens\n         */\n        function getTextBetween(node1, node2) {\n            const allTokens = [node1].concat(sourceCode.getTokensBetween(node1, node2)).concat(node2);\n            const sourceText = sourceCode.getText();\n\n            return allTokens.slice(0, -1).reduce((accumulator, token, index) => accumulator + sourceText.slice(token.range[1], allTokens[index + 1].range[0]), \"\");\n        }\n\n        /**\n         * Returns a template literal form of the given node.\n         * @param {ASTNode} currentNode A node that should be converted to a template literal\n         * @param {string} textBeforeNode Text that should appear before the node\n         * @param {string} textAfterNode Text that should appear after the node\n         * @returns {string} A string form of this node, represented as a template literal\n         */\n        function getTemplateLiteral(currentNode, textBeforeNode, textAfterNode) {\n            if (currentNode.type === \"Literal\" && typeof currentNode.value === \"string\") {\n\n                /*\n                 * If the current node is a string literal, escape any instances of ${ or ` to prevent them from being interpreted\n                 * as a template placeholder. However, if the code already contains a backslash before the ${ or `\n                 * for some reason, don't add another backslash, because that would change the meaning of the code (it would cause\n                 * an actual backslash character to appear before the dollar sign).\n                 */\n                return `\\`${currentNode.raw.slice(1, -1).replace(/\\\\*(\\$\\{|`)/gu, matched => {\n                    if (matched.lastIndexOf(\"\\\\\") % 2) {\n                        return `\\\\${matched}`;\n                    }\n                    return matched;\n\n                // Unescape any quotes that appear in the original Literal that no longer need to be escaped.\n                }).replace(new RegExp(`\\\\\\\\${currentNode.raw[0]}`, \"gu\"), currentNode.raw[0])}\\``;\n            }\n\n            if (currentNode.type === \"TemplateLiteral\") {\n                return sourceCode.getText(currentNode);\n            }\n\n            if (isConcatenation(currentNode) && hasStringLiteral(currentNode) && hasNonStringLiteral(currentNode)) {\n                const plusSign = sourceCode.getFirstTokenBetween(currentNode.left, currentNode.right, token => token.value === \"+\");\n                const textBeforePlus = getTextBetween(currentNode.left, plusSign);\n                const textAfterPlus = getTextBetween(plusSign, currentNode.right);\n                const leftEndsWithCurly = endsWithTemplateCurly(currentNode.left);\n                const rightStartsWithCurly = startsWithTemplateCurly(currentNode.right);\n\n                if (leftEndsWithCurly) {\n\n                    // If the left side of the expression ends with a template curly, add the extra text to the end of the curly bracket.\n                    // `foo${bar}` /* comment */ + 'baz' --> `foo${bar /* comment */  }${baz}`\n                    return getTemplateLiteral(currentNode.left, textBeforeNode, textBeforePlus + textAfterPlus).slice(0, -1) +\n                        getTemplateLiteral(currentNode.right, null, textAfterNode).slice(1);\n                }\n                if (rightStartsWithCurly) {\n\n                    // Otherwise, if the right side of the expression starts with a template curly, add the text there.\n                    // 'foo' /* comment */ + `${bar}baz` --> `foo${ /* comment */  bar}baz`\n                    return getTemplateLiteral(currentNode.left, textBeforeNode, null).slice(0, -1) +\n                        getTemplateLiteral(currentNode.right, textBeforePlus + textAfterPlus, textAfterNode).slice(1);\n                }\n\n                /*\n                 * Otherwise, these nodes should not be combined into a template curly, since there is nowhere to put\n                 * the text between them.\n                 */\n                return `${getTemplateLiteral(currentNode.left, textBeforeNode, null)}${textBeforePlus}+${textAfterPlus}${getTemplateLiteral(currentNode.right, textAfterNode, null)}`;\n            }\n\n            return `\\`\\${${textBeforeNode || \"\"}${sourceCode.getText(currentNode)}${textAfterNode || \"\"}}\\``;\n        }\n\n        /**\n         * Returns a fixer object that converts a non-string binary expression to a template literal\n         * @param {SourceCodeFixer} fixer The fixer object\n         * @param {ASTNode} node A node that should be converted to a template literal\n         * @returns {Object} A fix for this binary expression\n         */\n        function fixNonStringBinaryExpression(fixer, node) {\n            const topBinaryExpr = getTopConcatBinaryExpression(node.parent);\n\n            if (hasOctalOrNonOctalDecimalEscapeSequence(topBinaryExpr)) {\n                return null;\n            }\n\n            return fixer.replaceText(topBinaryExpr, getTemplateLiteral(topBinaryExpr, null, null));\n        }\n\n        /**\n         * Reports if a given node is string concatenation with non string literals.\n         * @param {ASTNode} node A node to check.\n         * @returns {void}\n         */\n        function checkForStringConcat(node) {\n            if (!astUtils.isStringLiteral(node) || !isConcatenation(node.parent)) {\n                return;\n            }\n\n            const topBinaryExpr = getTopConcatBinaryExpression(node.parent);\n\n            // Checks whether or not this node had been checked already.\n            if (done[topBinaryExpr.range[0]]) {\n                return;\n            }\n            done[topBinaryExpr.range[0]] = true;\n\n            if (hasNonStringLiteral(topBinaryExpr)) {\n                context.report({\n                    node: topBinaryExpr,\n                    messageId: \"unexpectedStringConcatenation\",\n                    fix: fixer => fixNonStringBinaryExpression(fixer, node)\n                });\n            }\n        }\n\n        return {\n            Program() {\n                done = Object.create(null);\n            },\n\n            Literal: checkForStringConcat,\n            TemplateLiteral: checkForStringConcat\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}