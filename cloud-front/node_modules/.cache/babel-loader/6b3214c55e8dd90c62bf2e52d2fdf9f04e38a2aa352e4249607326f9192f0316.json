{"ast":null,"code":"/**\n * @fileoverview Rule to flag use of variables before they are defined\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\nconst SENTINEL_TYPE = /^(?:(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression|CatchClause|ImportDeclaration|ExportNamedDeclaration)$/u;\nconst FOR_IN_OF_TYPE = /^For(?:In|Of)Statement$/u;\n\n/**\n * Parses a given value as options.\n * @param {any} options A value to parse.\n * @returns {Object} The parsed options.\n */\nfunction parseOptions(options) {\n  let functions = true;\n  let classes = true;\n  let variables = true;\n  if (typeof options === \"string\") {\n    functions = options !== \"nofunc\";\n  } else if (typeof options === \"object\" && options !== null) {\n    functions = options.functions !== false;\n    classes = options.classes !== false;\n    variables = options.variables !== false;\n  }\n  return {\n    functions,\n    classes,\n    variables\n  };\n}\n\n/**\n * Checks whether or not a given variable is a function declaration.\n * @param {eslint-scope.Variable} variable A variable to check.\n * @returns {boolean} `true` if the variable is a function declaration.\n */\nfunction isFunction(variable) {\n  return variable.defs[0].type === \"FunctionName\";\n}\n\n/**\n * Checks whether or not a given variable is a class declaration in an upper function scope.\n * @param {eslint-scope.Variable} variable A variable to check.\n * @param {eslint-scope.Reference} reference A reference to check.\n * @returns {boolean} `true` if the variable is a class declaration.\n */\nfunction isOuterClass(variable, reference) {\n  return variable.defs[0].type === \"ClassName\" && variable.scope.variableScope !== reference.from.variableScope;\n}\n\n/**\n * Checks whether or not a given variable is a variable declaration in an upper function scope.\n * @param {eslint-scope.Variable} variable A variable to check.\n * @param {eslint-scope.Reference} reference A reference to check.\n * @returns {boolean} `true` if the variable is a variable declaration.\n */\nfunction isOuterVariable(variable, reference) {\n  return variable.defs[0].type === \"Variable\" && variable.scope.variableScope !== reference.from.variableScope;\n}\n\n/**\n * Checks whether or not a given location is inside of the range of a given node.\n * @param {ASTNode} node An node to check.\n * @param {number} location A location to check.\n * @returns {boolean} `true` if the location is inside of the range of the node.\n */\nfunction isInRange(node, location) {\n  return node && node.range[0] <= location && location <= node.range[1];\n}\n\n/**\n * Checks whether or not a given reference is inside of the initializers of a given variable.\n *\n * This returns `true` in the following cases:\n *\n *     var a = a\n *     var [a = a] = list\n *     var {a = a} = obj\n *     for (var a in a) {}\n *     for (var a of a) {}\n * @param {Variable} variable A variable to check.\n * @param {Reference} reference A reference to check.\n * @returns {boolean} `true` if the reference is inside of the initializers.\n */\nfunction isInInitializer(variable, reference) {\n  if (variable.scope !== reference.from) {\n    return false;\n  }\n  let node = variable.identifiers[0].parent;\n  const location = reference.identifier.range[1];\n  while (node) {\n    if (node.type === \"VariableDeclarator\") {\n      if (isInRange(node.init, location)) {\n        return true;\n      }\n      if (FOR_IN_OF_TYPE.test(node.parent.parent.type) && isInRange(node.parent.parent.right, location)) {\n        return true;\n      }\n      break;\n    } else if (node.type === \"AssignmentPattern\") {\n      if (isInRange(node.right, location)) {\n        return true;\n      }\n    } else if (SENTINEL_TYPE.test(node.type)) {\n      break;\n    }\n    node = node.parent;\n  }\n  return false;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow the use of variables before they are defined\",\n      category: \"Variables\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-use-before-define\"\n    },\n    schema: [{\n      oneOf: [{\n        enum: [\"nofunc\"]\n      }, {\n        type: \"object\",\n        properties: {\n          functions: {\n            type: \"boolean\"\n          },\n          classes: {\n            type: \"boolean\"\n          },\n          variables: {\n            type: \"boolean\"\n          }\n        },\n        additionalProperties: false\n      }]\n    }],\n    messages: {\n      usedBeforeDefined: \"'{{name}}' was used before it was defined.\"\n    }\n  },\n  create(context) {\n    const options = parseOptions(context.options[0]);\n\n    /**\n     * Determines whether a given use-before-define case should be reported according to the options.\n     * @param {eslint-scope.Variable} variable The variable that gets used before being defined\n     * @param {eslint-scope.Reference} reference The reference to the variable\n     * @returns {boolean} `true` if the usage should be reported\n     */\n    function isForbidden(variable, reference) {\n      if (isFunction(variable)) {\n        return options.functions;\n      }\n      if (isOuterClass(variable, reference)) {\n        return options.classes;\n      }\n      if (isOuterVariable(variable, reference)) {\n        return options.variables;\n      }\n      return true;\n    }\n\n    /**\n     * Finds and validates all variables in a given scope.\n     * @param {Scope} scope The scope object.\n     * @returns {void}\n     * @private\n     */\n    function findVariablesInScope(scope) {\n      scope.references.forEach(reference => {\n        const variable = reference.resolved;\n\n        /*\n         * Skips when the reference is:\n         * - initialization's.\n         * - referring to an undefined variable.\n         * - referring to a global environment variable (there're no identifiers).\n         * - located preceded by the variable (except in initializers).\n         * - allowed by options.\n         */\n        if (reference.init || !variable || variable.identifiers.length === 0 || variable.identifiers[0].range[1] < reference.identifier.range[1] && !isInInitializer(variable, reference) || !isForbidden(variable, reference)) {\n          return;\n        }\n\n        // Reports.\n        context.report({\n          node: reference.identifier,\n          messageId: \"usedBeforeDefined\",\n          data: reference.identifier\n        });\n      });\n      scope.childScopes.forEach(findVariablesInScope);\n    }\n    return {\n      Program() {\n        findVariablesInScope(context.getScope());\n      }\n    };\n  }\n};","map":{"version":3,"names":["SENTINEL_TYPE","FOR_IN_OF_TYPE","parseOptions","options","functions","classes","variables","isFunction","variable","defs","type","isOuterClass","reference","scope","variableScope","from","isOuterVariable","isInRange","node","location","range","isInInitializer","identifiers","parent","identifier","init","test","right","module","exports","meta","docs","description","category","recommended","url","schema","oneOf","enum","properties","additionalProperties","messages","usedBeforeDefined","create","context","isForbidden","findVariablesInScope","references","forEach","resolved","length","report","messageId","data","childScopes","Program","getScope"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/no-use-before-define.js"],"sourcesContent":["/**\n * @fileoverview Rule to flag use of variables before they are defined\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst SENTINEL_TYPE = /^(?:(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression|CatchClause|ImportDeclaration|ExportNamedDeclaration)$/u;\nconst FOR_IN_OF_TYPE = /^For(?:In|Of)Statement$/u;\n\n/**\n * Parses a given value as options.\n * @param {any} options A value to parse.\n * @returns {Object} The parsed options.\n */\nfunction parseOptions(options) {\n    let functions = true;\n    let classes = true;\n    let variables = true;\n\n    if (typeof options === \"string\") {\n        functions = (options !== \"nofunc\");\n    } else if (typeof options === \"object\" && options !== null) {\n        functions = options.functions !== false;\n        classes = options.classes !== false;\n        variables = options.variables !== false;\n    }\n\n    return { functions, classes, variables };\n}\n\n/**\n * Checks whether or not a given variable is a function declaration.\n * @param {eslint-scope.Variable} variable A variable to check.\n * @returns {boolean} `true` if the variable is a function declaration.\n */\nfunction isFunction(variable) {\n    return variable.defs[0].type === \"FunctionName\";\n}\n\n/**\n * Checks whether or not a given variable is a class declaration in an upper function scope.\n * @param {eslint-scope.Variable} variable A variable to check.\n * @param {eslint-scope.Reference} reference A reference to check.\n * @returns {boolean} `true` if the variable is a class declaration.\n */\nfunction isOuterClass(variable, reference) {\n    return (\n        variable.defs[0].type === \"ClassName\" &&\n        variable.scope.variableScope !== reference.from.variableScope\n    );\n}\n\n/**\n * Checks whether or not a given variable is a variable declaration in an upper function scope.\n * @param {eslint-scope.Variable} variable A variable to check.\n * @param {eslint-scope.Reference} reference A reference to check.\n * @returns {boolean} `true` if the variable is a variable declaration.\n */\nfunction isOuterVariable(variable, reference) {\n    return (\n        variable.defs[0].type === \"Variable\" &&\n        variable.scope.variableScope !== reference.from.variableScope\n    );\n}\n\n/**\n * Checks whether or not a given location is inside of the range of a given node.\n * @param {ASTNode} node An node to check.\n * @param {number} location A location to check.\n * @returns {boolean} `true` if the location is inside of the range of the node.\n */\nfunction isInRange(node, location) {\n    return node && node.range[0] <= location && location <= node.range[1];\n}\n\n/**\n * Checks whether or not a given reference is inside of the initializers of a given variable.\n *\n * This returns `true` in the following cases:\n *\n *     var a = a\n *     var [a = a] = list\n *     var {a = a} = obj\n *     for (var a in a) {}\n *     for (var a of a) {}\n * @param {Variable} variable A variable to check.\n * @param {Reference} reference A reference to check.\n * @returns {boolean} `true` if the reference is inside of the initializers.\n */\nfunction isInInitializer(variable, reference) {\n    if (variable.scope !== reference.from) {\n        return false;\n    }\n\n    let node = variable.identifiers[0].parent;\n    const location = reference.identifier.range[1];\n\n    while (node) {\n        if (node.type === \"VariableDeclarator\") {\n            if (isInRange(node.init, location)) {\n                return true;\n            }\n            if (FOR_IN_OF_TYPE.test(node.parent.parent.type) &&\n                isInRange(node.parent.parent.right, location)\n            ) {\n                return true;\n            }\n            break;\n        } else if (node.type === \"AssignmentPattern\") {\n            if (isInRange(node.right, location)) {\n                return true;\n            }\n        } else if (SENTINEL_TYPE.test(node.type)) {\n            break;\n        }\n\n        node = node.parent;\n    }\n\n    return false;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow the use of variables before they are defined\",\n            category: \"Variables\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-use-before-define\"\n        },\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"nofunc\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            functions: { type: \"boolean\" },\n                            classes: { type: \"boolean\" },\n                            variables: { type: \"boolean\" }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ],\n\n        messages: {\n            usedBeforeDefined: \"'{{name}}' was used before it was defined.\"\n        }\n    },\n\n    create(context) {\n        const options = parseOptions(context.options[0]);\n\n        /**\n         * Determines whether a given use-before-define case should be reported according to the options.\n         * @param {eslint-scope.Variable} variable The variable that gets used before being defined\n         * @param {eslint-scope.Reference} reference The reference to the variable\n         * @returns {boolean} `true` if the usage should be reported\n         */\n        function isForbidden(variable, reference) {\n            if (isFunction(variable)) {\n                return options.functions;\n            }\n            if (isOuterClass(variable, reference)) {\n                return options.classes;\n            }\n            if (isOuterVariable(variable, reference)) {\n                return options.variables;\n            }\n            return true;\n        }\n\n        /**\n         * Finds and validates all variables in a given scope.\n         * @param {Scope} scope The scope object.\n         * @returns {void}\n         * @private\n         */\n        function findVariablesInScope(scope) {\n            scope.references.forEach(reference => {\n                const variable = reference.resolved;\n\n                /*\n                 * Skips when the reference is:\n                 * - initialization's.\n                 * - referring to an undefined variable.\n                 * - referring to a global environment variable (there're no identifiers).\n                 * - located preceded by the variable (except in initializers).\n                 * - allowed by options.\n                 */\n                if (reference.init ||\n                    !variable ||\n                    variable.identifiers.length === 0 ||\n                    (variable.identifiers[0].range[1] < reference.identifier.range[1] && !isInInitializer(variable, reference)) ||\n                    !isForbidden(variable, reference)\n                ) {\n                    return;\n                }\n\n                // Reports.\n                context.report({\n                    node: reference.identifier,\n                    messageId: \"usedBeforeDefined\",\n                    data: reference.identifier\n                });\n            });\n\n            scope.childScopes.forEach(findVariablesInScope);\n        }\n\n        return {\n            Program() {\n                findVariablesInScope(context.getScope());\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}