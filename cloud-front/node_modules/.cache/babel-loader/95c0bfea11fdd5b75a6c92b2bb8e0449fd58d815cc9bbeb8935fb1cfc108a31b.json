{"ast":null,"code":"/**\n * @fileoverview Validates spacing before and after semicolon\n * @author Mathias Schreck\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce consistent spacing before and after semicolons\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/semi-spacing\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      type: \"object\",\n      properties: {\n        before: {\n          type: \"boolean\",\n          default: false\n        },\n        after: {\n          type: \"boolean\",\n          default: true\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unexpectedWhitespaceBefore: \"Unexpected whitespace before semicolon.\",\n      unexpectedWhitespaceAfter: \"Unexpected whitespace after semicolon.\",\n      missingWhitespaceBefore: \"Missing whitespace before semicolon.\",\n      missingWhitespaceAfter: \"Missing whitespace after semicolon.\"\n    }\n  },\n  create(context) {\n    const config = context.options[0],\n      sourceCode = context.getSourceCode();\n    let requireSpaceBefore = false,\n      requireSpaceAfter = true;\n    if (typeof config === \"object\") {\n      requireSpaceBefore = config.before;\n      requireSpaceAfter = config.after;\n    }\n\n    /**\n     * Checks if a given token has leading whitespace.\n     * @param {Object} token The token to check.\n     * @returns {boolean} True if the given token has leading space, false if not.\n     */\n    function hasLeadingSpace(token) {\n      const tokenBefore = sourceCode.getTokenBefore(token);\n      return tokenBefore && astUtils.isTokenOnSameLine(tokenBefore, token) && sourceCode.isSpaceBetweenTokens(tokenBefore, token);\n    }\n\n    /**\n     * Checks if a given token has trailing whitespace.\n     * @param {Object} token The token to check.\n     * @returns {boolean} True if the given token has trailing space, false if not.\n     */\n    function hasTrailingSpace(token) {\n      const tokenAfter = sourceCode.getTokenAfter(token);\n      return tokenAfter && astUtils.isTokenOnSameLine(token, tokenAfter) && sourceCode.isSpaceBetweenTokens(token, tokenAfter);\n    }\n\n    /**\n     * Checks if the given token is the last token in its line.\n     * @param {Token} token The token to check.\n     * @returns {boolean} Whether or not the token is the last in its line.\n     */\n    function isLastTokenInCurrentLine(token) {\n      const tokenAfter = sourceCode.getTokenAfter(token);\n      return !(tokenAfter && astUtils.isTokenOnSameLine(token, tokenAfter));\n    }\n\n    /**\n     * Checks if the given token is the first token in its line\n     * @param {Token} token The token to check.\n     * @returns {boolean} Whether or not the token is the first in its line.\n     */\n    function isFirstTokenInCurrentLine(token) {\n      const tokenBefore = sourceCode.getTokenBefore(token);\n      return !(tokenBefore && astUtils.isTokenOnSameLine(token, tokenBefore));\n    }\n\n    /**\n     * Checks if the next token of a given token is a closing parenthesis.\n     * @param {Token} token The token to check.\n     * @returns {boolean} Whether or not the next token of a given token is a closing parenthesis.\n     */\n    function isBeforeClosingParen(token) {\n      const nextToken = sourceCode.getTokenAfter(token);\n      return nextToken && astUtils.isClosingBraceToken(nextToken) || astUtils.isClosingParenToken(nextToken);\n    }\n\n    /**\n     * Report location example :\n     *\n     * for unexpected space `before`\n     *\n     * var a = 'b'   ;\n     *            ^^^\n     *\n     * for unexpected space `after`\n     *\n     * var a = 'b';  c = 10;\n     *             ^^\n     *\n     * Reports if the given token has invalid spacing.\n     * @param {Token} token The semicolon token to check.\n     * @param {ASTNode} node The corresponding node of the token.\n     * @returns {void}\n     */\n    function checkSemicolonSpacing(token, node) {\n      if (astUtils.isSemicolonToken(token)) {\n        if (hasLeadingSpace(token)) {\n          if (!requireSpaceBefore) {\n            const tokenBefore = sourceCode.getTokenBefore(token);\n            const loc = {\n              start: tokenBefore.loc.end,\n              end: token.loc.start\n            };\n            context.report({\n              node,\n              loc,\n              messageId: \"unexpectedWhitespaceBefore\",\n              fix(fixer) {\n                return fixer.removeRange([tokenBefore.range[1], token.range[0]]);\n              }\n            });\n          }\n        } else {\n          if (requireSpaceBefore) {\n            const loc = token.loc;\n            context.report({\n              node,\n              loc,\n              messageId: \"missingWhitespaceBefore\",\n              fix(fixer) {\n                return fixer.insertTextBefore(token, \" \");\n              }\n            });\n          }\n        }\n        if (!isFirstTokenInCurrentLine(token) && !isLastTokenInCurrentLine(token) && !isBeforeClosingParen(token)) {\n          if (hasTrailingSpace(token)) {\n            if (!requireSpaceAfter) {\n              const tokenAfter = sourceCode.getTokenAfter(token);\n              const loc = {\n                start: token.loc.end,\n                end: tokenAfter.loc.start\n              };\n              context.report({\n                node,\n                loc,\n                messageId: \"unexpectedWhitespaceAfter\",\n                fix(fixer) {\n                  return fixer.removeRange([token.range[1], tokenAfter.range[0]]);\n                }\n              });\n            }\n          } else {\n            if (requireSpaceAfter) {\n              const loc = token.loc;\n              context.report({\n                node,\n                loc,\n                messageId: \"missingWhitespaceAfter\",\n                fix(fixer) {\n                  return fixer.insertTextAfter(token, \" \");\n                }\n              });\n            }\n          }\n        }\n      }\n    }\n\n    /**\n     * Checks the spacing of the semicolon with the assumption that the last token is the semicolon.\n     * @param {ASTNode} node The node to check.\n     * @returns {void}\n     */\n    function checkNode(node) {\n      const token = sourceCode.getLastToken(node);\n      checkSemicolonSpacing(token, node);\n    }\n    return {\n      VariableDeclaration: checkNode,\n      ExpressionStatement: checkNode,\n      BreakStatement: checkNode,\n      ContinueStatement: checkNode,\n      DebuggerStatement: checkNode,\n      DoWhileStatement: checkNode,\n      ReturnStatement: checkNode,\n      ThrowStatement: checkNode,\n      ImportDeclaration: checkNode,\n      ExportNamedDeclaration: checkNode,\n      ExportAllDeclaration: checkNode,\n      ExportDefaultDeclaration: checkNode,\n      ForStatement(node) {\n        if (node.init) {\n          checkSemicolonSpacing(sourceCode.getTokenAfter(node.init), node);\n        }\n        if (node.test) {\n          checkSemicolonSpacing(sourceCode.getTokenAfter(node.test), node);\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","module","exports","meta","type","docs","description","category","recommended","url","fixable","schema","properties","before","default","after","additionalProperties","messages","unexpectedWhitespaceBefore","unexpectedWhitespaceAfter","missingWhitespaceBefore","missingWhitespaceAfter","create","context","config","options","sourceCode","getSourceCode","requireSpaceBefore","requireSpaceAfter","hasLeadingSpace","token","tokenBefore","getTokenBefore","isTokenOnSameLine","isSpaceBetweenTokens","hasTrailingSpace","tokenAfter","getTokenAfter","isLastTokenInCurrentLine","isFirstTokenInCurrentLine","isBeforeClosingParen","nextToken","isClosingBraceToken","isClosingParenToken","checkSemicolonSpacing","node","isSemicolonToken","loc","start","end","report","messageId","fix","fixer","removeRange","range","insertTextBefore","insertTextAfter","checkNode","getLastToken","VariableDeclaration","ExpressionStatement","BreakStatement","ContinueStatement","DebuggerStatement","DoWhileStatement","ReturnStatement","ThrowStatement","ImportDeclaration","ExportNamedDeclaration","ExportAllDeclaration","ExportDefaultDeclaration","ForStatement","init","test"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/semi-spacing.js"],"sourcesContent":["/**\n * @fileoverview Validates spacing before and after semicolon\n * @author Mathias Schreck\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce consistent spacing before and after semicolons\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/semi-spacing\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    before: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    after: {\n                        type: \"boolean\",\n                        default: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            unexpectedWhitespaceBefore: \"Unexpected whitespace before semicolon.\",\n            unexpectedWhitespaceAfter: \"Unexpected whitespace after semicolon.\",\n            missingWhitespaceBefore: \"Missing whitespace before semicolon.\",\n            missingWhitespaceAfter: \"Missing whitespace after semicolon.\"\n        }\n    },\n\n    create(context) {\n\n        const config = context.options[0],\n            sourceCode = context.getSourceCode();\n        let requireSpaceBefore = false,\n            requireSpaceAfter = true;\n\n        if (typeof config === \"object\") {\n            requireSpaceBefore = config.before;\n            requireSpaceAfter = config.after;\n        }\n\n        /**\n         * Checks if a given token has leading whitespace.\n         * @param {Object} token The token to check.\n         * @returns {boolean} True if the given token has leading space, false if not.\n         */\n        function hasLeadingSpace(token) {\n            const tokenBefore = sourceCode.getTokenBefore(token);\n\n            return tokenBefore && astUtils.isTokenOnSameLine(tokenBefore, token) && sourceCode.isSpaceBetweenTokens(tokenBefore, token);\n        }\n\n        /**\n         * Checks if a given token has trailing whitespace.\n         * @param {Object} token The token to check.\n         * @returns {boolean} True if the given token has trailing space, false if not.\n         */\n        function hasTrailingSpace(token) {\n            const tokenAfter = sourceCode.getTokenAfter(token);\n\n            return tokenAfter && astUtils.isTokenOnSameLine(token, tokenAfter) && sourceCode.isSpaceBetweenTokens(token, tokenAfter);\n        }\n\n        /**\n         * Checks if the given token is the last token in its line.\n         * @param {Token} token The token to check.\n         * @returns {boolean} Whether or not the token is the last in its line.\n         */\n        function isLastTokenInCurrentLine(token) {\n            const tokenAfter = sourceCode.getTokenAfter(token);\n\n            return !(tokenAfter && astUtils.isTokenOnSameLine(token, tokenAfter));\n        }\n\n        /**\n         * Checks if the given token is the first token in its line\n         * @param {Token} token The token to check.\n         * @returns {boolean} Whether or not the token is the first in its line.\n         */\n        function isFirstTokenInCurrentLine(token) {\n            const tokenBefore = sourceCode.getTokenBefore(token);\n\n            return !(tokenBefore && astUtils.isTokenOnSameLine(token, tokenBefore));\n        }\n\n        /**\n         * Checks if the next token of a given token is a closing parenthesis.\n         * @param {Token} token The token to check.\n         * @returns {boolean} Whether or not the next token of a given token is a closing parenthesis.\n         */\n        function isBeforeClosingParen(token) {\n            const nextToken = sourceCode.getTokenAfter(token);\n\n            return (nextToken && astUtils.isClosingBraceToken(nextToken) || astUtils.isClosingParenToken(nextToken));\n        }\n\n        /**\n         * Report location example :\n         *\n         * for unexpected space `before`\n         *\n         * var a = 'b'   ;\n         *            ^^^\n         *\n         * for unexpected space `after`\n         *\n         * var a = 'b';  c = 10;\n         *             ^^\n         *\n         * Reports if the given token has invalid spacing.\n         * @param {Token} token The semicolon token to check.\n         * @param {ASTNode} node The corresponding node of the token.\n         * @returns {void}\n         */\n        function checkSemicolonSpacing(token, node) {\n            if (astUtils.isSemicolonToken(token)) {\n                if (hasLeadingSpace(token)) {\n                    if (!requireSpaceBefore) {\n                        const tokenBefore = sourceCode.getTokenBefore(token);\n                        const loc = {\n                            start: tokenBefore.loc.end,\n                            end: token.loc.start\n                        };\n\n                        context.report({\n                            node,\n                            loc,\n                            messageId: \"unexpectedWhitespaceBefore\",\n                            fix(fixer) {\n\n                                return fixer.removeRange([tokenBefore.range[1], token.range[0]]);\n                            }\n                        });\n                    }\n                } else {\n                    if (requireSpaceBefore) {\n                        const loc = token.loc;\n\n                        context.report({\n                            node,\n                            loc,\n                            messageId: \"missingWhitespaceBefore\",\n                            fix(fixer) {\n                                return fixer.insertTextBefore(token, \" \");\n                            }\n                        });\n                    }\n                }\n\n                if (!isFirstTokenInCurrentLine(token) && !isLastTokenInCurrentLine(token) && !isBeforeClosingParen(token)) {\n                    if (hasTrailingSpace(token)) {\n                        if (!requireSpaceAfter) {\n                            const tokenAfter = sourceCode.getTokenAfter(token);\n                            const loc = {\n                                start: token.loc.end,\n                                end: tokenAfter.loc.start\n                            };\n\n                            context.report({\n                                node,\n                                loc,\n                                messageId: \"unexpectedWhitespaceAfter\",\n                                fix(fixer) {\n\n                                    return fixer.removeRange([token.range[1], tokenAfter.range[0]]);\n                                }\n                            });\n                        }\n                    } else {\n                        if (requireSpaceAfter) {\n                            const loc = token.loc;\n\n                            context.report({\n                                node,\n                                loc,\n                                messageId: \"missingWhitespaceAfter\",\n                                fix(fixer) {\n                                    return fixer.insertTextAfter(token, \" \");\n                                }\n                            });\n                        }\n                    }\n                }\n            }\n        }\n\n        /**\n         * Checks the spacing of the semicolon with the assumption that the last token is the semicolon.\n         * @param {ASTNode} node The node to check.\n         * @returns {void}\n         */\n        function checkNode(node) {\n            const token = sourceCode.getLastToken(node);\n\n            checkSemicolonSpacing(token, node);\n        }\n\n        return {\n            VariableDeclaration: checkNode,\n            ExpressionStatement: checkNode,\n            BreakStatement: checkNode,\n            ContinueStatement: checkNode,\n            DebuggerStatement: checkNode,\n            DoWhileStatement: checkNode,\n            ReturnStatement: checkNode,\n            ThrowStatement: checkNode,\n            ImportDeclaration: checkNode,\n            ExportNamedDeclaration: checkNode,\n            ExportAllDeclaration: checkNode,\n            ExportDefaultDeclaration: checkNode,\n            ForStatement(node) {\n                if (node.init) {\n                    checkSemicolonSpacing(sourceCode.getTokenAfter(node.init), node);\n                }\n\n                if (node.test) {\n                    checkSemicolonSpacing(sourceCode.getTokenAfter(node.test), node);\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}