{"ast":null,"code":"/**\n * @fileoverview Rule to flag unnecessary double negation in Boolean contexts\n * @author Brandon Mills\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils\");\nconst eslintUtils = require(\"eslint-utils\");\nconst precedence = astUtils.getPrecedence;\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow unnecessary boolean casts\",\n      category: \"Possible Errors\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-extra-boolean-cast\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        enforceForLogicalOperands: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    fixable: \"code\",\n    messages: {\n      unexpectedCall: \"Redundant Boolean call.\",\n      unexpectedNegation: \"Redundant double negation.\"\n    }\n  },\n  create(context) {\n    const sourceCode = context.getSourceCode();\n\n    // Node types which have a test which will coerce values to booleans.\n    const BOOLEAN_NODE_TYPES = [\"IfStatement\", \"DoWhileStatement\", \"WhileStatement\", \"ConditionalExpression\", \"ForStatement\"];\n\n    /**\n     * Check if a node is a Boolean function or constructor.\n     * @param {ASTNode} node the node\n     * @returns {boolean} If the node is Boolean function or constructor\n     */\n    function isBooleanFunctionOrConstructorCall(node) {\n      // Boolean(<bool>) and new Boolean(<bool>)\n      return (node.type === \"CallExpression\" || node.type === \"NewExpression\") && node.callee.type === \"Identifier\" && node.callee.name === \"Boolean\";\n    }\n\n    /**\n     * Checks whether the node is a logical expression and that the option is enabled\n     * @param {ASTNode} node the node\n     * @returns {boolean} if the node is a logical expression and option is enabled\n     */\n    function isLogicalContext(node) {\n      return node.type === \"LogicalExpression\" && (node.operator === \"||\" || node.operator === \"&&\") && context.options.length && context.options[0].enforceForLogicalOperands === true;\n    }\n\n    /**\n     * Check if a node is in a context where its value would be coerced to a boolean at runtime.\n     * @param {ASTNode} node The node\n     * @returns {boolean} If it is in a boolean context\n     */\n    function isInBooleanContext(node) {\n      return isBooleanFunctionOrConstructorCall(node.parent) && node === node.parent.arguments[0] || BOOLEAN_NODE_TYPES.indexOf(node.parent.type) !== -1 && node === node.parent.test ||\n      // !<bool>\n      node.parent.type === \"UnaryExpression\" && node.parent.operator === \"!\";\n    }\n\n    /**\n     * Checks whether the node is a context that should report an error\n     * Acts recursively if it is in a logical context\n     * @param {ASTNode} node the node\n     * @returns {boolean} If the node is in one of the flagged contexts\n     */\n    function isInFlaggedContext(node) {\n      if (node.parent.type === \"ChainExpression\") {\n        return isInFlaggedContext(node.parent);\n      }\n      return isInBooleanContext(node) || isLogicalContext(node.parent) &&\n      // For nested logical statements\n      isInFlaggedContext(node.parent);\n    }\n\n    /**\n     * Check if a node has comments inside.\n     * @param {ASTNode} node The node to check.\n     * @returns {boolean} `true` if it has comments inside.\n     */\n    function hasCommentsInside(node) {\n      return Boolean(sourceCode.getCommentsInside(node).length);\n    }\n\n    /**\n     * Checks if the given node is wrapped in grouping parentheses. Parentheses for constructs such as if() don't count.\n     * @param {ASTNode} node The node to check.\n     * @returns {boolean} `true` if the node is parenthesized.\n     * @private\n     */\n    function isParenthesized(node) {\n      return eslintUtils.isParenthesized(1, node, sourceCode);\n    }\n\n    /**\n     * Determines whether the given node needs to be parenthesized when replacing the previous node.\n     * It assumes that `previousNode` is the node to be reported by this rule, so it has a limited list\n     * of possible parent node types. By the same assumption, the node's role in a particular parent is already known.\n     * For example, if the parent is `ConditionalExpression`, `previousNode` must be its `test` child.\n     * @param {ASTNode} previousNode Previous node.\n     * @param {ASTNode} node The node to check.\n     * @returns {boolean} `true` if the node needs to be parenthesized.\n     */\n    function needsParens(previousNode, node) {\n      if (previousNode.parent.type === \"ChainExpression\") {\n        return needsParens(previousNode.parent, node);\n      }\n      if (isParenthesized(previousNode)) {\n        // parentheses around the previous node will stay, so there is no need for an additional pair\n        return false;\n      }\n\n      // parent of the previous node will become parent of the replacement node\n      const parent = previousNode.parent;\n      switch (parent.type) {\n        case \"CallExpression\":\n        case \"NewExpression\":\n          return node.type === \"SequenceExpression\";\n        case \"IfStatement\":\n        case \"DoWhileStatement\":\n        case \"WhileStatement\":\n        case \"ForStatement\":\n          return false;\n        case \"ConditionalExpression\":\n          return precedence(node) <= precedence(parent);\n        case \"UnaryExpression\":\n          return precedence(node) < precedence(parent);\n        case \"LogicalExpression\":\n          if (astUtils.isMixedLogicalAndCoalesceExpressions(node, parent)) {\n            return true;\n          }\n          if (previousNode === parent.left) {\n            return precedence(node) < precedence(parent);\n          }\n          return precedence(node) <= precedence(parent);\n\n        /* istanbul ignore next */\n        default:\n          throw new Error(`Unexpected parent type: ${parent.type}`);\n      }\n    }\n    return {\n      UnaryExpression(node) {\n        const parent = node.parent;\n\n        // Exit early if it's guaranteed not to match\n        if (node.operator !== \"!\" || parent.type !== \"UnaryExpression\" || parent.operator !== \"!\") {\n          return;\n        }\n        if (isInFlaggedContext(parent)) {\n          context.report({\n            node: parent,\n            messageId: \"unexpectedNegation\",\n            fix(fixer) {\n              if (hasCommentsInside(parent)) {\n                return null;\n              }\n              if (needsParens(parent, node.argument)) {\n                return fixer.replaceText(parent, `(${sourceCode.getText(node.argument)})`);\n              }\n              let prefix = \"\";\n              const tokenBefore = sourceCode.getTokenBefore(parent);\n              const firstReplacementToken = sourceCode.getFirstToken(node.argument);\n              if (tokenBefore && tokenBefore.range[1] === parent.range[0] && !astUtils.canTokensBeAdjacent(tokenBefore, firstReplacementToken)) {\n                prefix = \" \";\n              }\n              return fixer.replaceText(parent, prefix + sourceCode.getText(node.argument));\n            }\n          });\n        }\n      },\n      CallExpression(node) {\n        if (node.callee.type !== \"Identifier\" || node.callee.name !== \"Boolean\") {\n          return;\n        }\n        if (isInFlaggedContext(node)) {\n          context.report({\n            node,\n            messageId: \"unexpectedCall\",\n            fix(fixer) {\n              const parent = node.parent;\n              if (node.arguments.length === 0) {\n                if (parent.type === \"UnaryExpression\" && parent.operator === \"!\") {\n                  /*\n                   * !Boolean() -> true\n                   */\n\n                  if (hasCommentsInside(parent)) {\n                    return null;\n                  }\n                  const replacement = \"true\";\n                  let prefix = \"\";\n                  const tokenBefore = sourceCode.getTokenBefore(parent);\n                  if (tokenBefore && tokenBefore.range[1] === parent.range[0] && !astUtils.canTokensBeAdjacent(tokenBefore, replacement)) {\n                    prefix = \" \";\n                  }\n                  return fixer.replaceText(parent, prefix + replacement);\n                }\n\n                /*\n                 * Boolean() -> false\n                 */\n\n                if (hasCommentsInside(node)) {\n                  return null;\n                }\n                return fixer.replaceText(node, \"false\");\n              }\n              if (node.arguments.length === 1) {\n                const argument = node.arguments[0];\n                if (argument.type === \"SpreadElement\" || hasCommentsInside(node)) {\n                  return null;\n                }\n\n                /*\n                 * Boolean(expression) -> expression\n                 */\n\n                if (needsParens(node, argument)) {\n                  return fixer.replaceText(node, `(${sourceCode.getText(argument)})`);\n                }\n                return fixer.replaceText(node, sourceCode.getText(argument));\n              }\n\n              // two or more arguments\n              return null;\n            }\n          });\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","eslintUtils","precedence","getPrecedence","module","exports","meta","type","docs","description","category","recommended","url","schema","properties","enforceForLogicalOperands","default","additionalProperties","fixable","messages","unexpectedCall","unexpectedNegation","create","context","sourceCode","getSourceCode","BOOLEAN_NODE_TYPES","isBooleanFunctionOrConstructorCall","node","callee","name","isLogicalContext","operator","options","length","isInBooleanContext","parent","arguments","indexOf","test","isInFlaggedContext","hasCommentsInside","Boolean","getCommentsInside","isParenthesized","needsParens","previousNode","isMixedLogicalAndCoalesceExpressions","left","Error","UnaryExpression","report","messageId","fix","fixer","argument","replaceText","getText","prefix","tokenBefore","getTokenBefore","firstReplacementToken","getFirstToken","range","canTokensBeAdjacent","CallExpression","replacement"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/no-extra-boolean-cast.js"],"sourcesContent":["/**\n * @fileoverview Rule to flag unnecessary double negation in Boolean contexts\n * @author Brandon Mills\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\nconst eslintUtils = require(\"eslint-utils\");\n\nconst precedence = astUtils.getPrecedence;\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow unnecessary boolean casts\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-extra-boolean-cast\"\n        },\n\n        schema: [{\n            type: \"object\",\n            properties: {\n                enforceForLogicalOperands: {\n                    type: \"boolean\",\n                    default: false\n                }\n            },\n            additionalProperties: false\n        }],\n        fixable: \"code\",\n\n        messages: {\n            unexpectedCall: \"Redundant Boolean call.\",\n            unexpectedNegation: \"Redundant double negation.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        // Node types which have a test which will coerce values to booleans.\n        const BOOLEAN_NODE_TYPES = [\n            \"IfStatement\",\n            \"DoWhileStatement\",\n            \"WhileStatement\",\n            \"ConditionalExpression\",\n            \"ForStatement\"\n        ];\n\n        /**\n         * Check if a node is a Boolean function or constructor.\n         * @param {ASTNode} node the node\n         * @returns {boolean} If the node is Boolean function or constructor\n         */\n        function isBooleanFunctionOrConstructorCall(node) {\n\n            // Boolean(<bool>) and new Boolean(<bool>)\n            return (node.type === \"CallExpression\" || node.type === \"NewExpression\") &&\n                    node.callee.type === \"Identifier\" &&\n                        node.callee.name === \"Boolean\";\n        }\n\n        /**\n         * Checks whether the node is a logical expression and that the option is enabled\n         * @param {ASTNode} node the node\n         * @returns {boolean} if the node is a logical expression and option is enabled\n         */\n        function isLogicalContext(node) {\n            return node.type === \"LogicalExpression\" &&\n            (node.operator === \"||\" || node.operator === \"&&\") &&\n            (context.options.length && context.options[0].enforceForLogicalOperands === true);\n\n        }\n\n\n        /**\n         * Check if a node is in a context where its value would be coerced to a boolean at runtime.\n         * @param {ASTNode} node The node\n         * @returns {boolean} If it is in a boolean context\n         */\n        function isInBooleanContext(node) {\n            return (\n                (isBooleanFunctionOrConstructorCall(node.parent) &&\n                node === node.parent.arguments[0]) ||\n\n                (BOOLEAN_NODE_TYPES.indexOf(node.parent.type) !== -1 &&\n                    node === node.parent.test) ||\n\n                // !<bool>\n                (node.parent.type === \"UnaryExpression\" &&\n                    node.parent.operator === \"!\")\n            );\n        }\n\n        /**\n         * Checks whether the node is a context that should report an error\n         * Acts recursively if it is in a logical context\n         * @param {ASTNode} node the node\n         * @returns {boolean} If the node is in one of the flagged contexts\n         */\n        function isInFlaggedContext(node) {\n            if (node.parent.type === \"ChainExpression\") {\n                return isInFlaggedContext(node.parent);\n            }\n\n            return isInBooleanContext(node) ||\n            (isLogicalContext(node.parent) &&\n\n            // For nested logical statements\n            isInFlaggedContext(node.parent)\n            );\n        }\n\n\n        /**\n         * Check if a node has comments inside.\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} `true` if it has comments inside.\n         */\n        function hasCommentsInside(node) {\n            return Boolean(sourceCode.getCommentsInside(node).length);\n        }\n\n        /**\n         * Checks if the given node is wrapped in grouping parentheses. Parentheses for constructs such as if() don't count.\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} `true` if the node is parenthesized.\n         * @private\n         */\n        function isParenthesized(node) {\n            return eslintUtils.isParenthesized(1, node, sourceCode);\n        }\n\n        /**\n         * Determines whether the given node needs to be parenthesized when replacing the previous node.\n         * It assumes that `previousNode` is the node to be reported by this rule, so it has a limited list\n         * of possible parent node types. By the same assumption, the node's role in a particular parent is already known.\n         * For example, if the parent is `ConditionalExpression`, `previousNode` must be its `test` child.\n         * @param {ASTNode} previousNode Previous node.\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} `true` if the node needs to be parenthesized.\n         */\n        function needsParens(previousNode, node) {\n            if (previousNode.parent.type === \"ChainExpression\") {\n                return needsParens(previousNode.parent, node);\n            }\n            if (isParenthesized(previousNode)) {\n\n                // parentheses around the previous node will stay, so there is no need for an additional pair\n                return false;\n            }\n\n            // parent of the previous node will become parent of the replacement node\n            const parent = previousNode.parent;\n\n            switch (parent.type) {\n                case \"CallExpression\":\n                case \"NewExpression\":\n                    return node.type === \"SequenceExpression\";\n                case \"IfStatement\":\n                case \"DoWhileStatement\":\n                case \"WhileStatement\":\n                case \"ForStatement\":\n                    return false;\n                case \"ConditionalExpression\":\n                    return precedence(node) <= precedence(parent);\n                case \"UnaryExpression\":\n                    return precedence(node) < precedence(parent);\n                case \"LogicalExpression\":\n                    if (astUtils.isMixedLogicalAndCoalesceExpressions(node, parent)) {\n                        return true;\n                    }\n                    if (previousNode === parent.left) {\n                        return precedence(node) < precedence(parent);\n                    }\n                    return precedence(node) <= precedence(parent);\n\n                /* istanbul ignore next */\n                default:\n                    throw new Error(`Unexpected parent type: ${parent.type}`);\n            }\n        }\n\n        return {\n            UnaryExpression(node) {\n                const parent = node.parent;\n\n\n                // Exit early if it's guaranteed not to match\n                if (node.operator !== \"!\" ||\n                          parent.type !== \"UnaryExpression\" ||\n                          parent.operator !== \"!\") {\n                    return;\n                }\n\n\n                if (isInFlaggedContext(parent)) {\n                    context.report({\n                        node: parent,\n                        messageId: \"unexpectedNegation\",\n                        fix(fixer) {\n                            if (hasCommentsInside(parent)) {\n                                return null;\n                            }\n\n                            if (needsParens(parent, node.argument)) {\n                                return fixer.replaceText(parent, `(${sourceCode.getText(node.argument)})`);\n                            }\n\n                            let prefix = \"\";\n                            const tokenBefore = sourceCode.getTokenBefore(parent);\n                            const firstReplacementToken = sourceCode.getFirstToken(node.argument);\n\n                            if (\n                                tokenBefore &&\n                                tokenBefore.range[1] === parent.range[0] &&\n                                !astUtils.canTokensBeAdjacent(tokenBefore, firstReplacementToken)\n                            ) {\n                                prefix = \" \";\n                            }\n\n                            return fixer.replaceText(parent, prefix + sourceCode.getText(node.argument));\n                        }\n                    });\n                }\n            },\n\n            CallExpression(node) {\n                if (node.callee.type !== \"Identifier\" || node.callee.name !== \"Boolean\") {\n                    return;\n                }\n\n                if (isInFlaggedContext(node)) {\n                    context.report({\n                        node,\n                        messageId: \"unexpectedCall\",\n                        fix(fixer) {\n                            const parent = node.parent;\n\n                            if (node.arguments.length === 0) {\n                                if (parent.type === \"UnaryExpression\" && parent.operator === \"!\") {\n\n                                    /*\n                                     * !Boolean() -> true\n                                     */\n\n                                    if (hasCommentsInside(parent)) {\n                                        return null;\n                                    }\n\n                                    const replacement = \"true\";\n                                    let prefix = \"\";\n                                    const tokenBefore = sourceCode.getTokenBefore(parent);\n\n                                    if (\n                                        tokenBefore &&\n                                        tokenBefore.range[1] === parent.range[0] &&\n                                        !astUtils.canTokensBeAdjacent(tokenBefore, replacement)\n                                    ) {\n                                        prefix = \" \";\n                                    }\n\n                                    return fixer.replaceText(parent, prefix + replacement);\n                                }\n\n                                /*\n                                 * Boolean() -> false\n                                 */\n\n                                if (hasCommentsInside(node)) {\n                                    return null;\n                                }\n\n                                return fixer.replaceText(node, \"false\");\n                            }\n\n                            if (node.arguments.length === 1) {\n                                const argument = node.arguments[0];\n\n                                if (argument.type === \"SpreadElement\" || hasCommentsInside(node)) {\n                                    return null;\n                                }\n\n                                /*\n                                 * Boolean(expression) -> expression\n                                 */\n\n                                if (needsParens(node, argument)) {\n                                    return fixer.replaceText(node, `(${sourceCode.getText(argument)})`);\n                                }\n\n                                return fixer.replaceText(node, sourceCode.getText(argument));\n                            }\n\n                            // two or more arguments\n                            return null;\n                        }\n                    });\n                }\n            }\n        };\n\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}