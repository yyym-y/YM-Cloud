{"ast":null,"code":"/**\n * @fileoverview A variant of EventEmitter which does not give listeners information about each other\n * @author Teddy Katz\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/**\n * An event emitter\n * @typedef {Object} SafeEmitter\n * @property {function(eventName: string, listenerFunc: Function): void} on Adds a listener for a given event name\n * @property {function(eventName: string, arg1?: any, arg2?: any, arg3?: any)} emit Emits an event with a given name.\n * This calls all the listeners that were listening for that name, with `arg1`, `arg2`, and `arg3` as arguments.\n * @property {function(): string[]} eventNames Gets the list of event names that have registered listeners.\n */\n\n/**\n * Creates an object which can listen for and emit events.\n * This is similar to the EventEmitter API in Node's standard library, but it has a few differences.\n * The goal is to allow multiple modules to attach arbitrary listeners to the same emitter, without\n * letting the modules know about each other at all.\n * 1. It has no special keys like `error` and `newListener`, which would allow modules to detect when\n * another module throws an error or registers a listener.\n * 2. It calls listener functions without any `this` value. (`EventEmitter` calls listeners with a\n * `this` value of the emitter instance, which would give listeners access to other listeners.)\n * @returns {SafeEmitter} An emitter\n */\nrequire(\"core-js/modules/es.array.push.js\");\nmodule.exports = () => {\n  const listeners = Object.create(null);\n  return Object.freeze({\n    on(eventName, listener) {\n      if (eventName in listeners) {\n        listeners[eventName].push(listener);\n      } else {\n        listeners[eventName] = [listener];\n      }\n    },\n    emit(eventName, ...args) {\n      if (eventName in listeners) {\n        listeners[eventName].forEach(listener => listener(...args));\n      }\n    },\n    eventNames() {\n      return Object.keys(listeners);\n    }\n  });\n};","map":{"version":3,"names":["require","module","exports","listeners","Object","create","freeze","on","eventName","listener","push","emit","args","forEach","eventNames","keys"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/linter/safe-emitter.js"],"sourcesContent":["/**\n * @fileoverview A variant of EventEmitter which does not give listeners information about each other\n * @author Teddy Katz\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/**\n * An event emitter\n * @typedef {Object} SafeEmitter\n * @property {function(eventName: string, listenerFunc: Function): void} on Adds a listener for a given event name\n * @property {function(eventName: string, arg1?: any, arg2?: any, arg3?: any)} emit Emits an event with a given name.\n * This calls all the listeners that were listening for that name, with `arg1`, `arg2`, and `arg3` as arguments.\n * @property {function(): string[]} eventNames Gets the list of event names that have registered listeners.\n */\n\n/**\n * Creates an object which can listen for and emit events.\n * This is similar to the EventEmitter API in Node's standard library, but it has a few differences.\n * The goal is to allow multiple modules to attach arbitrary listeners to the same emitter, without\n * letting the modules know about each other at all.\n * 1. It has no special keys like `error` and `newListener`, which would allow modules to detect when\n * another module throws an error or registers a listener.\n * 2. It calls listener functions without any `this` value. (`EventEmitter` calls listeners with a\n * `this` value of the emitter instance, which would give listeners access to other listeners.)\n * @returns {SafeEmitter} An emitter\n */\nmodule.exports = () => {\n    const listeners = Object.create(null);\n\n    return Object.freeze({\n        on(eventName, listener) {\n            if (eventName in listeners) {\n                listeners[eventName].push(listener);\n            } else {\n                listeners[eventName] = [listener];\n            }\n        },\n        emit(eventName, ...args) {\n            if (eventName in listeners) {\n                listeners[eventName].forEach(listener => listener(...args));\n            }\n        },\n        eventNames() {\n            return Object.keys(listeners);\n        }\n    });\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA,YAAY;;AAEZ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAVAA,OAAA;AAWAC,MAAM,CAACC,OAAO,GAAG,MAAM;EACnB,MAAMC,SAAS,GAAGC,MAAM,CAACC,MAAM,CAAC,IAAI,CAAC;EAErC,OAAOD,MAAM,CAACE,MAAM,CAAC;IACjBC,EAAEA,CAACC,SAAS,EAAEC,QAAQ,EAAE;MACpB,IAAID,SAAS,IAAIL,SAAS,EAAE;QACxBA,SAAS,CAACK,SAAS,CAAC,CAACE,IAAI,CAACD,QAAQ,CAAC;MACvC,CAAC,MAAM;QACHN,SAAS,CAACK,SAAS,CAAC,GAAG,CAACC,QAAQ,CAAC;MACrC;IACJ,CAAC;IACDE,IAAIA,CAACH,SAAS,EAAE,GAAGI,IAAI,EAAE;MACrB,IAAIJ,SAAS,IAAIL,SAAS,EAAE;QACxBA,SAAS,CAACK,SAAS,CAAC,CAACK,OAAO,CAACJ,QAAQ,IAAIA,QAAQ,CAAC,GAAGG,IAAI,CAAC,CAAC;MAC/D;IACJ,CAAC;IACDE,UAAUA,CAAA,EAAG;MACT,OAAOV,MAAM,CAACW,IAAI,CAACZ,SAAS,CAAC;IACjC;EACJ,CAAC,CAAC;AACN,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}