{"ast":null,"code":"/**\n * @fileoverview Rule to disallow useless backreferences in regular expressions\n * @author Milos Djermanovic\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nrequire(\"core-js/modules/es.array.push.js\");\nrequire(\"core-js/modules/es.regexp.flags.js\");\nconst {\n  CALL,\n  CONSTRUCT,\n  ReferenceTracker,\n  getStringIfConstant\n} = require(\"eslint-utils\");\nconst {\n  RegExpParser,\n  visitRegExpAST\n} = require(\"regexpp\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst parser = new RegExpParser();\n\n/**\n * Finds the path from the given `regexpp` AST node to the root node.\n * @param {regexpp.Node} node Node.\n * @returns {regexpp.Node[]} Array that starts with the given node and ends with the root node.\n */\nfunction getPathToRoot(node) {\n  const path = [];\n  let current = node;\n  do {\n    path.push(current);\n    current = current.parent;\n  } while (current);\n  return path;\n}\n\n/**\n * Determines whether the given `regexpp` AST node is a lookaround node.\n * @param {regexpp.Node} node Node.\n * @returns {boolean} `true` if it is a lookaround node.\n */\nfunction isLookaround(node) {\n  return node.type === \"Assertion\" && (node.kind === \"lookahead\" || node.kind === \"lookbehind\");\n}\n\n/**\n * Determines whether the given `regexpp` AST node is a negative lookaround node.\n * @param {regexpp.Node} node Node.\n * @returns {boolean} `true` if it is a negative lookaround node.\n */\nfunction isNegativeLookaround(node) {\n  return isLookaround(node) && node.negate;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow useless backreferences in regular expressions\",\n      category: \"Possible Errors\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-useless-backreference\"\n    },\n    schema: [],\n    messages: {\n      nested: \"Backreference '{{ bref }}' will be ignored. It references group '{{ group }}' from within that group.\",\n      forward: \"Backreference '{{ bref }}' will be ignored. It references group '{{ group }}' which appears later in the pattern.\",\n      backward: \"Backreference '{{ bref }}' will be ignored. It references group '{{ group }}' which appears before in the same lookbehind.\",\n      disjunctive: \"Backreference '{{ bref }}' will be ignored. It references group '{{ group }}' which is in another alternative.\",\n      intoNegativeLookaround: \"Backreference '{{ bref }}' will be ignored. It references group '{{ group }}' which is in a negative lookaround.\"\n    }\n  },\n  create(context) {\n    /**\n     * Checks and reports useless backreferences in the given regular expression.\n     * @param {ASTNode} node Node that represents regular expression. A regex literal or RegExp constructor call.\n     * @param {string} pattern Regular expression pattern.\n     * @param {string} flags Regular expression flags.\n     * @returns {void}\n     */\n    function checkRegex(node, pattern, flags) {\n      let regExpAST;\n      try {\n        regExpAST = parser.parsePattern(pattern, 0, pattern.length, flags.includes(\"u\"));\n      } catch {\n        // Ignore regular expressions with syntax errors\n        return;\n      }\n      visitRegExpAST(regExpAST, {\n        onBackreferenceEnter(bref) {\n          const group = bref.resolved,\n            brefPath = getPathToRoot(bref),\n            groupPath = getPathToRoot(group);\n          let messageId = null;\n          if (brefPath.includes(group)) {\n            // group is bref's ancestor => bref is nested ('nested reference') => group hasn't matched yet when bref starts to match.\n            messageId = \"nested\";\n          } else {\n            // Start from the root to find the lowest common ancestor.\n            let i = brefPath.length - 1,\n              j = groupPath.length - 1;\n            do {\n              i--;\n              j--;\n            } while (brefPath[i] === groupPath[j]);\n            const indexOfLowestCommonAncestor = j + 1,\n              groupCut = groupPath.slice(0, indexOfLowestCommonAncestor),\n              commonPath = groupPath.slice(indexOfLowestCommonAncestor),\n              lowestCommonLookaround = commonPath.find(isLookaround),\n              isMatchingBackward = lowestCommonLookaround && lowestCommonLookaround.kind === \"lookbehind\";\n            if (!isMatchingBackward && bref.end <= group.start) {\n              // bref is left, group is right ('forward reference') => group hasn't matched yet when bref starts to match.\n              messageId = \"forward\";\n            } else if (isMatchingBackward && group.end <= bref.start) {\n              // the opposite of the previous when the regex is matching backward in a lookbehind context.\n              messageId = \"backward\";\n            } else if (groupCut[groupCut.length - 1].type === \"Alternative\") {\n              // group's and bref's ancestor nodes below the lowest common ancestor are sibling alternatives => they're disjunctive.\n              messageId = \"disjunctive\";\n            } else if (groupCut.some(isNegativeLookaround)) {\n              // group is in a negative lookaround which isn't bref's ancestor => group has already failed when bref starts to match.\n              messageId = \"intoNegativeLookaround\";\n            }\n          }\n          if (messageId) {\n            context.report({\n              node,\n              messageId,\n              data: {\n                bref: bref.raw,\n                group: group.raw\n              }\n            });\n          }\n        }\n      });\n    }\n    return {\n      \"Literal[regex]\"(node) {\n        const {\n          pattern,\n          flags\n        } = node.regex;\n        checkRegex(node, pattern, flags);\n      },\n      Program() {\n        const scope = context.getScope(),\n          tracker = new ReferenceTracker(scope),\n          traceMap = {\n            RegExp: {\n              [CALL]: true,\n              [CONSTRUCT]: true\n            }\n          };\n        for (const {\n          node\n        } of tracker.iterateGlobalReferences(traceMap)) {\n          const [patternNode, flagsNode] = node.arguments,\n            pattern = getStringIfConstant(patternNode, scope),\n            flags = getStringIfConstant(flagsNode, scope);\n          if (typeof pattern === \"string\") {\n            checkRegex(node, pattern, flags || \"\");\n          }\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["require","CALL","CONSTRUCT","ReferenceTracker","getStringIfConstant","RegExpParser","visitRegExpAST","parser","getPathToRoot","node","path","current","push","parent","isLookaround","type","kind","isNegativeLookaround","negate","module","exports","meta","docs","description","category","recommended","url","schema","messages","nested","forward","backward","disjunctive","intoNegativeLookaround","create","context","checkRegex","pattern","flags","regExpAST","parsePattern","length","includes","onBackreferenceEnter","bref","group","resolved","brefPath","groupPath","messageId","i","j","indexOfLowestCommonAncestor","groupCut","slice","commonPath","lowestCommonLookaround","find","isMatchingBackward","end","start","some","report","data","raw","Literal[regex]","regex","Program","scope","getScope","tracker","traceMap","RegExp","iterateGlobalReferences","patternNode","flagsNode","arguments"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/no-useless-backreference.js"],"sourcesContent":["/**\n * @fileoverview Rule to disallow useless backreferences in regular expressions\n * @author Milos Djermanovic\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst { CALL, CONSTRUCT, ReferenceTracker, getStringIfConstant } = require(\"eslint-utils\");\nconst { RegExpParser, visitRegExpAST } = require(\"regexpp\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst parser = new RegExpParser();\n\n/**\n * Finds the path from the given `regexpp` AST node to the root node.\n * @param {regexpp.Node} node Node.\n * @returns {regexpp.Node[]} Array that starts with the given node and ends with the root node.\n */\nfunction getPathToRoot(node) {\n    const path = [];\n    let current = node;\n\n    do {\n        path.push(current);\n        current = current.parent;\n    } while (current);\n\n    return path;\n}\n\n/**\n * Determines whether the given `regexpp` AST node is a lookaround node.\n * @param {regexpp.Node} node Node.\n * @returns {boolean} `true` if it is a lookaround node.\n */\nfunction isLookaround(node) {\n    return node.type === \"Assertion\" &&\n        (node.kind === \"lookahead\" || node.kind === \"lookbehind\");\n}\n\n/**\n * Determines whether the given `regexpp` AST node is a negative lookaround node.\n * @param {regexpp.Node} node Node.\n * @returns {boolean} `true` if it is a negative lookaround node.\n */\nfunction isNegativeLookaround(node) {\n    return isLookaround(node) && node.negate;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow useless backreferences in regular expressions\",\n            category: \"Possible Errors\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-useless-backreference\"\n        },\n\n        schema: [],\n\n        messages: {\n            nested: \"Backreference '{{ bref }}' will be ignored. It references group '{{ group }}' from within that group.\",\n            forward: \"Backreference '{{ bref }}' will be ignored. It references group '{{ group }}' which appears later in the pattern.\",\n            backward: \"Backreference '{{ bref }}' will be ignored. It references group '{{ group }}' which appears before in the same lookbehind.\",\n            disjunctive: \"Backreference '{{ bref }}' will be ignored. It references group '{{ group }}' which is in another alternative.\",\n            intoNegativeLookaround: \"Backreference '{{ bref }}' will be ignored. It references group '{{ group }}' which is in a negative lookaround.\"\n        }\n    },\n\n    create(context) {\n\n        /**\n         * Checks and reports useless backreferences in the given regular expression.\n         * @param {ASTNode} node Node that represents regular expression. A regex literal or RegExp constructor call.\n         * @param {string} pattern Regular expression pattern.\n         * @param {string} flags Regular expression flags.\n         * @returns {void}\n         */\n        function checkRegex(node, pattern, flags) {\n            let regExpAST;\n\n            try {\n                regExpAST = parser.parsePattern(pattern, 0, pattern.length, flags.includes(\"u\"));\n            } catch {\n\n                // Ignore regular expressions with syntax errors\n                return;\n            }\n\n            visitRegExpAST(regExpAST, {\n                onBackreferenceEnter(bref) {\n                    const group = bref.resolved,\n                        brefPath = getPathToRoot(bref),\n                        groupPath = getPathToRoot(group);\n                    let messageId = null;\n\n                    if (brefPath.includes(group)) {\n\n                        // group is bref's ancestor => bref is nested ('nested reference') => group hasn't matched yet when bref starts to match.\n                        messageId = \"nested\";\n                    } else {\n\n                        // Start from the root to find the lowest common ancestor.\n                        let i = brefPath.length - 1,\n                            j = groupPath.length - 1;\n\n                        do {\n                            i--;\n                            j--;\n                        } while (brefPath[i] === groupPath[j]);\n\n                        const indexOfLowestCommonAncestor = j + 1,\n                            groupCut = groupPath.slice(0, indexOfLowestCommonAncestor),\n                            commonPath = groupPath.slice(indexOfLowestCommonAncestor),\n                            lowestCommonLookaround = commonPath.find(isLookaround),\n                            isMatchingBackward = lowestCommonLookaround && lowestCommonLookaround.kind === \"lookbehind\";\n\n                        if (!isMatchingBackward && bref.end <= group.start) {\n\n                            // bref is left, group is right ('forward reference') => group hasn't matched yet when bref starts to match.\n                            messageId = \"forward\";\n                        } else if (isMatchingBackward && group.end <= bref.start) {\n\n                            // the opposite of the previous when the regex is matching backward in a lookbehind context.\n                            messageId = \"backward\";\n                        } else if (groupCut[groupCut.length - 1].type === \"Alternative\") {\n\n                            // group's and bref's ancestor nodes below the lowest common ancestor are sibling alternatives => they're disjunctive.\n                            messageId = \"disjunctive\";\n                        } else if (groupCut.some(isNegativeLookaround)) {\n\n                            // group is in a negative lookaround which isn't bref's ancestor => group has already failed when bref starts to match.\n                            messageId = \"intoNegativeLookaround\";\n                        }\n                    }\n\n                    if (messageId) {\n                        context.report({\n                            node,\n                            messageId,\n                            data: {\n                                bref: bref.raw,\n                                group: group.raw\n                            }\n                        });\n                    }\n                }\n            });\n        }\n\n        return {\n            \"Literal[regex]\"(node) {\n                const { pattern, flags } = node.regex;\n\n                checkRegex(node, pattern, flags);\n            },\n            Program() {\n                const scope = context.getScope(),\n                    tracker = new ReferenceTracker(scope),\n                    traceMap = {\n                        RegExp: {\n                            [CALL]: true,\n                            [CONSTRUCT]: true\n                        }\n                    };\n\n                for (const { node } of tracker.iterateGlobalReferences(traceMap)) {\n                    const [patternNode, flagsNode] = node.arguments,\n                        pattern = getStringIfConstant(patternNode, scope),\n                        flags = getStringIfConstant(flagsNode, scope);\n\n                    if (typeof pattern === \"string\") {\n                        checkRegex(node, pattern, flags || \"\");\n                    }\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}