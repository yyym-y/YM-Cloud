{"ast":null,"code":"/**\n * @fileoverview Enforces that a return statement is present in property getters.\n * @author Aladdin-ADD(hh_2013@foxmail.com)\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\nconst TARGET_NODE_TYPE = /^(?:Arrow)?FunctionExpression$/u;\n\n/**\n * Checks a given code path segment is reachable.\n * @param {CodePathSegment} segment A segment to check.\n * @returns {boolean} `true` if the segment is reachable.\n */\nfunction isReachable(segment) {\n  return segment.reachable;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"enforce `return` statements in getters\",\n      category: \"Possible Errors\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/getter-return\"\n    },\n    fixable: null,\n    schema: [{\n      type: \"object\",\n      properties: {\n        allowImplicit: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      expected: \"Expected to return a value in {{name}}.\",\n      expectedAlways: \"Expected {{name}} to always return a value.\"\n    }\n  },\n  create(context) {\n    const options = context.options[0] || {\n      allowImplicit: false\n    };\n    const sourceCode = context.getSourceCode();\n    let funcInfo = {\n      upper: null,\n      codePath: null,\n      hasReturn: false,\n      shouldCheck: false,\n      node: null\n    };\n\n    /**\n     * Checks whether or not the last code path segment is reachable.\n     * Then reports this function if the segment is reachable.\n     *\n     * If the last code path segment is reachable, there are paths which are not\n     * returned or thrown.\n     * @param {ASTNode} node A node to check.\n     * @returns {void}\n     */\n    function checkLastSegment(node) {\n      if (funcInfo.shouldCheck && funcInfo.codePath.currentSegments.some(isReachable)) {\n        context.report({\n          node,\n          loc: astUtils.getFunctionHeadLoc(node, sourceCode),\n          messageId: funcInfo.hasReturn ? \"expectedAlways\" : \"expected\",\n          data: {\n            name: astUtils.getFunctionNameWithKind(funcInfo.node)\n          }\n        });\n      }\n    }\n\n    /**\n     * Checks whether a node means a getter function.\n     * @param {ASTNode} node a node to check.\n     * @returns {boolean} if node means a getter, return true; else return false.\n     */\n    function isGetter(node) {\n      const parent = node.parent;\n      if (TARGET_NODE_TYPE.test(node.type) && node.body.type === \"BlockStatement\") {\n        if (parent.kind === \"get\") {\n          return true;\n        }\n        if (parent.type === \"Property\" && astUtils.getStaticPropertyName(parent) === \"get\" && parent.parent.type === \"ObjectExpression\") {\n          // Object.defineProperty()\n          if (parent.parent.parent.type === \"CallExpression\" && astUtils.getStaticPropertyName(parent.parent.parent.callee) === \"defineProperty\") {\n            return true;\n          }\n\n          // Object.defineProperties()\n          if (parent.parent.parent.type === \"Property\" && parent.parent.parent.parent.type === \"ObjectExpression\" && parent.parent.parent.parent.parent.type === \"CallExpression\" && astUtils.getStaticPropertyName(parent.parent.parent.parent.parent.callee) === \"defineProperties\") {\n            return true;\n          }\n        }\n      }\n      return false;\n    }\n    return {\n      // Stacks this function's information.\n      onCodePathStart(codePath, node) {\n        funcInfo = {\n          upper: funcInfo,\n          codePath,\n          hasReturn: false,\n          shouldCheck: isGetter(node),\n          node\n        };\n      },\n      // Pops this function's information.\n      onCodePathEnd() {\n        funcInfo = funcInfo.upper;\n      },\n      // Checks the return statement is valid.\n      ReturnStatement(node) {\n        if (funcInfo.shouldCheck) {\n          funcInfo.hasReturn = true;\n\n          // if allowImplicit: false, should also check node.argument\n          if (!options.allowImplicit && !node.argument) {\n            context.report({\n              node,\n              messageId: \"expected\",\n              data: {\n                name: astUtils.getFunctionNameWithKind(funcInfo.node)\n              }\n            });\n          }\n        }\n      },\n      // Reports a given function if the last path is reachable.\n      \"FunctionExpression:exit\": checkLastSegment,\n      \"ArrowFunctionExpression:exit\": checkLastSegment\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","TARGET_NODE_TYPE","isReachable","segment","reachable","module","exports","meta","type","docs","description","category","recommended","url","fixable","schema","properties","allowImplicit","default","additionalProperties","messages","expected","expectedAlways","create","context","options","sourceCode","getSourceCode","funcInfo","upper","codePath","hasReturn","shouldCheck","node","checkLastSegment","currentSegments","some","report","loc","getFunctionHeadLoc","messageId","data","name","getFunctionNameWithKind","isGetter","parent","test","body","kind","getStaticPropertyName","callee","onCodePathStart","onCodePathEnd","ReturnStatement","argument"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/getter-return.js"],"sourcesContent":["/**\n * @fileoverview Enforces that a return statement is present in property getters.\n * @author Aladdin-ADD(hh_2013@foxmail.com)\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\nconst TARGET_NODE_TYPE = /^(?:Arrow)?FunctionExpression$/u;\n\n/**\n * Checks a given code path segment is reachable.\n * @param {CodePathSegment} segment A segment to check.\n * @returns {boolean} `true` if the segment is reachable.\n */\nfunction isReachable(segment) {\n    return segment.reachable;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"enforce `return` statements in getters\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/getter-return\"\n        },\n\n        fixable: null,\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allowImplicit: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            expected: \"Expected to return a value in {{name}}.\",\n            expectedAlways: \"Expected {{name}} to always return a value.\"\n        }\n    },\n\n    create(context) {\n\n        const options = context.options[0] || { allowImplicit: false };\n        const sourceCode = context.getSourceCode();\n\n        let funcInfo = {\n            upper: null,\n            codePath: null,\n            hasReturn: false,\n            shouldCheck: false,\n            node: null\n        };\n\n        /**\n         * Checks whether or not the last code path segment is reachable.\n         * Then reports this function if the segment is reachable.\n         *\n         * If the last code path segment is reachable, there are paths which are not\n         * returned or thrown.\n         * @param {ASTNode} node A node to check.\n         * @returns {void}\n         */\n        function checkLastSegment(node) {\n            if (funcInfo.shouldCheck &&\n                funcInfo.codePath.currentSegments.some(isReachable)\n            ) {\n                context.report({\n                    node,\n                    loc: astUtils.getFunctionHeadLoc(node, sourceCode),\n                    messageId: funcInfo.hasReturn ? \"expectedAlways\" : \"expected\",\n                    data: {\n                        name: astUtils.getFunctionNameWithKind(funcInfo.node)\n                    }\n                });\n            }\n        }\n\n        /**\n         * Checks whether a node means a getter function.\n         * @param {ASTNode} node a node to check.\n         * @returns {boolean} if node means a getter, return true; else return false.\n         */\n        function isGetter(node) {\n            const parent = node.parent;\n\n            if (TARGET_NODE_TYPE.test(node.type) && node.body.type === \"BlockStatement\") {\n                if (parent.kind === \"get\") {\n                    return true;\n                }\n                if (parent.type === \"Property\" && astUtils.getStaticPropertyName(parent) === \"get\" && parent.parent.type === \"ObjectExpression\") {\n\n                    // Object.defineProperty()\n                    if (parent.parent.parent.type === \"CallExpression\" &&\n                        astUtils.getStaticPropertyName(parent.parent.parent.callee) === \"defineProperty\") {\n                        return true;\n                    }\n\n                    // Object.defineProperties()\n                    if (parent.parent.parent.type === \"Property\" &&\n                        parent.parent.parent.parent.type === \"ObjectExpression\" &&\n                        parent.parent.parent.parent.parent.type === \"CallExpression\" &&\n                        astUtils.getStaticPropertyName(parent.parent.parent.parent.parent.callee) === \"defineProperties\") {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n        return {\n\n            // Stacks this function's information.\n            onCodePathStart(codePath, node) {\n                funcInfo = {\n                    upper: funcInfo,\n                    codePath,\n                    hasReturn: false,\n                    shouldCheck: isGetter(node),\n                    node\n                };\n            },\n\n            // Pops this function's information.\n            onCodePathEnd() {\n                funcInfo = funcInfo.upper;\n            },\n\n            // Checks the return statement is valid.\n            ReturnStatement(node) {\n                if (funcInfo.shouldCheck) {\n                    funcInfo.hasReturn = true;\n\n                    // if allowImplicit: false, should also check node.argument\n                    if (!options.allowImplicit && !node.argument) {\n                        context.report({\n                            node,\n                            messageId: \"expected\",\n                            data: {\n                                name: astUtils.getFunctionNameWithKind(funcInfo.node)\n                            }\n                        });\n                    }\n                }\n            },\n\n            // Reports a given function if the last path is reachable.\n            \"FunctionExpression:exit\": checkLastSegment,\n            \"ArrowFunctionExpression:exit\": checkLastSegment\n        };\n    }\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA,YAAY;;AAEZ;AACA;AACA;AAEA,MAAMA,QAAQ,GAAGC,OAAO,CAAC,mBAAmB,CAAC;;AAE7C;AACA;AACA;AACA,MAAMC,gBAAgB,GAAG,iCAAiC;;AAE1D;AACA;AACA;AACA;AACA;AACA,SAASC,WAAWA,CAACC,OAAO,EAAE;EAC1B,OAAOA,OAAO,CAACC,SAAS;AAC5B;;AAEA;AACA;AACA;;AAEAC,MAAM,CAACC,OAAO,GAAG;EACbC,IAAI,EAAE;IACFC,IAAI,EAAE,SAAS;IAEfC,IAAI,EAAE;MACFC,WAAW,EAAE,wCAAwC;MACrDC,QAAQ,EAAE,iBAAiB;MAC3BC,WAAW,EAAE,IAAI;MACjBC,GAAG,EAAE;IACT,CAAC;IAEDC,OAAO,EAAE,IAAI;IAEbC,MAAM,EAAE,CACJ;MACIP,IAAI,EAAE,QAAQ;MACdQ,UAAU,EAAE;QACRC,aAAa,EAAE;UACXT,IAAI,EAAE,SAAS;UACfU,OAAO,EAAE;QACb;MACJ,CAAC;MACDC,oBAAoB,EAAE;IAC1B,CAAC,CACJ;IAEDC,QAAQ,EAAE;MACNC,QAAQ,EAAE,yCAAyC;MACnDC,cAAc,EAAE;IACpB;EACJ,CAAC;EAEDC,MAAMA,CAACC,OAAO,EAAE;IAEZ,MAAMC,OAAO,GAAGD,OAAO,CAACC,OAAO,CAAC,CAAC,CAAC,IAAI;MAAER,aAAa,EAAE;IAAM,CAAC;IAC9D,MAAMS,UAAU,GAAGF,OAAO,CAACG,aAAa,CAAC,CAAC;IAE1C,IAAIC,QAAQ,GAAG;MACXC,KAAK,EAAE,IAAI;MACXC,QAAQ,EAAE,IAAI;MACdC,SAAS,EAAE,KAAK;MAChBC,WAAW,EAAE,KAAK;MAClBC,IAAI,EAAE;IACV,CAAC;;IAED;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQ,SAASC,gBAAgBA,CAACD,IAAI,EAAE;MAC5B,IAAIL,QAAQ,CAACI,WAAW,IACpBJ,QAAQ,CAACE,QAAQ,CAACK,eAAe,CAACC,IAAI,CAAClC,WAAW,CAAC,EACrD;QACEsB,OAAO,CAACa,MAAM,CAAC;UACXJ,IAAI;UACJK,GAAG,EAAEvC,QAAQ,CAACwC,kBAAkB,CAACN,IAAI,EAAEP,UAAU,CAAC;UAClDc,SAAS,EAAEZ,QAAQ,CAACG,SAAS,GAAG,gBAAgB,GAAG,UAAU;UAC7DU,IAAI,EAAE;YACFC,IAAI,EAAE3C,QAAQ,CAAC4C,uBAAuB,CAACf,QAAQ,CAACK,IAAI;UACxD;QACJ,CAAC,CAAC;MACN;IACJ;;IAEA;AACR;AACA;AACA;AACA;IACQ,SAASW,QAAQA,CAACX,IAAI,EAAE;MACpB,MAAMY,MAAM,GAAGZ,IAAI,CAACY,MAAM;MAE1B,IAAI5C,gBAAgB,CAAC6C,IAAI,CAACb,IAAI,CAACzB,IAAI,CAAC,IAAIyB,IAAI,CAACc,IAAI,CAACvC,IAAI,KAAK,gBAAgB,EAAE;QACzE,IAAIqC,MAAM,CAACG,IAAI,KAAK,KAAK,EAAE;UACvB,OAAO,IAAI;QACf;QACA,IAAIH,MAAM,CAACrC,IAAI,KAAK,UAAU,IAAIT,QAAQ,CAACkD,qBAAqB,CAACJ,MAAM,CAAC,KAAK,KAAK,IAAIA,MAAM,CAACA,MAAM,CAACrC,IAAI,KAAK,kBAAkB,EAAE;UAE7H;UACA,IAAIqC,MAAM,CAACA,MAAM,CAACA,MAAM,CAACrC,IAAI,KAAK,gBAAgB,IAC9CT,QAAQ,CAACkD,qBAAqB,CAACJ,MAAM,CAACA,MAAM,CAACA,MAAM,CAACK,MAAM,CAAC,KAAK,gBAAgB,EAAE;YAClF,OAAO,IAAI;UACf;;UAEA;UACA,IAAIL,MAAM,CAACA,MAAM,CAACA,MAAM,CAACrC,IAAI,KAAK,UAAU,IACxCqC,MAAM,CAACA,MAAM,CAACA,MAAM,CAACA,MAAM,CAACrC,IAAI,KAAK,kBAAkB,IACvDqC,MAAM,CAACA,MAAM,CAACA,MAAM,CAACA,MAAM,CAACA,MAAM,CAACrC,IAAI,KAAK,gBAAgB,IAC5DT,QAAQ,CAACkD,qBAAqB,CAACJ,MAAM,CAACA,MAAM,CAACA,MAAM,CAACA,MAAM,CAACA,MAAM,CAACK,MAAM,CAAC,KAAK,kBAAkB,EAAE;YAClG,OAAO,IAAI;UACf;QACJ;MACJ;MACA,OAAO,KAAK;IAChB;IACA,OAAO;MAEH;MACAC,eAAeA,CAACrB,QAAQ,EAAEG,IAAI,EAAE;QAC5BL,QAAQ,GAAG;UACPC,KAAK,EAAED,QAAQ;UACfE,QAAQ;UACRC,SAAS,EAAE,KAAK;UAChBC,WAAW,EAAEY,QAAQ,CAACX,IAAI,CAAC;UAC3BA;QACJ,CAAC;MACL,CAAC;MAED;MACAmB,aAAaA,CAAA,EAAG;QACZxB,QAAQ,GAAGA,QAAQ,CAACC,KAAK;MAC7B,CAAC;MAED;MACAwB,eAAeA,CAACpB,IAAI,EAAE;QAClB,IAAIL,QAAQ,CAACI,WAAW,EAAE;UACtBJ,QAAQ,CAACG,SAAS,GAAG,IAAI;;UAEzB;UACA,IAAI,CAACN,OAAO,CAACR,aAAa,IAAI,CAACgB,IAAI,CAACqB,QAAQ,EAAE;YAC1C9B,OAAO,CAACa,MAAM,CAAC;cACXJ,IAAI;cACJO,SAAS,EAAE,UAAU;cACrBC,IAAI,EAAE;gBACFC,IAAI,EAAE3C,QAAQ,CAAC4C,uBAAuB,CAACf,QAAQ,CAACK,IAAI;cACxD;YACJ,CAAC,CAAC;UACN;QACJ;MACJ,CAAC;MAED;MACA,yBAAyB,EAAEC,gBAAgB;MAC3C,8BAA8B,EAAEA;IACpC,CAAC;EACL;AACJ,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}