{"ast":null,"code":"/**\n * @fileoverview Validates JSDoc comments are syntactically correct\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nrequire(\"core-js/modules/es.array.push.js\");\nconst doctrine = require(\"doctrine\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"enforce valid JSDoc comments\",\n      category: \"Possible Errors\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/valid-jsdoc\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        prefer: {\n          type: \"object\",\n          additionalProperties: {\n            type: \"string\"\n          }\n        },\n        preferType: {\n          type: \"object\",\n          additionalProperties: {\n            type: \"string\"\n          }\n        },\n        requireReturn: {\n          type: \"boolean\",\n          default: true\n        },\n        requireParamDescription: {\n          type: \"boolean\",\n          default: true\n        },\n        requireReturnDescription: {\n          type: \"boolean\",\n          default: true\n        },\n        matchDescription: {\n          type: \"string\"\n        },\n        requireReturnType: {\n          type: \"boolean\",\n          default: true\n        },\n        requireParamType: {\n          type: \"boolean\",\n          default: true\n        }\n      },\n      additionalProperties: false\n    }],\n    fixable: \"code\",\n    messages: {\n      unexpectedTag: \"Unexpected @{{title}} tag; function has no return statement.\",\n      expected: \"Expected JSDoc for '{{name}}' but found '{{jsdocName}}'.\",\n      use: \"Use @{{name}} instead.\",\n      useType: \"Use '{{expectedTypeName}}' instead of '{{currentTypeName}}'.\",\n      syntaxError: \"JSDoc syntax error.\",\n      missingBrace: \"JSDoc type missing brace.\",\n      missingParamDesc: \"Missing JSDoc parameter description for '{{name}}'.\",\n      missingParamType: \"Missing JSDoc parameter type for '{{name}}'.\",\n      missingReturnType: \"Missing JSDoc return type.\",\n      missingReturnDesc: \"Missing JSDoc return description.\",\n      missingReturn: \"Missing JSDoc @{{returns}} for function.\",\n      missingParam: \"Missing JSDoc for parameter '{{name}}'.\",\n      duplicateParam: \"Duplicate JSDoc parameter '{{name}}'.\",\n      unsatisfiedDesc: \"JSDoc description does not satisfy the regex pattern.\"\n    },\n    deprecated: true,\n    replacedBy: []\n  },\n  create(context) {\n    const options = context.options[0] || {},\n      prefer = options.prefer || {},\n      sourceCode = context.getSourceCode(),\n      // these both default to true, so you have to explicitly make them false\n      requireReturn = options.requireReturn !== false,\n      requireParamDescription = options.requireParamDescription !== false,\n      requireReturnDescription = options.requireReturnDescription !== false,\n      requireReturnType = options.requireReturnType !== false,\n      requireParamType = options.requireParamType !== false,\n      preferType = options.preferType || {},\n      checkPreferType = Object.keys(preferType).length !== 0;\n\n    //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    // Using a stack to store if a function returns or not (handling nested functions)\n    const fns = [];\n\n    /**\n     * Check if node type is a Class\n     * @param {ASTNode} node node to check.\n     * @returns {boolean} True is its a class\n     * @private\n     */\n    function isTypeClass(node) {\n      return node.type === \"ClassExpression\" || node.type === \"ClassDeclaration\";\n    }\n\n    /**\n     * When parsing a new function, store it in our function stack.\n     * @param {ASTNode} node A function node to check.\n     * @returns {void}\n     * @private\n     */\n    function startFunction(node) {\n      fns.push({\n        returnPresent: node.type === \"ArrowFunctionExpression\" && node.body.type !== \"BlockStatement\" || isTypeClass(node) || node.async\n      });\n    }\n\n    /**\n     * Indicate that return has been found in the current function.\n     * @param {ASTNode} node The return node.\n     * @returns {void}\n     * @private\n     */\n    function addReturn(node) {\n      const functionState = fns[fns.length - 1];\n      if (functionState && node.argument !== null) {\n        functionState.returnPresent = true;\n      }\n    }\n\n    /**\n     * Check if return tag type is void or undefined\n     * @param {Object} tag JSDoc tag\n     * @returns {boolean} True if its of type void or undefined\n     * @private\n     */\n    function isValidReturnType(tag) {\n      return tag.type === null || tag.type.name === \"void\" || tag.type.type === \"UndefinedLiteral\";\n    }\n\n    /**\n     * Check if type should be validated based on some exceptions\n     * @param {Object} type JSDoc tag\n     * @returns {boolean} True if it can be validated\n     * @private\n     */\n    function canTypeBeValidated(type) {\n      return type !== \"UndefinedLiteral\" &&\n      // {undefined} as there is no name property available.\n      type !== \"NullLiteral\" &&\n      // {null}\n      type !== \"NullableLiteral\" &&\n      // {?}\n      type !== \"FunctionType\" &&\n      // {function(a)}\n      type !== \"AllLiteral\"; // {*}\n    }\n\n    /**\n     * Extract the current and expected type based on the input type object\n     * @param {Object} type JSDoc tag\n     * @returns {{currentType: Doctrine.Type, expectedTypeName: string}} The current type annotation and\n     * the expected name of the annotation\n     * @private\n     */\n    function getCurrentExpectedTypes(type) {\n      let currentType;\n      if (type.name) {\n        currentType = type;\n      } else if (type.expression) {\n        currentType = type.expression;\n      }\n      return {\n        currentType,\n        expectedTypeName: currentType && preferType[currentType.name]\n      };\n    }\n\n    /**\n     * Gets the location of a JSDoc node in a file\n     * @param {Token} jsdocComment The comment that this node is parsed from\n     * @param {{range: number[]}} parsedJsdocNode A tag or other node which was parsed from this comment\n     * @returns {{start: SourceLocation, end: SourceLocation}} The 0-based source location for the tag\n     */\n    function getAbsoluteRange(jsdocComment, parsedJsdocNode) {\n      return {\n        start: sourceCode.getLocFromIndex(jsdocComment.range[0] + 2 + parsedJsdocNode.range[0]),\n        end: sourceCode.getLocFromIndex(jsdocComment.range[0] + 2 + parsedJsdocNode.range[1])\n      };\n    }\n\n    /**\n     * Validate type for a given JSDoc node\n     * @param {Object} jsdocNode JSDoc node\n     * @param {Object} type JSDoc tag\n     * @returns {void}\n     * @private\n     */\n    function validateType(jsdocNode, type) {\n      if (!type || !canTypeBeValidated(type.type)) {\n        return;\n      }\n      const typesToCheck = [];\n      let elements = [];\n      switch (type.type) {\n        case \"TypeApplication\":\n          // {Array.<String>}\n          elements = type.applications[0].type === \"UnionType\" ? type.applications[0].elements : type.applications;\n          typesToCheck.push(getCurrentExpectedTypes(type));\n          break;\n        case \"RecordType\":\n          // {{20:String}}\n          elements = type.fields;\n          break;\n        case \"UnionType\": // {String|number|Test}\n        case \"ArrayType\":\n          // {[String, number, Test]}\n          elements = type.elements;\n          break;\n        case \"FieldType\":\n          // Array.<{count: number, votes: number}>\n          if (type.value) {\n            typesToCheck.push(getCurrentExpectedTypes(type.value));\n          }\n          break;\n        default:\n          typesToCheck.push(getCurrentExpectedTypes(type));\n      }\n      elements.forEach(validateType.bind(null, jsdocNode));\n      typesToCheck.forEach(typeToCheck => {\n        if (typeToCheck.expectedTypeName && typeToCheck.expectedTypeName !== typeToCheck.currentType.name) {\n          context.report({\n            node: jsdocNode,\n            messageId: \"useType\",\n            loc: getAbsoluteRange(jsdocNode, typeToCheck.currentType),\n            data: {\n              currentTypeName: typeToCheck.currentType.name,\n              expectedTypeName: typeToCheck.expectedTypeName\n            },\n            fix(fixer) {\n              return fixer.replaceTextRange(typeToCheck.currentType.range.map(indexInComment => jsdocNode.range[0] + 2 + indexInComment), typeToCheck.expectedTypeName);\n            }\n          });\n        }\n      });\n    }\n\n    /**\n     * Validate the JSDoc node and output warnings if anything is wrong.\n     * @param {ASTNode} node The AST node to check.\n     * @returns {void}\n     * @private\n     */\n    function checkJSDoc(node) {\n      const jsdocNode = sourceCode.getJSDocComment(node),\n        functionData = fns.pop(),\n        paramTagsByName = Object.create(null),\n        paramTags = [];\n      let hasReturns = false,\n        returnsTag,\n        hasConstructor = false,\n        isInterface = false,\n        isOverride = false,\n        isAbstract = false;\n\n      // make sure only to validate JSDoc comments\n      if (jsdocNode) {\n        let jsdoc;\n        try {\n          jsdoc = doctrine.parse(jsdocNode.value, {\n            strict: true,\n            unwrap: true,\n            sloppy: true,\n            range: true\n          });\n        } catch (ex) {\n          if (/braces/iu.test(ex.message)) {\n            context.report({\n              node: jsdocNode,\n              messageId: \"missingBrace\"\n            });\n          } else {\n            context.report({\n              node: jsdocNode,\n              messageId: \"syntaxError\"\n            });\n          }\n          return;\n        }\n        jsdoc.tags.forEach(tag => {\n          switch (tag.title.toLowerCase()) {\n            case \"param\":\n            case \"arg\":\n            case \"argument\":\n              paramTags.push(tag);\n              break;\n            case \"return\":\n            case \"returns\":\n              hasReturns = true;\n              returnsTag = tag;\n              break;\n            case \"constructor\":\n            case \"class\":\n              hasConstructor = true;\n              break;\n            case \"override\":\n            case \"inheritdoc\":\n              isOverride = true;\n              break;\n            case \"abstract\":\n            case \"virtual\":\n              isAbstract = true;\n              break;\n            case \"interface\":\n              isInterface = true;\n              break;\n\n            // no default\n          }\n\n          // check tag preferences\n          if (Object.prototype.hasOwnProperty.call(prefer, tag.title) && tag.title !== prefer[tag.title]) {\n            const entireTagRange = getAbsoluteRange(jsdocNode, tag);\n            context.report({\n              node: jsdocNode,\n              messageId: \"use\",\n              loc: {\n                start: entireTagRange.start,\n                end: {\n                  line: entireTagRange.start.line,\n                  column: entireTagRange.start.column + `@${tag.title}`.length\n                }\n              },\n              data: {\n                name: prefer[tag.title]\n              },\n              fix(fixer) {\n                return fixer.replaceTextRange([jsdocNode.range[0] + tag.range[0] + 3, jsdocNode.range[0] + tag.range[0] + tag.title.length + 3], prefer[tag.title]);\n              }\n            });\n          }\n\n          // validate the types\n          if (checkPreferType && tag.type) {\n            validateType(jsdocNode, tag.type);\n          }\n        });\n        paramTags.forEach(param => {\n          if (requireParamType && !param.type) {\n            context.report({\n              node: jsdocNode,\n              messageId: \"missingParamType\",\n              loc: getAbsoluteRange(jsdocNode, param),\n              data: {\n                name: param.name\n              }\n            });\n          }\n          if (!param.description && requireParamDescription) {\n            context.report({\n              node: jsdocNode,\n              messageId: \"missingParamDesc\",\n              loc: getAbsoluteRange(jsdocNode, param),\n              data: {\n                name: param.name\n              }\n            });\n          }\n          if (paramTagsByName[param.name]) {\n            context.report({\n              node: jsdocNode,\n              messageId: \"duplicateParam\",\n              loc: getAbsoluteRange(jsdocNode, param),\n              data: {\n                name: param.name\n              }\n            });\n          } else if (param.name.indexOf(\".\") === -1) {\n            paramTagsByName[param.name] = param;\n          }\n        });\n        if (hasReturns) {\n          if (!requireReturn && !functionData.returnPresent && (returnsTag.type === null || !isValidReturnType(returnsTag)) && !isAbstract) {\n            context.report({\n              node: jsdocNode,\n              messageId: \"unexpectedTag\",\n              loc: getAbsoluteRange(jsdocNode, returnsTag),\n              data: {\n                title: returnsTag.title\n              }\n            });\n          } else {\n            if (requireReturnType && !returnsTag.type) {\n              context.report({\n                node: jsdocNode,\n                messageId: \"missingReturnType\"\n              });\n            }\n            if (!isValidReturnType(returnsTag) && !returnsTag.description && requireReturnDescription) {\n              context.report({\n                node: jsdocNode,\n                messageId: \"missingReturnDesc\"\n              });\n            }\n          }\n        }\n\n        // check for functions missing @returns\n        if (!isOverride && !hasReturns && !hasConstructor && !isInterface && node.parent.kind !== \"get\" && node.parent.kind !== \"constructor\" && node.parent.kind !== \"set\" && !isTypeClass(node)) {\n          if (requireReturn || functionData.returnPresent && !node.async) {\n            context.report({\n              node: jsdocNode,\n              messageId: \"missingReturn\",\n              data: {\n                returns: prefer.returns || \"returns\"\n              }\n            });\n          }\n        }\n\n        // check the parameters\n        const jsdocParamNames = Object.keys(paramTagsByName);\n        if (node.params) {\n          node.params.forEach((param, paramsIndex) => {\n            const bindingParam = param.type === \"AssignmentPattern\" ? param.left : param;\n\n            // TODO(nzakas): Figure out logical things to do with destructured, default, rest params\n            if (bindingParam.type === \"Identifier\") {\n              const name = bindingParam.name;\n              if (jsdocParamNames[paramsIndex] && name !== jsdocParamNames[paramsIndex]) {\n                context.report({\n                  node: jsdocNode,\n                  messageId: \"expected\",\n                  loc: getAbsoluteRange(jsdocNode, paramTagsByName[jsdocParamNames[paramsIndex]]),\n                  data: {\n                    name,\n                    jsdocName: jsdocParamNames[paramsIndex]\n                  }\n                });\n              } else if (!paramTagsByName[name] && !isOverride) {\n                context.report({\n                  node: jsdocNode,\n                  messageId: \"missingParam\",\n                  data: {\n                    name\n                  }\n                });\n              }\n            }\n          });\n        }\n        if (options.matchDescription) {\n          const regex = new RegExp(options.matchDescription, \"u\");\n          if (!regex.test(jsdoc.description)) {\n            context.report({\n              node: jsdocNode,\n              messageId: \"unsatisfiedDesc\"\n            });\n          }\n        }\n      }\n    }\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    return {\n      ArrowFunctionExpression: startFunction,\n      FunctionExpression: startFunction,\n      FunctionDeclaration: startFunction,\n      ClassExpression: startFunction,\n      ClassDeclaration: startFunction,\n      \"ArrowFunctionExpression:exit\": checkJSDoc,\n      \"FunctionExpression:exit\": checkJSDoc,\n      \"FunctionDeclaration:exit\": checkJSDoc,\n      \"ClassExpression:exit\": checkJSDoc,\n      \"ClassDeclaration:exit\": checkJSDoc,\n      ReturnStatement: addReturn\n    };\n  }\n};","map":{"version":3,"names":["require","doctrine","module","exports","meta","type","docs","description","category","recommended","url","schema","properties","prefer","additionalProperties","preferType","requireReturn","default","requireParamDescription","requireReturnDescription","matchDescription","requireReturnType","requireParamType","fixable","messages","unexpectedTag","expected","use","useType","syntaxError","missingBrace","missingParamDesc","missingParamType","missingReturnType","missingReturnDesc","missingReturn","missingParam","duplicateParam","unsatisfiedDesc","deprecated","replacedBy","create","context","options","sourceCode","getSourceCode","checkPreferType","Object","keys","length","fns","isTypeClass","node","startFunction","push","returnPresent","body","async","addReturn","functionState","argument","isValidReturnType","tag","name","canTypeBeValidated","getCurrentExpectedTypes","currentType","expression","expectedTypeName","getAbsoluteRange","jsdocComment","parsedJsdocNode","start","getLocFromIndex","range","end","validateType","jsdocNode","typesToCheck","elements","applications","fields","value","forEach","bind","typeToCheck","report","messageId","loc","data","currentTypeName","fix","fixer","replaceTextRange","map","indexInComment","checkJSDoc","getJSDocComment","functionData","pop","paramTagsByName","paramTags","hasReturns","returnsTag","hasConstructor","isInterface","isOverride","isAbstract","jsdoc","parse","strict","unwrap","sloppy","ex","test","message","tags","title","toLowerCase","prototype","hasOwnProperty","call","entireTagRange","line","column","param","indexOf","parent","kind","returns","jsdocParamNames","params","paramsIndex","bindingParam","left","jsdocName","regex","RegExp","ArrowFunctionExpression","FunctionExpression","FunctionDeclaration","ClassExpression","ClassDeclaration","ReturnStatement"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/valid-jsdoc.js"],"sourcesContent":["/**\n * @fileoverview Validates JSDoc comments are syntactically correct\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst doctrine = require(\"doctrine\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce valid JSDoc comments\",\n            category: \"Possible Errors\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/valid-jsdoc\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    prefer: {\n                        type: \"object\",\n                        additionalProperties: {\n                            type: \"string\"\n                        }\n                    },\n                    preferType: {\n                        type: \"object\",\n                        additionalProperties: {\n                            type: \"string\"\n                        }\n                    },\n                    requireReturn: {\n                        type: \"boolean\",\n                        default: true\n                    },\n                    requireParamDescription: {\n                        type: \"boolean\",\n                        default: true\n                    },\n                    requireReturnDescription: {\n                        type: \"boolean\",\n                        default: true\n                    },\n                    matchDescription: {\n                        type: \"string\"\n                    },\n                    requireReturnType: {\n                        type: \"boolean\",\n                        default: true\n                    },\n                    requireParamType: {\n                        type: \"boolean\",\n                        default: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: \"code\",\n        messages: {\n            unexpectedTag: \"Unexpected @{{title}} tag; function has no return statement.\",\n            expected: \"Expected JSDoc for '{{name}}' but found '{{jsdocName}}'.\",\n            use: \"Use @{{name}} instead.\",\n            useType: \"Use '{{expectedTypeName}}' instead of '{{currentTypeName}}'.\",\n            syntaxError: \"JSDoc syntax error.\",\n            missingBrace: \"JSDoc type missing brace.\",\n            missingParamDesc: \"Missing JSDoc parameter description for '{{name}}'.\",\n            missingParamType: \"Missing JSDoc parameter type for '{{name}}'.\",\n            missingReturnType: \"Missing JSDoc return type.\",\n            missingReturnDesc: \"Missing JSDoc return description.\",\n            missingReturn: \"Missing JSDoc @{{returns}} for function.\",\n            missingParam: \"Missing JSDoc for parameter '{{name}}'.\",\n            duplicateParam: \"Duplicate JSDoc parameter '{{name}}'.\",\n            unsatisfiedDesc: \"JSDoc description does not satisfy the regex pattern.\"\n        },\n\n        deprecated: true,\n        replacedBy: []\n    },\n\n    create(context) {\n\n        const options = context.options[0] || {},\n            prefer = options.prefer || {},\n            sourceCode = context.getSourceCode(),\n\n            // these both default to true, so you have to explicitly make them false\n            requireReturn = options.requireReturn !== false,\n            requireParamDescription = options.requireParamDescription !== false,\n            requireReturnDescription = options.requireReturnDescription !== false,\n            requireReturnType = options.requireReturnType !== false,\n            requireParamType = options.requireParamType !== false,\n            preferType = options.preferType || {},\n            checkPreferType = Object.keys(preferType).length !== 0;\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        // Using a stack to store if a function returns or not (handling nested functions)\n        const fns = [];\n\n        /**\n         * Check if node type is a Class\n         * @param {ASTNode} node node to check.\n         * @returns {boolean} True is its a class\n         * @private\n         */\n        function isTypeClass(node) {\n            return node.type === \"ClassExpression\" || node.type === \"ClassDeclaration\";\n        }\n\n        /**\n         * When parsing a new function, store it in our function stack.\n         * @param {ASTNode} node A function node to check.\n         * @returns {void}\n         * @private\n         */\n        function startFunction(node) {\n            fns.push({\n                returnPresent: (node.type === \"ArrowFunctionExpression\" && node.body.type !== \"BlockStatement\") ||\n                    isTypeClass(node) || node.async\n            });\n        }\n\n        /**\n         * Indicate that return has been found in the current function.\n         * @param {ASTNode} node The return node.\n         * @returns {void}\n         * @private\n         */\n        function addReturn(node) {\n            const functionState = fns[fns.length - 1];\n\n            if (functionState && node.argument !== null) {\n                functionState.returnPresent = true;\n            }\n        }\n\n        /**\n         * Check if return tag type is void or undefined\n         * @param {Object} tag JSDoc tag\n         * @returns {boolean} True if its of type void or undefined\n         * @private\n         */\n        function isValidReturnType(tag) {\n            return tag.type === null || tag.type.name === \"void\" || tag.type.type === \"UndefinedLiteral\";\n        }\n\n        /**\n         * Check if type should be validated based on some exceptions\n         * @param {Object} type JSDoc tag\n         * @returns {boolean} True if it can be validated\n         * @private\n         */\n        function canTypeBeValidated(type) {\n            return type !== \"UndefinedLiteral\" && // {undefined} as there is no name property available.\n                   type !== \"NullLiteral\" && // {null}\n                   type !== \"NullableLiteral\" && // {?}\n                   type !== \"FunctionType\" && // {function(a)}\n                   type !== \"AllLiteral\"; // {*}\n        }\n\n        /**\n         * Extract the current and expected type based on the input type object\n         * @param {Object} type JSDoc tag\n         * @returns {{currentType: Doctrine.Type, expectedTypeName: string}} The current type annotation and\n         * the expected name of the annotation\n         * @private\n         */\n        function getCurrentExpectedTypes(type) {\n            let currentType;\n\n            if (type.name) {\n                currentType = type;\n            } else if (type.expression) {\n                currentType = type.expression;\n            }\n\n            return {\n                currentType,\n                expectedTypeName: currentType && preferType[currentType.name]\n            };\n        }\n\n        /**\n         * Gets the location of a JSDoc node in a file\n         * @param {Token} jsdocComment The comment that this node is parsed from\n         * @param {{range: number[]}} parsedJsdocNode A tag or other node which was parsed from this comment\n         * @returns {{start: SourceLocation, end: SourceLocation}} The 0-based source location for the tag\n         */\n        function getAbsoluteRange(jsdocComment, parsedJsdocNode) {\n            return {\n                start: sourceCode.getLocFromIndex(jsdocComment.range[0] + 2 + parsedJsdocNode.range[0]),\n                end: sourceCode.getLocFromIndex(jsdocComment.range[0] + 2 + parsedJsdocNode.range[1])\n            };\n        }\n\n        /**\n         * Validate type for a given JSDoc node\n         * @param {Object} jsdocNode JSDoc node\n         * @param {Object} type JSDoc tag\n         * @returns {void}\n         * @private\n         */\n        function validateType(jsdocNode, type) {\n            if (!type || !canTypeBeValidated(type.type)) {\n                return;\n            }\n\n            const typesToCheck = [];\n            let elements = [];\n\n            switch (type.type) {\n                case \"TypeApplication\": // {Array.<String>}\n                    elements = type.applications[0].type === \"UnionType\" ? type.applications[0].elements : type.applications;\n                    typesToCheck.push(getCurrentExpectedTypes(type));\n                    break;\n                case \"RecordType\": // {{20:String}}\n                    elements = type.fields;\n                    break;\n                case \"UnionType\": // {String|number|Test}\n                case \"ArrayType\": // {[String, number, Test]}\n                    elements = type.elements;\n                    break;\n                case \"FieldType\": // Array.<{count: number, votes: number}>\n                    if (type.value) {\n                        typesToCheck.push(getCurrentExpectedTypes(type.value));\n                    }\n                    break;\n                default:\n                    typesToCheck.push(getCurrentExpectedTypes(type));\n            }\n\n            elements.forEach(validateType.bind(null, jsdocNode));\n\n            typesToCheck.forEach(typeToCheck => {\n                if (typeToCheck.expectedTypeName &&\n                    typeToCheck.expectedTypeName !== typeToCheck.currentType.name) {\n                    context.report({\n                        node: jsdocNode,\n                        messageId: \"useType\",\n                        loc: getAbsoluteRange(jsdocNode, typeToCheck.currentType),\n                        data: {\n                            currentTypeName: typeToCheck.currentType.name,\n                            expectedTypeName: typeToCheck.expectedTypeName\n                        },\n                        fix(fixer) {\n                            return fixer.replaceTextRange(\n                                typeToCheck.currentType.range.map(indexInComment => jsdocNode.range[0] + 2 + indexInComment),\n                                typeToCheck.expectedTypeName\n                            );\n                        }\n                    });\n                }\n            });\n        }\n\n        /**\n         * Validate the JSDoc node and output warnings if anything is wrong.\n         * @param {ASTNode} node The AST node to check.\n         * @returns {void}\n         * @private\n         */\n        function checkJSDoc(node) {\n            const jsdocNode = sourceCode.getJSDocComment(node),\n                functionData = fns.pop(),\n                paramTagsByName = Object.create(null),\n                paramTags = [];\n            let hasReturns = false,\n                returnsTag,\n                hasConstructor = false,\n                isInterface = false,\n                isOverride = false,\n                isAbstract = false;\n\n            // make sure only to validate JSDoc comments\n            if (jsdocNode) {\n                let jsdoc;\n\n                try {\n                    jsdoc = doctrine.parse(jsdocNode.value, {\n                        strict: true,\n                        unwrap: true,\n                        sloppy: true,\n                        range: true\n                    });\n                } catch (ex) {\n\n                    if (/braces/iu.test(ex.message)) {\n                        context.report({ node: jsdocNode, messageId: \"missingBrace\" });\n                    } else {\n                        context.report({ node: jsdocNode, messageId: \"syntaxError\" });\n                    }\n\n                    return;\n                }\n\n                jsdoc.tags.forEach(tag => {\n\n                    switch (tag.title.toLowerCase()) {\n\n                        case \"param\":\n                        case \"arg\":\n                        case \"argument\":\n                            paramTags.push(tag);\n                            break;\n\n                        case \"return\":\n                        case \"returns\":\n                            hasReturns = true;\n                            returnsTag = tag;\n                            break;\n\n                        case \"constructor\":\n                        case \"class\":\n                            hasConstructor = true;\n                            break;\n\n                        case \"override\":\n                        case \"inheritdoc\":\n                            isOverride = true;\n                            break;\n\n                        case \"abstract\":\n                        case \"virtual\":\n                            isAbstract = true;\n                            break;\n\n                        case \"interface\":\n                            isInterface = true;\n                            break;\n\n                        // no default\n                    }\n\n                    // check tag preferences\n                    if (Object.prototype.hasOwnProperty.call(prefer, tag.title) && tag.title !== prefer[tag.title]) {\n                        const entireTagRange = getAbsoluteRange(jsdocNode, tag);\n\n                        context.report({\n                            node: jsdocNode,\n                            messageId: \"use\",\n                            loc: {\n                                start: entireTagRange.start,\n                                end: {\n                                    line: entireTagRange.start.line,\n                                    column: entireTagRange.start.column + `@${tag.title}`.length\n                                }\n                            },\n                            data: { name: prefer[tag.title] },\n                            fix(fixer) {\n                                return fixer.replaceTextRange(\n                                    [\n                                        jsdocNode.range[0] + tag.range[0] + 3,\n                                        jsdocNode.range[0] + tag.range[0] + tag.title.length + 3\n                                    ],\n                                    prefer[tag.title]\n                                );\n                            }\n                        });\n                    }\n\n                    // validate the types\n                    if (checkPreferType && tag.type) {\n                        validateType(jsdocNode, tag.type);\n                    }\n                });\n\n                paramTags.forEach(param => {\n                    if (requireParamType && !param.type) {\n                        context.report({\n                            node: jsdocNode,\n                            messageId: \"missingParamType\",\n                            loc: getAbsoluteRange(jsdocNode, param),\n                            data: { name: param.name }\n                        });\n                    }\n                    if (!param.description && requireParamDescription) {\n                        context.report({\n                            node: jsdocNode,\n                            messageId: \"missingParamDesc\",\n                            loc: getAbsoluteRange(jsdocNode, param),\n                            data: { name: param.name }\n                        });\n                    }\n                    if (paramTagsByName[param.name]) {\n                        context.report({\n                            node: jsdocNode,\n                            messageId: \"duplicateParam\",\n                            loc: getAbsoluteRange(jsdocNode, param),\n                            data: { name: param.name }\n                        });\n                    } else if (param.name.indexOf(\".\") === -1) {\n                        paramTagsByName[param.name] = param;\n                    }\n                });\n\n                if (hasReturns) {\n                    if (!requireReturn && !functionData.returnPresent && (returnsTag.type === null || !isValidReturnType(returnsTag)) && !isAbstract) {\n                        context.report({\n                            node: jsdocNode,\n                            messageId: \"unexpectedTag\",\n                            loc: getAbsoluteRange(jsdocNode, returnsTag),\n                            data: {\n                                title: returnsTag.title\n                            }\n                        });\n                    } else {\n                        if (requireReturnType && !returnsTag.type) {\n                            context.report({ node: jsdocNode, messageId: \"missingReturnType\" });\n                        }\n\n                        if (!isValidReturnType(returnsTag) && !returnsTag.description && requireReturnDescription) {\n                            context.report({ node: jsdocNode, messageId: \"missingReturnDesc\" });\n                        }\n                    }\n                }\n\n                // check for functions missing @returns\n                if (!isOverride && !hasReturns && !hasConstructor && !isInterface &&\n                    node.parent.kind !== \"get\" && node.parent.kind !== \"constructor\" &&\n                    node.parent.kind !== \"set\" && !isTypeClass(node)) {\n                    if (requireReturn || (functionData.returnPresent && !node.async)) {\n                        context.report({\n                            node: jsdocNode,\n                            messageId: \"missingReturn\",\n                            data: {\n                                returns: prefer.returns || \"returns\"\n                            }\n                        });\n                    }\n                }\n\n                // check the parameters\n                const jsdocParamNames = Object.keys(paramTagsByName);\n\n                if (node.params) {\n                    node.params.forEach((param, paramsIndex) => {\n                        const bindingParam = param.type === \"AssignmentPattern\"\n                            ? param.left\n                            : param;\n\n                        // TODO(nzakas): Figure out logical things to do with destructured, default, rest params\n                        if (bindingParam.type === \"Identifier\") {\n                            const name = bindingParam.name;\n\n                            if (jsdocParamNames[paramsIndex] && (name !== jsdocParamNames[paramsIndex])) {\n                                context.report({\n                                    node: jsdocNode,\n                                    messageId: \"expected\",\n                                    loc: getAbsoluteRange(jsdocNode, paramTagsByName[jsdocParamNames[paramsIndex]]),\n                                    data: {\n                                        name,\n                                        jsdocName: jsdocParamNames[paramsIndex]\n                                    }\n                                });\n                            } else if (!paramTagsByName[name] && !isOverride) {\n                                context.report({\n                                    node: jsdocNode,\n                                    messageId: \"missingParam\",\n                                    data: {\n                                        name\n                                    }\n                                });\n                            }\n                        }\n                    });\n                }\n\n                if (options.matchDescription) {\n                    const regex = new RegExp(options.matchDescription, \"u\");\n\n                    if (!regex.test(jsdoc.description)) {\n                        context.report({ node: jsdocNode, messageId: \"unsatisfiedDesc\" });\n                    }\n                }\n\n            }\n\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            ArrowFunctionExpression: startFunction,\n            FunctionExpression: startFunction,\n            FunctionDeclaration: startFunction,\n            ClassExpression: startFunction,\n            ClassDeclaration: startFunction,\n            \"ArrowFunctionExpression:exit\": checkJSDoc,\n            \"FunctionExpression:exit\": checkJSDoc,\n            \"FunctionDeclaration:exit\": checkJSDoc,\n            \"ClassExpression:exit\": checkJSDoc,\n            \"ClassDeclaration:exit\": checkJSDoc,\n            ReturnStatement: addReturn\n        };\n\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}