{"ast":null,"code":"/**\n * @fileoverview A rule to control the use of single variable declarations.\n * @author Ian Christian Myers\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nrequire(\"core-js/modules/es.array.push.js\");\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Determines whether the given node is in a statement list.\n * @param {ASTNode} node node to check\n * @returns {boolean} `true` if the given node is in a statement list\n */\nfunction isInStatementList(node) {\n  return astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"enforce variables to be declared either together or separately in functions\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/one-var\"\n    },\n    fixable: \"code\",\n    schema: [{\n      oneOf: [{\n        enum: [\"always\", \"never\", \"consecutive\"]\n      }, {\n        type: \"object\",\n        properties: {\n          separateRequires: {\n            type: \"boolean\"\n          },\n          var: {\n            enum: [\"always\", \"never\", \"consecutive\"]\n          },\n          let: {\n            enum: [\"always\", \"never\", \"consecutive\"]\n          },\n          const: {\n            enum: [\"always\", \"never\", \"consecutive\"]\n          }\n        },\n        additionalProperties: false\n      }, {\n        type: \"object\",\n        properties: {\n          initialized: {\n            enum: [\"always\", \"never\", \"consecutive\"]\n          },\n          uninitialized: {\n            enum: [\"always\", \"never\", \"consecutive\"]\n          }\n        },\n        additionalProperties: false\n      }]\n    }],\n    messages: {\n      combineUninitialized: \"Combine this with the previous '{{type}}' statement with uninitialized variables.\",\n      combineInitialized: \"Combine this with the previous '{{type}}' statement with initialized variables.\",\n      splitUninitialized: \"Split uninitialized '{{type}}' declarations into multiple statements.\",\n      splitInitialized: \"Split initialized '{{type}}' declarations into multiple statements.\",\n      splitRequires: \"Split requires to be separated into a single block.\",\n      combine: \"Combine this with the previous '{{type}}' statement.\",\n      split: \"Split '{{type}}' declarations into multiple statements.\"\n    }\n  },\n  create(context) {\n    const MODE_ALWAYS = \"always\";\n    const MODE_NEVER = \"never\";\n    const MODE_CONSECUTIVE = \"consecutive\";\n    const mode = context.options[0] || MODE_ALWAYS;\n    const options = {};\n    if (typeof mode === \"string\") {\n      // simple options configuration with just a string\n      options.var = {\n        uninitialized: mode,\n        initialized: mode\n      };\n      options.let = {\n        uninitialized: mode,\n        initialized: mode\n      };\n      options.const = {\n        uninitialized: mode,\n        initialized: mode\n      };\n    } else if (typeof mode === \"object\") {\n      // options configuration is an object\n      options.separateRequires = !!mode.separateRequires;\n      options.var = {\n        uninitialized: mode.var,\n        initialized: mode.var\n      };\n      options.let = {\n        uninitialized: mode.let,\n        initialized: mode.let\n      };\n      options.const = {\n        uninitialized: mode.const,\n        initialized: mode.const\n      };\n      if (Object.prototype.hasOwnProperty.call(mode, \"uninitialized\")) {\n        options.var.uninitialized = mode.uninitialized;\n        options.let.uninitialized = mode.uninitialized;\n        options.const.uninitialized = mode.uninitialized;\n      }\n      if (Object.prototype.hasOwnProperty.call(mode, \"initialized\")) {\n        options.var.initialized = mode.initialized;\n        options.let.initialized = mode.initialized;\n        options.const.initialized = mode.initialized;\n      }\n    }\n    const sourceCode = context.getSourceCode();\n\n    //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    const functionStack = [];\n    const blockStack = [];\n\n    /**\n     * Increments the blockStack counter.\n     * @returns {void}\n     * @private\n     */\n    function startBlock() {\n      blockStack.push({\n        let: {\n          initialized: false,\n          uninitialized: false\n        },\n        const: {\n          initialized: false,\n          uninitialized: false\n        }\n      });\n    }\n\n    /**\n     * Increments the functionStack counter.\n     * @returns {void}\n     * @private\n     */\n    function startFunction() {\n      functionStack.push({\n        initialized: false,\n        uninitialized: false\n      });\n      startBlock();\n    }\n\n    /**\n     * Decrements the blockStack counter.\n     * @returns {void}\n     * @private\n     */\n    function endBlock() {\n      blockStack.pop();\n    }\n\n    /**\n     * Decrements the functionStack counter.\n     * @returns {void}\n     * @private\n     */\n    function endFunction() {\n      functionStack.pop();\n      endBlock();\n    }\n\n    /**\n     * Check if a variable declaration is a require.\n     * @param {ASTNode} decl variable declaration Node\n     * @returns {bool} if decl is a require, return true; else return false.\n     * @private\n     */\n    function isRequire(decl) {\n      return decl.init && decl.init.type === \"CallExpression\" && decl.init.callee.name === \"require\";\n    }\n\n    /**\n     * Records whether initialized/uninitialized/required variables are defined in current scope.\n     * @param {string} statementType node.kind, one of: \"var\", \"let\", or \"const\"\n     * @param {ASTNode[]} declarations List of declarations\n     * @param {Object} currentScope The scope being investigated\n     * @returns {void}\n     * @private\n     */\n    function recordTypes(statementType, declarations, currentScope) {\n      for (let i = 0; i < declarations.length; i++) {\n        if (declarations[i].init === null) {\n          if (options[statementType] && options[statementType].uninitialized === MODE_ALWAYS) {\n            currentScope.uninitialized = true;\n          }\n        } else {\n          if (options[statementType] && options[statementType].initialized === MODE_ALWAYS) {\n            if (options.separateRequires && isRequire(declarations[i])) {\n              currentScope.required = true;\n            } else {\n              currentScope.initialized = true;\n            }\n          }\n        }\n      }\n    }\n\n    /**\n     * Determines the current scope (function or block)\n     * @param  {string} statementType node.kind, one of: \"var\", \"let\", or \"const\"\n     * @returns {Object} The scope associated with statementType\n     */\n    function getCurrentScope(statementType) {\n      let currentScope;\n      if (statementType === \"var\") {\n        currentScope = functionStack[functionStack.length - 1];\n      } else if (statementType === \"let\") {\n        currentScope = blockStack[blockStack.length - 1].let;\n      } else if (statementType === \"const\") {\n        currentScope = blockStack[blockStack.length - 1].const;\n      }\n      return currentScope;\n    }\n\n    /**\n     * Counts the number of initialized and uninitialized declarations in a list of declarations\n     * @param {ASTNode[]} declarations List of declarations\n     * @returns {Object} Counts of 'uninitialized' and 'initialized' declarations\n     * @private\n     */\n    function countDeclarations(declarations) {\n      const counts = {\n        uninitialized: 0,\n        initialized: 0\n      };\n      for (let i = 0; i < declarations.length; i++) {\n        if (declarations[i].init === null) {\n          counts.uninitialized++;\n        } else {\n          counts.initialized++;\n        }\n      }\n      return counts;\n    }\n\n    /**\n     * Determines if there is more than one var statement in the current scope.\n     * @param {string} statementType node.kind, one of: \"var\", \"let\", or \"const\"\n     * @param {ASTNode[]} declarations List of declarations\n     * @returns {boolean} Returns true if it is the first var declaration, false if not.\n     * @private\n     */\n    function hasOnlyOneStatement(statementType, declarations) {\n      const declarationCounts = countDeclarations(declarations);\n      const currentOptions = options[statementType] || {};\n      const currentScope = getCurrentScope(statementType);\n      const hasRequires = declarations.some(isRequire);\n      if (currentOptions.uninitialized === MODE_ALWAYS && currentOptions.initialized === MODE_ALWAYS) {\n        if (currentScope.uninitialized || currentScope.initialized) {\n          if (!hasRequires) {\n            return false;\n          }\n        }\n      }\n      if (declarationCounts.uninitialized > 0) {\n        if (currentOptions.uninitialized === MODE_ALWAYS && currentScope.uninitialized) {\n          return false;\n        }\n      }\n      if (declarationCounts.initialized > 0) {\n        if (currentOptions.initialized === MODE_ALWAYS && currentScope.initialized) {\n          if (!hasRequires) {\n            return false;\n          }\n        }\n      }\n      if (currentScope.required && hasRequires) {\n        return false;\n      }\n      recordTypes(statementType, declarations, currentScope);\n      return true;\n    }\n\n    /**\n     * Fixer to join VariableDeclaration's into a single declaration\n     * @param {VariableDeclarator[]} declarations The `VariableDeclaration` to join\n     * @returns {Function} The fixer function\n     */\n    function joinDeclarations(declarations) {\n      const declaration = declarations[0];\n      const body = Array.isArray(declaration.parent.parent.body) ? declaration.parent.parent.body : [];\n      const currentIndex = body.findIndex(node => node.range[0] === declaration.parent.range[0]);\n      const previousNode = body[currentIndex - 1];\n      return fixer => {\n        const type = sourceCode.getTokenBefore(declaration);\n        const prevSemi = sourceCode.getTokenBefore(type);\n        const res = [];\n        if (previousNode && previousNode.kind === sourceCode.getText(type)) {\n          if (prevSemi.value === \";\") {\n            res.push(fixer.replaceText(prevSemi, \",\"));\n          } else {\n            res.push(fixer.insertTextAfter(prevSemi, \",\"));\n          }\n          res.push(fixer.replaceText(type, \"\"));\n        }\n        return res;\n      };\n    }\n\n    /**\n     * Fixer to split a VariableDeclaration into individual declarations\n     * @param {VariableDeclaration} declaration The `VariableDeclaration` to split\n     * @returns {Function|null} The fixer function\n     */\n    function splitDeclarations(declaration) {\n      const {\n        parent\n      } = declaration;\n\n      // don't autofix code such as: if (foo) var x, y;\n      if (!isInStatementList(parent.type === \"ExportNamedDeclaration\" ? parent : declaration)) {\n        return null;\n      }\n      return fixer => declaration.declarations.map(declarator => {\n        const tokenAfterDeclarator = sourceCode.getTokenAfter(declarator);\n        if (tokenAfterDeclarator === null) {\n          return null;\n        }\n        const afterComma = sourceCode.getTokenAfter(tokenAfterDeclarator, {\n          includeComments: true\n        });\n        if (tokenAfterDeclarator.value !== \",\") {\n          return null;\n        }\n        const exportPlacement = declaration.parent.type === \"ExportNamedDeclaration\" ? \"export \" : \"\";\n\n        /*\n         * `var x,y`\n         * tokenAfterDeclarator ^^ afterComma\n         */\n        if (afterComma.range[0] === tokenAfterDeclarator.range[1]) {\n          return fixer.replaceText(tokenAfterDeclarator, `; ${exportPlacement}${declaration.kind} `);\n        }\n\n        /*\n         * `var x,\n         * tokenAfterDeclarator ^\n         *      y`\n         *      ^ afterComma\n         */\n        if (afterComma.loc.start.line > tokenAfterDeclarator.loc.end.line || afterComma.type === \"Line\" || afterComma.type === \"Block\") {\n          let lastComment = afterComma;\n          while (lastComment.type === \"Line\" || lastComment.type === \"Block\") {\n            lastComment = sourceCode.getTokenAfter(lastComment, {\n              includeComments: true\n            });\n          }\n          return fixer.replaceTextRange([tokenAfterDeclarator.range[0], lastComment.range[0]], `;${sourceCode.text.slice(tokenAfterDeclarator.range[1], lastComment.range[0])}${exportPlacement}${declaration.kind} `);\n        }\n        return fixer.replaceText(tokenAfterDeclarator, `; ${exportPlacement}${declaration.kind}`);\n      }).filter(x => x);\n    }\n\n    /**\n     * Checks a given VariableDeclaration node for errors.\n     * @param {ASTNode} node The VariableDeclaration node to check\n     * @returns {void}\n     * @private\n     */\n    function checkVariableDeclaration(node) {\n      const parent = node.parent;\n      const type = node.kind;\n      if (!options[type]) {\n        return;\n      }\n      const declarations = node.declarations;\n      const declarationCounts = countDeclarations(declarations);\n      const mixedRequires = declarations.some(isRequire) && !declarations.every(isRequire);\n      if (options[type].initialized === MODE_ALWAYS) {\n        if (options.separateRequires && mixedRequires) {\n          context.report({\n            node,\n            messageId: \"splitRequires\"\n          });\n        }\n      }\n\n      // consecutive\n      const nodeIndex = parent.body && parent.body.length > 0 && parent.body.indexOf(node) || 0;\n      if (nodeIndex > 0) {\n        const previousNode = parent.body[nodeIndex - 1];\n        const isPreviousNodeDeclaration = previousNode.type === \"VariableDeclaration\";\n        const declarationsWithPrevious = declarations.concat(previousNode.declarations || []);\n        if (isPreviousNodeDeclaration && previousNode.kind === type && !(declarationsWithPrevious.some(isRequire) && !declarationsWithPrevious.every(isRequire))) {\n          const previousDeclCounts = countDeclarations(previousNode.declarations);\n          if (options[type].initialized === MODE_CONSECUTIVE && options[type].uninitialized === MODE_CONSECUTIVE) {\n            context.report({\n              node,\n              messageId: \"combine\",\n              data: {\n                type\n              },\n              fix: joinDeclarations(declarations)\n            });\n          } else if (options[type].initialized === MODE_CONSECUTIVE && declarationCounts.initialized > 0 && previousDeclCounts.initialized > 0) {\n            context.report({\n              node,\n              messageId: \"combineInitialized\",\n              data: {\n                type\n              },\n              fix: joinDeclarations(declarations)\n            });\n          } else if (options[type].uninitialized === MODE_CONSECUTIVE && declarationCounts.uninitialized > 0 && previousDeclCounts.uninitialized > 0) {\n            context.report({\n              node,\n              messageId: \"combineUninitialized\",\n              data: {\n                type\n              },\n              fix: joinDeclarations(declarations)\n            });\n          }\n        }\n      }\n\n      // always\n      if (!hasOnlyOneStatement(type, declarations)) {\n        if (options[type].initialized === MODE_ALWAYS && options[type].uninitialized === MODE_ALWAYS) {\n          context.report({\n            node,\n            messageId: \"combine\",\n            data: {\n              type\n            },\n            fix: joinDeclarations(declarations)\n          });\n        } else {\n          if (options[type].initialized === MODE_ALWAYS && declarationCounts.initialized > 0) {\n            context.report({\n              node,\n              messageId: \"combineInitialized\",\n              data: {\n                type\n              },\n              fix: joinDeclarations(declarations)\n            });\n          }\n          if (options[type].uninitialized === MODE_ALWAYS && declarationCounts.uninitialized > 0) {\n            if (node.parent.left === node && (node.parent.type === \"ForInStatement\" || node.parent.type === \"ForOfStatement\")) {\n              return;\n            }\n            context.report({\n              node,\n              messageId: \"combineUninitialized\",\n              data: {\n                type\n              },\n              fix: joinDeclarations(declarations)\n            });\n          }\n        }\n      }\n\n      // never\n      if (parent.type !== \"ForStatement\" || parent.init !== node) {\n        const totalDeclarations = declarationCounts.uninitialized + declarationCounts.initialized;\n        if (totalDeclarations > 1) {\n          if (options[type].initialized === MODE_NEVER && options[type].uninitialized === MODE_NEVER) {\n            // both initialized and uninitialized\n            context.report({\n              node,\n              messageId: \"split\",\n              data: {\n                type\n              },\n              fix: splitDeclarations(node)\n            });\n          } else if (options[type].initialized === MODE_NEVER && declarationCounts.initialized > 0) {\n            // initialized\n            context.report({\n              node,\n              messageId: \"splitInitialized\",\n              data: {\n                type\n              },\n              fix: splitDeclarations(node)\n            });\n          } else if (options[type].uninitialized === MODE_NEVER && declarationCounts.uninitialized > 0) {\n            // uninitialized\n            context.report({\n              node,\n              messageId: \"splitUninitialized\",\n              data: {\n                type\n              },\n              fix: splitDeclarations(node)\n            });\n          }\n        }\n      }\n    }\n\n    //--------------------------------------------------------------------------\n    // Public API\n    //--------------------------------------------------------------------------\n\n    return {\n      Program: startFunction,\n      FunctionDeclaration: startFunction,\n      FunctionExpression: startFunction,\n      ArrowFunctionExpression: startFunction,\n      BlockStatement: startBlock,\n      ForStatement: startBlock,\n      ForInStatement: startBlock,\n      ForOfStatement: startBlock,\n      SwitchStatement: startBlock,\n      VariableDeclaration: checkVariableDeclaration,\n      \"ForStatement:exit\": endBlock,\n      \"ForOfStatement:exit\": endBlock,\n      \"ForInStatement:exit\": endBlock,\n      \"SwitchStatement:exit\": endBlock,\n      \"BlockStatement:exit\": endBlock,\n      \"Program:exit\": endFunction,\n      \"FunctionDeclaration:exit\": endFunction,\n      \"FunctionExpression:exit\": endFunction,\n      \"ArrowFunctionExpression:exit\": endFunction\n    };\n  }\n};","map":{"version":3,"names":["require","astUtils","isInStatementList","node","STATEMENT_LIST_PARENTS","has","parent","type","module","exports","meta","docs","description","category","recommended","url","fixable","schema","oneOf","enum","properties","separateRequires","var","let","const","additionalProperties","initialized","uninitialized","messages","combineUninitialized","combineInitialized","splitUninitialized","splitInitialized","splitRequires","combine","split","create","context","MODE_ALWAYS","MODE_NEVER","MODE_CONSECUTIVE","mode","options","Object","prototype","hasOwnProperty","call","sourceCode","getSourceCode","functionStack","blockStack","startBlock","push","startFunction","endBlock","pop","endFunction","isRequire","decl","init","callee","name","recordTypes","statementType","declarations","currentScope","i","length","required","getCurrentScope","countDeclarations","counts","hasOnlyOneStatement","declarationCounts","currentOptions","hasRequires","some","joinDeclarations","declaration","body","Array","isArray","currentIndex","findIndex","range","previousNode","fixer","getTokenBefore","prevSemi","res","kind","getText","value","replaceText","insertTextAfter","splitDeclarations","map","declarator","tokenAfterDeclarator","getTokenAfter","afterComma","includeComments","exportPlacement","loc","start","line","end","lastComment","replaceTextRange","text","slice","filter","x","checkVariableDeclaration","mixedRequires","every","report","messageId","nodeIndex","indexOf","isPreviousNodeDeclaration","declarationsWithPrevious","concat","previousDeclCounts","data","fix","left","totalDeclarations","Program","FunctionDeclaration","FunctionExpression","ArrowFunctionExpression","BlockStatement","ForStatement","ForInStatement","ForOfStatement","SwitchStatement","VariableDeclaration"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/one-var.js"],"sourcesContent":["/**\n * @fileoverview A rule to control the use of single variable declarations.\n * @author Ian Christian Myers\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Determines whether the given node is in a statement list.\n * @param {ASTNode} node node to check\n * @returns {boolean} `true` if the given node is in a statement list\n */\nfunction isInStatementList(node) {\n    return astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce variables to be declared either together or separately in functions\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/one-var\"\n        },\n\n        fixable: \"code\",\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"always\", \"never\", \"consecutive\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            separateRequires: {\n                                type: \"boolean\"\n                            },\n                            var: {\n                                enum: [\"always\", \"never\", \"consecutive\"]\n                            },\n                            let: {\n                                enum: [\"always\", \"never\", \"consecutive\"]\n                            },\n                            const: {\n                                enum: [\"always\", \"never\", \"consecutive\"]\n                            }\n                        },\n                        additionalProperties: false\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            initialized: {\n                                enum: [\"always\", \"never\", \"consecutive\"]\n                            },\n                            uninitialized: {\n                                enum: [\"always\", \"never\", \"consecutive\"]\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ],\n\n        messages: {\n            combineUninitialized: \"Combine this with the previous '{{type}}' statement with uninitialized variables.\",\n            combineInitialized: \"Combine this with the previous '{{type}}' statement with initialized variables.\",\n            splitUninitialized: \"Split uninitialized '{{type}}' declarations into multiple statements.\",\n            splitInitialized: \"Split initialized '{{type}}' declarations into multiple statements.\",\n            splitRequires: \"Split requires to be separated into a single block.\",\n            combine: \"Combine this with the previous '{{type}}' statement.\",\n            split: \"Split '{{type}}' declarations into multiple statements.\"\n        }\n    },\n\n    create(context) {\n        const MODE_ALWAYS = \"always\";\n        const MODE_NEVER = \"never\";\n        const MODE_CONSECUTIVE = \"consecutive\";\n        const mode = context.options[0] || MODE_ALWAYS;\n\n        const options = {};\n\n        if (typeof mode === \"string\") { // simple options configuration with just a string\n            options.var = { uninitialized: mode, initialized: mode };\n            options.let = { uninitialized: mode, initialized: mode };\n            options.const = { uninitialized: mode, initialized: mode };\n        } else if (typeof mode === \"object\") { // options configuration is an object\n            options.separateRequires = !!mode.separateRequires;\n            options.var = { uninitialized: mode.var, initialized: mode.var };\n            options.let = { uninitialized: mode.let, initialized: mode.let };\n            options.const = { uninitialized: mode.const, initialized: mode.const };\n            if (Object.prototype.hasOwnProperty.call(mode, \"uninitialized\")) {\n                options.var.uninitialized = mode.uninitialized;\n                options.let.uninitialized = mode.uninitialized;\n                options.const.uninitialized = mode.uninitialized;\n            }\n            if (Object.prototype.hasOwnProperty.call(mode, \"initialized\")) {\n                options.var.initialized = mode.initialized;\n                options.let.initialized = mode.initialized;\n                options.const.initialized = mode.initialized;\n            }\n        }\n\n        const sourceCode = context.getSourceCode();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        const functionStack = [];\n        const blockStack = [];\n\n        /**\n         * Increments the blockStack counter.\n         * @returns {void}\n         * @private\n         */\n        function startBlock() {\n            blockStack.push({\n                let: { initialized: false, uninitialized: false },\n                const: { initialized: false, uninitialized: false }\n            });\n        }\n\n        /**\n         * Increments the functionStack counter.\n         * @returns {void}\n         * @private\n         */\n        function startFunction() {\n            functionStack.push({ initialized: false, uninitialized: false });\n            startBlock();\n        }\n\n        /**\n         * Decrements the blockStack counter.\n         * @returns {void}\n         * @private\n         */\n        function endBlock() {\n            blockStack.pop();\n        }\n\n        /**\n         * Decrements the functionStack counter.\n         * @returns {void}\n         * @private\n         */\n        function endFunction() {\n            functionStack.pop();\n            endBlock();\n        }\n\n        /**\n         * Check if a variable declaration is a require.\n         * @param {ASTNode} decl variable declaration Node\n         * @returns {bool} if decl is a require, return true; else return false.\n         * @private\n         */\n        function isRequire(decl) {\n            return decl.init && decl.init.type === \"CallExpression\" && decl.init.callee.name === \"require\";\n        }\n\n        /**\n         * Records whether initialized/uninitialized/required variables are defined in current scope.\n         * @param {string} statementType node.kind, one of: \"var\", \"let\", or \"const\"\n         * @param {ASTNode[]} declarations List of declarations\n         * @param {Object} currentScope The scope being investigated\n         * @returns {void}\n         * @private\n         */\n        function recordTypes(statementType, declarations, currentScope) {\n            for (let i = 0; i < declarations.length; i++) {\n                if (declarations[i].init === null) {\n                    if (options[statementType] && options[statementType].uninitialized === MODE_ALWAYS) {\n                        currentScope.uninitialized = true;\n                    }\n                } else {\n                    if (options[statementType] && options[statementType].initialized === MODE_ALWAYS) {\n                        if (options.separateRequires && isRequire(declarations[i])) {\n                            currentScope.required = true;\n                        } else {\n                            currentScope.initialized = true;\n                        }\n                    }\n                }\n            }\n        }\n\n        /**\n         * Determines the current scope (function or block)\n         * @param  {string} statementType node.kind, one of: \"var\", \"let\", or \"const\"\n         * @returns {Object} The scope associated with statementType\n         */\n        function getCurrentScope(statementType) {\n            let currentScope;\n\n            if (statementType === \"var\") {\n                currentScope = functionStack[functionStack.length - 1];\n            } else if (statementType === \"let\") {\n                currentScope = blockStack[blockStack.length - 1].let;\n            } else if (statementType === \"const\") {\n                currentScope = blockStack[blockStack.length - 1].const;\n            }\n            return currentScope;\n        }\n\n        /**\n         * Counts the number of initialized and uninitialized declarations in a list of declarations\n         * @param {ASTNode[]} declarations List of declarations\n         * @returns {Object} Counts of 'uninitialized' and 'initialized' declarations\n         * @private\n         */\n        function countDeclarations(declarations) {\n            const counts = { uninitialized: 0, initialized: 0 };\n\n            for (let i = 0; i < declarations.length; i++) {\n                if (declarations[i].init === null) {\n                    counts.uninitialized++;\n                } else {\n                    counts.initialized++;\n                }\n            }\n            return counts;\n        }\n\n        /**\n         * Determines if there is more than one var statement in the current scope.\n         * @param {string} statementType node.kind, one of: \"var\", \"let\", or \"const\"\n         * @param {ASTNode[]} declarations List of declarations\n         * @returns {boolean} Returns true if it is the first var declaration, false if not.\n         * @private\n         */\n        function hasOnlyOneStatement(statementType, declarations) {\n\n            const declarationCounts = countDeclarations(declarations);\n            const currentOptions = options[statementType] || {};\n            const currentScope = getCurrentScope(statementType);\n            const hasRequires = declarations.some(isRequire);\n\n            if (currentOptions.uninitialized === MODE_ALWAYS && currentOptions.initialized === MODE_ALWAYS) {\n                if (currentScope.uninitialized || currentScope.initialized) {\n                    if (!hasRequires) {\n                        return false;\n                    }\n                }\n            }\n\n            if (declarationCounts.uninitialized > 0) {\n                if (currentOptions.uninitialized === MODE_ALWAYS && currentScope.uninitialized) {\n                    return false;\n                }\n            }\n            if (declarationCounts.initialized > 0) {\n                if (currentOptions.initialized === MODE_ALWAYS && currentScope.initialized) {\n                    if (!hasRequires) {\n                        return false;\n                    }\n                }\n            }\n            if (currentScope.required && hasRequires) {\n                return false;\n            }\n            recordTypes(statementType, declarations, currentScope);\n            return true;\n        }\n\n        /**\n         * Fixer to join VariableDeclaration's into a single declaration\n         * @param {VariableDeclarator[]} declarations The `VariableDeclaration` to join\n         * @returns {Function} The fixer function\n         */\n        function joinDeclarations(declarations) {\n            const declaration = declarations[0];\n            const body = Array.isArray(declaration.parent.parent.body) ? declaration.parent.parent.body : [];\n            const currentIndex = body.findIndex(node => node.range[0] === declaration.parent.range[0]);\n            const previousNode = body[currentIndex - 1];\n\n            return fixer => {\n                const type = sourceCode.getTokenBefore(declaration);\n                const prevSemi = sourceCode.getTokenBefore(type);\n                const res = [];\n\n                if (previousNode && previousNode.kind === sourceCode.getText(type)) {\n                    if (prevSemi.value === \";\") {\n                        res.push(fixer.replaceText(prevSemi, \",\"));\n                    } else {\n                        res.push(fixer.insertTextAfter(prevSemi, \",\"));\n                    }\n                    res.push(fixer.replaceText(type, \"\"));\n                }\n\n                return res;\n            };\n        }\n\n        /**\n         * Fixer to split a VariableDeclaration into individual declarations\n         * @param {VariableDeclaration} declaration The `VariableDeclaration` to split\n         * @returns {Function|null} The fixer function\n         */\n        function splitDeclarations(declaration) {\n            const { parent } = declaration;\n\n            // don't autofix code such as: if (foo) var x, y;\n            if (!isInStatementList(parent.type === \"ExportNamedDeclaration\" ? parent : declaration)) {\n                return null;\n            }\n\n            return fixer => declaration.declarations.map(declarator => {\n                const tokenAfterDeclarator = sourceCode.getTokenAfter(declarator);\n\n                if (tokenAfterDeclarator === null) {\n                    return null;\n                }\n\n                const afterComma = sourceCode.getTokenAfter(tokenAfterDeclarator, { includeComments: true });\n\n                if (tokenAfterDeclarator.value !== \",\") {\n                    return null;\n                }\n\n                const exportPlacement = declaration.parent.type === \"ExportNamedDeclaration\" ? \"export \" : \"\";\n\n                /*\n                 * `var x,y`\n                 * tokenAfterDeclarator ^^ afterComma\n                 */\n                if (afterComma.range[0] === tokenAfterDeclarator.range[1]) {\n                    return fixer.replaceText(tokenAfterDeclarator, `; ${exportPlacement}${declaration.kind} `);\n                }\n\n                /*\n                 * `var x,\n                 * tokenAfterDeclarator ^\n                 *      y`\n                 *      ^ afterComma\n                 */\n                if (\n                    afterComma.loc.start.line > tokenAfterDeclarator.loc.end.line ||\n                    afterComma.type === \"Line\" ||\n                    afterComma.type === \"Block\"\n                ) {\n                    let lastComment = afterComma;\n\n                    while (lastComment.type === \"Line\" || lastComment.type === \"Block\") {\n                        lastComment = sourceCode.getTokenAfter(lastComment, { includeComments: true });\n                    }\n\n                    return fixer.replaceTextRange(\n                        [tokenAfterDeclarator.range[0], lastComment.range[0]],\n                        `;${sourceCode.text.slice(tokenAfterDeclarator.range[1], lastComment.range[0])}${exportPlacement}${declaration.kind} `\n                    );\n                }\n\n                return fixer.replaceText(tokenAfterDeclarator, `; ${exportPlacement}${declaration.kind}`);\n            }).filter(x => x);\n        }\n\n        /**\n         * Checks a given VariableDeclaration node for errors.\n         * @param {ASTNode} node The VariableDeclaration node to check\n         * @returns {void}\n         * @private\n         */\n        function checkVariableDeclaration(node) {\n            const parent = node.parent;\n            const type = node.kind;\n\n            if (!options[type]) {\n                return;\n            }\n\n            const declarations = node.declarations;\n            const declarationCounts = countDeclarations(declarations);\n            const mixedRequires = declarations.some(isRequire) && !declarations.every(isRequire);\n\n            if (options[type].initialized === MODE_ALWAYS) {\n                if (options.separateRequires && mixedRequires) {\n                    context.report({\n                        node,\n                        messageId: \"splitRequires\"\n                    });\n                }\n            }\n\n            // consecutive\n            const nodeIndex = (parent.body && parent.body.length > 0 && parent.body.indexOf(node)) || 0;\n\n            if (nodeIndex > 0) {\n                const previousNode = parent.body[nodeIndex - 1];\n                const isPreviousNodeDeclaration = previousNode.type === \"VariableDeclaration\";\n                const declarationsWithPrevious = declarations.concat(previousNode.declarations || []);\n\n                if (\n                    isPreviousNodeDeclaration &&\n                    previousNode.kind === type &&\n                    !(declarationsWithPrevious.some(isRequire) && !declarationsWithPrevious.every(isRequire))\n                ) {\n                    const previousDeclCounts = countDeclarations(previousNode.declarations);\n\n                    if (options[type].initialized === MODE_CONSECUTIVE && options[type].uninitialized === MODE_CONSECUTIVE) {\n                        context.report({\n                            node,\n                            messageId: \"combine\",\n                            data: {\n                                type\n                            },\n                            fix: joinDeclarations(declarations)\n                        });\n                    } else if (options[type].initialized === MODE_CONSECUTIVE && declarationCounts.initialized > 0 && previousDeclCounts.initialized > 0) {\n                        context.report({\n                            node,\n                            messageId: \"combineInitialized\",\n                            data: {\n                                type\n                            },\n                            fix: joinDeclarations(declarations)\n                        });\n                    } else if (options[type].uninitialized === MODE_CONSECUTIVE &&\n                            declarationCounts.uninitialized > 0 &&\n                            previousDeclCounts.uninitialized > 0) {\n                        context.report({\n                            node,\n                            messageId: \"combineUninitialized\",\n                            data: {\n                                type\n                            },\n                            fix: joinDeclarations(declarations)\n                        });\n                    }\n                }\n            }\n\n            // always\n            if (!hasOnlyOneStatement(type, declarations)) {\n                if (options[type].initialized === MODE_ALWAYS && options[type].uninitialized === MODE_ALWAYS) {\n                    context.report({\n                        node,\n                        messageId: \"combine\",\n                        data: {\n                            type\n                        },\n                        fix: joinDeclarations(declarations)\n                    });\n                } else {\n                    if (options[type].initialized === MODE_ALWAYS && declarationCounts.initialized > 0) {\n                        context.report({\n                            node,\n                            messageId: \"combineInitialized\",\n                            data: {\n                                type\n                            },\n                            fix: joinDeclarations(declarations)\n                        });\n                    }\n                    if (options[type].uninitialized === MODE_ALWAYS && declarationCounts.uninitialized > 0) {\n                        if (node.parent.left === node && (node.parent.type === \"ForInStatement\" || node.parent.type === \"ForOfStatement\")) {\n                            return;\n                        }\n                        context.report({\n                            node,\n                            messageId: \"combineUninitialized\",\n                            data: {\n                                type\n                            },\n                            fix: joinDeclarations(declarations)\n                        });\n                    }\n                }\n            }\n\n            // never\n            if (parent.type !== \"ForStatement\" || parent.init !== node) {\n                const totalDeclarations = declarationCounts.uninitialized + declarationCounts.initialized;\n\n                if (totalDeclarations > 1) {\n                    if (options[type].initialized === MODE_NEVER && options[type].uninitialized === MODE_NEVER) {\n\n                        // both initialized and uninitialized\n                        context.report({\n                            node,\n                            messageId: \"split\",\n                            data: {\n                                type\n                            },\n                            fix: splitDeclarations(node)\n                        });\n                    } else if (options[type].initialized === MODE_NEVER && declarationCounts.initialized > 0) {\n\n                        // initialized\n                        context.report({\n                            node,\n                            messageId: \"splitInitialized\",\n                            data: {\n                                type\n                            },\n                            fix: splitDeclarations(node)\n                        });\n                    } else if (options[type].uninitialized === MODE_NEVER && declarationCounts.uninitialized > 0) {\n\n                        // uninitialized\n                        context.report({\n                            node,\n                            messageId: \"splitUninitialized\",\n                            data: {\n                                type\n                            },\n                            fix: splitDeclarations(node)\n                        });\n                    }\n                }\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n            Program: startFunction,\n            FunctionDeclaration: startFunction,\n            FunctionExpression: startFunction,\n            ArrowFunctionExpression: startFunction,\n            BlockStatement: startBlock,\n            ForStatement: startBlock,\n            ForInStatement: startBlock,\n            ForOfStatement: startBlock,\n            SwitchStatement: startBlock,\n            VariableDeclaration: checkVariableDeclaration,\n            \"ForStatement:exit\": endBlock,\n            \"ForOfStatement:exit\": endBlock,\n            \"ForInStatement:exit\": endBlock,\n            \"SwitchStatement:exit\": endBlock,\n            \"BlockStatement:exit\": endBlock,\n            \"Program:exit\": endFunction,\n            \"FunctionDeclaration:exit\": endFunction,\n            \"FunctionExpression:exit\": endFunction,\n            \"ArrowFunctionExpression:exit\": endFunction\n        };\n\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}