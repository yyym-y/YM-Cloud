{"ast":null,"code":"/**\n * @fileoverview Rule to check empty newline after \"var\" statement\n * @author Gopal Venkatesan\n * @deprecated\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"require or disallow an empty line after variable declarations\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/newline-after-var\"\n    },\n    schema: [{\n      enum: [\"never\", \"always\"]\n    }],\n    fixable: \"whitespace\",\n    messages: {\n      expected: \"Expected blank line after variable declarations.\",\n      unexpected: \"Unexpected blank line after variable declarations.\"\n    },\n    deprecated: true,\n    replacedBy: [\"padding-line-between-statements\"]\n  },\n  create(context) {\n    const sourceCode = context.getSourceCode();\n\n    // Default `mode` to \"always\".\n    const mode = context.options[0] === \"never\" ? \"never\" : \"always\";\n\n    // Cache starting and ending line numbers of comments for faster lookup\n    const commentEndLine = sourceCode.getAllComments().reduce((result, token) => {\n      result[token.loc.start.line] = token.loc.end.line;\n      return result;\n    }, {});\n\n    //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    /**\n     * Gets a token from the given node to compare line to the next statement.\n     *\n     * In general, the token is the last token of the node. However, the token is the second last token if the following conditions satisfy.\n     *\n     * - The last token is semicolon.\n     * - The semicolon is on a different line from the previous token of the semicolon.\n     *\n     * This behavior would address semicolon-less style code. e.g.:\n     *\n     *     var foo = 1\n     *\n     *     ;(a || b).doSomething()\n     * @param {ASTNode} node The node to get.\n     * @returns {Token} The token to compare line to the next statement.\n     */\n    function getLastToken(node) {\n      const lastToken = sourceCode.getLastToken(node);\n      if (lastToken.type === \"Punctuator\" && lastToken.value === \";\") {\n        const prevToken = sourceCode.getTokenBefore(lastToken);\n        if (prevToken.loc.end.line !== lastToken.loc.start.line) {\n          return prevToken;\n        }\n      }\n      return lastToken;\n    }\n\n    /**\n     * Determine if provided keyword is a variable declaration\n     * @private\n     * @param {string} keyword keyword to test\n     * @returns {boolean} True if `keyword` is a type of var\n     */\n    function isVar(keyword) {\n      return keyword === \"var\" || keyword === \"let\" || keyword === \"const\";\n    }\n\n    /**\n     * Determine if provided keyword is a variant of for specifiers\n     * @private\n     * @param {string} keyword keyword to test\n     * @returns {boolean} True if `keyword` is a variant of for specifier\n     */\n    function isForTypeSpecifier(keyword) {\n      return keyword === \"ForStatement\" || keyword === \"ForInStatement\" || keyword === \"ForOfStatement\";\n    }\n\n    /**\n     * Determine if provided keyword is an export specifiers\n     * @private\n     * @param {string} nodeType nodeType to test\n     * @returns {boolean} True if `nodeType` is an export specifier\n     */\n    function isExportSpecifier(nodeType) {\n      return nodeType === \"ExportNamedDeclaration\" || nodeType === \"ExportSpecifier\" || nodeType === \"ExportDefaultDeclaration\" || nodeType === \"ExportAllDeclaration\";\n    }\n\n    /**\n     * Determine if provided node is the last of their parent block.\n     * @private\n     * @param {ASTNode} node node to test\n     * @returns {boolean} True if `node` is last of their parent block.\n     */\n    function isLastNode(node) {\n      const token = sourceCode.getTokenAfter(node);\n      return !token || token.type === \"Punctuator\" && token.value === \"}\";\n    }\n\n    /**\n     * Gets the last line of a group of consecutive comments\n     * @param {number} commentStartLine The starting line of the group\n     * @returns {number} The number of the last comment line of the group\n     */\n    function getLastCommentLineOfBlock(commentStartLine) {\n      const currentCommentEnd = commentEndLine[commentStartLine];\n      return commentEndLine[currentCommentEnd + 1] ? getLastCommentLineOfBlock(currentCommentEnd + 1) : currentCommentEnd;\n    }\n\n    /**\n     * Determine if a token starts more than one line after a comment ends\n     * @param  {token}   token            The token being checked\n     * @param {integer}  commentStartLine The line number on which the comment starts\n     * @returns {boolean}                 True if `token` does not start immediately after a comment\n     */\n    function hasBlankLineAfterComment(token, commentStartLine) {\n      return token.loc.start.line > getLastCommentLineOfBlock(commentStartLine) + 1;\n    }\n\n    /**\n     * Checks that a blank line exists after a variable declaration when mode is\n     * set to \"always\", or checks that there is no blank line when mode is set\n     * to \"never\"\n     * @private\n     * @param {ASTNode} node `VariableDeclaration` node to test\n     * @returns {void}\n     */\n    function checkForBlankLine(node) {\n      /*\n       * lastToken is the last token on the node's line. It will usually also be the last token of the node, but it will\n       * sometimes be second-last if there is a semicolon on a different line.\n       */\n      const lastToken = getLastToken(node),\n        /*\n         * If lastToken is the last token of the node, nextToken should be the token after the node. Otherwise, nextToken\n         * is the last token of the node.\n         */\n        nextToken = lastToken === sourceCode.getLastToken(node) ? sourceCode.getTokenAfter(node) : sourceCode.getLastToken(node),\n        nextLineNum = lastToken.loc.end.line + 1;\n\n      // Ignore if there is no following statement\n      if (!nextToken) {\n        return;\n      }\n\n      // Ignore if parent of node is a for variant\n      if (isForTypeSpecifier(node.parent.type)) {\n        return;\n      }\n\n      // Ignore if parent of node is an export specifier\n      if (isExportSpecifier(node.parent.type)) {\n        return;\n      }\n\n      /*\n       * Some coding styles use multiple `var` statements, so do nothing if\n       * the next token is a `var` statement.\n       */\n      if (nextToken.type === \"Keyword\" && isVar(nextToken.value)) {\n        return;\n      }\n\n      // Ignore if it is last statement in a block\n      if (isLastNode(node)) {\n        return;\n      }\n\n      // Next statement is not a `var`...\n      const noNextLineToken = nextToken.loc.start.line > nextLineNum;\n      const hasNextLineComment = typeof commentEndLine[nextLineNum] !== \"undefined\";\n      if (mode === \"never\" && noNextLineToken && !hasNextLineComment) {\n        context.report({\n          node,\n          messageId: \"unexpected\",\n          data: {\n            identifier: node.name\n          },\n          fix(fixer) {\n            const linesBetween = sourceCode.getText().slice(lastToken.range[1], nextToken.range[0]).split(astUtils.LINEBREAK_MATCHER);\n            return fixer.replaceTextRange([lastToken.range[1], nextToken.range[0]], `${linesBetween.slice(0, -1).join(\"\")}\\n${linesBetween[linesBetween.length - 1]}`);\n          }\n        });\n      }\n\n      // Token on the next line, or comment without blank line\n      if (mode === \"always\" && (!noNextLineToken || hasNextLineComment && !hasBlankLineAfterComment(nextToken, nextLineNum))) {\n        context.report({\n          node,\n          messageId: \"expected\",\n          data: {\n            identifier: node.name\n          },\n          fix(fixer) {\n            if ((noNextLineToken ? getLastCommentLineOfBlock(nextLineNum) : lastToken.loc.end.line) === nextToken.loc.start.line) {\n              return fixer.insertTextBefore(nextToken, \"\\n\\n\");\n            }\n            return fixer.insertTextBeforeRange([nextToken.range[0] - nextToken.loc.start.column, nextToken.range[1]], \"\\n\");\n          }\n        });\n      }\n    }\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    return {\n      VariableDeclaration: checkForBlankLine\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","module","exports","meta","type","docs","description","category","recommended","url","schema","enum","fixable","messages","expected","unexpected","deprecated","replacedBy","create","context","sourceCode","getSourceCode","mode","options","commentEndLine","getAllComments","reduce","result","token","loc","start","line","end","getLastToken","node","lastToken","value","prevToken","getTokenBefore","isVar","keyword","isForTypeSpecifier","isExportSpecifier","nodeType","isLastNode","getTokenAfter","getLastCommentLineOfBlock","commentStartLine","currentCommentEnd","hasBlankLineAfterComment","checkForBlankLine","nextToken","nextLineNum","parent","noNextLineToken","hasNextLineComment","report","messageId","data","identifier","name","fix","fixer","linesBetween","getText","slice","range","split","LINEBREAK_MATCHER","replaceTextRange","join","length","insertTextBefore","insertTextBeforeRange","column","VariableDeclaration"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/newline-after-var.js"],"sourcesContent":["/**\n * @fileoverview Rule to check empty newline after \"var\" statement\n * @author Gopal Venkatesan\n * @deprecated\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"require or disallow an empty line after variable declarations\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/newline-after-var\"\n        },\n        schema: [\n            {\n                enum: [\"never\", \"always\"]\n            }\n        ],\n        fixable: \"whitespace\",\n        messages: {\n            expected: \"Expected blank line after variable declarations.\",\n            unexpected: \"Unexpected blank line after variable declarations.\"\n        },\n\n        deprecated: true,\n\n        replacedBy: [\"padding-line-between-statements\"]\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        // Default `mode` to \"always\".\n        const mode = context.options[0] === \"never\" ? \"never\" : \"always\";\n\n        // Cache starting and ending line numbers of comments for faster lookup\n        const commentEndLine = sourceCode.getAllComments().reduce((result, token) => {\n            result[token.loc.start.line] = token.loc.end.line;\n            return result;\n        }, {});\n\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Gets a token from the given node to compare line to the next statement.\n         *\n         * In general, the token is the last token of the node. However, the token is the second last token if the following conditions satisfy.\n         *\n         * - The last token is semicolon.\n         * - The semicolon is on a different line from the previous token of the semicolon.\n         *\n         * This behavior would address semicolon-less style code. e.g.:\n         *\n         *     var foo = 1\n         *\n         *     ;(a || b).doSomething()\n         * @param {ASTNode} node The node to get.\n         * @returns {Token} The token to compare line to the next statement.\n         */\n        function getLastToken(node) {\n            const lastToken = sourceCode.getLastToken(node);\n\n            if (lastToken.type === \"Punctuator\" && lastToken.value === \";\") {\n                const prevToken = sourceCode.getTokenBefore(lastToken);\n\n                if (prevToken.loc.end.line !== lastToken.loc.start.line) {\n                    return prevToken;\n                }\n            }\n\n            return lastToken;\n        }\n\n        /**\n         * Determine if provided keyword is a variable declaration\n         * @private\n         * @param {string} keyword keyword to test\n         * @returns {boolean} True if `keyword` is a type of var\n         */\n        function isVar(keyword) {\n            return keyword === \"var\" || keyword === \"let\" || keyword === \"const\";\n        }\n\n        /**\n         * Determine if provided keyword is a variant of for specifiers\n         * @private\n         * @param {string} keyword keyword to test\n         * @returns {boolean} True if `keyword` is a variant of for specifier\n         */\n        function isForTypeSpecifier(keyword) {\n            return keyword === \"ForStatement\" || keyword === \"ForInStatement\" || keyword === \"ForOfStatement\";\n        }\n\n        /**\n         * Determine if provided keyword is an export specifiers\n         * @private\n         * @param {string} nodeType nodeType to test\n         * @returns {boolean} True if `nodeType` is an export specifier\n         */\n        function isExportSpecifier(nodeType) {\n            return nodeType === \"ExportNamedDeclaration\" || nodeType === \"ExportSpecifier\" ||\n                nodeType === \"ExportDefaultDeclaration\" || nodeType === \"ExportAllDeclaration\";\n        }\n\n        /**\n         * Determine if provided node is the last of their parent block.\n         * @private\n         * @param {ASTNode} node node to test\n         * @returns {boolean} True if `node` is last of their parent block.\n         */\n        function isLastNode(node) {\n            const token = sourceCode.getTokenAfter(node);\n\n            return !token || (token.type === \"Punctuator\" && token.value === \"}\");\n        }\n\n        /**\n         * Gets the last line of a group of consecutive comments\n         * @param {number} commentStartLine The starting line of the group\n         * @returns {number} The number of the last comment line of the group\n         */\n        function getLastCommentLineOfBlock(commentStartLine) {\n            const currentCommentEnd = commentEndLine[commentStartLine];\n\n            return commentEndLine[currentCommentEnd + 1] ? getLastCommentLineOfBlock(currentCommentEnd + 1) : currentCommentEnd;\n        }\n\n        /**\n         * Determine if a token starts more than one line after a comment ends\n         * @param  {token}   token            The token being checked\n         * @param {integer}  commentStartLine The line number on which the comment starts\n         * @returns {boolean}                 True if `token` does not start immediately after a comment\n         */\n        function hasBlankLineAfterComment(token, commentStartLine) {\n            return token.loc.start.line > getLastCommentLineOfBlock(commentStartLine) + 1;\n        }\n\n        /**\n         * Checks that a blank line exists after a variable declaration when mode is\n         * set to \"always\", or checks that there is no blank line when mode is set\n         * to \"never\"\n         * @private\n         * @param {ASTNode} node `VariableDeclaration` node to test\n         * @returns {void}\n         */\n        function checkForBlankLine(node) {\n\n            /*\n             * lastToken is the last token on the node's line. It will usually also be the last token of the node, but it will\n             * sometimes be second-last if there is a semicolon on a different line.\n             */\n            const lastToken = getLastToken(node),\n\n                /*\n                 * If lastToken is the last token of the node, nextToken should be the token after the node. Otherwise, nextToken\n                 * is the last token of the node.\n                 */\n                nextToken = lastToken === sourceCode.getLastToken(node) ? sourceCode.getTokenAfter(node) : sourceCode.getLastToken(node),\n                nextLineNum = lastToken.loc.end.line + 1;\n\n            // Ignore if there is no following statement\n            if (!nextToken) {\n                return;\n            }\n\n            // Ignore if parent of node is a for variant\n            if (isForTypeSpecifier(node.parent.type)) {\n                return;\n            }\n\n            // Ignore if parent of node is an export specifier\n            if (isExportSpecifier(node.parent.type)) {\n                return;\n            }\n\n            /*\n             * Some coding styles use multiple `var` statements, so do nothing if\n             * the next token is a `var` statement.\n             */\n            if (nextToken.type === \"Keyword\" && isVar(nextToken.value)) {\n                return;\n            }\n\n            // Ignore if it is last statement in a block\n            if (isLastNode(node)) {\n                return;\n            }\n\n            // Next statement is not a `var`...\n            const noNextLineToken = nextToken.loc.start.line > nextLineNum;\n            const hasNextLineComment = (typeof commentEndLine[nextLineNum] !== \"undefined\");\n\n            if (mode === \"never\" && noNextLineToken && !hasNextLineComment) {\n                context.report({\n                    node,\n                    messageId: \"unexpected\",\n                    data: { identifier: node.name },\n                    fix(fixer) {\n                        const linesBetween = sourceCode.getText().slice(lastToken.range[1], nextToken.range[0]).split(astUtils.LINEBREAK_MATCHER);\n\n                        return fixer.replaceTextRange([lastToken.range[1], nextToken.range[0]], `${linesBetween.slice(0, -1).join(\"\")}\\n${linesBetween[linesBetween.length - 1]}`);\n                    }\n                });\n            }\n\n            // Token on the next line, or comment without blank line\n            if (\n                mode === \"always\" && (\n                    !noNextLineToken ||\n                    hasNextLineComment && !hasBlankLineAfterComment(nextToken, nextLineNum)\n                )\n            ) {\n                context.report({\n                    node,\n                    messageId: \"expected\",\n                    data: { identifier: node.name },\n                    fix(fixer) {\n                        if ((noNextLineToken ? getLastCommentLineOfBlock(nextLineNum) : lastToken.loc.end.line) === nextToken.loc.start.line) {\n                            return fixer.insertTextBefore(nextToken, \"\\n\\n\");\n                        }\n\n                        return fixer.insertTextBeforeRange([nextToken.range[0] - nextToken.loc.start.column, nextToken.range[1]], \"\\n\");\n                    }\n                });\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            VariableDeclaration: checkForBlankLine\n        };\n\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}