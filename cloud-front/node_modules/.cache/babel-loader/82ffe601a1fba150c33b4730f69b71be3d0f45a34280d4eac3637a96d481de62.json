{"ast":null,"code":"/**\n * @fileoverview Disallow use of multiple spaces.\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"disallow multiple spaces\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-multi-spaces\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      type: \"object\",\n      properties: {\n        exceptions: {\n          type: \"object\",\n          patternProperties: {\n            \"^([A-Z][a-z]*)+$\": {\n              type: \"boolean\"\n            }\n          },\n          additionalProperties: false\n        },\n        ignoreEOLComments: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      multipleSpaces: \"Multiple spaces found before '{{displayValue}}'.\"\n    }\n  },\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const options = context.options[0] || {};\n    const ignoreEOLComments = options.ignoreEOLComments;\n    const exceptions = Object.assign({\n      Property: true\n    }, options.exceptions);\n    const hasExceptions = Object.keys(exceptions).filter(key => exceptions[key]).length > 0;\n\n    /**\n     * Formats value of given comment token for error message by truncating its length.\n     * @param {Token} token comment token\n     * @returns {string} formatted value\n     * @private\n     */\n    function formatReportedCommentValue(token) {\n      const valueLines = token.value.split(\"\\n\");\n      const value = valueLines[0];\n      const formattedValue = `${value.slice(0, 12)}...`;\n      return valueLines.length === 1 && value.length <= 12 ? value : formattedValue;\n    }\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    return {\n      Program() {\n        sourceCode.tokensAndComments.forEach((leftToken, leftIndex, tokensAndComments) => {\n          if (leftIndex === tokensAndComments.length - 1) {\n            return;\n          }\n          const rightToken = tokensAndComments[leftIndex + 1];\n\n          // Ignore tokens that don't have 2 spaces between them or are on different lines\n          if (!sourceCode.text.slice(leftToken.range[1], rightToken.range[0]).includes(\"  \") || leftToken.loc.end.line < rightToken.loc.start.line) {\n            return;\n          }\n\n          // Ignore comments that are the last token on their line if `ignoreEOLComments` is active.\n          if (ignoreEOLComments && astUtils.isCommentToken(rightToken) && (leftIndex === tokensAndComments.length - 2 || rightToken.loc.end.line < tokensAndComments[leftIndex + 2].loc.start.line)) {\n            return;\n          }\n\n          // Ignore tokens that are in a node in the \"exceptions\" object\n          if (hasExceptions) {\n            const parentNode = sourceCode.getNodeByRangeIndex(rightToken.range[0] - 1);\n            if (parentNode && exceptions[parentNode.type]) {\n              return;\n            }\n          }\n          let displayValue;\n          if (rightToken.type === \"Block\") {\n            displayValue = `/*${formatReportedCommentValue(rightToken)}*/`;\n          } else if (rightToken.type === \"Line\") {\n            displayValue = `//${formatReportedCommentValue(rightToken)}`;\n          } else {\n            displayValue = rightToken.value;\n          }\n          context.report({\n            node: rightToken,\n            loc: {\n              start: leftToken.loc.end,\n              end: rightToken.loc.start\n            },\n            messageId: \"multipleSpaces\",\n            data: {\n              displayValue\n            },\n            fix: fixer => fixer.replaceTextRange([leftToken.range[1], rightToken.range[0]], \" \")\n          });\n        });\n      }\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","module","exports","meta","type","docs","description","category","recommended","url","fixable","schema","properties","exceptions","patternProperties","additionalProperties","ignoreEOLComments","default","messages","multipleSpaces","create","context","sourceCode","getSourceCode","options","Object","assign","Property","hasExceptions","keys","filter","key","length","formatReportedCommentValue","token","valueLines","value","split","formattedValue","slice","Program","tokensAndComments","forEach","leftToken","leftIndex","rightToken","text","range","includes","loc","end","line","start","isCommentToken","parentNode","getNodeByRangeIndex","displayValue","report","node","messageId","data","fix","fixer","replaceTextRange"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/no-multi-spaces.js"],"sourcesContent":["/**\n * @fileoverview Disallow use of multiple spaces.\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"disallow multiple spaces\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-multi-spaces\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    exceptions: {\n                        type: \"object\",\n                        patternProperties: {\n                            \"^([A-Z][a-z]*)+$\": {\n                                type: \"boolean\"\n                            }\n                        },\n                        additionalProperties: false\n                    },\n                    ignoreEOLComments: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            multipleSpaces: \"Multiple spaces found before '{{displayValue}}'.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const options = context.options[0] || {};\n        const ignoreEOLComments = options.ignoreEOLComments;\n        const exceptions = Object.assign({ Property: true }, options.exceptions);\n        const hasExceptions = Object.keys(exceptions).filter(key => exceptions[key]).length > 0;\n\n        /**\n         * Formats value of given comment token for error message by truncating its length.\n         * @param {Token} token comment token\n         * @returns {string} formatted value\n         * @private\n         */\n        function formatReportedCommentValue(token) {\n            const valueLines = token.value.split(\"\\n\");\n            const value = valueLines[0];\n            const formattedValue = `${value.slice(0, 12)}...`;\n\n            return valueLines.length === 1 && value.length <= 12 ? value : formattedValue;\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            Program() {\n                sourceCode.tokensAndComments.forEach((leftToken, leftIndex, tokensAndComments) => {\n                    if (leftIndex === tokensAndComments.length - 1) {\n                        return;\n                    }\n                    const rightToken = tokensAndComments[leftIndex + 1];\n\n                    // Ignore tokens that don't have 2 spaces between them or are on different lines\n                    if (\n                        !sourceCode.text.slice(leftToken.range[1], rightToken.range[0]).includes(\"  \") ||\n                        leftToken.loc.end.line < rightToken.loc.start.line\n                    ) {\n                        return;\n                    }\n\n                    // Ignore comments that are the last token on their line if `ignoreEOLComments` is active.\n                    if (\n                        ignoreEOLComments &&\n                        astUtils.isCommentToken(rightToken) &&\n                        (\n                            leftIndex === tokensAndComments.length - 2 ||\n                            rightToken.loc.end.line < tokensAndComments[leftIndex + 2].loc.start.line\n                        )\n                    ) {\n                        return;\n                    }\n\n                    // Ignore tokens that are in a node in the \"exceptions\" object\n                    if (hasExceptions) {\n                        const parentNode = sourceCode.getNodeByRangeIndex(rightToken.range[0] - 1);\n\n                        if (parentNode && exceptions[parentNode.type]) {\n                            return;\n                        }\n                    }\n\n                    let displayValue;\n\n                    if (rightToken.type === \"Block\") {\n                        displayValue = `/*${formatReportedCommentValue(rightToken)}*/`;\n                    } else if (rightToken.type === \"Line\") {\n                        displayValue = `//${formatReportedCommentValue(rightToken)}`;\n                    } else {\n                        displayValue = rightToken.value;\n                    }\n\n                    context.report({\n                        node: rightToken,\n                        loc: { start: leftToken.loc.end, end: rightToken.loc.start },\n                        messageId: \"multipleSpaces\",\n                        data: { displayValue },\n                        fix: fixer => fixer.replaceTextRange([leftToken.range[1], rightToken.range[0]], \" \")\n                    });\n                });\n            }\n        };\n\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}