{"ast":null,"code":"'use strict';\n\n/*eslint-disable max-len*/\nrequire(\"core-js/modules/es.array.push.js\");\nvar common = require('./common');\nvar YAMLException = require('./exception');\nvar Type = require('./type');\nfunction compileList(schema, name, result) {\n  var exclude = [];\n  schema.include.forEach(function (includedSchema) {\n    result = compileList(includedSchema, name, result);\n  });\n  schema[name].forEach(function (currentType) {\n    result.forEach(function (previousType, previousIndex) {\n      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind) {\n        exclude.push(previousIndex);\n      }\n    });\n    result.push(currentType);\n  });\n  return result.filter(function (type, index) {\n    return exclude.indexOf(index) === -1;\n  });\n}\nfunction compileMap( /* lists... */\n) {\n  var result = {\n      scalar: {},\n      sequence: {},\n      mapping: {},\n      fallback: {}\n    },\n    index,\n    length;\n  function collectType(type) {\n    result[type.kind][type.tag] = result['fallback'][type.tag] = type;\n  }\n  for (index = 0, length = arguments.length; index < length; index += 1) {\n    arguments[index].forEach(collectType);\n  }\n  return result;\n}\nfunction Schema(definition) {\n  this.include = definition.include || [];\n  this.implicit = definition.implicit || [];\n  this.explicit = definition.explicit || [];\n  this.implicit.forEach(function (type) {\n    if (type.loadKind && type.loadKind !== 'scalar') {\n      throw new YAMLException('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');\n    }\n  });\n  this.compiledImplicit = compileList(this, 'implicit', []);\n  this.compiledExplicit = compileList(this, 'explicit', []);\n  this.compiledTypeMap = compileMap(this.compiledImplicit, this.compiledExplicit);\n}\nSchema.DEFAULT = null;\nSchema.create = function createSchema() {\n  var schemas, types;\n  switch (arguments.length) {\n    case 1:\n      schemas = Schema.DEFAULT;\n      types = arguments[0];\n      break;\n    case 2:\n      schemas = arguments[0];\n      types = arguments[1];\n      break;\n    default:\n      throw new YAMLException('Wrong number of arguments for Schema.create function');\n  }\n  schemas = common.toArray(schemas);\n  types = common.toArray(types);\n  if (!schemas.every(function (schema) {\n    return schema instanceof Schema;\n  })) {\n    throw new YAMLException('Specified list of super schemas (or a single Schema object) contains a non-Schema object.');\n  }\n  if (!types.every(function (type) {\n    return type instanceof Type;\n  })) {\n    throw new YAMLException('Specified list of YAML types (or a single Type object) contains a non-Type object.');\n  }\n  return new Schema({\n    include: schemas,\n    explicit: types\n  });\n};\nmodule.exports = Schema;","map":{"version":3,"names":["require","common","YAMLException","Type","compileList","schema","name","result","exclude","include","forEach","includedSchema","currentType","previousType","previousIndex","tag","kind","push","filter","type","index","indexOf","compileMap","scalar","sequence","mapping","fallback","length","collectType","arguments","Schema","definition","implicit","explicit","loadKind","compiledImplicit","compiledExplicit","compiledTypeMap","DEFAULT","create","createSchema","schemas","types","toArray","every","module","exports"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/js-yaml/lib/js-yaml/schema.js"],"sourcesContent":["'use strict';\n\n/*eslint-disable max-len*/\n\nvar common        = require('./common');\nvar YAMLException = require('./exception');\nvar Type          = require('./type');\n\n\nfunction compileList(schema, name, result) {\n  var exclude = [];\n\n  schema.include.forEach(function (includedSchema) {\n    result = compileList(includedSchema, name, result);\n  });\n\n  schema[name].forEach(function (currentType) {\n    result.forEach(function (previousType, previousIndex) {\n      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind) {\n        exclude.push(previousIndex);\n      }\n    });\n\n    result.push(currentType);\n  });\n\n  return result.filter(function (type, index) {\n    return exclude.indexOf(index) === -1;\n  });\n}\n\n\nfunction compileMap(/* lists... */) {\n  var result = {\n        scalar: {},\n        sequence: {},\n        mapping: {},\n        fallback: {}\n      }, index, length;\n\n  function collectType(type) {\n    result[type.kind][type.tag] = result['fallback'][type.tag] = type;\n  }\n\n  for (index = 0, length = arguments.length; index < length; index += 1) {\n    arguments[index].forEach(collectType);\n  }\n  return result;\n}\n\n\nfunction Schema(definition) {\n  this.include  = definition.include  || [];\n  this.implicit = definition.implicit || [];\n  this.explicit = definition.explicit || [];\n\n  this.implicit.forEach(function (type) {\n    if (type.loadKind && type.loadKind !== 'scalar') {\n      throw new YAMLException('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');\n    }\n  });\n\n  this.compiledImplicit = compileList(this, 'implicit', []);\n  this.compiledExplicit = compileList(this, 'explicit', []);\n  this.compiledTypeMap  = compileMap(this.compiledImplicit, this.compiledExplicit);\n}\n\n\nSchema.DEFAULT = null;\n\n\nSchema.create = function createSchema() {\n  var schemas, types;\n\n  switch (arguments.length) {\n    case 1:\n      schemas = Schema.DEFAULT;\n      types = arguments[0];\n      break;\n\n    case 2:\n      schemas = arguments[0];\n      types = arguments[1];\n      break;\n\n    default:\n      throw new YAMLException('Wrong number of arguments for Schema.create function');\n  }\n\n  schemas = common.toArray(schemas);\n  types = common.toArray(types);\n\n  if (!schemas.every(function (schema) { return schema instanceof Schema; })) {\n    throw new YAMLException('Specified list of super schemas (or a single Schema object) contains a non-Schema object.');\n  }\n\n  if (!types.every(function (type) { return type instanceof Type; })) {\n    throw new YAMLException('Specified list of YAML types (or a single Type object) contains a non-Type object.');\n  }\n\n  return new Schema({\n    include: schemas,\n    explicit: types\n  });\n};\n\n\nmodule.exports = Schema;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}