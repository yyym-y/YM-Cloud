{"ast":null,"code":"/**\n * @fileoverview Rule to flag use of eval() statement\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst candidatesOfGlobalObject = Object.freeze([\"global\", \"window\", \"globalThis\"]);\n\n/**\n * Checks a given node is a MemberExpression node which has the specified name's\n * property.\n * @param {ASTNode} node A node to check.\n * @param {string} name A name to check.\n * @returns {boolean} `true` if the node is a MemberExpression node which has\n *      the specified name's property\n */\nfunction isMember(node, name) {\n  return astUtils.isSpecificMemberAccess(node, null, name);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow the use of `eval()`\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-eval\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        allowIndirect: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unexpected: \"eval can be harmful.\"\n    }\n  },\n  create(context) {\n    const allowIndirect = Boolean(context.options[0] && context.options[0].allowIndirect);\n    const sourceCode = context.getSourceCode();\n    let funcInfo = null;\n\n    /**\n     * Pushs a variable scope (Program or Function) information to the stack.\n     *\n     * This is used in order to check whether or not `this` binding is a\n     * reference to the global object.\n     * @param {ASTNode} node A node of the scope. This is one of Program,\n     *      FunctionDeclaration, FunctionExpression, and ArrowFunctionExpression.\n     * @returns {void}\n     */\n    function enterVarScope(node) {\n      const strict = context.getScope().isStrict;\n      funcInfo = {\n        upper: funcInfo,\n        node,\n        strict,\n        defaultThis: false,\n        initialized: strict\n      };\n    }\n\n    /**\n     * Pops a variable scope from the stack.\n     * @returns {void}\n     */\n    function exitVarScope() {\n      funcInfo = funcInfo.upper;\n    }\n\n    /**\n     * Reports a given node.\n     *\n     * `node` is `Identifier` or `MemberExpression`.\n     * The parent of `node` might be `CallExpression`.\n     *\n     * The location of the report is always `eval` `Identifier` (or possibly\n     * `Literal`). The type of the report is `CallExpression` if the parent is\n     * `CallExpression`. Otherwise, it's the given node type.\n     * @param {ASTNode} node A node to report.\n     * @returns {void}\n     */\n    function report(node) {\n      const parent = node.parent;\n      const locationNode = node.type === \"MemberExpression\" ? node.property : node;\n      const reportNode = parent.type === \"CallExpression\" && parent.callee === node ? parent : node;\n      context.report({\n        node: reportNode,\n        loc: locationNode.loc,\n        messageId: \"unexpected\"\n      });\n    }\n\n    /**\n     * Reports accesses of `eval` via the global object.\n     * @param {eslint-scope.Scope} globalScope The global scope.\n     * @returns {void}\n     */\n    function reportAccessingEvalViaGlobalObject(globalScope) {\n      for (let i = 0; i < candidatesOfGlobalObject.length; ++i) {\n        const name = candidatesOfGlobalObject[i];\n        const variable = astUtils.getVariableByName(globalScope, name);\n        if (!variable) {\n          continue;\n        }\n        const references = variable.references;\n        for (let j = 0; j < references.length; ++j) {\n          const identifier = references[j].identifier;\n          let node = identifier.parent;\n\n          // To detect code like `window.window.eval`.\n          while (isMember(node, name)) {\n            node = node.parent;\n          }\n\n          // Reports.\n          if (isMember(node, \"eval\")) {\n            report(node);\n          }\n        }\n      }\n    }\n\n    /**\n     * Reports all accesses of `eval` (excludes direct calls to eval).\n     * @param {eslint-scope.Scope} globalScope The global scope.\n     * @returns {void}\n     */\n    function reportAccessingEval(globalScope) {\n      const variable = astUtils.getVariableByName(globalScope, \"eval\");\n      if (!variable) {\n        return;\n      }\n      const references = variable.references;\n      for (let i = 0; i < references.length; ++i) {\n        const reference = references[i];\n        const id = reference.identifier;\n        if (id.name === \"eval\" && !astUtils.isCallee(id)) {\n          // Is accessing to eval (excludes direct calls to eval)\n          report(id);\n        }\n      }\n    }\n    if (allowIndirect) {\n      // Checks only direct calls to eval. It's simple!\n      return {\n        \"CallExpression:exit\"(node) {\n          const callee = node.callee;\n\n          /*\n           * Optional call (`eval?.(\"code\")`) is not direct eval.\n           * The direct eval is only step 6.a.vi of https://tc39.es/ecma262/#sec-function-calls-runtime-semantics-evaluation\n           * But the optional call is https://tc39.es/ecma262/#sec-optional-chaining-chain-evaluation\n           */\n          if (!node.optional && astUtils.isSpecificId(callee, \"eval\")) {\n            report(callee);\n          }\n        }\n      };\n    }\n    return {\n      \"CallExpression:exit\"(node) {\n        const callee = node.callee;\n        if (astUtils.isSpecificId(callee, \"eval\")) {\n          report(callee);\n        }\n      },\n      Program(node) {\n        const scope = context.getScope(),\n          features = context.parserOptions.ecmaFeatures || {},\n          strict = scope.isStrict || node.sourceType === \"module\" || features.globalReturn && scope.childScopes[0].isStrict;\n        funcInfo = {\n          upper: null,\n          node,\n          strict,\n          defaultThis: true,\n          initialized: true\n        };\n      },\n      \"Program:exit\"() {\n        const globalScope = context.getScope();\n        exitVarScope();\n        reportAccessingEval(globalScope);\n        reportAccessingEvalViaGlobalObject(globalScope);\n      },\n      FunctionDeclaration: enterVarScope,\n      \"FunctionDeclaration:exit\": exitVarScope,\n      FunctionExpression: enterVarScope,\n      \"FunctionExpression:exit\": exitVarScope,\n      ArrowFunctionExpression: enterVarScope,\n      \"ArrowFunctionExpression:exit\": exitVarScope,\n      ThisExpression(node) {\n        if (!isMember(node.parent, \"eval\")) {\n          return;\n        }\n\n        /*\n         * `this.eval` is found.\n         * Checks whether or not the value of `this` is the global object.\n         */\n        if (!funcInfo.initialized) {\n          funcInfo.initialized = true;\n          funcInfo.defaultThis = astUtils.isDefaultThisBinding(funcInfo.node, sourceCode);\n        }\n        if (!funcInfo.strict && funcInfo.defaultThis) {\n          // `this.eval` is possible built-in `eval`.\n          report(node.parent);\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","candidatesOfGlobalObject","Object","freeze","isMember","node","name","isSpecificMemberAccess","module","exports","meta","type","docs","description","category","recommended","url","schema","properties","allowIndirect","default","additionalProperties","messages","unexpected","create","context","Boolean","options","sourceCode","getSourceCode","funcInfo","enterVarScope","strict","getScope","isStrict","upper","defaultThis","initialized","exitVarScope","report","parent","locationNode","property","reportNode","callee","loc","messageId","reportAccessingEvalViaGlobalObject","globalScope","i","length","variable","getVariableByName","references","j","identifier","reportAccessingEval","reference","id","isCallee","CallExpression:exit","optional","isSpecificId","Program","scope","features","parserOptions","ecmaFeatures","sourceType","globalReturn","childScopes","Program:exit","FunctionDeclaration","FunctionExpression","ArrowFunctionExpression","ThisExpression","isDefaultThisBinding"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/no-eval.js"],"sourcesContent":["/**\n * @fileoverview Rule to flag use of eval() statement\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst candidatesOfGlobalObject = Object.freeze([\n    \"global\",\n    \"window\",\n    \"globalThis\"\n]);\n\n/**\n * Checks a given node is a MemberExpression node which has the specified name's\n * property.\n * @param {ASTNode} node A node to check.\n * @param {string} name A name to check.\n * @returns {boolean} `true` if the node is a MemberExpression node which has\n *      the specified name's property\n */\nfunction isMember(node, name) {\n    return astUtils.isSpecificMemberAccess(node, null, name);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow the use of `eval()`\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-eval\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allowIndirect: { type: \"boolean\", default: false }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            unexpected: \"eval can be harmful.\"\n        }\n    },\n\n    create(context) {\n        const allowIndirect = Boolean(\n            context.options[0] &&\n            context.options[0].allowIndirect\n        );\n        const sourceCode = context.getSourceCode();\n        let funcInfo = null;\n\n        /**\n         * Pushs a variable scope (Program or Function) information to the stack.\n         *\n         * This is used in order to check whether or not `this` binding is a\n         * reference to the global object.\n         * @param {ASTNode} node A node of the scope. This is one of Program,\n         *      FunctionDeclaration, FunctionExpression, and ArrowFunctionExpression.\n         * @returns {void}\n         */\n        function enterVarScope(node) {\n            const strict = context.getScope().isStrict;\n\n            funcInfo = {\n                upper: funcInfo,\n                node,\n                strict,\n                defaultThis: false,\n                initialized: strict\n            };\n        }\n\n        /**\n         * Pops a variable scope from the stack.\n         * @returns {void}\n         */\n        function exitVarScope() {\n            funcInfo = funcInfo.upper;\n        }\n\n        /**\n         * Reports a given node.\n         *\n         * `node` is `Identifier` or `MemberExpression`.\n         * The parent of `node` might be `CallExpression`.\n         *\n         * The location of the report is always `eval` `Identifier` (or possibly\n         * `Literal`). The type of the report is `CallExpression` if the parent is\n         * `CallExpression`. Otherwise, it's the given node type.\n         * @param {ASTNode} node A node to report.\n         * @returns {void}\n         */\n        function report(node) {\n            const parent = node.parent;\n            const locationNode = node.type === \"MemberExpression\"\n                ? node.property\n                : node;\n\n            const reportNode = parent.type === \"CallExpression\" && parent.callee === node\n                ? parent\n                : node;\n\n            context.report({\n                node: reportNode,\n                loc: locationNode.loc,\n                messageId: \"unexpected\"\n            });\n        }\n\n        /**\n         * Reports accesses of `eval` via the global object.\n         * @param {eslint-scope.Scope} globalScope The global scope.\n         * @returns {void}\n         */\n        function reportAccessingEvalViaGlobalObject(globalScope) {\n            for (let i = 0; i < candidatesOfGlobalObject.length; ++i) {\n                const name = candidatesOfGlobalObject[i];\n                const variable = astUtils.getVariableByName(globalScope, name);\n\n                if (!variable) {\n                    continue;\n                }\n\n                const references = variable.references;\n\n                for (let j = 0; j < references.length; ++j) {\n                    const identifier = references[j].identifier;\n                    let node = identifier.parent;\n\n                    // To detect code like `window.window.eval`.\n                    while (isMember(node, name)) {\n                        node = node.parent;\n                    }\n\n                    // Reports.\n                    if (isMember(node, \"eval\")) {\n                        report(node);\n                    }\n                }\n            }\n        }\n\n        /**\n         * Reports all accesses of `eval` (excludes direct calls to eval).\n         * @param {eslint-scope.Scope} globalScope The global scope.\n         * @returns {void}\n         */\n        function reportAccessingEval(globalScope) {\n            const variable = astUtils.getVariableByName(globalScope, \"eval\");\n\n            if (!variable) {\n                return;\n            }\n\n            const references = variable.references;\n\n            for (let i = 0; i < references.length; ++i) {\n                const reference = references[i];\n                const id = reference.identifier;\n\n                if (id.name === \"eval\" && !astUtils.isCallee(id)) {\n\n                    // Is accessing to eval (excludes direct calls to eval)\n                    report(id);\n                }\n            }\n        }\n\n        if (allowIndirect) {\n\n            // Checks only direct calls to eval. It's simple!\n            return {\n                \"CallExpression:exit\"(node) {\n                    const callee = node.callee;\n\n                    /*\n                     * Optional call (`eval?.(\"code\")`) is not direct eval.\n                     * The direct eval is only step 6.a.vi of https://tc39.es/ecma262/#sec-function-calls-runtime-semantics-evaluation\n                     * But the optional call is https://tc39.es/ecma262/#sec-optional-chaining-chain-evaluation\n                     */\n                    if (!node.optional && astUtils.isSpecificId(callee, \"eval\")) {\n                        report(callee);\n                    }\n                }\n            };\n        }\n\n        return {\n            \"CallExpression:exit\"(node) {\n                const callee = node.callee;\n\n                if (astUtils.isSpecificId(callee, \"eval\")) {\n                    report(callee);\n                }\n            },\n\n            Program(node) {\n                const scope = context.getScope(),\n                    features = context.parserOptions.ecmaFeatures || {},\n                    strict =\n                        scope.isStrict ||\n                        node.sourceType === \"module\" ||\n                        (features.globalReturn && scope.childScopes[0].isStrict);\n\n                funcInfo = {\n                    upper: null,\n                    node,\n                    strict,\n                    defaultThis: true,\n                    initialized: true\n                };\n            },\n\n            \"Program:exit\"() {\n                const globalScope = context.getScope();\n\n                exitVarScope();\n                reportAccessingEval(globalScope);\n                reportAccessingEvalViaGlobalObject(globalScope);\n            },\n\n            FunctionDeclaration: enterVarScope,\n            \"FunctionDeclaration:exit\": exitVarScope,\n            FunctionExpression: enterVarScope,\n            \"FunctionExpression:exit\": exitVarScope,\n            ArrowFunctionExpression: enterVarScope,\n            \"ArrowFunctionExpression:exit\": exitVarScope,\n\n            ThisExpression(node) {\n                if (!isMember(node.parent, \"eval\")) {\n                    return;\n                }\n\n                /*\n                 * `this.eval` is found.\n                 * Checks whether or not the value of `this` is the global object.\n                 */\n                if (!funcInfo.initialized) {\n                    funcInfo.initialized = true;\n                    funcInfo.defaultThis = astUtils.isDefaultThisBinding(\n                        funcInfo.node,\n                        sourceCode\n                    );\n                }\n\n                if (!funcInfo.strict && funcInfo.defaultThis) {\n\n                    // `this.eval` is possible built-in `eval`.\n                    report(node.parent);\n                }\n            }\n        };\n\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}