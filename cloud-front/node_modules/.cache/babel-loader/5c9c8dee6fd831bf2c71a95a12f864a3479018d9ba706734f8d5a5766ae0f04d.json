{"ast":null,"code":"/**\n * @fileoverview Prefers object spread property over Object.assign\n * @author Sharmila Jesupaul\n * See LICENSE file in root directory for full license.\n */\n\n\"use strict\";\n\nrequire(\"core-js/modules/es.array.push.js\");\nconst {\n  CALL,\n  ReferenceTracker\n} = require(\"eslint-utils\");\nconst {\n  isCommaToken,\n  isOpeningParenToken,\n  isClosingParenToken,\n  isParenthesised\n} = require(\"./utils/ast-utils\");\nconst ANY_SPACE = /\\s/u;\n\n/**\n * Helper that checks if the Object.assign call has array spread\n * @param {ASTNode} node The node that the rule warns on\n * @returns {boolean} - Returns true if the Object.assign call has array spread\n */\nfunction hasArraySpread(node) {\n  return node.arguments.some(arg => arg.type === \"SpreadElement\");\n}\n\n/**\n * Determines whether the given node is an accessor property (getter/setter).\n * @param {ASTNode} node Node to check.\n * @returns {boolean} `true` if the node is a getter or a setter.\n */\nfunction isAccessorProperty(node) {\n  return node.type === \"Property\" && (node.kind === \"get\" || node.kind === \"set\");\n}\n\n/**\n * Determines whether the given object expression node has accessor properties (getters/setters).\n * @param {ASTNode} node `ObjectExpression` node to check.\n * @returns {boolean} `true` if the node has at least one getter/setter.\n */\nfunction hasAccessors(node) {\n  return node.properties.some(isAccessorProperty);\n}\n\n/**\n * Determines whether the given call expression node has object expression arguments with accessor properties (getters/setters).\n * @param {ASTNode} node `CallExpression` node to check.\n * @returns {boolean} `true` if the node has at least one argument that is an object expression with at least one getter/setter.\n */\nfunction hasArgumentsWithAccessors(node) {\n  return node.arguments.filter(arg => arg.type === \"ObjectExpression\").some(hasAccessors);\n}\n\n/**\n * Helper that checks if the node needs parentheses to be valid JS.\n * The default is to wrap the node in parentheses to avoid parsing errors.\n * @param {ASTNode} node The node that the rule warns on\n * @param {Object} sourceCode in context sourcecode object\n * @returns {boolean} - Returns true if the node needs parentheses\n */\nfunction needsParens(node, sourceCode) {\n  const parent = node.parent;\n  switch (parent.type) {\n    case \"VariableDeclarator\":\n    case \"ArrayExpression\":\n    case \"ReturnStatement\":\n    case \"CallExpression\":\n    case \"Property\":\n      return false;\n    case \"AssignmentExpression\":\n      return parent.left === node && !isParenthesised(sourceCode, node);\n    default:\n      return !isParenthesised(sourceCode, node);\n  }\n}\n\n/**\n * Determines if an argument needs parentheses. The default is to not add parens.\n * @param {ASTNode} node The node to be checked.\n * @param {Object} sourceCode in context sourcecode object\n * @returns {boolean} True if the node needs parentheses\n */\nfunction argNeedsParens(node, sourceCode) {\n  switch (node.type) {\n    case \"AssignmentExpression\":\n    case \"ArrowFunctionExpression\":\n    case \"ConditionalExpression\":\n      return !isParenthesised(sourceCode, node);\n    default:\n      return false;\n  }\n}\n\n/**\n * Get the parenthesis tokens of a given ObjectExpression node.\n * This includes the braces of the object literal and enclosing parentheses.\n * @param {ASTNode} node The node to get.\n * @param {Token} leftArgumentListParen The opening paren token of the argument list.\n * @param {SourceCode} sourceCode The source code object to get tokens.\n * @returns {Token[]} The parenthesis tokens of the node. This is sorted by the location.\n */\nfunction getParenTokens(node, leftArgumentListParen, sourceCode) {\n  const parens = [sourceCode.getFirstToken(node), sourceCode.getLastToken(node)];\n  let leftNext = sourceCode.getTokenBefore(node);\n  let rightNext = sourceCode.getTokenAfter(node);\n\n  // Note: don't include the parens of the argument list.\n  while (leftNext && rightNext && leftNext.range[0] > leftArgumentListParen.range[0] && isOpeningParenToken(leftNext) && isClosingParenToken(rightNext)) {\n    parens.push(leftNext, rightNext);\n    leftNext = sourceCode.getTokenBefore(leftNext);\n    rightNext = sourceCode.getTokenAfter(rightNext);\n  }\n  return parens.sort((a, b) => a.range[0] - b.range[0]);\n}\n\n/**\n * Get the range of a given token and around whitespaces.\n * @param {Token} token The token to get range.\n * @param {SourceCode} sourceCode The source code object to get tokens.\n * @returns {number} The end of the range of the token and around whitespaces.\n */\nfunction getStartWithSpaces(token, sourceCode) {\n  const text = sourceCode.text;\n  let start = token.range[0];\n\n  // If the previous token is a line comment then skip this step to avoid commenting this token out.\n  {\n    const prevToken = sourceCode.getTokenBefore(token, {\n      includeComments: true\n    });\n    if (prevToken && prevToken.type === \"Line\") {\n      return start;\n    }\n  }\n\n  // Detect spaces before the token.\n  while (ANY_SPACE.test(text[start - 1] || \"\")) {\n    start -= 1;\n  }\n  return start;\n}\n\n/**\n * Get the range of a given token and around whitespaces.\n * @param {Token} token The token to get range.\n * @param {SourceCode} sourceCode The source code object to get tokens.\n * @returns {number} The start of the range of the token and around whitespaces.\n */\nfunction getEndWithSpaces(token, sourceCode) {\n  const text = sourceCode.text;\n  let end = token.range[1];\n\n  // Detect spaces after the token.\n  while (ANY_SPACE.test(text[end] || \"\")) {\n    end += 1;\n  }\n  return end;\n}\n\n/**\n * Autofixes the Object.assign call to use an object spread instead.\n * @param {ASTNode|null} node The node that the rule warns on, i.e. the Object.assign call\n * @param {string} sourceCode sourceCode of the Object.assign call\n * @returns {Function} autofixer - replaces the Object.assign with a spread object.\n */\nfunction defineFixer(node, sourceCode) {\n  return function* (fixer) {\n    const leftParen = sourceCode.getTokenAfter(node.callee, isOpeningParenToken);\n    const rightParen = sourceCode.getLastToken(node);\n\n    // Remove everything before the opening paren: callee `Object.assign`, type arguments, and whitespace between the callee and the paren.\n    yield fixer.removeRange([node.range[0], leftParen.range[0]]);\n\n    // Replace the parens of argument list to braces.\n    if (needsParens(node, sourceCode)) {\n      yield fixer.replaceText(leftParen, \"({\");\n      yield fixer.replaceText(rightParen, \"})\");\n    } else {\n      yield fixer.replaceText(leftParen, \"{\");\n      yield fixer.replaceText(rightParen, \"}\");\n    }\n\n    // Process arguments.\n    for (const argNode of node.arguments) {\n      const innerParens = getParenTokens(argNode, leftParen, sourceCode);\n      const left = innerParens.shift();\n      const right = innerParens.pop();\n      if (argNode.type === \"ObjectExpression\") {\n        const maybeTrailingComma = sourceCode.getLastToken(argNode, 1);\n        const maybeArgumentComma = sourceCode.getTokenAfter(right);\n\n        /*\n         * Make bare this object literal.\n         * And remove spaces inside of the braces for better formatting.\n         */\n        for (const innerParen of innerParens) {\n          yield fixer.remove(innerParen);\n        }\n        const leftRange = [left.range[0], getEndWithSpaces(left, sourceCode)];\n        const rightRange = [Math.max(getStartWithSpaces(right, sourceCode), leftRange[1]),\n        // Ensure ranges don't overlap\n        right.range[1]];\n        yield fixer.removeRange(leftRange);\n        yield fixer.removeRange(rightRange);\n\n        // Remove the comma of this argument if it's duplication.\n        if ((argNode.properties.length === 0 || isCommaToken(maybeTrailingComma)) && isCommaToken(maybeArgumentComma)) {\n          yield fixer.remove(maybeArgumentComma);\n        }\n      } else {\n        // Make spread.\n        if (argNeedsParens(argNode, sourceCode)) {\n          yield fixer.insertTextBefore(left, \"...(\");\n          yield fixer.insertTextAfter(right, \")\");\n        } else {\n          yield fixer.insertTextBefore(left, \"...\");\n        }\n      }\n    }\n  };\n}\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow using Object.assign with an object literal as the first argument and prefer the use of object spread instead.\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/prefer-object-spread\"\n    },\n    schema: [],\n    fixable: \"code\",\n    messages: {\n      useSpreadMessage: \"Use an object spread instead of `Object.assign` eg: `{ ...foo }`.\",\n      useLiteralMessage: \"Use an object literal instead of `Object.assign`. eg: `{ foo: bar }`.\"\n    }\n  },\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    return {\n      Program() {\n        const scope = context.getScope();\n        const tracker = new ReferenceTracker(scope);\n        const trackMap = {\n          Object: {\n            assign: {\n              [CALL]: true\n            }\n          }\n        };\n\n        // Iterate all calls of `Object.assign` (only of the global variable `Object`).\n        for (const {\n          node\n        } of tracker.iterateGlobalReferences(trackMap)) {\n          if (node.arguments.length >= 1 && node.arguments[0].type === \"ObjectExpression\" && !hasArraySpread(node) && !(node.arguments.length > 1 && hasArgumentsWithAccessors(node))) {\n            const messageId = node.arguments.length === 1 ? \"useLiteralMessage\" : \"useSpreadMessage\";\n            const fix = defineFixer(node, sourceCode);\n            context.report({\n              node,\n              messageId,\n              fix\n            });\n          }\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["require","CALL","ReferenceTracker","isCommaToken","isOpeningParenToken","isClosingParenToken","isParenthesised","ANY_SPACE","hasArraySpread","node","arguments","some","arg","type","isAccessorProperty","kind","hasAccessors","properties","hasArgumentsWithAccessors","filter","needsParens","sourceCode","parent","left","argNeedsParens","getParenTokens","leftArgumentListParen","parens","getFirstToken","getLastToken","leftNext","getTokenBefore","rightNext","getTokenAfter","range","push","sort","a","b","getStartWithSpaces","token","text","start","prevToken","includeComments","test","getEndWithSpaces","end","defineFixer","fixer","leftParen","callee","rightParen","removeRange","replaceText","argNode","innerParens","shift","right","pop","maybeTrailingComma","maybeArgumentComma","innerParen","remove","leftRange","rightRange","Math","max","length","insertTextBefore","insertTextAfter","module","exports","meta","docs","description","category","recommended","url","schema","fixable","messages","useSpreadMessage","useLiteralMessage","create","context","getSourceCode","Program","scope","getScope","tracker","trackMap","Object","assign","iterateGlobalReferences","messageId","fix","report"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/prefer-object-spread.js"],"sourcesContent":["/**\n * @fileoverview Prefers object spread property over Object.assign\n * @author Sharmila Jesupaul\n * See LICENSE file in root directory for full license.\n */\n\n\"use strict\";\n\nconst { CALL, ReferenceTracker } = require(\"eslint-utils\");\nconst {\n    isCommaToken,\n    isOpeningParenToken,\n    isClosingParenToken,\n    isParenthesised\n} = require(\"./utils/ast-utils\");\n\nconst ANY_SPACE = /\\s/u;\n\n/**\n * Helper that checks if the Object.assign call has array spread\n * @param {ASTNode} node The node that the rule warns on\n * @returns {boolean} - Returns true if the Object.assign call has array spread\n */\nfunction hasArraySpread(node) {\n    return node.arguments.some(arg => arg.type === \"SpreadElement\");\n}\n\n/**\n * Determines whether the given node is an accessor property (getter/setter).\n * @param {ASTNode} node Node to check.\n * @returns {boolean} `true` if the node is a getter or a setter.\n */\nfunction isAccessorProperty(node) {\n    return node.type === \"Property\" &&\n        (node.kind === \"get\" || node.kind === \"set\");\n}\n\n/**\n * Determines whether the given object expression node has accessor properties (getters/setters).\n * @param {ASTNode} node `ObjectExpression` node to check.\n * @returns {boolean} `true` if the node has at least one getter/setter.\n */\nfunction hasAccessors(node) {\n    return node.properties.some(isAccessorProperty);\n}\n\n/**\n * Determines whether the given call expression node has object expression arguments with accessor properties (getters/setters).\n * @param {ASTNode} node `CallExpression` node to check.\n * @returns {boolean} `true` if the node has at least one argument that is an object expression with at least one getter/setter.\n */\nfunction hasArgumentsWithAccessors(node) {\n    return node.arguments\n        .filter(arg => arg.type === \"ObjectExpression\")\n        .some(hasAccessors);\n}\n\n/**\n * Helper that checks if the node needs parentheses to be valid JS.\n * The default is to wrap the node in parentheses to avoid parsing errors.\n * @param {ASTNode} node The node that the rule warns on\n * @param {Object} sourceCode in context sourcecode object\n * @returns {boolean} - Returns true if the node needs parentheses\n */\nfunction needsParens(node, sourceCode) {\n    const parent = node.parent;\n\n    switch (parent.type) {\n        case \"VariableDeclarator\":\n        case \"ArrayExpression\":\n        case \"ReturnStatement\":\n        case \"CallExpression\":\n        case \"Property\":\n            return false;\n        case \"AssignmentExpression\":\n            return parent.left === node && !isParenthesised(sourceCode, node);\n        default:\n            return !isParenthesised(sourceCode, node);\n    }\n}\n\n/**\n * Determines if an argument needs parentheses. The default is to not add parens.\n * @param {ASTNode} node The node to be checked.\n * @param {Object} sourceCode in context sourcecode object\n * @returns {boolean} True if the node needs parentheses\n */\nfunction argNeedsParens(node, sourceCode) {\n    switch (node.type) {\n        case \"AssignmentExpression\":\n        case \"ArrowFunctionExpression\":\n        case \"ConditionalExpression\":\n            return !isParenthesised(sourceCode, node);\n        default:\n            return false;\n    }\n}\n\n/**\n * Get the parenthesis tokens of a given ObjectExpression node.\n * This includes the braces of the object literal and enclosing parentheses.\n * @param {ASTNode} node The node to get.\n * @param {Token} leftArgumentListParen The opening paren token of the argument list.\n * @param {SourceCode} sourceCode The source code object to get tokens.\n * @returns {Token[]} The parenthesis tokens of the node. This is sorted by the location.\n */\nfunction getParenTokens(node, leftArgumentListParen, sourceCode) {\n    const parens = [sourceCode.getFirstToken(node), sourceCode.getLastToken(node)];\n    let leftNext = sourceCode.getTokenBefore(node);\n    let rightNext = sourceCode.getTokenAfter(node);\n\n    // Note: don't include the parens of the argument list.\n    while (\n        leftNext &&\n        rightNext &&\n        leftNext.range[0] > leftArgumentListParen.range[0] &&\n        isOpeningParenToken(leftNext) &&\n        isClosingParenToken(rightNext)\n    ) {\n        parens.push(leftNext, rightNext);\n        leftNext = sourceCode.getTokenBefore(leftNext);\n        rightNext = sourceCode.getTokenAfter(rightNext);\n    }\n\n    return parens.sort((a, b) => a.range[0] - b.range[0]);\n}\n\n/**\n * Get the range of a given token and around whitespaces.\n * @param {Token} token The token to get range.\n * @param {SourceCode} sourceCode The source code object to get tokens.\n * @returns {number} The end of the range of the token and around whitespaces.\n */\nfunction getStartWithSpaces(token, sourceCode) {\n    const text = sourceCode.text;\n    let start = token.range[0];\n\n    // If the previous token is a line comment then skip this step to avoid commenting this token out.\n    {\n        const prevToken = sourceCode.getTokenBefore(token, { includeComments: true });\n\n        if (prevToken && prevToken.type === \"Line\") {\n            return start;\n        }\n    }\n\n    // Detect spaces before the token.\n    while (ANY_SPACE.test(text[start - 1] || \"\")) {\n        start -= 1;\n    }\n\n    return start;\n}\n\n/**\n * Get the range of a given token and around whitespaces.\n * @param {Token} token The token to get range.\n * @param {SourceCode} sourceCode The source code object to get tokens.\n * @returns {number} The start of the range of the token and around whitespaces.\n */\nfunction getEndWithSpaces(token, sourceCode) {\n    const text = sourceCode.text;\n    let end = token.range[1];\n\n    // Detect spaces after the token.\n    while (ANY_SPACE.test(text[end] || \"\")) {\n        end += 1;\n    }\n\n    return end;\n}\n\n/**\n * Autofixes the Object.assign call to use an object spread instead.\n * @param {ASTNode|null} node The node that the rule warns on, i.e. the Object.assign call\n * @param {string} sourceCode sourceCode of the Object.assign call\n * @returns {Function} autofixer - replaces the Object.assign with a spread object.\n */\nfunction defineFixer(node, sourceCode) {\n    return function *(fixer) {\n        const leftParen = sourceCode.getTokenAfter(node.callee, isOpeningParenToken);\n        const rightParen = sourceCode.getLastToken(node);\n\n        // Remove everything before the opening paren: callee `Object.assign`, type arguments, and whitespace between the callee and the paren.\n        yield fixer.removeRange([node.range[0], leftParen.range[0]]);\n\n        // Replace the parens of argument list to braces.\n        if (needsParens(node, sourceCode)) {\n            yield fixer.replaceText(leftParen, \"({\");\n            yield fixer.replaceText(rightParen, \"})\");\n        } else {\n            yield fixer.replaceText(leftParen, \"{\");\n            yield fixer.replaceText(rightParen, \"}\");\n        }\n\n        // Process arguments.\n        for (const argNode of node.arguments) {\n            const innerParens = getParenTokens(argNode, leftParen, sourceCode);\n            const left = innerParens.shift();\n            const right = innerParens.pop();\n\n            if (argNode.type === \"ObjectExpression\") {\n                const maybeTrailingComma = sourceCode.getLastToken(argNode, 1);\n                const maybeArgumentComma = sourceCode.getTokenAfter(right);\n\n                /*\n                 * Make bare this object literal.\n                 * And remove spaces inside of the braces for better formatting.\n                 */\n                for (const innerParen of innerParens) {\n                    yield fixer.remove(innerParen);\n                }\n                const leftRange = [left.range[0], getEndWithSpaces(left, sourceCode)];\n                const rightRange = [\n                    Math.max(getStartWithSpaces(right, sourceCode), leftRange[1]), // Ensure ranges don't overlap\n                    right.range[1]\n                ];\n\n                yield fixer.removeRange(leftRange);\n                yield fixer.removeRange(rightRange);\n\n                // Remove the comma of this argument if it's duplication.\n                if (\n                    (argNode.properties.length === 0 || isCommaToken(maybeTrailingComma)) &&\n                    isCommaToken(maybeArgumentComma)\n                ) {\n                    yield fixer.remove(maybeArgumentComma);\n                }\n            } else {\n\n                // Make spread.\n                if (argNeedsParens(argNode, sourceCode)) {\n                    yield fixer.insertTextBefore(left, \"...(\");\n                    yield fixer.insertTextAfter(right, \")\");\n                } else {\n                    yield fixer.insertTextBefore(left, \"...\");\n                }\n            }\n        }\n    };\n}\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description:\n                \"disallow using Object.assign with an object literal as the first argument and prefer the use of object spread instead.\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/prefer-object-spread\"\n        },\n\n        schema: [],\n        fixable: \"code\",\n\n        messages: {\n            useSpreadMessage: \"Use an object spread instead of `Object.assign` eg: `{ ...foo }`.\",\n            useLiteralMessage: \"Use an object literal instead of `Object.assign`. eg: `{ foo: bar }`.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        return {\n            Program() {\n                const scope = context.getScope();\n                const tracker = new ReferenceTracker(scope);\n                const trackMap = {\n                    Object: {\n                        assign: { [CALL]: true }\n                    }\n                };\n\n                // Iterate all calls of `Object.assign` (only of the global variable `Object`).\n                for (const { node } of tracker.iterateGlobalReferences(trackMap)) {\n                    if (\n                        node.arguments.length >= 1 &&\n                        node.arguments[0].type === \"ObjectExpression\" &&\n                        !hasArraySpread(node) &&\n                        !(\n                            node.arguments.length > 1 &&\n                            hasArgumentsWithAccessors(node)\n                        )\n                    ) {\n                        const messageId = node.arguments.length === 1\n                            ? \"useLiteralMessage\"\n                            : \"useSpreadMessage\";\n                        const fix = defineFixer(node, sourceCode);\n\n                        context.report({ node, messageId, fix });\n                    }\n                }\n            }\n        };\n    }\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;;AAEA,YAAY;;AAACA,OAAA;AAEb,MAAM;EAAEC,IAAI;EAAEC;AAAiB,CAAC,GAAGF,OAAO,CAAC,cAAc,CAAC;AAC1D,MAAM;EACFG,YAAY;EACZC,mBAAmB;EACnBC,mBAAmB;EACnBC;AACJ,CAAC,GAAGN,OAAO,CAAC,mBAAmB,CAAC;AAEhC,MAAMO,SAAS,GAAG,KAAK;;AAEvB;AACA;AACA;AACA;AACA;AACA,SAASC,cAAcA,CAACC,IAAI,EAAE;EAC1B,OAAOA,IAAI,CAACC,SAAS,CAACC,IAAI,CAACC,GAAG,IAAIA,GAAG,CAACC,IAAI,KAAK,eAAe,CAAC;AACnE;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASC,kBAAkBA,CAACL,IAAI,EAAE;EAC9B,OAAOA,IAAI,CAACI,IAAI,KAAK,UAAU,KAC1BJ,IAAI,CAACM,IAAI,KAAK,KAAK,IAAIN,IAAI,CAACM,IAAI,KAAK,KAAK,CAAC;AACpD;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASC,YAAYA,CAACP,IAAI,EAAE;EACxB,OAAOA,IAAI,CAACQ,UAAU,CAACN,IAAI,CAACG,kBAAkB,CAAC;AACnD;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASI,yBAAyBA,CAACT,IAAI,EAAE;EACrC,OAAOA,IAAI,CAACC,SAAS,CAChBS,MAAM,CAACP,GAAG,IAAIA,GAAG,CAACC,IAAI,KAAK,kBAAkB,CAAC,CAC9CF,IAAI,CAACK,YAAY,CAAC;AAC3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASI,WAAWA,CAACX,IAAI,EAAEY,UAAU,EAAE;EACnC,MAAMC,MAAM,GAAGb,IAAI,CAACa,MAAM;EAE1B,QAAQA,MAAM,CAACT,IAAI;IACf,KAAK,oBAAoB;IACzB,KAAK,iBAAiB;IACtB,KAAK,iBAAiB;IACtB,KAAK,gBAAgB;IACrB,KAAK,UAAU;MACX,OAAO,KAAK;IAChB,KAAK,sBAAsB;MACvB,OAAOS,MAAM,CAACC,IAAI,KAAKd,IAAI,IAAI,CAACH,eAAe,CAACe,UAAU,EAAEZ,IAAI,CAAC;IACrE;MACI,OAAO,CAACH,eAAe,CAACe,UAAU,EAAEZ,IAAI,CAAC;EACjD;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASe,cAAcA,CAACf,IAAI,EAAEY,UAAU,EAAE;EACtC,QAAQZ,IAAI,CAACI,IAAI;IACb,KAAK,sBAAsB;IAC3B,KAAK,yBAAyB;IAC9B,KAAK,uBAAuB;MACxB,OAAO,CAACP,eAAe,CAACe,UAAU,EAAEZ,IAAI,CAAC;IAC7C;MACI,OAAO,KAAK;EACpB;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASgB,cAAcA,CAAChB,IAAI,EAAEiB,qBAAqB,EAAEL,UAAU,EAAE;EAC7D,MAAMM,MAAM,GAAG,CAACN,UAAU,CAACO,aAAa,CAACnB,IAAI,CAAC,EAAEY,UAAU,CAACQ,YAAY,CAACpB,IAAI,CAAC,CAAC;EAC9E,IAAIqB,QAAQ,GAAGT,UAAU,CAACU,cAAc,CAACtB,IAAI,CAAC;EAC9C,IAAIuB,SAAS,GAAGX,UAAU,CAACY,aAAa,CAACxB,IAAI,CAAC;;EAE9C;EACA,OACIqB,QAAQ,IACRE,SAAS,IACTF,QAAQ,CAACI,KAAK,CAAC,CAAC,CAAC,GAAGR,qBAAqB,CAACQ,KAAK,CAAC,CAAC,CAAC,IAClD9B,mBAAmB,CAAC0B,QAAQ,CAAC,IAC7BzB,mBAAmB,CAAC2B,SAAS,CAAC,EAChC;IACEL,MAAM,CAACQ,IAAI,CAACL,QAAQ,EAAEE,SAAS,CAAC;IAChCF,QAAQ,GAAGT,UAAU,CAACU,cAAc,CAACD,QAAQ,CAAC;IAC9CE,SAAS,GAAGX,UAAU,CAACY,aAAa,CAACD,SAAS,CAAC;EACnD;EAEA,OAAOL,MAAM,CAACS,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKD,CAAC,CAACH,KAAK,CAAC,CAAC,CAAC,GAAGI,CAAC,CAACJ,KAAK,CAAC,CAAC,CAAC,CAAC;AACzD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASK,kBAAkBA,CAACC,KAAK,EAAEnB,UAAU,EAAE;EAC3C,MAAMoB,IAAI,GAAGpB,UAAU,CAACoB,IAAI;EAC5B,IAAIC,KAAK,GAAGF,KAAK,CAACN,KAAK,CAAC,CAAC,CAAC;;EAE1B;EACA;IACI,MAAMS,SAAS,GAAGtB,UAAU,CAACU,cAAc,CAACS,KAAK,EAAE;MAAEI,eAAe,EAAE;IAAK,CAAC,CAAC;IAE7E,IAAID,SAAS,IAAIA,SAAS,CAAC9B,IAAI,KAAK,MAAM,EAAE;MACxC,OAAO6B,KAAK;IAChB;EACJ;;EAEA;EACA,OAAOnC,SAAS,CAACsC,IAAI,CAACJ,IAAI,CAACC,KAAK,GAAG,CAAC,CAAC,IAAI,EAAE,CAAC,EAAE;IAC1CA,KAAK,IAAI,CAAC;EACd;EAEA,OAAOA,KAAK;AAChB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASI,gBAAgBA,CAACN,KAAK,EAAEnB,UAAU,EAAE;EACzC,MAAMoB,IAAI,GAAGpB,UAAU,CAACoB,IAAI;EAC5B,IAAIM,GAAG,GAAGP,KAAK,CAACN,KAAK,CAAC,CAAC,CAAC;;EAExB;EACA,OAAO3B,SAAS,CAACsC,IAAI,CAACJ,IAAI,CAACM,GAAG,CAAC,IAAI,EAAE,CAAC,EAAE;IACpCA,GAAG,IAAI,CAAC;EACZ;EAEA,OAAOA,GAAG;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,WAAWA,CAACvC,IAAI,EAAEY,UAAU,EAAE;EACnC,OAAO,WAAW4B,KAAK,EAAE;IACrB,MAAMC,SAAS,GAAG7B,UAAU,CAACY,aAAa,CAACxB,IAAI,CAAC0C,MAAM,EAAE/C,mBAAmB,CAAC;IAC5E,MAAMgD,UAAU,GAAG/B,UAAU,CAACQ,YAAY,CAACpB,IAAI,CAAC;;IAEhD;IACA,MAAMwC,KAAK,CAACI,WAAW,CAAC,CAAC5C,IAAI,CAACyB,KAAK,CAAC,CAAC,CAAC,EAAEgB,SAAS,CAAChB,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;;IAE5D;IACA,IAAId,WAAW,CAACX,IAAI,EAAEY,UAAU,CAAC,EAAE;MAC/B,MAAM4B,KAAK,CAACK,WAAW,CAACJ,SAAS,EAAE,IAAI,CAAC;MACxC,MAAMD,KAAK,CAACK,WAAW,CAACF,UAAU,EAAE,IAAI,CAAC;IAC7C,CAAC,MAAM;MACH,MAAMH,KAAK,CAACK,WAAW,CAACJ,SAAS,EAAE,GAAG,CAAC;MACvC,MAAMD,KAAK,CAACK,WAAW,CAACF,UAAU,EAAE,GAAG,CAAC;IAC5C;;IAEA;IACA,KAAK,MAAMG,OAAO,IAAI9C,IAAI,CAACC,SAAS,EAAE;MAClC,MAAM8C,WAAW,GAAG/B,cAAc,CAAC8B,OAAO,EAAEL,SAAS,EAAE7B,UAAU,CAAC;MAClE,MAAME,IAAI,GAAGiC,WAAW,CAACC,KAAK,CAAC,CAAC;MAChC,MAAMC,KAAK,GAAGF,WAAW,CAACG,GAAG,CAAC,CAAC;MAE/B,IAAIJ,OAAO,CAAC1C,IAAI,KAAK,kBAAkB,EAAE;QACrC,MAAM+C,kBAAkB,GAAGvC,UAAU,CAACQ,YAAY,CAAC0B,OAAO,EAAE,CAAC,CAAC;QAC9D,MAAMM,kBAAkB,GAAGxC,UAAU,CAACY,aAAa,CAACyB,KAAK,CAAC;;QAE1D;AAChB;AACA;AACA;QACgB,KAAK,MAAMI,UAAU,IAAIN,WAAW,EAAE;UAClC,MAAMP,KAAK,CAACc,MAAM,CAACD,UAAU,CAAC;QAClC;QACA,MAAME,SAAS,GAAG,CAACzC,IAAI,CAACW,KAAK,CAAC,CAAC,CAAC,EAAEY,gBAAgB,CAACvB,IAAI,EAAEF,UAAU,CAAC,CAAC;QACrE,MAAM4C,UAAU,GAAG,CACfC,IAAI,CAACC,GAAG,CAAC5B,kBAAkB,CAACmB,KAAK,EAAErC,UAAU,CAAC,EAAE2C,SAAS,CAAC,CAAC,CAAC,CAAC;QAAE;QAC/DN,KAAK,CAACxB,KAAK,CAAC,CAAC,CAAC,CACjB;QAED,MAAMe,KAAK,CAACI,WAAW,CAACW,SAAS,CAAC;QAClC,MAAMf,KAAK,CAACI,WAAW,CAACY,UAAU,CAAC;;QAEnC;QACA,IACI,CAACV,OAAO,CAACtC,UAAU,CAACmD,MAAM,KAAK,CAAC,IAAIjE,YAAY,CAACyD,kBAAkB,CAAC,KACpEzD,YAAY,CAAC0D,kBAAkB,CAAC,EAClC;UACE,MAAMZ,KAAK,CAACc,MAAM,CAACF,kBAAkB,CAAC;QAC1C;MACJ,CAAC,MAAM;QAEH;QACA,IAAIrC,cAAc,CAAC+B,OAAO,EAAElC,UAAU,CAAC,EAAE;UACrC,MAAM4B,KAAK,CAACoB,gBAAgB,CAAC9C,IAAI,EAAE,MAAM,CAAC;UAC1C,MAAM0B,KAAK,CAACqB,eAAe,CAACZ,KAAK,EAAE,GAAG,CAAC;QAC3C,CAAC,MAAM;UACH,MAAMT,KAAK,CAACoB,gBAAgB,CAAC9C,IAAI,EAAE,KAAK,CAAC;QAC7C;MACJ;IACJ;EACJ,CAAC;AACL;AAEAgD,MAAM,CAACC,OAAO,GAAG;EACbC,IAAI,EAAE;IACF5D,IAAI,EAAE,YAAY;IAElB6D,IAAI,EAAE;MACFC,WAAW,EACP,wHAAwH;MAC5HC,QAAQ,EAAE,kBAAkB;MAC5BC,WAAW,EAAE,KAAK;MAClBC,GAAG,EAAE;IACT,CAAC;IAEDC,MAAM,EAAE,EAAE;IACVC,OAAO,EAAE,MAAM;IAEfC,QAAQ,EAAE;MACNC,gBAAgB,EAAE,mEAAmE;MACrFC,iBAAiB,EAAE;IACvB;EACJ,CAAC;EAEDC,MAAMA,CAACC,OAAO,EAAE;IACZ,MAAMhE,UAAU,GAAGgE,OAAO,CAACC,aAAa,CAAC,CAAC;IAE1C,OAAO;MACHC,OAAOA,CAAA,EAAG;QACN,MAAMC,KAAK,GAAGH,OAAO,CAACI,QAAQ,CAAC,CAAC;QAChC,MAAMC,OAAO,GAAG,IAAIxF,gBAAgB,CAACsF,KAAK,CAAC;QAC3C,MAAMG,QAAQ,GAAG;UACbC,MAAM,EAAE;YACJC,MAAM,EAAE;cAAE,CAAC5F,IAAI,GAAG;YAAK;UAC3B;QACJ,CAAC;;QAED;QACA,KAAK,MAAM;UAAEQ;QAAK,CAAC,IAAIiF,OAAO,CAACI,uBAAuB,CAACH,QAAQ,CAAC,EAAE;UAC9D,IACIlF,IAAI,CAACC,SAAS,CAAC0D,MAAM,IAAI,CAAC,IAC1B3D,IAAI,CAACC,SAAS,CAAC,CAAC,CAAC,CAACG,IAAI,KAAK,kBAAkB,IAC7C,CAACL,cAAc,CAACC,IAAI,CAAC,IACrB,EACIA,IAAI,CAACC,SAAS,CAAC0D,MAAM,GAAG,CAAC,IACzBlD,yBAAyB,CAACT,IAAI,CAAC,CAClC,EACH;YACE,MAAMsF,SAAS,GAAGtF,IAAI,CAACC,SAAS,CAAC0D,MAAM,KAAK,CAAC,GACvC,mBAAmB,GACnB,kBAAkB;YACxB,MAAM4B,GAAG,GAAGhD,WAAW,CAACvC,IAAI,EAAEY,UAAU,CAAC;YAEzCgE,OAAO,CAACY,MAAM,CAAC;cAAExF,IAAI;cAAEsF,SAAS;cAAEC;YAAI,CAAC,CAAC;UAC5C;QACJ;MACJ;IACJ,CAAC;EACL;AACJ,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}