{"ast":null,"code":"/**\n * @fileoverview Enforce newlines between operands of ternary expressions\n * @author Kai Cataldo\n */\n\n\"use strict\";\n\nrequire(\"core-js/modules/es.array.push.js\");\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce newlines between operands of ternary expressions\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/multiline-ternary\"\n    },\n    schema: [{\n      enum: [\"always\", \"always-multiline\", \"never\"]\n    }],\n    messages: {\n      expectedTestCons: \"Expected newline between test and consequent of ternary expression.\",\n      expectedConsAlt: \"Expected newline between consequent and alternate of ternary expression.\",\n      unexpectedTestCons: \"Unexpected newline between test and consequent of ternary expression.\",\n      unexpectedConsAlt: \"Unexpected newline between consequent and alternate of ternary expression.\"\n    },\n    fixable: \"whitespace\"\n  },\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const option = context.options[0];\n    const multiline = option !== \"never\";\n    const allowSingleLine = option === \"always-multiline\";\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    return {\n      ConditionalExpression(node) {\n        const questionToken = sourceCode.getTokenAfter(node.test, astUtils.isNotClosingParenToken);\n        const colonToken = sourceCode.getTokenAfter(node.consequent, astUtils.isNotClosingParenToken);\n        const firstTokenOfTest = sourceCode.getFirstToken(node);\n        const lastTokenOfTest = sourceCode.getTokenBefore(questionToken);\n        const firstTokenOfConsequent = sourceCode.getTokenAfter(questionToken);\n        const lastTokenOfConsequent = sourceCode.getTokenBefore(colonToken);\n        const firstTokenOfAlternate = sourceCode.getTokenAfter(colonToken);\n        const areTestAndConsequentOnSameLine = astUtils.isTokenOnSameLine(lastTokenOfTest, firstTokenOfConsequent);\n        const areConsequentAndAlternateOnSameLine = astUtils.isTokenOnSameLine(lastTokenOfConsequent, firstTokenOfAlternate);\n        const hasComments = !!sourceCode.getCommentsInside(node).length;\n        if (!multiline) {\n          if (!areTestAndConsequentOnSameLine) {\n            context.report({\n              node: node.test,\n              loc: {\n                start: firstTokenOfTest.loc.start,\n                end: lastTokenOfTest.loc.end\n              },\n              messageId: \"unexpectedTestCons\",\n              fix: fixer => {\n                if (hasComments) {\n                  return null;\n                }\n                const fixers = [];\n                const areTestAndQuestionOnSameLine = astUtils.isTokenOnSameLine(lastTokenOfTest, questionToken);\n                const areQuestionAndConsOnSameLine = astUtils.isTokenOnSameLine(questionToken, firstTokenOfConsequent);\n                if (!areTestAndQuestionOnSameLine) {\n                  fixers.push(fixer.removeRange([lastTokenOfTest.range[1], questionToken.range[0]]));\n                }\n                if (!areQuestionAndConsOnSameLine) {\n                  fixers.push(fixer.removeRange([questionToken.range[1], firstTokenOfConsequent.range[0]]));\n                }\n                return fixers;\n              }\n            });\n          }\n          if (!areConsequentAndAlternateOnSameLine) {\n            context.report({\n              node: node.consequent,\n              loc: {\n                start: firstTokenOfConsequent.loc.start,\n                end: lastTokenOfConsequent.loc.end\n              },\n              messageId: \"unexpectedConsAlt\",\n              fix: fixer => {\n                if (hasComments) {\n                  return null;\n                }\n                const fixers = [];\n                const areConsAndColonOnSameLine = astUtils.isTokenOnSameLine(lastTokenOfConsequent, colonToken);\n                const areColonAndAltOnSameLine = astUtils.isTokenOnSameLine(colonToken, firstTokenOfAlternate);\n                if (!areConsAndColonOnSameLine) {\n                  fixers.push(fixer.removeRange([lastTokenOfConsequent.range[1], colonToken.range[0]]));\n                }\n                if (!areColonAndAltOnSameLine) {\n                  fixers.push(fixer.removeRange([colonToken.range[1], firstTokenOfAlternate.range[0]]));\n                }\n                return fixers;\n              }\n            });\n          }\n        } else {\n          if (allowSingleLine && node.loc.start.line === node.loc.end.line) {\n            return;\n          }\n          if (areTestAndConsequentOnSameLine) {\n            context.report({\n              node: node.test,\n              loc: {\n                start: firstTokenOfTest.loc.start,\n                end: lastTokenOfTest.loc.end\n              },\n              messageId: \"expectedTestCons\",\n              fix: fixer => hasComments ? null : fixer.replaceTextRange([lastTokenOfTest.range[1], questionToken.range[0]], \"\\n\")\n            });\n          }\n          if (areConsequentAndAlternateOnSameLine) {\n            context.report({\n              node: node.consequent,\n              loc: {\n                start: firstTokenOfConsequent.loc.start,\n                end: lastTokenOfConsequent.loc.end\n              },\n              messageId: \"expectedConsAlt\",\n              fix: fixer => hasComments ? null : fixer.replaceTextRange([lastTokenOfConsequent.range[1], colonToken.range[0]], \"\\n\")\n            });\n          }\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["require","astUtils","module","exports","meta","type","docs","description","category","recommended","url","schema","enum","messages","expectedTestCons","expectedConsAlt","unexpectedTestCons","unexpectedConsAlt","fixable","create","context","sourceCode","getSourceCode","option","options","multiline","allowSingleLine","ConditionalExpression","node","questionToken","getTokenAfter","test","isNotClosingParenToken","colonToken","consequent","firstTokenOfTest","getFirstToken","lastTokenOfTest","getTokenBefore","firstTokenOfConsequent","lastTokenOfConsequent","firstTokenOfAlternate","areTestAndConsequentOnSameLine","isTokenOnSameLine","areConsequentAndAlternateOnSameLine","hasComments","getCommentsInside","length","report","loc","start","end","messageId","fix","fixer","fixers","areTestAndQuestionOnSameLine","areQuestionAndConsOnSameLine","push","removeRange","range","areConsAndColonOnSameLine","areColonAndAltOnSameLine","line","replaceTextRange"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/multiline-ternary.js"],"sourcesContent":["/**\n * @fileoverview Enforce newlines between operands of ternary expressions\n * @author Kai Cataldo\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce newlines between operands of ternary expressions\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/multiline-ternary\"\n        },\n\n        schema: [\n            {\n                enum: [\"always\", \"always-multiline\", \"never\"]\n            }\n        ],\n\n        messages: {\n            expectedTestCons: \"Expected newline between test and consequent of ternary expression.\",\n            expectedConsAlt: \"Expected newline between consequent and alternate of ternary expression.\",\n            unexpectedTestCons: \"Unexpected newline between test and consequent of ternary expression.\",\n            unexpectedConsAlt: \"Unexpected newline between consequent and alternate of ternary expression.\"\n        },\n\n        fixable: \"whitespace\"\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const option = context.options[0];\n        const multiline = option !== \"never\";\n        const allowSingleLine = option === \"always-multiline\";\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            ConditionalExpression(node) {\n                const questionToken = sourceCode.getTokenAfter(node.test, astUtils.isNotClosingParenToken);\n                const colonToken = sourceCode.getTokenAfter(node.consequent, astUtils.isNotClosingParenToken);\n\n                const firstTokenOfTest = sourceCode.getFirstToken(node);\n                const lastTokenOfTest = sourceCode.getTokenBefore(questionToken);\n                const firstTokenOfConsequent = sourceCode.getTokenAfter(questionToken);\n                const lastTokenOfConsequent = sourceCode.getTokenBefore(colonToken);\n                const firstTokenOfAlternate = sourceCode.getTokenAfter(colonToken);\n\n                const areTestAndConsequentOnSameLine = astUtils.isTokenOnSameLine(lastTokenOfTest, firstTokenOfConsequent);\n                const areConsequentAndAlternateOnSameLine = astUtils.isTokenOnSameLine(lastTokenOfConsequent, firstTokenOfAlternate);\n\n                const hasComments = !!sourceCode.getCommentsInside(node).length;\n\n                if (!multiline) {\n                    if (!areTestAndConsequentOnSameLine) {\n                        context.report({\n                            node: node.test,\n                            loc: {\n                                start: firstTokenOfTest.loc.start,\n                                end: lastTokenOfTest.loc.end\n                            },\n                            messageId: \"unexpectedTestCons\",\n                            fix: fixer => {\n                                if (hasComments) {\n                                    return null;\n                                }\n                                const fixers = [];\n                                const areTestAndQuestionOnSameLine = astUtils.isTokenOnSameLine(lastTokenOfTest, questionToken);\n                                const areQuestionAndConsOnSameLine = astUtils.isTokenOnSameLine(questionToken, firstTokenOfConsequent);\n\n                                if (!areTestAndQuestionOnSameLine) {\n                                    fixers.push(fixer.removeRange([lastTokenOfTest.range[1], questionToken.range[0]]));\n                                }\n                                if (!areQuestionAndConsOnSameLine) {\n                                    fixers.push(fixer.removeRange([questionToken.range[1], firstTokenOfConsequent.range[0]]));\n                                }\n\n                                return fixers;\n                            }\n                        });\n                    }\n\n                    if (!areConsequentAndAlternateOnSameLine) {\n                        context.report({\n                            node: node.consequent,\n                            loc: {\n                                start: firstTokenOfConsequent.loc.start,\n                                end: lastTokenOfConsequent.loc.end\n                            },\n                            messageId: \"unexpectedConsAlt\",\n                            fix: fixer => {\n                                if (hasComments) {\n                                    return null;\n                                }\n                                const fixers = [];\n                                const areConsAndColonOnSameLine = astUtils.isTokenOnSameLine(lastTokenOfConsequent, colonToken);\n                                const areColonAndAltOnSameLine = astUtils.isTokenOnSameLine(colonToken, firstTokenOfAlternate);\n\n                                if (!areConsAndColonOnSameLine) {\n                                    fixers.push(fixer.removeRange([lastTokenOfConsequent.range[1], colonToken.range[0]]));\n                                }\n                                if (!areColonAndAltOnSameLine) {\n                                    fixers.push(fixer.removeRange([colonToken.range[1], firstTokenOfAlternate.range[0]]));\n                                }\n\n                                return fixers;\n                            }\n                        });\n                    }\n                } else {\n                    if (allowSingleLine && node.loc.start.line === node.loc.end.line) {\n                        return;\n                    }\n\n                    if (areTestAndConsequentOnSameLine) {\n                        context.report({\n                            node: node.test,\n                            loc: {\n                                start: firstTokenOfTest.loc.start,\n                                end: lastTokenOfTest.loc.end\n                            },\n                            messageId: \"expectedTestCons\",\n                            fix: fixer => (hasComments ? null : (\n                                fixer.replaceTextRange(\n                                    [\n                                        lastTokenOfTest.range[1],\n                                        questionToken.range[0]\n                                    ],\n                                    \"\\n\"\n                                )\n                            ))\n                        });\n                    }\n\n                    if (areConsequentAndAlternateOnSameLine) {\n                        context.report({\n                            node: node.consequent,\n                            loc: {\n                                start: firstTokenOfConsequent.loc.start,\n                                end: lastTokenOfConsequent.loc.end\n                            },\n                            messageId: \"expectedConsAlt\",\n                            fix: (fixer => (hasComments ? null : (\n                                fixer.replaceTextRange(\n                                    [\n                                        lastTokenOfConsequent.range[1],\n                                        colonToken.range[0]\n                                    ],\n                                    \"\\n\"\n                                )\n                            )))\n                        });\n                    }\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}