{"ast":null,"code":"/**\n * @author Toru Nagashima <https://github.com/mysticatea>\n */\n\"use strict\";\n\nrequire(\"core-js/modules/es.array.push.js\");\nrequire(\"core-js/modules/es.regexp.flags.js\");\nconst {\n  CALL,\n  CONSTRUCT,\n  ReferenceTracker,\n  getStringIfConstant\n} = require(\"eslint-utils\");\nconst {\n  RegExpParser,\n  visitRegExpAST\n} = require(\"regexpp\");\nconst {\n  isCombiningCharacter,\n  isEmojiModifier,\n  isRegionalIndicatorSymbol,\n  isSurrogatePair\n} = require(\"./utils/unicode\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Iterate character sequences of a given nodes.\n *\n * CharacterClassRange syntax can steal a part of character sequence,\n * so this function reverts CharacterClassRange syntax and restore the sequence.\n * @param {regexpp.AST.CharacterClassElement[]} nodes The node list to iterate character sequences.\n * @returns {IterableIterator<number[]>} The list of character sequences.\n */\nfunction* iterateCharacterSequence(nodes) {\n  let seq = [];\n  for (const node of nodes) {\n    switch (node.type) {\n      case \"Character\":\n        seq.push(node.value);\n        break;\n      case \"CharacterClassRange\":\n        seq.push(node.min.value);\n        yield seq;\n        seq = [node.max.value];\n        break;\n      case \"CharacterSet\":\n        if (seq.length > 0) {\n          yield seq;\n          seq = [];\n        }\n        break;\n\n      // no default\n    }\n  }\n\n  if (seq.length > 0) {\n    yield seq;\n  }\n}\nconst hasCharacterSequence = {\n  surrogatePairWithoutUFlag(chars) {\n    return chars.some((c, i) => i !== 0 && isSurrogatePair(chars[i - 1], c));\n  },\n  combiningClass(chars) {\n    return chars.some((c, i) => i !== 0 && isCombiningCharacter(c) && !isCombiningCharacter(chars[i - 1]));\n  },\n  emojiModifier(chars) {\n    return chars.some((c, i) => i !== 0 && isEmojiModifier(c) && !isEmojiModifier(chars[i - 1]));\n  },\n  regionalIndicatorSymbol(chars) {\n    return chars.some((c, i) => i !== 0 && isRegionalIndicatorSymbol(c) && isRegionalIndicatorSymbol(chars[i - 1]));\n  },\n  zwj(chars) {\n    const lastIndex = chars.length - 1;\n    return chars.some((c, i) => i !== 0 && i !== lastIndex && c === 0x200d && chars[i - 1] !== 0x200d && chars[i + 1] !== 0x200d);\n  }\n};\nconst kinds = Object.keys(hasCharacterSequence);\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow characters which are made with multiple code points in character class syntax\",\n      category: \"Possible Errors\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-misleading-character-class\"\n    },\n    schema: [],\n    messages: {\n      surrogatePairWithoutUFlag: \"Unexpected surrogate pair in character class. Use 'u' flag.\",\n      combiningClass: \"Unexpected combined character in character class.\",\n      emojiModifier: \"Unexpected modified Emoji in character class.\",\n      regionalIndicatorSymbol: \"Unexpected national flag in character class.\",\n      zwj: \"Unexpected joined character sequence in character class.\"\n    }\n  },\n  create(context) {\n    const parser = new RegExpParser();\n\n    /**\n     * Verify a given regular expression.\n     * @param {Node} node The node to report.\n     * @param {string} pattern The regular expression pattern to verify.\n     * @param {string} flags The flags of the regular expression.\n     * @returns {void}\n     */\n    function verify(node, pattern, flags) {\n      const has = {\n        surrogatePairWithoutUFlag: false,\n        combiningClass: false,\n        variationSelector: false,\n        emojiModifier: false,\n        regionalIndicatorSymbol: false,\n        zwj: false\n      };\n      let patternNode;\n      try {\n        patternNode = parser.parsePattern(pattern, 0, pattern.length, flags.includes(\"u\"));\n      } catch {\n        // Ignore regular expressions with syntax errors\n        return;\n      }\n      visitRegExpAST(patternNode, {\n        onCharacterClassEnter(ccNode) {\n          for (const chars of iterateCharacterSequence(ccNode.elements)) {\n            for (const kind of kinds) {\n              has[kind] = has[kind] || hasCharacterSequence[kind](chars);\n            }\n          }\n        }\n      });\n      for (const kind of kinds) {\n        if (has[kind]) {\n          context.report({\n            node,\n            messageId: kind\n          });\n        }\n      }\n    }\n    return {\n      \"Literal[regex]\"(node) {\n        verify(node, node.regex.pattern, node.regex.flags);\n      },\n      \"Program\"() {\n        const scope = context.getScope();\n        const tracker = new ReferenceTracker(scope);\n\n        /*\n         * Iterate calls of RegExp.\n         * E.g., `new RegExp()`, `RegExp()`, `new window.RegExp()`,\n         *       `const {RegExp: a} = window; new a()`, etc...\n         */\n        for (const {\n          node\n        } of tracker.iterateGlobalReferences({\n          RegExp: {\n            [CALL]: true,\n            [CONSTRUCT]: true\n          }\n        })) {\n          const [patternNode, flagsNode] = node.arguments;\n          const pattern = getStringIfConstant(patternNode, scope);\n          const flags = getStringIfConstant(flagsNode, scope);\n          if (typeof pattern === \"string\") {\n            verify(node, pattern, flags || \"\");\n          }\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["require","CALL","CONSTRUCT","ReferenceTracker","getStringIfConstant","RegExpParser","visitRegExpAST","isCombiningCharacter","isEmojiModifier","isRegionalIndicatorSymbol","isSurrogatePair","iterateCharacterSequence","nodes","seq","node","type","push","value","min","max","length","hasCharacterSequence","surrogatePairWithoutUFlag","chars","some","c","i","combiningClass","emojiModifier","regionalIndicatorSymbol","zwj","lastIndex","kinds","Object","keys","module","exports","meta","docs","description","category","recommended","url","schema","messages","create","context","parser","verify","pattern","flags","has","variationSelector","patternNode","parsePattern","includes","onCharacterClassEnter","ccNode","elements","kind","report","messageId","Literal[regex]","regex","Program","scope","getScope","tracker","iterateGlobalReferences","RegExp","flagsNode","arguments"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/no-misleading-character-class.js"],"sourcesContent":["/**\n * @author Toru Nagashima <https://github.com/mysticatea>\n */\n\"use strict\";\n\nconst { CALL, CONSTRUCT, ReferenceTracker, getStringIfConstant } = require(\"eslint-utils\");\nconst { RegExpParser, visitRegExpAST } = require(\"regexpp\");\nconst { isCombiningCharacter, isEmojiModifier, isRegionalIndicatorSymbol, isSurrogatePair } = require(\"./utils/unicode\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Iterate character sequences of a given nodes.\n *\n * CharacterClassRange syntax can steal a part of character sequence,\n * so this function reverts CharacterClassRange syntax and restore the sequence.\n * @param {regexpp.AST.CharacterClassElement[]} nodes The node list to iterate character sequences.\n * @returns {IterableIterator<number[]>} The list of character sequences.\n */\nfunction *iterateCharacterSequence(nodes) {\n    let seq = [];\n\n    for (const node of nodes) {\n        switch (node.type) {\n            case \"Character\":\n                seq.push(node.value);\n                break;\n\n            case \"CharacterClassRange\":\n                seq.push(node.min.value);\n                yield seq;\n                seq = [node.max.value];\n                break;\n\n            case \"CharacterSet\":\n                if (seq.length > 0) {\n                    yield seq;\n                    seq = [];\n                }\n                break;\n\n            // no default\n        }\n    }\n\n    if (seq.length > 0) {\n        yield seq;\n    }\n}\n\nconst hasCharacterSequence = {\n    surrogatePairWithoutUFlag(chars) {\n        return chars.some((c, i) => i !== 0 && isSurrogatePair(chars[i - 1], c));\n    },\n\n    combiningClass(chars) {\n        return chars.some((c, i) => (\n            i !== 0 &&\n            isCombiningCharacter(c) &&\n            !isCombiningCharacter(chars[i - 1])\n        ));\n    },\n\n    emojiModifier(chars) {\n        return chars.some((c, i) => (\n            i !== 0 &&\n            isEmojiModifier(c) &&\n            !isEmojiModifier(chars[i - 1])\n        ));\n    },\n\n    regionalIndicatorSymbol(chars) {\n        return chars.some((c, i) => (\n            i !== 0 &&\n            isRegionalIndicatorSymbol(c) &&\n            isRegionalIndicatorSymbol(chars[i - 1])\n        ));\n    },\n\n    zwj(chars) {\n        const lastIndex = chars.length - 1;\n\n        return chars.some((c, i) => (\n            i !== 0 &&\n            i !== lastIndex &&\n            c === 0x200d &&\n            chars[i - 1] !== 0x200d &&\n            chars[i + 1] !== 0x200d\n        ));\n    }\n};\n\nconst kinds = Object.keys(hasCharacterSequence);\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow characters which are made with multiple code points in character class syntax\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-misleading-character-class\"\n        },\n\n        schema: [],\n\n        messages: {\n            surrogatePairWithoutUFlag: \"Unexpected surrogate pair in character class. Use 'u' flag.\",\n            combiningClass: \"Unexpected combined character in character class.\",\n            emojiModifier: \"Unexpected modified Emoji in character class.\",\n            regionalIndicatorSymbol: \"Unexpected national flag in character class.\",\n            zwj: \"Unexpected joined character sequence in character class.\"\n        }\n    },\n    create(context) {\n        const parser = new RegExpParser();\n\n        /**\n         * Verify a given regular expression.\n         * @param {Node} node The node to report.\n         * @param {string} pattern The regular expression pattern to verify.\n         * @param {string} flags The flags of the regular expression.\n         * @returns {void}\n         */\n        function verify(node, pattern, flags) {\n            const has = {\n                surrogatePairWithoutUFlag: false,\n                combiningClass: false,\n                variationSelector: false,\n                emojiModifier: false,\n                regionalIndicatorSymbol: false,\n                zwj: false\n            };\n            let patternNode;\n\n            try {\n                patternNode = parser.parsePattern(\n                    pattern,\n                    0,\n                    pattern.length,\n                    flags.includes(\"u\")\n                );\n            } catch {\n\n                // Ignore regular expressions with syntax errors\n                return;\n            }\n\n            visitRegExpAST(patternNode, {\n                onCharacterClassEnter(ccNode) {\n                    for (const chars of iterateCharacterSequence(ccNode.elements)) {\n                        for (const kind of kinds) {\n                            has[kind] = has[kind] || hasCharacterSequence[kind](chars);\n                        }\n                    }\n                }\n            });\n\n            for (const kind of kinds) {\n                if (has[kind]) {\n                    context.report({ node, messageId: kind });\n                }\n            }\n        }\n\n        return {\n            \"Literal[regex]\"(node) {\n                verify(node, node.regex.pattern, node.regex.flags);\n            },\n            \"Program\"() {\n                const scope = context.getScope();\n                const tracker = new ReferenceTracker(scope);\n\n                /*\n                 * Iterate calls of RegExp.\n                 * E.g., `new RegExp()`, `RegExp()`, `new window.RegExp()`,\n                 *       `const {RegExp: a} = window; new a()`, etc...\n                 */\n                for (const { node } of tracker.iterateGlobalReferences({\n                    RegExp: { [CALL]: true, [CONSTRUCT]: true }\n                })) {\n                    const [patternNode, flagsNode] = node.arguments;\n                    const pattern = getStringIfConstant(patternNode, scope);\n                    const flags = getStringIfConstant(flagsNode, scope);\n\n                    if (typeof pattern === \"string\") {\n                        verify(node, pattern, flags || \"\");\n                    }\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}