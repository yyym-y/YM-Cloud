{"ast":null,"code":"/**\n * @fileoverview Rule to require sorting of variables within a single Variable Declaration block\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require variables within the same declaration block to be sorted\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/sort-vars\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        ignoreCase: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    fixable: \"code\",\n    messages: {\n      sortVars: \"Variables within the same declaration block should be sorted alphabetically.\"\n    }\n  },\n  create(context) {\n    const configuration = context.options[0] || {},\n      ignoreCase = configuration.ignoreCase || false,\n      sourceCode = context.getSourceCode();\n    return {\n      VariableDeclaration(node) {\n        const idDeclarations = node.declarations.filter(decl => decl.id.type === \"Identifier\");\n        const getSortableName = ignoreCase ? decl => decl.id.name.toLowerCase() : decl => decl.id.name;\n        const unfixable = idDeclarations.some(decl => decl.init !== null && decl.init.type !== \"Literal\");\n        let fixed = false;\n        idDeclarations.slice(1).reduce((memo, decl) => {\n          const lastVariableName = getSortableName(memo),\n            currentVariableName = getSortableName(decl);\n          if (currentVariableName < lastVariableName) {\n            context.report({\n              node: decl,\n              messageId: \"sortVars\",\n              fix(fixer) {\n                if (unfixable || fixed) {\n                  return null;\n                }\n                return fixer.replaceTextRange([idDeclarations[0].range[0], idDeclarations[idDeclarations.length - 1].range[1]], idDeclarations\n\n                // Clone the idDeclarations array to avoid mutating it\n                .slice()\n\n                // Sort the array into the desired order\n                .sort((declA, declB) => {\n                  const aName = getSortableName(declA);\n                  const bName = getSortableName(declB);\n                  return aName > bName ? 1 : -1;\n                })\n\n                // Build a string out of the sorted list of identifier declarations and the text between the originals\n                .reduce((sourceText, identifier, index) => {\n                  const textAfterIdentifier = index === idDeclarations.length - 1 ? \"\" : sourceCode.getText().slice(idDeclarations[index].range[1], idDeclarations[index + 1].range[0]);\n                  return sourceText + sourceCode.getText(identifier) + textAfterIdentifier;\n                }, \"\"));\n              }\n            });\n            fixed = true;\n            return memo;\n          }\n          return decl;\n        }, idDeclarations[0]);\n      }\n    };\n  }\n};","map":{"version":3,"names":["module","exports","meta","type","docs","description","category","recommended","url","schema","properties","ignoreCase","default","additionalProperties","fixable","messages","sortVars","create","context","configuration","options","sourceCode","getSourceCode","VariableDeclaration","node","idDeclarations","declarations","filter","decl","id","getSortableName","name","toLowerCase","unfixable","some","init","fixed","slice","reduce","memo","lastVariableName","currentVariableName","report","messageId","fix","fixer","replaceTextRange","range","length","sort","declA","declB","aName","bName","sourceText","identifier","index","textAfterIdentifier","getText"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/sort-vars.js"],"sourcesContent":["/**\n * @fileoverview Rule to require sorting of variables within a single Variable Declaration block\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require variables within the same declaration block to be sorted\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/sort-vars\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    ignoreCase: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: \"code\",\n\n        messages: {\n            sortVars: \"Variables within the same declaration block should be sorted alphabetically.\"\n        }\n    },\n\n    create(context) {\n\n        const configuration = context.options[0] || {},\n            ignoreCase = configuration.ignoreCase || false,\n            sourceCode = context.getSourceCode();\n\n        return {\n            VariableDeclaration(node) {\n                const idDeclarations = node.declarations.filter(decl => decl.id.type === \"Identifier\");\n                const getSortableName = ignoreCase ? decl => decl.id.name.toLowerCase() : decl => decl.id.name;\n                const unfixable = idDeclarations.some(decl => decl.init !== null && decl.init.type !== \"Literal\");\n                let fixed = false;\n\n                idDeclarations.slice(1).reduce((memo, decl) => {\n                    const lastVariableName = getSortableName(memo),\n                        currentVariableName = getSortableName(decl);\n\n                    if (currentVariableName < lastVariableName) {\n                        context.report({\n                            node: decl,\n                            messageId: \"sortVars\",\n                            fix(fixer) {\n                                if (unfixable || fixed) {\n                                    return null;\n                                }\n                                return fixer.replaceTextRange(\n                                    [idDeclarations[0].range[0], idDeclarations[idDeclarations.length - 1].range[1]],\n                                    idDeclarations\n\n                                        // Clone the idDeclarations array to avoid mutating it\n                                        .slice()\n\n                                        // Sort the array into the desired order\n                                        .sort((declA, declB) => {\n                                            const aName = getSortableName(declA);\n                                            const bName = getSortableName(declB);\n\n                                            return aName > bName ? 1 : -1;\n                                        })\n\n                                        // Build a string out of the sorted list of identifier declarations and the text between the originals\n                                        .reduce((sourceText, identifier, index) => {\n                                            const textAfterIdentifier = index === idDeclarations.length - 1\n                                                ? \"\"\n                                                : sourceCode.getText().slice(idDeclarations[index].range[1], idDeclarations[index + 1].range[0]);\n\n                                            return sourceText + sourceCode.getText(identifier) + textAfterIdentifier;\n                                        }, \"\")\n\n                                );\n                            }\n                        });\n                        fixed = true;\n                        return memo;\n                    }\n                    return decl;\n\n                }, idDeclarations[0]);\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}