{"ast":null,"code":"/**\n * @fileoverview Rule to disallow duplicate conditions in if-else-if chains\n * @author Milos Djermanovic\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Determines whether the first given array is a subset of the second given array.\n * @param {Function} comparator A function to compare two elements, should return `true` if they are equal.\n * @param {Array} arrA The array to compare from.\n * @param {Array} arrB The array to compare against.\n * @returns {boolean} `true` if the array `arrA` is a subset of the array `arrB`.\n */\nfunction isSubsetByComparator(comparator, arrA, arrB) {\n  return arrA.every(a => arrB.some(b => comparator(a, b)));\n}\n\n/**\n * Splits the given node by the given logical operator.\n * @param {string} operator Logical operator `||` or `&&`.\n * @param {ASTNode} node The node to split.\n * @returns {ASTNode[]} Array of conditions that makes the node when joined by the operator.\n */\nfunction splitByLogicalOperator(operator, node) {\n  if (node.type === \"LogicalExpression\" && node.operator === operator) {\n    return [...splitByLogicalOperator(operator, node.left), ...splitByLogicalOperator(operator, node.right)];\n  }\n  return [node];\n}\nconst splitByOr = splitByLogicalOperator.bind(null, \"||\");\nconst splitByAnd = splitByLogicalOperator.bind(null, \"&&\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow duplicate conditions in if-else-if chains\",\n      category: \"Possible Errors\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-dupe-else-if\"\n    },\n    schema: [],\n    messages: {\n      unexpected: \"This branch can never execute. Its condition is a duplicate or covered by previous conditions in the if-else-if chain.\"\n    }\n  },\n  create(context) {\n    const sourceCode = context.getSourceCode();\n\n    /**\n     * Determines whether the two given nodes are considered to be equal. In particular, given that the nodes\n     * represent expressions in a boolean context, `||` and `&&` can be considered as commutative operators.\n     * @param {ASTNode} a First node.\n     * @param {ASTNode} b Second node.\n     * @returns {boolean} `true` if the nodes are considered to be equal.\n     */\n    function equal(a, b) {\n      if (a.type !== b.type) {\n        return false;\n      }\n      if (a.type === \"LogicalExpression\" && (a.operator === \"||\" || a.operator === \"&&\") && a.operator === b.operator) {\n        return equal(a.left, b.left) && equal(a.right, b.right) || equal(a.left, b.right) && equal(a.right, b.left);\n      }\n      return astUtils.equalTokens(a, b, sourceCode);\n    }\n    const isSubset = isSubsetByComparator.bind(null, equal);\n    return {\n      IfStatement(node) {\n        const test = node.test,\n          conditionsToCheck = test.type === \"LogicalExpression\" && test.operator === \"&&\" ? [test, ...splitByAnd(test)] : [test];\n        let current = node,\n          listToCheck = conditionsToCheck.map(c => splitByOr(c).map(splitByAnd));\n        while (current.parent && current.parent.type === \"IfStatement\" && current.parent.alternate === current) {\n          current = current.parent;\n          const currentOrOperands = splitByOr(current.test).map(splitByAnd);\n          listToCheck = listToCheck.map(orOperands => orOperands.filter(orOperand => !currentOrOperands.some(currentOrOperand => isSubset(currentOrOperand, orOperand))));\n          if (listToCheck.some(orOperands => orOperands.length === 0)) {\n            context.report({\n              node: test,\n              messageId: \"unexpected\"\n            });\n            break;\n          }\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","isSubsetByComparator","comparator","arrA","arrB","every","a","some","b","splitByLogicalOperator","operator","node","type","left","right","splitByOr","bind","splitByAnd","module","exports","meta","docs","description","category","recommended","url","schema","messages","unexpected","create","context","sourceCode","getSourceCode","equal","equalTokens","isSubset","IfStatement","test","conditionsToCheck","current","listToCheck","map","c","parent","alternate","currentOrOperands","orOperands","filter","orOperand","currentOrOperand","length","report","messageId"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/no-dupe-else-if.js"],"sourcesContent":["/**\n * @fileoverview Rule to disallow duplicate conditions in if-else-if chains\n * @author Milos Djermanovic\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Determines whether the first given array is a subset of the second given array.\n * @param {Function} comparator A function to compare two elements, should return `true` if they are equal.\n * @param {Array} arrA The array to compare from.\n * @param {Array} arrB The array to compare against.\n * @returns {boolean} `true` if the array `arrA` is a subset of the array `arrB`.\n */\nfunction isSubsetByComparator(comparator, arrA, arrB) {\n    return arrA.every(a => arrB.some(b => comparator(a, b)));\n}\n\n/**\n * Splits the given node by the given logical operator.\n * @param {string} operator Logical operator `||` or `&&`.\n * @param {ASTNode} node The node to split.\n * @returns {ASTNode[]} Array of conditions that makes the node when joined by the operator.\n */\nfunction splitByLogicalOperator(operator, node) {\n    if (node.type === \"LogicalExpression\" && node.operator === operator) {\n        return [...splitByLogicalOperator(operator, node.left), ...splitByLogicalOperator(operator, node.right)];\n    }\n    return [node];\n}\n\nconst splitByOr = splitByLogicalOperator.bind(null, \"||\");\nconst splitByAnd = splitByLogicalOperator.bind(null, \"&&\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow duplicate conditions in if-else-if chains\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-dupe-else-if\"\n        },\n\n        schema: [],\n\n        messages: {\n            unexpected: \"This branch can never execute. Its condition is a duplicate or covered by previous conditions in the if-else-if chain.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Determines whether the two given nodes are considered to be equal. In particular, given that the nodes\n         * represent expressions in a boolean context, `||` and `&&` can be considered as commutative operators.\n         * @param {ASTNode} a First node.\n         * @param {ASTNode} b Second node.\n         * @returns {boolean} `true` if the nodes are considered to be equal.\n         */\n        function equal(a, b) {\n            if (a.type !== b.type) {\n                return false;\n            }\n\n            if (\n                a.type === \"LogicalExpression\" &&\n                (a.operator === \"||\" || a.operator === \"&&\") &&\n                a.operator === b.operator\n            ) {\n                return equal(a.left, b.left) && equal(a.right, b.right) ||\n                    equal(a.left, b.right) && equal(a.right, b.left);\n            }\n\n            return astUtils.equalTokens(a, b, sourceCode);\n        }\n\n        const isSubset = isSubsetByComparator.bind(null, equal);\n\n        return {\n            IfStatement(node) {\n                const test = node.test,\n                    conditionsToCheck = test.type === \"LogicalExpression\" && test.operator === \"&&\"\n                        ? [test, ...splitByAnd(test)]\n                        : [test];\n                let current = node,\n                    listToCheck = conditionsToCheck.map(c => splitByOr(c).map(splitByAnd));\n\n                while (current.parent && current.parent.type === \"IfStatement\" && current.parent.alternate === current) {\n                    current = current.parent;\n\n                    const currentOrOperands = splitByOr(current.test).map(splitByAnd);\n\n                    listToCheck = listToCheck.map(orOperands => orOperands.filter(\n                        orOperand => !currentOrOperands.some(currentOrOperand => isSubset(currentOrOperand, orOperand))\n                    ));\n\n                    if (listToCheck.some(orOperands => orOperands.length === 0)) {\n                        context.report({ node: test, messageId: \"unexpected\" });\n                        break;\n                    }\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}