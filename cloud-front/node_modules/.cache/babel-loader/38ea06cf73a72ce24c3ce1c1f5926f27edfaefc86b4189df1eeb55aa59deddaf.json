{"ast":null,"code":"/**\n * @fileoverview `IgnorePattern` class.\n *\n * `IgnorePattern` class has the set of glob patterns and the base path.\n *\n * It provides two static methods.\n *\n * - `IgnorePattern.createDefaultIgnore(cwd)`\n *      Create the default predicate function.\n * - `IgnorePattern.createIgnore(ignorePatterns)`\n *      Create the predicate function from multiple `IgnorePattern` objects.\n *\n * It provides two properties and a method.\n *\n * - `patterns`\n *      The glob patterns that ignore to lint.\n * - `basePath`\n *      The base path of the glob patterns. If absolute paths existed in the\n *      glob patterns, those are handled as relative paths to the base path.\n * - `getPatternsRelativeTo(basePath)`\n *      Get `patterns` as modified for a given base path. It modifies the\n *      absolute paths in the patterns as prepending the difference of two base\n *      paths.\n *\n * `ConfigArrayFactory` creates `IgnorePattern` objects when it processes\n * `ignorePatterns` properties.\n *\n * @author Toru Nagashima <https://github.com/mysticatea>\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst assert = require(\"assert\");\nconst path = require(\"path\");\nconst ignore = require(\"ignore\");\nconst debug = require(\"debug\")(\"eslintrc:ignore-pattern\");\n\n/** @typedef {ReturnType<import(\"ignore\").default>} Ignore */\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Get the path to the common ancestor directory of given paths.\n * @param {string[]} sourcePaths The paths to calculate the common ancestor.\n * @returns {string} The path to the common ancestor directory.\n */\nfunction getCommonAncestorPath(sourcePaths) {\n  let result = sourcePaths[0];\n  for (let i = 1; i < sourcePaths.length; ++i) {\n    const a = result;\n    const b = sourcePaths[i];\n\n    // Set the shorter one (it's the common ancestor if one includes the other).\n    result = a.length < b.length ? a : b;\n\n    // Set the common ancestor.\n    for (let j = 0, lastSepPos = 0; j < a.length && j < b.length; ++j) {\n      if (a[j] !== b[j]) {\n        result = a.slice(0, lastSepPos);\n        break;\n      }\n      if (a[j] === path.sep) {\n        lastSepPos = j;\n      }\n    }\n  }\n  let resolvedResult = result || path.sep;\n\n  // if Windows common ancestor is root of drive must have trailing slash to be absolute.\n  if (resolvedResult && resolvedResult.endsWith(\":\") && process.platform === \"win32\") {\n    resolvedResult += path.sep;\n  }\n  return resolvedResult;\n}\n\n/**\n * Make relative path.\n * @param {string} from The source path to get relative path.\n * @param {string} to The destination path to get relative path.\n * @returns {string} The relative path.\n */\nfunction relative(from, to) {\n  const relPath = path.relative(from, to);\n  if (path.sep === \"/\") {\n    return relPath;\n  }\n  return relPath.split(path.sep).join(\"/\");\n}\n\n/**\n * Get the trailing slash if existed.\n * @param {string} filePath The path to check.\n * @returns {string} The trailing slash if existed.\n */\nfunction dirSuffix(filePath) {\n  const isDir = filePath.endsWith(path.sep) || process.platform === \"win32\" && filePath.endsWith(\"/\");\n  return isDir ? \"/\" : \"\";\n}\nconst DefaultPatterns = Object.freeze([\"/**/node_modules/*\"]);\nconst DotPatterns = Object.freeze([\".*\", \"!.eslintrc.*\", \"!../\"]);\n\n//------------------------------------------------------------------------------\n// Public\n//------------------------------------------------------------------------------\n\nclass IgnorePattern {\n  /**\n   * The default patterns.\n   * @type {string[]}\n   */\n  static get DefaultPatterns() {\n    return DefaultPatterns;\n  }\n\n  /**\n   * Create the default predicate function.\n   * @param {string} cwd The current working directory.\n   * @returns {((filePath:string, dot:boolean) => boolean) & {basePath:string; patterns:string[]}}\n   * The preficate function.\n   * The first argument is an absolute path that is checked.\n   * The second argument is the flag to not ignore dotfiles.\n   * If the predicate function returned `true`, it means the path should be ignored.\n   */\n  static createDefaultIgnore(cwd) {\n    return this.createIgnore([new IgnorePattern(DefaultPatterns, cwd)]);\n  }\n\n  /**\n   * Create the predicate function from multiple `IgnorePattern` objects.\n   * @param {IgnorePattern[]} ignorePatterns The list of ignore patterns.\n   * @returns {((filePath:string, dot?:boolean) => boolean) & {basePath:string; patterns:string[]}}\n   * The preficate function.\n   * The first argument is an absolute path that is checked.\n   * The second argument is the flag to not ignore dotfiles.\n   * If the predicate function returned `true`, it means the path should be ignored.\n   */\n  static createIgnore(ignorePatterns) {\n    debug(\"Create with: %o\", ignorePatterns);\n    const basePath = getCommonAncestorPath(ignorePatterns.map(p => p.basePath));\n    const patterns = [].concat(...ignorePatterns.map(p => p.getPatternsRelativeTo(basePath)));\n    const ig = ignore().add([...DotPatterns, ...patterns]);\n    const dotIg = ignore().add(patterns);\n    debug(\"  processed: %o\", {\n      basePath,\n      patterns\n    });\n    return Object.assign((filePath, dot = false) => {\n      assert(path.isAbsolute(filePath), \"'filePath' should be an absolute path.\");\n      const relPathRaw = relative(basePath, filePath);\n      const relPath = relPathRaw && relPathRaw + dirSuffix(filePath);\n      const adoptedIg = dot ? dotIg : ig;\n      const result = relPath !== \"\" && adoptedIg.ignores(relPath);\n      debug(\"Check\", {\n        filePath,\n        dot,\n        relativePath: relPath,\n        result\n      });\n      return result;\n    }, {\n      basePath,\n      patterns\n    });\n  }\n\n  /**\n   * Initialize a new `IgnorePattern` instance.\n   * @param {string[]} patterns The glob patterns that ignore to lint.\n   * @param {string} basePath The base path of `patterns`.\n   */\n  constructor(patterns, basePath) {\n    assert(path.isAbsolute(basePath), \"'basePath' should be an absolute path.\");\n\n    /**\n     * The glob patterns that ignore to lint.\n     * @type {string[]}\n     */\n    this.patterns = patterns;\n\n    /**\n     * The base path of `patterns`.\n     * @type {string}\n     */\n    this.basePath = basePath;\n\n    /**\n     * If `true` then patterns which don't start with `/` will match the paths to the outside of `basePath`. Defaults to `false`.\n     *\n     * It's set `true` for `.eslintignore`, `package.json`, and `--ignore-path` for backward compatibility.\n     * It's `false` as-is for `ignorePatterns` property in config files.\n     * @type {boolean}\n     */\n    this.loose = false;\n  }\n\n  /**\n   * Get `patterns` as modified for a given base path. It modifies the\n   * absolute paths in the patterns as prepending the difference of two base\n   * paths.\n   * @param {string} newBasePath The base path.\n   * @returns {string[]} Modifired patterns.\n   */\n  getPatternsRelativeTo(newBasePath) {\n    assert(path.isAbsolute(newBasePath), \"'newBasePath' should be an absolute path.\");\n    const {\n      basePath,\n      loose,\n      patterns\n    } = this;\n    if (newBasePath === basePath) {\n      return patterns;\n    }\n    const prefix = `/${relative(newBasePath, basePath)}`;\n    return patterns.map(pattern => {\n      const negative = pattern.startsWith(\"!\");\n      const head = negative ? \"!\" : \"\";\n      const body = negative ? pattern.slice(1) : pattern;\n      if (body.startsWith(\"/\") || body.startsWith(\"../\")) {\n        return `${head}${prefix}${body}`;\n      }\n      return loose ? pattern : `${head}${prefix}/**/${body}`;\n    });\n  }\n}\nmodule.exports = {\n  IgnorePattern\n};","map":{"version":3,"names":["assert","require","path","ignore","debug","getCommonAncestorPath","sourcePaths","result","i","length","a","b","j","lastSepPos","slice","sep","resolvedResult","endsWith","process","platform","relative","from","to","relPath","split","join","dirSuffix","filePath","isDir","DefaultPatterns","Object","freeze","DotPatterns","IgnorePattern","createDefaultIgnore","cwd","createIgnore","ignorePatterns","basePath","map","p","patterns","concat","getPatternsRelativeTo","ig","add","dotIg","assign","dot","isAbsolute","relPathRaw","adoptedIg","ignores","relativePath","constructor","loose","newBasePath","prefix","pattern","negative","startsWith","head","body","module","exports"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/@eslint/eslintrc/lib/config-array/ignore-pattern.js"],"sourcesContent":["/**\n * @fileoverview `IgnorePattern` class.\n *\n * `IgnorePattern` class has the set of glob patterns and the base path.\n *\n * It provides two static methods.\n *\n * - `IgnorePattern.createDefaultIgnore(cwd)`\n *      Create the default predicate function.\n * - `IgnorePattern.createIgnore(ignorePatterns)`\n *      Create the predicate function from multiple `IgnorePattern` objects.\n *\n * It provides two properties and a method.\n *\n * - `patterns`\n *      The glob patterns that ignore to lint.\n * - `basePath`\n *      The base path of the glob patterns. If absolute paths existed in the\n *      glob patterns, those are handled as relative paths to the base path.\n * - `getPatternsRelativeTo(basePath)`\n *      Get `patterns` as modified for a given base path. It modifies the\n *      absolute paths in the patterns as prepending the difference of two base\n *      paths.\n *\n * `ConfigArrayFactory` creates `IgnorePattern` objects when it processes\n * `ignorePatterns` properties.\n *\n * @author Toru Nagashima <https://github.com/mysticatea>\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst assert = require(\"assert\");\nconst path = require(\"path\");\nconst ignore = require(\"ignore\");\nconst debug = require(\"debug\")(\"eslintrc:ignore-pattern\");\n\n/** @typedef {ReturnType<import(\"ignore\").default>} Ignore */\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Get the path to the common ancestor directory of given paths.\n * @param {string[]} sourcePaths The paths to calculate the common ancestor.\n * @returns {string} The path to the common ancestor directory.\n */\nfunction getCommonAncestorPath(sourcePaths) {\n    let result = sourcePaths[0];\n\n    for (let i = 1; i < sourcePaths.length; ++i) {\n        const a = result;\n        const b = sourcePaths[i];\n\n        // Set the shorter one (it's the common ancestor if one includes the other).\n        result = a.length < b.length ? a : b;\n\n        // Set the common ancestor.\n        for (let j = 0, lastSepPos = 0; j < a.length && j < b.length; ++j) {\n            if (a[j] !== b[j]) {\n                result = a.slice(0, lastSepPos);\n                break;\n            }\n            if (a[j] === path.sep) {\n                lastSepPos = j;\n            }\n        }\n    }\n\n    let resolvedResult = result || path.sep;\n\n    // if Windows common ancestor is root of drive must have trailing slash to be absolute.\n    if (resolvedResult && resolvedResult.endsWith(\":\") && process.platform === \"win32\") {\n        resolvedResult += path.sep;\n    }\n    return resolvedResult;\n}\n\n/**\n * Make relative path.\n * @param {string} from The source path to get relative path.\n * @param {string} to The destination path to get relative path.\n * @returns {string} The relative path.\n */\nfunction relative(from, to) {\n    const relPath = path.relative(from, to);\n\n    if (path.sep === \"/\") {\n        return relPath;\n    }\n    return relPath.split(path.sep).join(\"/\");\n}\n\n/**\n * Get the trailing slash if existed.\n * @param {string} filePath The path to check.\n * @returns {string} The trailing slash if existed.\n */\nfunction dirSuffix(filePath) {\n    const isDir = (\n        filePath.endsWith(path.sep) ||\n        (process.platform === \"win32\" && filePath.endsWith(\"/\"))\n    );\n\n    return isDir ? \"/\" : \"\";\n}\n\nconst DefaultPatterns = Object.freeze([\"/**/node_modules/*\"]);\nconst DotPatterns = Object.freeze([\".*\", \"!.eslintrc.*\", \"!../\"]);\n\n//------------------------------------------------------------------------------\n// Public\n//------------------------------------------------------------------------------\n\nclass IgnorePattern {\n\n    /**\n     * The default patterns.\n     * @type {string[]}\n     */\n    static get DefaultPatterns() {\n        return DefaultPatterns;\n    }\n\n    /**\n     * Create the default predicate function.\n     * @param {string} cwd The current working directory.\n     * @returns {((filePath:string, dot:boolean) => boolean) & {basePath:string; patterns:string[]}}\n     * The preficate function.\n     * The first argument is an absolute path that is checked.\n     * The second argument is the flag to not ignore dotfiles.\n     * If the predicate function returned `true`, it means the path should be ignored.\n     */\n    static createDefaultIgnore(cwd) {\n        return this.createIgnore([new IgnorePattern(DefaultPatterns, cwd)]);\n    }\n\n    /**\n     * Create the predicate function from multiple `IgnorePattern` objects.\n     * @param {IgnorePattern[]} ignorePatterns The list of ignore patterns.\n     * @returns {((filePath:string, dot?:boolean) => boolean) & {basePath:string; patterns:string[]}}\n     * The preficate function.\n     * The first argument is an absolute path that is checked.\n     * The second argument is the flag to not ignore dotfiles.\n     * If the predicate function returned `true`, it means the path should be ignored.\n     */\n    static createIgnore(ignorePatterns) {\n        debug(\"Create with: %o\", ignorePatterns);\n\n        const basePath = getCommonAncestorPath(ignorePatterns.map(p => p.basePath));\n        const patterns = [].concat(\n            ...ignorePatterns.map(p => p.getPatternsRelativeTo(basePath))\n        );\n        const ig = ignore().add([...DotPatterns, ...patterns]);\n        const dotIg = ignore().add(patterns);\n\n        debug(\"  processed: %o\", { basePath, patterns });\n\n        return Object.assign(\n            (filePath, dot = false) => {\n                assert(path.isAbsolute(filePath), \"'filePath' should be an absolute path.\");\n                const relPathRaw = relative(basePath, filePath);\n                const relPath = relPathRaw && (relPathRaw + dirSuffix(filePath));\n                const adoptedIg = dot ? dotIg : ig;\n                const result = relPath !== \"\" && adoptedIg.ignores(relPath);\n\n                debug(\"Check\", { filePath, dot, relativePath: relPath, result });\n                return result;\n            },\n            { basePath, patterns }\n        );\n    }\n\n    /**\n     * Initialize a new `IgnorePattern` instance.\n     * @param {string[]} patterns The glob patterns that ignore to lint.\n     * @param {string} basePath The base path of `patterns`.\n     */\n    constructor(patterns, basePath) {\n        assert(path.isAbsolute(basePath), \"'basePath' should be an absolute path.\");\n\n        /**\n         * The glob patterns that ignore to lint.\n         * @type {string[]}\n         */\n        this.patterns = patterns;\n\n        /**\n         * The base path of `patterns`.\n         * @type {string}\n         */\n        this.basePath = basePath;\n\n        /**\n         * If `true` then patterns which don't start with `/` will match the paths to the outside of `basePath`. Defaults to `false`.\n         *\n         * It's set `true` for `.eslintignore`, `package.json`, and `--ignore-path` for backward compatibility.\n         * It's `false` as-is for `ignorePatterns` property in config files.\n         * @type {boolean}\n         */\n        this.loose = false;\n    }\n\n    /**\n     * Get `patterns` as modified for a given base path. It modifies the\n     * absolute paths in the patterns as prepending the difference of two base\n     * paths.\n     * @param {string} newBasePath The base path.\n     * @returns {string[]} Modifired patterns.\n     */\n    getPatternsRelativeTo(newBasePath) {\n        assert(path.isAbsolute(newBasePath), \"'newBasePath' should be an absolute path.\");\n        const { basePath, loose, patterns } = this;\n\n        if (newBasePath === basePath) {\n            return patterns;\n        }\n        const prefix = `/${relative(newBasePath, basePath)}`;\n\n        return patterns.map(pattern => {\n            const negative = pattern.startsWith(\"!\");\n            const head = negative ? \"!\" : \"\";\n            const body = negative ? pattern.slice(1) : pattern;\n\n            if (body.startsWith(\"/\") || body.startsWith(\"../\")) {\n                return `${head}${prefix}${body}`;\n            }\n            return loose ? pattern : `${head}${prefix}/**/${body}`;\n        });\n    }\n}\n\nmodule.exports = { IgnorePattern };\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;;AAEZ;AACA;AACA;AAEA,MAAMA,MAAM,GAAGC,OAAO,CAAC,QAAQ,CAAC;AAChC,MAAMC,IAAI,GAAGD,OAAO,CAAC,MAAM,CAAC;AAC5B,MAAME,MAAM,GAAGF,OAAO,CAAC,QAAQ,CAAC;AAChC,MAAMG,KAAK,GAAGH,OAAO,CAAC,OAAO,CAAC,CAAC,yBAAyB,CAAC;;AAEzD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASI,qBAAqBA,CAACC,WAAW,EAAE;EACxC,IAAIC,MAAM,GAAGD,WAAW,CAAC,CAAC,CAAC;EAE3B,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,WAAW,CAACG,MAAM,EAAE,EAAED,CAAC,EAAE;IACzC,MAAME,CAAC,GAAGH,MAAM;IAChB,MAAMI,CAAC,GAAGL,WAAW,CAACE,CAAC,CAAC;;IAExB;IACAD,MAAM,GAAGG,CAAC,CAACD,MAAM,GAAGE,CAAC,CAACF,MAAM,GAAGC,CAAC,GAAGC,CAAC;;IAEpC;IACA,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,UAAU,GAAG,CAAC,EAAED,CAAC,GAAGF,CAAC,CAACD,MAAM,IAAIG,CAAC,GAAGD,CAAC,CAACF,MAAM,EAAE,EAAEG,CAAC,EAAE;MAC/D,IAAIF,CAAC,CAACE,CAAC,CAAC,KAAKD,CAAC,CAACC,CAAC,CAAC,EAAE;QACfL,MAAM,GAAGG,CAAC,CAACI,KAAK,CAAC,CAAC,EAAED,UAAU,CAAC;QAC/B;MACJ;MACA,IAAIH,CAAC,CAACE,CAAC,CAAC,KAAKV,IAAI,CAACa,GAAG,EAAE;QACnBF,UAAU,GAAGD,CAAC;MAClB;IACJ;EACJ;EAEA,IAAII,cAAc,GAAGT,MAAM,IAAIL,IAAI,CAACa,GAAG;;EAEvC;EACA,IAAIC,cAAc,IAAIA,cAAc,CAACC,QAAQ,CAAC,GAAG,CAAC,IAAIC,OAAO,CAACC,QAAQ,KAAK,OAAO,EAAE;IAChFH,cAAc,IAAId,IAAI,CAACa,GAAG;EAC9B;EACA,OAAOC,cAAc;AACzB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASI,QAAQA,CAACC,IAAI,EAAEC,EAAE,EAAE;EACxB,MAAMC,OAAO,GAAGrB,IAAI,CAACkB,QAAQ,CAACC,IAAI,EAAEC,EAAE,CAAC;EAEvC,IAAIpB,IAAI,CAACa,GAAG,KAAK,GAAG,EAAE;IAClB,OAAOQ,OAAO;EAClB;EACA,OAAOA,OAAO,CAACC,KAAK,CAACtB,IAAI,CAACa,GAAG,CAAC,CAACU,IAAI,CAAC,GAAG,CAAC;AAC5C;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASC,SAASA,CAACC,QAAQ,EAAE;EACzB,MAAMC,KAAK,GACPD,QAAQ,CAACV,QAAQ,CAACf,IAAI,CAACa,GAAG,CAAC,IAC1BG,OAAO,CAACC,QAAQ,KAAK,OAAO,IAAIQ,QAAQ,CAACV,QAAQ,CAAC,GAAG,CACzD;EAED,OAAOW,KAAK,GAAG,GAAG,GAAG,EAAE;AAC3B;AAEA,MAAMC,eAAe,GAAGC,MAAM,CAACC,MAAM,CAAC,CAAC,oBAAoB,CAAC,CAAC;AAC7D,MAAMC,WAAW,GAAGF,MAAM,CAACC,MAAM,CAAC,CAAC,IAAI,EAAE,cAAc,EAAE,MAAM,CAAC,CAAC;;AAEjE;AACA;AACA;;AAEA,MAAME,aAAa,CAAC;EAEhB;AACJ;AACA;AACA;EACI,WAAWJ,eAAeA,CAAA,EAAG;IACzB,OAAOA,eAAe;EAC1B;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,OAAOK,mBAAmBA,CAACC,GAAG,EAAE;IAC5B,OAAO,IAAI,CAACC,YAAY,CAAC,CAAC,IAAIH,aAAa,CAACJ,eAAe,EAAEM,GAAG,CAAC,CAAC,CAAC;EACvE;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,OAAOC,YAAYA,CAACC,cAAc,EAAE;IAChCjC,KAAK,CAAC,iBAAiB,EAAEiC,cAAc,CAAC;IAExC,MAAMC,QAAQ,GAAGjC,qBAAqB,CAACgC,cAAc,CAACE,GAAG,CAACC,CAAC,IAAIA,CAAC,CAACF,QAAQ,CAAC,CAAC;IAC3E,MAAMG,QAAQ,GAAG,EAAE,CAACC,MAAM,CACtB,GAAGL,cAAc,CAACE,GAAG,CAACC,CAAC,IAAIA,CAAC,CAACG,qBAAqB,CAACL,QAAQ,CAAC,CAChE,CAAC;IACD,MAAMM,EAAE,GAAGzC,MAAM,CAAC,CAAC,CAAC0C,GAAG,CAAC,CAAC,GAAGb,WAAW,EAAE,GAAGS,QAAQ,CAAC,CAAC;IACtD,MAAMK,KAAK,GAAG3C,MAAM,CAAC,CAAC,CAAC0C,GAAG,CAACJ,QAAQ,CAAC;IAEpCrC,KAAK,CAAC,iBAAiB,EAAE;MAAEkC,QAAQ;MAAEG;IAAS,CAAC,CAAC;IAEhD,OAAOX,MAAM,CAACiB,MAAM,CAChB,CAACpB,QAAQ,EAAEqB,GAAG,GAAG,KAAK,KAAK;MACvBhD,MAAM,CAACE,IAAI,CAAC+C,UAAU,CAACtB,QAAQ,CAAC,EAAE,wCAAwC,CAAC;MAC3E,MAAMuB,UAAU,GAAG9B,QAAQ,CAACkB,QAAQ,EAAEX,QAAQ,CAAC;MAC/C,MAAMJ,OAAO,GAAG2B,UAAU,IAAKA,UAAU,GAAGxB,SAAS,CAACC,QAAQ,CAAE;MAChE,MAAMwB,SAAS,GAAGH,GAAG,GAAGF,KAAK,GAAGF,EAAE;MAClC,MAAMrC,MAAM,GAAGgB,OAAO,KAAK,EAAE,IAAI4B,SAAS,CAACC,OAAO,CAAC7B,OAAO,CAAC;MAE3DnB,KAAK,CAAC,OAAO,EAAE;QAAEuB,QAAQ;QAAEqB,GAAG;QAAEK,YAAY,EAAE9B,OAAO;QAAEhB;MAAO,CAAC,CAAC;MAChE,OAAOA,MAAM;IACjB,CAAC,EACD;MAAE+B,QAAQ;MAAEG;IAAS,CACzB,CAAC;EACL;;EAEA;AACJ;AACA;AACA;AACA;EACIa,WAAWA,CAACb,QAAQ,EAAEH,QAAQ,EAAE;IAC5BtC,MAAM,CAACE,IAAI,CAAC+C,UAAU,CAACX,QAAQ,CAAC,EAAE,wCAAwC,CAAC;;IAE3E;AACR;AACA;AACA;IACQ,IAAI,CAACG,QAAQ,GAAGA,QAAQ;;IAExB;AACR;AACA;AACA;IACQ,IAAI,CAACH,QAAQ,GAAGA,QAAQ;;IAExB;AACR;AACA;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACiB,KAAK,GAAG,KAAK;EACtB;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;EACIZ,qBAAqBA,CAACa,WAAW,EAAE;IAC/BxD,MAAM,CAACE,IAAI,CAAC+C,UAAU,CAACO,WAAW,CAAC,EAAE,2CAA2C,CAAC;IACjF,MAAM;MAAElB,QAAQ;MAAEiB,KAAK;MAAEd;IAAS,CAAC,GAAG,IAAI;IAE1C,IAAIe,WAAW,KAAKlB,QAAQ,EAAE;MAC1B,OAAOG,QAAQ;IACnB;IACA,MAAMgB,MAAM,GAAI,IAAGrC,QAAQ,CAACoC,WAAW,EAAElB,QAAQ,CAAE,EAAC;IAEpD,OAAOG,QAAQ,CAACF,GAAG,CAACmB,OAAO,IAAI;MAC3B,MAAMC,QAAQ,GAAGD,OAAO,CAACE,UAAU,CAAC,GAAG,CAAC;MACxC,MAAMC,IAAI,GAAGF,QAAQ,GAAG,GAAG,GAAG,EAAE;MAChC,MAAMG,IAAI,GAAGH,QAAQ,GAAGD,OAAO,CAAC5C,KAAK,CAAC,CAAC,CAAC,GAAG4C,OAAO;MAElD,IAAII,IAAI,CAACF,UAAU,CAAC,GAAG,CAAC,IAAIE,IAAI,CAACF,UAAU,CAAC,KAAK,CAAC,EAAE;QAChD,OAAQ,GAAEC,IAAK,GAAEJ,MAAO,GAAEK,IAAK,EAAC;MACpC;MACA,OAAOP,KAAK,GAAGG,OAAO,GAAI,GAAEG,IAAK,GAAEJ,MAAO,OAAMK,IAAK,EAAC;IAC1D,CAAC,CAAC;EACN;AACJ;AAEAC,MAAM,CAACC,OAAO,GAAG;EAAE/B;AAAc,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}