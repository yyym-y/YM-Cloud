{"ast":null,"code":"/**\n * @fileoverview Comma style - enforces comma styles of two types: last and first\n * @author Vignesh Anand aka vegetableman\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce consistent comma style\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/comma-style\"\n    },\n    fixable: \"code\",\n    schema: [{\n      enum: [\"first\", \"last\"]\n    }, {\n      type: \"object\",\n      properties: {\n        exceptions: {\n          type: \"object\",\n          additionalProperties: {\n            type: \"boolean\"\n          }\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unexpectedLineBeforeAndAfterComma: \"Bad line breaking before and after ','.\",\n      expectedCommaFirst: \"',' should be placed first.\",\n      expectedCommaLast: \"',' should be placed last.\"\n    }\n  },\n  create(context) {\n    const style = context.options[0] || \"last\",\n      sourceCode = context.getSourceCode();\n    const exceptions = {\n      ArrayPattern: true,\n      ArrowFunctionExpression: true,\n      CallExpression: true,\n      FunctionDeclaration: true,\n      FunctionExpression: true,\n      ImportDeclaration: true,\n      ObjectPattern: true,\n      NewExpression: true\n    };\n    if (context.options.length === 2 && Object.prototype.hasOwnProperty.call(context.options[1], \"exceptions\")) {\n      const keys = Object.keys(context.options[1].exceptions);\n      for (let i = 0; i < keys.length; i++) {\n        exceptions[keys[i]] = context.options[1].exceptions[keys[i]];\n      }\n    }\n\n    //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    /**\n     * Modified text based on the style\n     * @param {string} styleType Style type\n     * @param {string} text Source code text\n     * @returns {string} modified text\n     * @private\n     */\n    function getReplacedText(styleType, text) {\n      switch (styleType) {\n        case \"between\":\n          return `,${text.replace(astUtils.LINEBREAK_MATCHER, \"\")}`;\n        case \"first\":\n          return `${text},`;\n        case \"last\":\n          return `,${text}`;\n        default:\n          return \"\";\n      }\n    }\n\n    /**\n     * Determines the fixer function for a given style.\n     * @param {string} styleType comma style\n     * @param {ASTNode} previousItemToken The token to check.\n     * @param {ASTNode} commaToken The token to check.\n     * @param {ASTNode} currentItemToken The token to check.\n     * @returns {Function} Fixer function\n     * @private\n     */\n    function getFixerFunction(styleType, previousItemToken, commaToken, currentItemToken) {\n      const text = sourceCode.text.slice(previousItemToken.range[1], commaToken.range[0]) + sourceCode.text.slice(commaToken.range[1], currentItemToken.range[0]);\n      const range = [previousItemToken.range[1], currentItemToken.range[0]];\n      return function (fixer) {\n        return fixer.replaceTextRange(range, getReplacedText(styleType, text));\n      };\n    }\n\n    /**\n     * Validates the spacing around single items in lists.\n     * @param {Token} previousItemToken The last token from the previous item.\n     * @param {Token} commaToken The token representing the comma.\n     * @param {Token} currentItemToken The first token of the current item.\n     * @param {Token} reportItem The item to use when reporting an error.\n     * @returns {void}\n     * @private\n     */\n    function validateCommaItemSpacing(previousItemToken, commaToken, currentItemToken, reportItem) {\n      // if single line\n      if (astUtils.isTokenOnSameLine(commaToken, currentItemToken) && astUtils.isTokenOnSameLine(previousItemToken, commaToken)) {\n\n        // do nothing.\n      } else if (!astUtils.isTokenOnSameLine(commaToken, currentItemToken) && !astUtils.isTokenOnSameLine(previousItemToken, commaToken)) {\n        const comment = sourceCode.getCommentsAfter(commaToken)[0];\n        const styleType = comment && comment.type === \"Block\" && astUtils.isTokenOnSameLine(commaToken, comment) ? style : \"between\";\n\n        // lone comma\n        context.report({\n          node: reportItem,\n          loc: commaToken.loc,\n          messageId: \"unexpectedLineBeforeAndAfterComma\",\n          fix: getFixerFunction(styleType, previousItemToken, commaToken, currentItemToken)\n        });\n      } else if (style === \"first\" && !astUtils.isTokenOnSameLine(commaToken, currentItemToken)) {\n        context.report({\n          node: reportItem,\n          loc: commaToken.loc,\n          messageId: \"expectedCommaFirst\",\n          fix: getFixerFunction(style, previousItemToken, commaToken, currentItemToken)\n        });\n      } else if (style === \"last\" && astUtils.isTokenOnSameLine(commaToken, currentItemToken)) {\n        context.report({\n          node: reportItem,\n          loc: commaToken.loc,\n          messageId: \"expectedCommaLast\",\n          fix: getFixerFunction(style, previousItemToken, commaToken, currentItemToken)\n        });\n      }\n    }\n\n    /**\n     * Checks the comma placement with regards to a declaration/property/element\n     * @param {ASTNode} node The binary expression node to check\n     * @param {string} property The property of the node containing child nodes.\n     * @private\n     * @returns {void}\n     */\n    function validateComma(node, property) {\n      const items = node[property],\n        arrayLiteral = node.type === \"ArrayExpression\" || node.type === \"ArrayPattern\";\n      if (items.length > 1 || arrayLiteral) {\n        // seed as opening [\n        let previousItemToken = sourceCode.getFirstToken(node);\n        items.forEach(item => {\n          const commaToken = item ? sourceCode.getTokenBefore(item) : previousItemToken,\n            currentItemToken = item ? sourceCode.getFirstToken(item) : sourceCode.getTokenAfter(commaToken),\n            reportItem = item || currentItemToken;\n\n          /*\n           * This works by comparing three token locations:\n           * - previousItemToken is the last token of the previous item\n           * - commaToken is the location of the comma before the current item\n           * - currentItemToken is the first token of the current item\n           *\n           * These values get switched around if item is undefined.\n           * previousItemToken will refer to the last token not belonging\n           * to the current item, which could be a comma or an opening\n           * square bracket. currentItemToken could be a comma.\n           *\n           * All comparisons are done based on these tokens directly, so\n           * they are always valid regardless of an undefined item.\n           */\n          if (astUtils.isCommaToken(commaToken)) {\n            validateCommaItemSpacing(previousItemToken, commaToken, currentItemToken, reportItem);\n          }\n          if (item) {\n            const tokenAfterItem = sourceCode.getTokenAfter(item, astUtils.isNotClosingParenToken);\n            previousItemToken = tokenAfterItem ? sourceCode.getTokenBefore(tokenAfterItem) : sourceCode.ast.tokens[sourceCode.ast.tokens.length - 1];\n          } else {\n            previousItemToken = currentItemToken;\n          }\n        });\n\n        /*\n         * Special case for array literals that have empty last items, such\n         * as [ 1, 2, ]. These arrays only have two items show up in the\n         * AST, so we need to look at the token to verify that there's no\n         * dangling comma.\n         */\n        if (arrayLiteral) {\n          const lastToken = sourceCode.getLastToken(node),\n            nextToLastToken = sourceCode.getTokenBefore(lastToken);\n          if (astUtils.isCommaToken(nextToLastToken)) {\n            validateCommaItemSpacing(sourceCode.getTokenBefore(nextToLastToken), nextToLastToken, lastToken, lastToken);\n          }\n        }\n      }\n    }\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    const nodes = {};\n    if (!exceptions.VariableDeclaration) {\n      nodes.VariableDeclaration = function (node) {\n        validateComma(node, \"declarations\");\n      };\n    }\n    if (!exceptions.ObjectExpression) {\n      nodes.ObjectExpression = function (node) {\n        validateComma(node, \"properties\");\n      };\n    }\n    if (!exceptions.ObjectPattern) {\n      nodes.ObjectPattern = function (node) {\n        validateComma(node, \"properties\");\n      };\n    }\n    if (!exceptions.ArrayExpression) {\n      nodes.ArrayExpression = function (node) {\n        validateComma(node, \"elements\");\n      };\n    }\n    if (!exceptions.ArrayPattern) {\n      nodes.ArrayPattern = function (node) {\n        validateComma(node, \"elements\");\n      };\n    }\n    if (!exceptions.FunctionDeclaration) {\n      nodes.FunctionDeclaration = function (node) {\n        validateComma(node, \"params\");\n      };\n    }\n    if (!exceptions.FunctionExpression) {\n      nodes.FunctionExpression = function (node) {\n        validateComma(node, \"params\");\n      };\n    }\n    if (!exceptions.ArrowFunctionExpression) {\n      nodes.ArrowFunctionExpression = function (node) {\n        validateComma(node, \"params\");\n      };\n    }\n    if (!exceptions.CallExpression) {\n      nodes.CallExpression = function (node) {\n        validateComma(node, \"arguments\");\n      };\n    }\n    if (!exceptions.ImportDeclaration) {\n      nodes.ImportDeclaration = function (node) {\n        validateComma(node, \"specifiers\");\n      };\n    }\n    if (!exceptions.NewExpression) {\n      nodes.NewExpression = function (node) {\n        validateComma(node, \"arguments\");\n      };\n    }\n    return nodes;\n  }\n};","map":{"version":3,"names":["astUtils","require","module","exports","meta","type","docs","description","category","recommended","url","fixable","schema","enum","properties","exceptions","additionalProperties","messages","unexpectedLineBeforeAndAfterComma","expectedCommaFirst","expectedCommaLast","create","context","style","options","sourceCode","getSourceCode","ArrayPattern","ArrowFunctionExpression","CallExpression","FunctionDeclaration","FunctionExpression","ImportDeclaration","ObjectPattern","NewExpression","length","Object","prototype","hasOwnProperty","call","keys","i","getReplacedText","styleType","text","replace","LINEBREAK_MATCHER","getFixerFunction","previousItemToken","commaToken","currentItemToken","slice","range","fixer","replaceTextRange","validateCommaItemSpacing","reportItem","isTokenOnSameLine","comment","getCommentsAfter","report","node","loc","messageId","fix","validateComma","property","items","arrayLiteral","getFirstToken","forEach","item","getTokenBefore","getTokenAfter","isCommaToken","tokenAfterItem","isNotClosingParenToken","ast","tokens","lastToken","getLastToken","nextToLastToken","nodes","VariableDeclaration","ObjectExpression","ArrayExpression"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/comma-style.js"],"sourcesContent":["/**\n * @fileoverview Comma style - enforces comma styles of two types: last and first\n * @author Vignesh Anand aka vegetableman\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce consistent comma style\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/comma-style\"\n        },\n\n        fixable: \"code\",\n\n        schema: [\n            {\n                enum: [\"first\", \"last\"]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    exceptions: {\n                        type: \"object\",\n                        additionalProperties: {\n                            type: \"boolean\"\n                        }\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            unexpectedLineBeforeAndAfterComma: \"Bad line breaking before and after ','.\",\n            expectedCommaFirst: \"',' should be placed first.\",\n            expectedCommaLast: \"',' should be placed last.\"\n        }\n    },\n\n    create(context) {\n        const style = context.options[0] || \"last\",\n            sourceCode = context.getSourceCode();\n        const exceptions = {\n            ArrayPattern: true,\n            ArrowFunctionExpression: true,\n            CallExpression: true,\n            FunctionDeclaration: true,\n            FunctionExpression: true,\n            ImportDeclaration: true,\n            ObjectPattern: true,\n            NewExpression: true\n        };\n\n        if (context.options.length === 2 && Object.prototype.hasOwnProperty.call(context.options[1], \"exceptions\")) {\n            const keys = Object.keys(context.options[1].exceptions);\n\n            for (let i = 0; i < keys.length; i++) {\n                exceptions[keys[i]] = context.options[1].exceptions[keys[i]];\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Modified text based on the style\n         * @param {string} styleType Style type\n         * @param {string} text Source code text\n         * @returns {string} modified text\n         * @private\n         */\n        function getReplacedText(styleType, text) {\n            switch (styleType) {\n                case \"between\":\n                    return `,${text.replace(astUtils.LINEBREAK_MATCHER, \"\")}`;\n\n                case \"first\":\n                    return `${text},`;\n\n                case \"last\":\n                    return `,${text}`;\n\n                default:\n                    return \"\";\n            }\n        }\n\n        /**\n         * Determines the fixer function for a given style.\n         * @param {string} styleType comma style\n         * @param {ASTNode} previousItemToken The token to check.\n         * @param {ASTNode} commaToken The token to check.\n         * @param {ASTNode} currentItemToken The token to check.\n         * @returns {Function} Fixer function\n         * @private\n         */\n        function getFixerFunction(styleType, previousItemToken, commaToken, currentItemToken) {\n            const text =\n                sourceCode.text.slice(previousItemToken.range[1], commaToken.range[0]) +\n                sourceCode.text.slice(commaToken.range[1], currentItemToken.range[0]);\n            const range = [previousItemToken.range[1], currentItemToken.range[0]];\n\n            return function(fixer) {\n                return fixer.replaceTextRange(range, getReplacedText(styleType, text));\n            };\n        }\n\n        /**\n         * Validates the spacing around single items in lists.\n         * @param {Token} previousItemToken The last token from the previous item.\n         * @param {Token} commaToken The token representing the comma.\n         * @param {Token} currentItemToken The first token of the current item.\n         * @param {Token} reportItem The item to use when reporting an error.\n         * @returns {void}\n         * @private\n         */\n        function validateCommaItemSpacing(previousItemToken, commaToken, currentItemToken, reportItem) {\n\n            // if single line\n            if (astUtils.isTokenOnSameLine(commaToken, currentItemToken) &&\n                    astUtils.isTokenOnSameLine(previousItemToken, commaToken)) {\n\n                // do nothing.\n\n            } else if (!astUtils.isTokenOnSameLine(commaToken, currentItemToken) &&\n                    !astUtils.isTokenOnSameLine(previousItemToken, commaToken)) {\n\n                const comment = sourceCode.getCommentsAfter(commaToken)[0];\n                const styleType = comment && comment.type === \"Block\" && astUtils.isTokenOnSameLine(commaToken, comment)\n                    ? style\n                    : \"between\";\n\n                // lone comma\n                context.report({\n                    node: reportItem,\n                    loc: commaToken.loc,\n                    messageId: \"unexpectedLineBeforeAndAfterComma\",\n                    fix: getFixerFunction(styleType, previousItemToken, commaToken, currentItemToken)\n                });\n\n            } else if (style === \"first\" && !astUtils.isTokenOnSameLine(commaToken, currentItemToken)) {\n\n                context.report({\n                    node: reportItem,\n                    loc: commaToken.loc,\n                    messageId: \"expectedCommaFirst\",\n                    fix: getFixerFunction(style, previousItemToken, commaToken, currentItemToken)\n                });\n\n            } else if (style === \"last\" && astUtils.isTokenOnSameLine(commaToken, currentItemToken)) {\n\n                context.report({\n                    node: reportItem,\n                    loc: commaToken.loc,\n                    messageId: \"expectedCommaLast\",\n                    fix: getFixerFunction(style, previousItemToken, commaToken, currentItemToken)\n                });\n            }\n        }\n\n        /**\n         * Checks the comma placement with regards to a declaration/property/element\n         * @param {ASTNode} node The binary expression node to check\n         * @param {string} property The property of the node containing child nodes.\n         * @private\n         * @returns {void}\n         */\n        function validateComma(node, property) {\n            const items = node[property],\n                arrayLiteral = (node.type === \"ArrayExpression\" || node.type === \"ArrayPattern\");\n\n            if (items.length > 1 || arrayLiteral) {\n\n                // seed as opening [\n                let previousItemToken = sourceCode.getFirstToken(node);\n\n                items.forEach(item => {\n                    const commaToken = item ? sourceCode.getTokenBefore(item) : previousItemToken,\n                        currentItemToken = item ? sourceCode.getFirstToken(item) : sourceCode.getTokenAfter(commaToken),\n                        reportItem = item || currentItemToken;\n\n                    /*\n                     * This works by comparing three token locations:\n                     * - previousItemToken is the last token of the previous item\n                     * - commaToken is the location of the comma before the current item\n                     * - currentItemToken is the first token of the current item\n                     *\n                     * These values get switched around if item is undefined.\n                     * previousItemToken will refer to the last token not belonging\n                     * to the current item, which could be a comma or an opening\n                     * square bracket. currentItemToken could be a comma.\n                     *\n                     * All comparisons are done based on these tokens directly, so\n                     * they are always valid regardless of an undefined item.\n                     */\n                    if (astUtils.isCommaToken(commaToken)) {\n                        validateCommaItemSpacing(previousItemToken, commaToken, currentItemToken, reportItem);\n                    }\n\n                    if (item) {\n                        const tokenAfterItem = sourceCode.getTokenAfter(item, astUtils.isNotClosingParenToken);\n\n                        previousItemToken = tokenAfterItem\n                            ? sourceCode.getTokenBefore(tokenAfterItem)\n                            : sourceCode.ast.tokens[sourceCode.ast.tokens.length - 1];\n                    } else {\n                        previousItemToken = currentItemToken;\n                    }\n                });\n\n                /*\n                 * Special case for array literals that have empty last items, such\n                 * as [ 1, 2, ]. These arrays only have two items show up in the\n                 * AST, so we need to look at the token to verify that there's no\n                 * dangling comma.\n                 */\n                if (arrayLiteral) {\n\n                    const lastToken = sourceCode.getLastToken(node),\n                        nextToLastToken = sourceCode.getTokenBefore(lastToken);\n\n                    if (astUtils.isCommaToken(nextToLastToken)) {\n                        validateCommaItemSpacing(\n                            sourceCode.getTokenBefore(nextToLastToken),\n                            nextToLastToken,\n                            lastToken,\n                            lastToken\n                        );\n                    }\n                }\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        const nodes = {};\n\n        if (!exceptions.VariableDeclaration) {\n            nodes.VariableDeclaration = function(node) {\n                validateComma(node, \"declarations\");\n            };\n        }\n        if (!exceptions.ObjectExpression) {\n            nodes.ObjectExpression = function(node) {\n                validateComma(node, \"properties\");\n            };\n        }\n        if (!exceptions.ObjectPattern) {\n            nodes.ObjectPattern = function(node) {\n                validateComma(node, \"properties\");\n            };\n        }\n        if (!exceptions.ArrayExpression) {\n            nodes.ArrayExpression = function(node) {\n                validateComma(node, \"elements\");\n            };\n        }\n        if (!exceptions.ArrayPattern) {\n            nodes.ArrayPattern = function(node) {\n                validateComma(node, \"elements\");\n            };\n        }\n        if (!exceptions.FunctionDeclaration) {\n            nodes.FunctionDeclaration = function(node) {\n                validateComma(node, \"params\");\n            };\n        }\n        if (!exceptions.FunctionExpression) {\n            nodes.FunctionExpression = function(node) {\n                validateComma(node, \"params\");\n            };\n        }\n        if (!exceptions.ArrowFunctionExpression) {\n            nodes.ArrowFunctionExpression = function(node) {\n                validateComma(node, \"params\");\n            };\n        }\n        if (!exceptions.CallExpression) {\n            nodes.CallExpression = function(node) {\n                validateComma(node, \"arguments\");\n            };\n        }\n        if (!exceptions.ImportDeclaration) {\n            nodes.ImportDeclaration = function(node) {\n                validateComma(node, \"specifiers\");\n            };\n        }\n        if (!exceptions.NewExpression) {\n            nodes.NewExpression = function(node) {\n                validateComma(node, \"arguments\");\n            };\n        }\n\n        return nodes;\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}