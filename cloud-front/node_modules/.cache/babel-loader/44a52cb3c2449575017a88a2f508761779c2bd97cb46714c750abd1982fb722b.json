{"ast":null,"code":"/**\n * @fileoverview Rule to require newlines before `return` statement\n * @author Kai Cataldo\n * @deprecated\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"require an empty line before `return` statements\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/newline-before-return\"\n    },\n    fixable: \"whitespace\",\n    schema: [],\n    messages: {\n      expected: \"Expected newline before return statement.\"\n    },\n    deprecated: true,\n    replacedBy: [\"padding-line-between-statements\"]\n  },\n  create(context) {\n    const sourceCode = context.getSourceCode();\n\n    //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    /**\n     * Tests whether node is preceded by supplied tokens\n     * @param {ASTNode} node node to check\n     * @param {Array} testTokens array of tokens to test against\n     * @returns {boolean} Whether or not the node is preceded by one of the supplied tokens\n     * @private\n     */\n    function isPrecededByTokens(node, testTokens) {\n      const tokenBefore = sourceCode.getTokenBefore(node);\n      return testTokens.some(token => tokenBefore.value === token);\n    }\n\n    /**\n     * Checks whether node is the first node after statement or in block\n     * @param {ASTNode} node node to check\n     * @returns {boolean} Whether or not the node is the first node after statement or in block\n     * @private\n     */\n    function isFirstNode(node) {\n      const parentType = node.parent.type;\n      if (node.parent.body) {\n        return Array.isArray(node.parent.body) ? node.parent.body[0] === node : node.parent.body === node;\n      }\n      if (parentType === \"IfStatement\") {\n        return isPrecededByTokens(node, [\"else\", \")\"]);\n      }\n      if (parentType === \"DoWhileStatement\") {\n        return isPrecededByTokens(node, [\"do\"]);\n      }\n      if (parentType === \"SwitchCase\") {\n        return isPrecededByTokens(node, [\":\"]);\n      }\n      return isPrecededByTokens(node, [\")\"]);\n    }\n\n    /**\n     * Returns the number of lines of comments that precede the node\n     * @param {ASTNode} node node to check for overlapping comments\n     * @param {number} lineNumTokenBefore line number of previous token, to check for overlapping comments\n     * @returns {number} Number of lines of comments that precede the node\n     * @private\n     */\n    function calcCommentLines(node, lineNumTokenBefore) {\n      const comments = sourceCode.getCommentsBefore(node);\n      let numLinesComments = 0;\n      if (!comments.length) {\n        return numLinesComments;\n      }\n      comments.forEach(comment => {\n        numLinesComments++;\n        if (comment.type === \"Block\") {\n          numLinesComments += comment.loc.end.line - comment.loc.start.line;\n        }\n\n        // avoid counting lines with inline comments twice\n        if (comment.loc.start.line === lineNumTokenBefore) {\n          numLinesComments--;\n        }\n        if (comment.loc.end.line === node.loc.start.line) {\n          numLinesComments--;\n        }\n      });\n      return numLinesComments;\n    }\n\n    /**\n     * Returns the line number of the token before the node that is passed in as an argument\n     * @param {ASTNode} node The node to use as the start of the calculation\n     * @returns {number} Line number of the token before `node`\n     * @private\n     */\n    function getLineNumberOfTokenBefore(node) {\n      const tokenBefore = sourceCode.getTokenBefore(node);\n      let lineNumTokenBefore;\n\n      /**\n       * Global return (at the beginning of a script) is a special case.\n       * If there is no token before `return`, then we expect no line\n       * break before the return. Comments are allowed to occupy lines\n       * before the global return, just no blank lines.\n       * Setting lineNumTokenBefore to zero in that case results in the\n       * desired behavior.\n       */\n      if (tokenBefore) {\n        lineNumTokenBefore = tokenBefore.loc.end.line;\n      } else {\n        lineNumTokenBefore = 0; // global return at beginning of script\n      }\n\n      return lineNumTokenBefore;\n    }\n\n    /**\n     * Checks whether node is preceded by a newline\n     * @param {ASTNode} node node to check\n     * @returns {boolean} Whether or not the node is preceded by a newline\n     * @private\n     */\n    function hasNewlineBefore(node) {\n      const lineNumNode = node.loc.start.line;\n      const lineNumTokenBefore = getLineNumberOfTokenBefore(node);\n      const commentLines = calcCommentLines(node, lineNumTokenBefore);\n      return lineNumNode - lineNumTokenBefore - commentLines > 1;\n    }\n\n    /**\n     * Checks whether it is safe to apply a fix to a given return statement.\n     *\n     * The fix is not considered safe if the given return statement has leading comments,\n     * as we cannot safely determine if the newline should be added before or after the comments.\n     * For more information, see: https://github.com/eslint/eslint/issues/5958#issuecomment-222767211\n     * @param {ASTNode} node The return statement node to check.\n     * @returns {boolean} `true` if it can fix the node.\n     * @private\n     */\n    function canFix(node) {\n      const leadingComments = sourceCode.getCommentsBefore(node);\n      const lastLeadingComment = leadingComments[leadingComments.length - 1];\n      const tokenBefore = sourceCode.getTokenBefore(node);\n      if (leadingComments.length === 0) {\n        return true;\n      }\n\n      /*\n       * if the last leading comment ends in the same line as the previous token and\n       * does not share a line with the `return` node, we can consider it safe to fix.\n       * Example:\n       * function a() {\n       *     var b; //comment\n       *     return;\n       * }\n       */\n      if (lastLeadingComment.loc.end.line === tokenBefore.loc.end.line && lastLeadingComment.loc.end.line !== node.loc.start.line) {\n        return true;\n      }\n      return false;\n    }\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    return {\n      ReturnStatement(node) {\n        if (!isFirstNode(node) && !hasNewlineBefore(node)) {\n          context.report({\n            node,\n            messageId: \"expected\",\n            fix(fixer) {\n              if (canFix(node)) {\n                const tokenBefore = sourceCode.getTokenBefore(node);\n                const newlines = node.loc.start.line === tokenBefore.loc.end.line ? \"\\n\\n\" : \"\\n\";\n                return fixer.insertTextBefore(node, newlines);\n              }\n              return null;\n            }\n          });\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["module","exports","meta","type","docs","description","category","recommended","url","fixable","schema","messages","expected","deprecated","replacedBy","create","context","sourceCode","getSourceCode","isPrecededByTokens","node","testTokens","tokenBefore","getTokenBefore","some","token","value","isFirstNode","parentType","parent","body","Array","isArray","calcCommentLines","lineNumTokenBefore","comments","getCommentsBefore","numLinesComments","length","forEach","comment","loc","end","line","start","getLineNumberOfTokenBefore","hasNewlineBefore","lineNumNode","commentLines","canFix","leadingComments","lastLeadingComment","ReturnStatement","report","messageId","fix","fixer","newlines","insertTextBefore"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/newline-before-return.js"],"sourcesContent":["/**\n * @fileoverview Rule to require newlines before `return` statement\n * @author Kai Cataldo\n * @deprecated\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"require an empty line before `return` statements\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/newline-before-return\"\n        },\n\n        fixable: \"whitespace\",\n        schema: [],\n        messages: {\n            expected: \"Expected newline before return statement.\"\n        },\n\n        deprecated: true,\n        replacedBy: [\"padding-line-between-statements\"]\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Tests whether node is preceded by supplied tokens\n         * @param {ASTNode} node node to check\n         * @param {Array} testTokens array of tokens to test against\n         * @returns {boolean} Whether or not the node is preceded by one of the supplied tokens\n         * @private\n         */\n        function isPrecededByTokens(node, testTokens) {\n            const tokenBefore = sourceCode.getTokenBefore(node);\n\n            return testTokens.some(token => tokenBefore.value === token);\n        }\n\n        /**\n         * Checks whether node is the first node after statement or in block\n         * @param {ASTNode} node node to check\n         * @returns {boolean} Whether or not the node is the first node after statement or in block\n         * @private\n         */\n        function isFirstNode(node) {\n            const parentType = node.parent.type;\n\n            if (node.parent.body) {\n                return Array.isArray(node.parent.body)\n                    ? node.parent.body[0] === node\n                    : node.parent.body === node;\n            }\n\n            if (parentType === \"IfStatement\") {\n                return isPrecededByTokens(node, [\"else\", \")\"]);\n            }\n            if (parentType === \"DoWhileStatement\") {\n                return isPrecededByTokens(node, [\"do\"]);\n            }\n            if (parentType === \"SwitchCase\") {\n                return isPrecededByTokens(node, [\":\"]);\n            }\n            return isPrecededByTokens(node, [\")\"]);\n\n        }\n\n        /**\n         * Returns the number of lines of comments that precede the node\n         * @param {ASTNode} node node to check for overlapping comments\n         * @param {number} lineNumTokenBefore line number of previous token, to check for overlapping comments\n         * @returns {number} Number of lines of comments that precede the node\n         * @private\n         */\n        function calcCommentLines(node, lineNumTokenBefore) {\n            const comments = sourceCode.getCommentsBefore(node);\n            let numLinesComments = 0;\n\n            if (!comments.length) {\n                return numLinesComments;\n            }\n\n            comments.forEach(comment => {\n                numLinesComments++;\n\n                if (comment.type === \"Block\") {\n                    numLinesComments += comment.loc.end.line - comment.loc.start.line;\n                }\n\n                // avoid counting lines with inline comments twice\n                if (comment.loc.start.line === lineNumTokenBefore) {\n                    numLinesComments--;\n                }\n\n                if (comment.loc.end.line === node.loc.start.line) {\n                    numLinesComments--;\n                }\n            });\n\n            return numLinesComments;\n        }\n\n        /**\n         * Returns the line number of the token before the node that is passed in as an argument\n         * @param {ASTNode} node The node to use as the start of the calculation\n         * @returns {number} Line number of the token before `node`\n         * @private\n         */\n        function getLineNumberOfTokenBefore(node) {\n            const tokenBefore = sourceCode.getTokenBefore(node);\n            let lineNumTokenBefore;\n\n            /**\n             * Global return (at the beginning of a script) is a special case.\n             * If there is no token before `return`, then we expect no line\n             * break before the return. Comments are allowed to occupy lines\n             * before the global return, just no blank lines.\n             * Setting lineNumTokenBefore to zero in that case results in the\n             * desired behavior.\n             */\n            if (tokenBefore) {\n                lineNumTokenBefore = tokenBefore.loc.end.line;\n            } else {\n                lineNumTokenBefore = 0; // global return at beginning of script\n            }\n\n            return lineNumTokenBefore;\n        }\n\n        /**\n         * Checks whether node is preceded by a newline\n         * @param {ASTNode} node node to check\n         * @returns {boolean} Whether or not the node is preceded by a newline\n         * @private\n         */\n        function hasNewlineBefore(node) {\n            const lineNumNode = node.loc.start.line;\n            const lineNumTokenBefore = getLineNumberOfTokenBefore(node);\n            const commentLines = calcCommentLines(node, lineNumTokenBefore);\n\n            return (lineNumNode - lineNumTokenBefore - commentLines) > 1;\n        }\n\n        /**\n         * Checks whether it is safe to apply a fix to a given return statement.\n         *\n         * The fix is not considered safe if the given return statement has leading comments,\n         * as we cannot safely determine if the newline should be added before or after the comments.\n         * For more information, see: https://github.com/eslint/eslint/issues/5958#issuecomment-222767211\n         * @param {ASTNode} node The return statement node to check.\n         * @returns {boolean} `true` if it can fix the node.\n         * @private\n         */\n        function canFix(node) {\n            const leadingComments = sourceCode.getCommentsBefore(node);\n            const lastLeadingComment = leadingComments[leadingComments.length - 1];\n            const tokenBefore = sourceCode.getTokenBefore(node);\n\n            if (leadingComments.length === 0) {\n                return true;\n            }\n\n            /*\n             * if the last leading comment ends in the same line as the previous token and\n             * does not share a line with the `return` node, we can consider it safe to fix.\n             * Example:\n             * function a() {\n             *     var b; //comment\n             *     return;\n             * }\n             */\n            if (lastLeadingComment.loc.end.line === tokenBefore.loc.end.line &&\n                lastLeadingComment.loc.end.line !== node.loc.start.line) {\n                return true;\n            }\n\n            return false;\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            ReturnStatement(node) {\n                if (!isFirstNode(node) && !hasNewlineBefore(node)) {\n                    context.report({\n                        node,\n                        messageId: \"expected\",\n                        fix(fixer) {\n                            if (canFix(node)) {\n                                const tokenBefore = sourceCode.getTokenBefore(node);\n                                const newlines = node.loc.start.line === tokenBefore.loc.end.line ? \"\\n\\n\" : \"\\n\";\n\n                                return fixer.insertTextBefore(node, newlines);\n                            }\n                            return null;\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA,YAAY;;AAEZ;AACA;AACA;AAEAA,MAAM,CAACC,OAAO,GAAG;EACbC,IAAI,EAAE;IACFC,IAAI,EAAE,QAAQ;IAEdC,IAAI,EAAE;MACFC,WAAW,EAAE,kDAAkD;MAC/DC,QAAQ,EAAE,kBAAkB;MAC5BC,WAAW,EAAE,KAAK;MAClBC,GAAG,EAAE;IACT,CAAC;IAEDC,OAAO,EAAE,YAAY;IACrBC,MAAM,EAAE,EAAE;IACVC,QAAQ,EAAE;MACNC,QAAQ,EAAE;IACd,CAAC;IAEDC,UAAU,EAAE,IAAI;IAChBC,UAAU,EAAE,CAAC,iCAAiC;EAClD,CAAC;EAEDC,MAAMA,CAACC,OAAO,EAAE;IACZ,MAAMC,UAAU,GAAGD,OAAO,CAACE,aAAa,CAAC,CAAC;;IAE1C;IACA;IACA;;IAEA;AACR;AACA;AACA;AACA;AACA;AACA;IACQ,SAASC,kBAAkBA,CAACC,IAAI,EAAEC,UAAU,EAAE;MAC1C,MAAMC,WAAW,GAAGL,UAAU,CAACM,cAAc,CAACH,IAAI,CAAC;MAEnD,OAAOC,UAAU,CAACG,IAAI,CAACC,KAAK,IAAIH,WAAW,CAACI,KAAK,KAAKD,KAAK,CAAC;IAChE;;IAEA;AACR;AACA;AACA;AACA;AACA;IACQ,SAASE,WAAWA,CAACP,IAAI,EAAE;MACvB,MAAMQ,UAAU,GAAGR,IAAI,CAACS,MAAM,CAAC1B,IAAI;MAEnC,IAAIiB,IAAI,CAACS,MAAM,CAACC,IAAI,EAAE;QAClB,OAAOC,KAAK,CAACC,OAAO,CAACZ,IAAI,CAACS,MAAM,CAACC,IAAI,CAAC,GAChCV,IAAI,CAACS,MAAM,CAACC,IAAI,CAAC,CAAC,CAAC,KAAKV,IAAI,GAC5BA,IAAI,CAACS,MAAM,CAACC,IAAI,KAAKV,IAAI;MACnC;MAEA,IAAIQ,UAAU,KAAK,aAAa,EAAE;QAC9B,OAAOT,kBAAkB,CAACC,IAAI,EAAE,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC;MAClD;MACA,IAAIQ,UAAU,KAAK,kBAAkB,EAAE;QACnC,OAAOT,kBAAkB,CAACC,IAAI,EAAE,CAAC,IAAI,CAAC,CAAC;MAC3C;MACA,IAAIQ,UAAU,KAAK,YAAY,EAAE;QAC7B,OAAOT,kBAAkB,CAACC,IAAI,EAAE,CAAC,GAAG,CAAC,CAAC;MAC1C;MACA,OAAOD,kBAAkB,CAACC,IAAI,EAAE,CAAC,GAAG,CAAC,CAAC;IAE1C;;IAEA;AACR;AACA;AACA;AACA;AACA;AACA;IACQ,SAASa,gBAAgBA,CAACb,IAAI,EAAEc,kBAAkB,EAAE;MAChD,MAAMC,QAAQ,GAAGlB,UAAU,CAACmB,iBAAiB,CAAChB,IAAI,CAAC;MACnD,IAAIiB,gBAAgB,GAAG,CAAC;MAExB,IAAI,CAACF,QAAQ,CAACG,MAAM,EAAE;QAClB,OAAOD,gBAAgB;MAC3B;MAEAF,QAAQ,CAACI,OAAO,CAACC,OAAO,IAAI;QACxBH,gBAAgB,EAAE;QAElB,IAAIG,OAAO,CAACrC,IAAI,KAAK,OAAO,EAAE;UAC1BkC,gBAAgB,IAAIG,OAAO,CAACC,GAAG,CAACC,GAAG,CAACC,IAAI,GAAGH,OAAO,CAACC,GAAG,CAACG,KAAK,CAACD,IAAI;QACrE;;QAEA;QACA,IAAIH,OAAO,CAACC,GAAG,CAACG,KAAK,CAACD,IAAI,KAAKT,kBAAkB,EAAE;UAC/CG,gBAAgB,EAAE;QACtB;QAEA,IAAIG,OAAO,CAACC,GAAG,CAACC,GAAG,CAACC,IAAI,KAAKvB,IAAI,CAACqB,GAAG,CAACG,KAAK,CAACD,IAAI,EAAE;UAC9CN,gBAAgB,EAAE;QACtB;MACJ,CAAC,CAAC;MAEF,OAAOA,gBAAgB;IAC3B;;IAEA;AACR;AACA;AACA;AACA;AACA;IACQ,SAASQ,0BAA0BA,CAACzB,IAAI,EAAE;MACtC,MAAME,WAAW,GAAGL,UAAU,CAACM,cAAc,CAACH,IAAI,CAAC;MACnD,IAAIc,kBAAkB;;MAEtB;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;MACY,IAAIZ,WAAW,EAAE;QACbY,kBAAkB,GAAGZ,WAAW,CAACmB,GAAG,CAACC,GAAG,CAACC,IAAI;MACjD,CAAC,MAAM;QACHT,kBAAkB,GAAG,CAAC,CAAC,CAAC;MAC5B;;MAEA,OAAOA,kBAAkB;IAC7B;;IAEA;AACR;AACA;AACA;AACA;AACA;IACQ,SAASY,gBAAgBA,CAAC1B,IAAI,EAAE;MAC5B,MAAM2B,WAAW,GAAG3B,IAAI,CAACqB,GAAG,CAACG,KAAK,CAACD,IAAI;MACvC,MAAMT,kBAAkB,GAAGW,0BAA0B,CAACzB,IAAI,CAAC;MAC3D,MAAM4B,YAAY,GAAGf,gBAAgB,CAACb,IAAI,EAAEc,kBAAkB,CAAC;MAE/D,OAAQa,WAAW,GAAGb,kBAAkB,GAAGc,YAAY,GAAI,CAAC;IAChE;;IAEA;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQ,SAASC,MAAMA,CAAC7B,IAAI,EAAE;MAClB,MAAM8B,eAAe,GAAGjC,UAAU,CAACmB,iBAAiB,CAAChB,IAAI,CAAC;MAC1D,MAAM+B,kBAAkB,GAAGD,eAAe,CAACA,eAAe,CAACZ,MAAM,GAAG,CAAC,CAAC;MACtE,MAAMhB,WAAW,GAAGL,UAAU,CAACM,cAAc,CAACH,IAAI,CAAC;MAEnD,IAAI8B,eAAe,CAACZ,MAAM,KAAK,CAAC,EAAE;QAC9B,OAAO,IAAI;MACf;;MAEA;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACY,IAAIa,kBAAkB,CAACV,GAAG,CAACC,GAAG,CAACC,IAAI,KAAKrB,WAAW,CAACmB,GAAG,CAACC,GAAG,CAACC,IAAI,IAC5DQ,kBAAkB,CAACV,GAAG,CAACC,GAAG,CAACC,IAAI,KAAKvB,IAAI,CAACqB,GAAG,CAACG,KAAK,CAACD,IAAI,EAAE;QACzD,OAAO,IAAI;MACf;MAEA,OAAO,KAAK;IAChB;;IAEA;IACA;IACA;;IAEA,OAAO;MACHS,eAAeA,CAAChC,IAAI,EAAE;QAClB,IAAI,CAACO,WAAW,CAACP,IAAI,CAAC,IAAI,CAAC0B,gBAAgB,CAAC1B,IAAI,CAAC,EAAE;UAC/CJ,OAAO,CAACqC,MAAM,CAAC;YACXjC,IAAI;YACJkC,SAAS,EAAE,UAAU;YACrBC,GAAGA,CAACC,KAAK,EAAE;cACP,IAAIP,MAAM,CAAC7B,IAAI,CAAC,EAAE;gBACd,MAAME,WAAW,GAAGL,UAAU,CAACM,cAAc,CAACH,IAAI,CAAC;gBACnD,MAAMqC,QAAQ,GAAGrC,IAAI,CAACqB,GAAG,CAACG,KAAK,CAACD,IAAI,KAAKrB,WAAW,CAACmB,GAAG,CAACC,GAAG,CAACC,IAAI,GAAG,MAAM,GAAG,IAAI;gBAEjF,OAAOa,KAAK,CAACE,gBAAgB,CAACtC,IAAI,EAAEqC,QAAQ,CAAC;cACjD;cACA,OAAO,IAAI;YACf;UACJ,CAAC,CAAC;QACN;MACJ;IACJ,CAAC;EACL;AACJ,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}