{"ast":null,"code":"/**\n * @fileoverview Rule to disallow `parseInt()` in favor of binary, octal, and hexadecimal literals\n * @author Annie Zhang, Henry Zhu\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst radixMap = new Map([[2, {\n  system: \"binary\",\n  literalPrefix: \"0b\"\n}], [8, {\n  system: \"octal\",\n  literalPrefix: \"0o\"\n}], [16, {\n  system: \"hexadecimal\",\n  literalPrefix: \"0x\"\n}]]);\n\n/**\n * Checks to see if a CallExpression's callee node is `parseInt` or\n * `Number.parseInt`.\n * @param {ASTNode} calleeNode The callee node to evaluate.\n * @returns {boolean} True if the callee is `parseInt` or `Number.parseInt`,\n * false otherwise.\n */\nfunction isParseInt(calleeNode) {\n  return astUtils.isSpecificId(calleeNode, \"parseInt\") || astUtils.isSpecificMemberAccess(calleeNode, \"Number\", \"parseInt\");\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow `parseInt()` and `Number.parseInt()` in favor of binary, octal, and hexadecimal literals\",\n      category: \"ECMAScript 6\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/prefer-numeric-literals\"\n    },\n    schema: [],\n    messages: {\n      useLiteral: \"Use {{system}} literals instead of {{functionName}}().\"\n    },\n    fixable: \"code\"\n  },\n  create(context) {\n    const sourceCode = context.getSourceCode();\n\n    //----------------------------------------------------------------------\n    // Public\n    //----------------------------------------------------------------------\n\n    return {\n      \"CallExpression[arguments.length=2]\"(node) {\n        const [strNode, radixNode] = node.arguments,\n          str = astUtils.getStaticStringValue(strNode),\n          radix = radixNode.value;\n        if (str !== null && astUtils.isStringLiteral(strNode) && radixNode.type === \"Literal\" && typeof radix === \"number\" && radixMap.has(radix) && isParseInt(node.callee)) {\n          const {\n            system,\n            literalPrefix\n          } = radixMap.get(radix);\n          context.report({\n            node,\n            messageId: \"useLiteral\",\n            data: {\n              system,\n              functionName: sourceCode.getText(node.callee)\n            },\n            fix(fixer) {\n              if (sourceCode.getCommentsInside(node).length) {\n                return null;\n              }\n              const replacement = `${literalPrefix}${str}`;\n              if (+replacement !== parseInt(str, radix)) {\n                /*\n                 * If the newly-produced literal would be invalid, (e.g. 0b1234),\n                 * or it would yield an incorrect parseInt result for some other reason, don't make a fix.\n                 *\n                 * If `str` had numeric separators, `+replacement` will evaluate to `NaN` because unary `+`\n                 * per the specification doesn't support numeric separators. Thus, the above condition will be `true`\n                 * (`NaN !== anything` is always `true`) regardless of the `parseInt(str, radix)` value.\n                 * Consequently, no autofixes will be made. This is correct behavior because `parseInt` also\n                 * doesn't support numeric separators, but it does parse part of the string before the first `_`,\n                 * so the autofix would be invalid:\n                 *\n                 *   parseInt(\"1_1\", 2) // === 1\n                 *   0b1_1 // === 3\n                 */\n                return null;\n              }\n              const tokenBefore = sourceCode.getTokenBefore(node),\n                tokenAfter = sourceCode.getTokenAfter(node);\n              let prefix = \"\",\n                suffix = \"\";\n              if (tokenBefore && tokenBefore.range[1] === node.range[0] && !astUtils.canTokensBeAdjacent(tokenBefore, replacement)) {\n                prefix = \" \";\n              }\n              if (tokenAfter && node.range[1] === tokenAfter.range[0] && !astUtils.canTokensBeAdjacent(replacement, tokenAfter)) {\n                suffix = \" \";\n              }\n              return fixer.replaceText(node, `${prefix}${replacement}${suffix}`);\n            }\n          });\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","radixMap","Map","system","literalPrefix","isParseInt","calleeNode","isSpecificId","isSpecificMemberAccess","module","exports","meta","type","docs","description","category","recommended","url","schema","messages","useLiteral","fixable","create","context","sourceCode","getSourceCode","CallExpression[arguments.length=2]","node","strNode","radixNode","arguments","str","getStaticStringValue","radix","value","isStringLiteral","has","callee","get","report","messageId","data","functionName","getText","fix","fixer","getCommentsInside","length","replacement","parseInt","tokenBefore","getTokenBefore","tokenAfter","getTokenAfter","prefix","suffix","range","canTokensBeAdjacent","replaceText"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/prefer-numeric-literals.js"],"sourcesContent":["/**\n * @fileoverview Rule to disallow `parseInt()` in favor of binary, octal, and hexadecimal literals\n * @author Annie Zhang, Henry Zhu\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst radixMap = new Map([\n    [2, { system: \"binary\", literalPrefix: \"0b\" }],\n    [8, { system: \"octal\", literalPrefix: \"0o\" }],\n    [16, { system: \"hexadecimal\", literalPrefix: \"0x\" }]\n]);\n\n/**\n * Checks to see if a CallExpression's callee node is `parseInt` or\n * `Number.parseInt`.\n * @param {ASTNode} calleeNode The callee node to evaluate.\n * @returns {boolean} True if the callee is `parseInt` or `Number.parseInt`,\n * false otherwise.\n */\nfunction isParseInt(calleeNode) {\n    return (\n        astUtils.isSpecificId(calleeNode, \"parseInt\") ||\n        astUtils.isSpecificMemberAccess(calleeNode, \"Number\", \"parseInt\")\n    );\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow `parseInt()` and `Number.parseInt()` in favor of binary, octal, and hexadecimal literals\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/prefer-numeric-literals\"\n        },\n\n        schema: [],\n\n        messages: {\n            useLiteral: \"Use {{system}} literals instead of {{functionName}}().\"\n        },\n\n        fixable: \"code\"\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        //----------------------------------------------------------------------\n        // Public\n        //----------------------------------------------------------------------\n\n        return {\n\n            \"CallExpression[arguments.length=2]\"(node) {\n                const [strNode, radixNode] = node.arguments,\n                    str = astUtils.getStaticStringValue(strNode),\n                    radix = radixNode.value;\n\n                if (\n                    str !== null &&\n                    astUtils.isStringLiteral(strNode) &&\n                    radixNode.type === \"Literal\" &&\n                    typeof radix === \"number\" &&\n                    radixMap.has(radix) &&\n                    isParseInt(node.callee)\n                ) {\n\n                    const { system, literalPrefix } = radixMap.get(radix);\n\n                    context.report({\n                        node,\n                        messageId: \"useLiteral\",\n                        data: {\n                            system,\n                            functionName: sourceCode.getText(node.callee)\n                        },\n                        fix(fixer) {\n                            if (sourceCode.getCommentsInside(node).length) {\n                                return null;\n                            }\n\n                            const replacement = `${literalPrefix}${str}`;\n\n                            if (+replacement !== parseInt(str, radix)) {\n\n                                /*\n                                 * If the newly-produced literal would be invalid, (e.g. 0b1234),\n                                 * or it would yield an incorrect parseInt result for some other reason, don't make a fix.\n                                 *\n                                 * If `str` had numeric separators, `+replacement` will evaluate to `NaN` because unary `+`\n                                 * per the specification doesn't support numeric separators. Thus, the above condition will be `true`\n                                 * (`NaN !== anything` is always `true`) regardless of the `parseInt(str, radix)` value.\n                                 * Consequently, no autofixes will be made. This is correct behavior because `parseInt` also\n                                 * doesn't support numeric separators, but it does parse part of the string before the first `_`,\n                                 * so the autofix would be invalid:\n                                 *\n                                 *   parseInt(\"1_1\", 2) // === 1\n                                 *   0b1_1 // === 3\n                                 */\n                                return null;\n                            }\n\n                            const tokenBefore = sourceCode.getTokenBefore(node),\n                                tokenAfter = sourceCode.getTokenAfter(node);\n                            let prefix = \"\",\n                                suffix = \"\";\n\n                            if (\n                                tokenBefore &&\n                                tokenBefore.range[1] === node.range[0] &&\n                                !astUtils.canTokensBeAdjacent(tokenBefore, replacement)\n                            ) {\n                                prefix = \" \";\n                            }\n\n                            if (\n                                tokenAfter &&\n                                node.range[1] === tokenAfter.range[0] &&\n                                !astUtils.canTokensBeAdjacent(replacement, tokenAfter)\n                            ) {\n                                suffix = \" \";\n                            }\n\n                            return fixer.replaceText(node, `${prefix}${replacement}${suffix}`);\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}