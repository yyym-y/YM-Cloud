{"ast":null,"code":"/**\n * @fileoverview Rule to require or disallow line breaks inside braces.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n// Schema objects.\nconst OPTION_VALUE = {\n  oneOf: [{\n    enum: [\"always\", \"never\"]\n  }, {\n    type: \"object\",\n    properties: {\n      multiline: {\n        type: \"boolean\"\n      },\n      minProperties: {\n        type: \"integer\",\n        minimum: 0\n      },\n      consistent: {\n        type: \"boolean\"\n      }\n    },\n    additionalProperties: false,\n    minProperties: 1\n  }]\n};\n\n/**\n * Normalizes a given option value.\n * @param {string|Object|undefined} value An option value to parse.\n * @returns {{multiline: boolean, minProperties: number, consistent: boolean}} Normalized option object.\n */\nfunction normalizeOptionValue(value) {\n  let multiline = false;\n  let minProperties = Number.POSITIVE_INFINITY;\n  let consistent = false;\n  if (value) {\n    if (value === \"always\") {\n      minProperties = 0;\n    } else if (value === \"never\") {\n      minProperties = Number.POSITIVE_INFINITY;\n    } else {\n      multiline = Boolean(value.multiline);\n      minProperties = value.minProperties || Number.POSITIVE_INFINITY;\n      consistent = Boolean(value.consistent);\n    }\n  } else {\n    consistent = true;\n  }\n  return {\n    multiline,\n    minProperties,\n    consistent\n  };\n}\n\n/**\n * Checks if a value is an object.\n * @param {any} value The value to check\n * @returns {boolean} `true` if the value is an object, otherwise `false`\n */\nfunction isObject(value) {\n  return typeof value === \"object\" && value !== null;\n}\n\n/**\n * Checks if an option is a node-specific option\n * @param {any} option The option to check\n * @returns {boolean} `true` if the option is node-specific, otherwise `false`\n */\nfunction isNodeSpecificOption(option) {\n  return isObject(option) || typeof option === \"string\";\n}\n\n/**\n * Normalizes a given option value.\n * @param {string|Object|undefined} options An option value to parse.\n * @returns {{\n *   ObjectExpression: {multiline: boolean, minProperties: number, consistent: boolean},\n *   ObjectPattern: {multiline: boolean, minProperties: number, consistent: boolean},\n *   ImportDeclaration: {multiline: boolean, minProperties: number, consistent: boolean},\n *   ExportNamedDeclaration : {multiline: boolean, minProperties: number, consistent: boolean}\n * }} Normalized option object.\n */\nfunction normalizeOptions(options) {\n  if (isObject(options) && Object.values(options).some(isNodeSpecificOption)) {\n    return {\n      ObjectExpression: normalizeOptionValue(options.ObjectExpression),\n      ObjectPattern: normalizeOptionValue(options.ObjectPattern),\n      ImportDeclaration: normalizeOptionValue(options.ImportDeclaration),\n      ExportNamedDeclaration: normalizeOptionValue(options.ExportDeclaration)\n    };\n  }\n  const value = normalizeOptionValue(options);\n  return {\n    ObjectExpression: value,\n    ObjectPattern: value,\n    ImportDeclaration: value,\n    ExportNamedDeclaration: value\n  };\n}\n\n/**\n * Determines if ObjectExpression, ObjectPattern, ImportDeclaration or ExportNamedDeclaration\n * node needs to be checked for missing line breaks\n * @param {ASTNode} node Node under inspection\n * @param {Object} options option specific to node type\n * @param {Token} first First object property\n * @param {Token} last Last object property\n * @returns {boolean} `true` if node needs to be checked for missing line breaks\n */\nfunction areLineBreaksRequired(node, options, first, last) {\n  let objectProperties;\n  if (node.type === \"ObjectExpression\" || node.type === \"ObjectPattern\") {\n    objectProperties = node.properties;\n  } else {\n    // is ImportDeclaration or ExportNamedDeclaration\n    objectProperties = node.specifiers.filter(s => s.type === \"ImportSpecifier\" || s.type === \"ExportSpecifier\");\n  }\n  return objectProperties.length >= options.minProperties || options.multiline && objectProperties.length > 0 && first.loc.start.line !== last.loc.end.line;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce consistent line breaks after opening and before closing braces\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/object-curly-newline\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      oneOf: [OPTION_VALUE, {\n        type: \"object\",\n        properties: {\n          ObjectExpression: OPTION_VALUE,\n          ObjectPattern: OPTION_VALUE,\n          ImportDeclaration: OPTION_VALUE,\n          ExportDeclaration: OPTION_VALUE\n        },\n        additionalProperties: false,\n        minProperties: 1\n      }]\n    }],\n    messages: {\n      unexpectedLinebreakBeforeClosingBrace: \"Unexpected line break before this closing brace.\",\n      unexpectedLinebreakAfterOpeningBrace: \"Unexpected line break after this opening brace.\",\n      expectedLinebreakBeforeClosingBrace: \"Expected a line break before this closing brace.\",\n      expectedLinebreakAfterOpeningBrace: \"Expected a line break after this opening brace.\"\n    }\n  },\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const normalizedOptions = normalizeOptions(context.options[0]);\n\n    /**\n     * Reports a given node if it violated this rule.\n     * @param {ASTNode} node A node to check. This is an ObjectExpression, ObjectPattern, ImportDeclaration or ExportNamedDeclaration node.\n     * @returns {void}\n     */\n    function check(node) {\n      const options = normalizedOptions[node.type];\n      if (node.type === \"ImportDeclaration\" && !node.specifiers.some(specifier => specifier.type === \"ImportSpecifier\") || node.type === \"ExportNamedDeclaration\" && !node.specifiers.some(specifier => specifier.type === \"ExportSpecifier\")) {\n        return;\n      }\n      const openBrace = sourceCode.getFirstToken(node, token => token.value === \"{\");\n      let closeBrace;\n      if (node.typeAnnotation) {\n        closeBrace = sourceCode.getTokenBefore(node.typeAnnotation);\n      } else {\n        closeBrace = sourceCode.getLastToken(node, token => token.value === \"}\");\n      }\n      let first = sourceCode.getTokenAfter(openBrace, {\n        includeComments: true\n      });\n      let last = sourceCode.getTokenBefore(closeBrace, {\n        includeComments: true\n      });\n      const needsLineBreaks = areLineBreaksRequired(node, options, first, last);\n      const hasCommentsFirstToken = astUtils.isCommentToken(first);\n      const hasCommentsLastToken = astUtils.isCommentToken(last);\n\n      /*\n       * Use tokens or comments to check multiline or not.\n       * But use only tokens to check whether line breaks are needed.\n       * This allows:\n       *     var obj = { // eslint-disable-line foo\n       *         a: 1\n       *     }\n       */\n      first = sourceCode.getTokenAfter(openBrace);\n      last = sourceCode.getTokenBefore(closeBrace);\n      if (needsLineBreaks) {\n        if (astUtils.isTokenOnSameLine(openBrace, first)) {\n          context.report({\n            messageId: \"expectedLinebreakAfterOpeningBrace\",\n            node,\n            loc: openBrace.loc,\n            fix(fixer) {\n              if (hasCommentsFirstToken) {\n                return null;\n              }\n              return fixer.insertTextAfter(openBrace, \"\\n\");\n            }\n          });\n        }\n        if (astUtils.isTokenOnSameLine(last, closeBrace)) {\n          context.report({\n            messageId: \"expectedLinebreakBeforeClosingBrace\",\n            node,\n            loc: closeBrace.loc,\n            fix(fixer) {\n              if (hasCommentsLastToken) {\n                return null;\n              }\n              return fixer.insertTextBefore(closeBrace, \"\\n\");\n            }\n          });\n        }\n      } else {\n        const consistent = options.consistent;\n        const hasLineBreakBetweenOpenBraceAndFirst = !astUtils.isTokenOnSameLine(openBrace, first);\n        const hasLineBreakBetweenCloseBraceAndLast = !astUtils.isTokenOnSameLine(last, closeBrace);\n        if (!consistent && hasLineBreakBetweenOpenBraceAndFirst || consistent && hasLineBreakBetweenOpenBraceAndFirst && !hasLineBreakBetweenCloseBraceAndLast) {\n          context.report({\n            messageId: \"unexpectedLinebreakAfterOpeningBrace\",\n            node,\n            loc: openBrace.loc,\n            fix(fixer) {\n              if (hasCommentsFirstToken) {\n                return null;\n              }\n              return fixer.removeRange([openBrace.range[1], first.range[0]]);\n            }\n          });\n        }\n        if (!consistent && hasLineBreakBetweenCloseBraceAndLast || consistent && !hasLineBreakBetweenOpenBraceAndFirst && hasLineBreakBetweenCloseBraceAndLast) {\n          context.report({\n            messageId: \"unexpectedLinebreakBeforeClosingBrace\",\n            node,\n            loc: closeBrace.loc,\n            fix(fixer) {\n              if (hasCommentsLastToken) {\n                return null;\n              }\n              return fixer.removeRange([last.range[1], closeBrace.range[0]]);\n            }\n          });\n        }\n      }\n    }\n    return {\n      ObjectExpression: check,\n      ObjectPattern: check,\n      ImportDeclaration: check,\n      ExportNamedDeclaration: check\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","OPTION_VALUE","oneOf","enum","type","properties","multiline","minProperties","minimum","consistent","additionalProperties","normalizeOptionValue","value","Number","POSITIVE_INFINITY","Boolean","isObject","isNodeSpecificOption","option","normalizeOptions","options","Object","values","some","ObjectExpression","ObjectPattern","ImportDeclaration","ExportNamedDeclaration","ExportDeclaration","areLineBreaksRequired","node","first","last","objectProperties","specifiers","filter","s","length","loc","start","line","end","module","exports","meta","docs","description","category","recommended","url","fixable","schema","messages","unexpectedLinebreakBeforeClosingBrace","unexpectedLinebreakAfterOpeningBrace","expectedLinebreakBeforeClosingBrace","expectedLinebreakAfterOpeningBrace","create","context","sourceCode","getSourceCode","normalizedOptions","check","specifier","openBrace","getFirstToken","token","closeBrace","typeAnnotation","getTokenBefore","getLastToken","getTokenAfter","includeComments","needsLineBreaks","hasCommentsFirstToken","isCommentToken","hasCommentsLastToken","isTokenOnSameLine","report","messageId","fix","fixer","insertTextAfter","insertTextBefore","hasLineBreakBetweenOpenBraceAndFirst","hasLineBreakBetweenCloseBraceAndLast","removeRange","range"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/object-curly-newline.js"],"sourcesContent":["/**\n * @fileoverview Rule to require or disallow line breaks inside braces.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n// Schema objects.\nconst OPTION_VALUE = {\n    oneOf: [\n        {\n            enum: [\"always\", \"never\"]\n        },\n        {\n            type: \"object\",\n            properties: {\n                multiline: {\n                    type: \"boolean\"\n                },\n                minProperties: {\n                    type: \"integer\",\n                    minimum: 0\n                },\n                consistent: {\n                    type: \"boolean\"\n                }\n            },\n            additionalProperties: false,\n            minProperties: 1\n        }\n    ]\n};\n\n/**\n * Normalizes a given option value.\n * @param {string|Object|undefined} value An option value to parse.\n * @returns {{multiline: boolean, minProperties: number, consistent: boolean}} Normalized option object.\n */\nfunction normalizeOptionValue(value) {\n    let multiline = false;\n    let minProperties = Number.POSITIVE_INFINITY;\n    let consistent = false;\n\n    if (value) {\n        if (value === \"always\") {\n            minProperties = 0;\n        } else if (value === \"never\") {\n            minProperties = Number.POSITIVE_INFINITY;\n        } else {\n            multiline = Boolean(value.multiline);\n            minProperties = value.minProperties || Number.POSITIVE_INFINITY;\n            consistent = Boolean(value.consistent);\n        }\n    } else {\n        consistent = true;\n    }\n\n    return { multiline, minProperties, consistent };\n}\n\n/**\n * Checks if a value is an object.\n * @param {any} value The value to check\n * @returns {boolean} `true` if the value is an object, otherwise `false`\n */\nfunction isObject(value) {\n    return typeof value === \"object\" && value !== null;\n}\n\n/**\n * Checks if an option is a node-specific option\n * @param {any} option The option to check\n * @returns {boolean} `true` if the option is node-specific, otherwise `false`\n */\nfunction isNodeSpecificOption(option) {\n    return isObject(option) || typeof option === \"string\";\n}\n\n/**\n * Normalizes a given option value.\n * @param {string|Object|undefined} options An option value to parse.\n * @returns {{\n *   ObjectExpression: {multiline: boolean, minProperties: number, consistent: boolean},\n *   ObjectPattern: {multiline: boolean, minProperties: number, consistent: boolean},\n *   ImportDeclaration: {multiline: boolean, minProperties: number, consistent: boolean},\n *   ExportNamedDeclaration : {multiline: boolean, minProperties: number, consistent: boolean}\n * }} Normalized option object.\n */\nfunction normalizeOptions(options) {\n    if (isObject(options) && Object.values(options).some(isNodeSpecificOption)) {\n        return {\n            ObjectExpression: normalizeOptionValue(options.ObjectExpression),\n            ObjectPattern: normalizeOptionValue(options.ObjectPattern),\n            ImportDeclaration: normalizeOptionValue(options.ImportDeclaration),\n            ExportNamedDeclaration: normalizeOptionValue(options.ExportDeclaration)\n        };\n    }\n\n    const value = normalizeOptionValue(options);\n\n    return { ObjectExpression: value, ObjectPattern: value, ImportDeclaration: value, ExportNamedDeclaration: value };\n}\n\n/**\n * Determines if ObjectExpression, ObjectPattern, ImportDeclaration or ExportNamedDeclaration\n * node needs to be checked for missing line breaks\n * @param {ASTNode} node Node under inspection\n * @param {Object} options option specific to node type\n * @param {Token} first First object property\n * @param {Token} last Last object property\n * @returns {boolean} `true` if node needs to be checked for missing line breaks\n */\nfunction areLineBreaksRequired(node, options, first, last) {\n    let objectProperties;\n\n    if (node.type === \"ObjectExpression\" || node.type === \"ObjectPattern\") {\n        objectProperties = node.properties;\n    } else {\n\n        // is ImportDeclaration or ExportNamedDeclaration\n        objectProperties = node.specifiers\n            .filter(s => s.type === \"ImportSpecifier\" || s.type === \"ExportSpecifier\");\n    }\n\n    return objectProperties.length >= options.minProperties ||\n        (\n            options.multiline &&\n            objectProperties.length > 0 &&\n            first.loc.start.line !== last.loc.end.line\n        );\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce consistent line breaks after opening and before closing braces\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/object-curly-newline\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                oneOf: [\n                    OPTION_VALUE,\n                    {\n                        type: \"object\",\n                        properties: {\n                            ObjectExpression: OPTION_VALUE,\n                            ObjectPattern: OPTION_VALUE,\n                            ImportDeclaration: OPTION_VALUE,\n                            ExportDeclaration: OPTION_VALUE\n                        },\n                        additionalProperties: false,\n                        minProperties: 1\n                    }\n                ]\n            }\n        ],\n\n        messages: {\n            unexpectedLinebreakBeforeClosingBrace: \"Unexpected line break before this closing brace.\",\n            unexpectedLinebreakAfterOpeningBrace: \"Unexpected line break after this opening brace.\",\n            expectedLinebreakBeforeClosingBrace: \"Expected a line break before this closing brace.\",\n            expectedLinebreakAfterOpeningBrace: \"Expected a line break after this opening brace.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const normalizedOptions = normalizeOptions(context.options[0]);\n\n        /**\n         * Reports a given node if it violated this rule.\n         * @param {ASTNode} node A node to check. This is an ObjectExpression, ObjectPattern, ImportDeclaration or ExportNamedDeclaration node.\n         * @returns {void}\n         */\n        function check(node) {\n            const options = normalizedOptions[node.type];\n\n            if (\n                (node.type === \"ImportDeclaration\" &&\n                    !node.specifiers.some(specifier => specifier.type === \"ImportSpecifier\")) ||\n                (node.type === \"ExportNamedDeclaration\" &&\n                    !node.specifiers.some(specifier => specifier.type === \"ExportSpecifier\"))\n            ) {\n                return;\n            }\n\n            const openBrace = sourceCode.getFirstToken(node, token => token.value === \"{\");\n\n            let closeBrace;\n\n            if (node.typeAnnotation) {\n                closeBrace = sourceCode.getTokenBefore(node.typeAnnotation);\n            } else {\n                closeBrace = sourceCode.getLastToken(node, token => token.value === \"}\");\n            }\n\n            let first = sourceCode.getTokenAfter(openBrace, { includeComments: true });\n            let last = sourceCode.getTokenBefore(closeBrace, { includeComments: true });\n\n            const needsLineBreaks = areLineBreaksRequired(node, options, first, last);\n\n            const hasCommentsFirstToken = astUtils.isCommentToken(first);\n            const hasCommentsLastToken = astUtils.isCommentToken(last);\n\n            /*\n             * Use tokens or comments to check multiline or not.\n             * But use only tokens to check whether line breaks are needed.\n             * This allows:\n             *     var obj = { // eslint-disable-line foo\n             *         a: 1\n             *     }\n             */\n            first = sourceCode.getTokenAfter(openBrace);\n            last = sourceCode.getTokenBefore(closeBrace);\n\n            if (needsLineBreaks) {\n                if (astUtils.isTokenOnSameLine(openBrace, first)) {\n                    context.report({\n                        messageId: \"expectedLinebreakAfterOpeningBrace\",\n                        node,\n                        loc: openBrace.loc,\n                        fix(fixer) {\n                            if (hasCommentsFirstToken) {\n                                return null;\n                            }\n\n                            return fixer.insertTextAfter(openBrace, \"\\n\");\n                        }\n                    });\n                }\n                if (astUtils.isTokenOnSameLine(last, closeBrace)) {\n                    context.report({\n                        messageId: \"expectedLinebreakBeforeClosingBrace\",\n                        node,\n                        loc: closeBrace.loc,\n                        fix(fixer) {\n                            if (hasCommentsLastToken) {\n                                return null;\n                            }\n\n                            return fixer.insertTextBefore(closeBrace, \"\\n\");\n                        }\n                    });\n                }\n            } else {\n                const consistent = options.consistent;\n                const hasLineBreakBetweenOpenBraceAndFirst = !astUtils.isTokenOnSameLine(openBrace, first);\n                const hasLineBreakBetweenCloseBraceAndLast = !astUtils.isTokenOnSameLine(last, closeBrace);\n\n                if (\n                    (!consistent && hasLineBreakBetweenOpenBraceAndFirst) ||\n                    (consistent && hasLineBreakBetweenOpenBraceAndFirst && !hasLineBreakBetweenCloseBraceAndLast)\n                ) {\n                    context.report({\n                        messageId: \"unexpectedLinebreakAfterOpeningBrace\",\n                        node,\n                        loc: openBrace.loc,\n                        fix(fixer) {\n                            if (hasCommentsFirstToken) {\n                                return null;\n                            }\n\n                            return fixer.removeRange([\n                                openBrace.range[1],\n                                first.range[0]\n                            ]);\n                        }\n                    });\n                }\n                if (\n                    (!consistent && hasLineBreakBetweenCloseBraceAndLast) ||\n                    (consistent && !hasLineBreakBetweenOpenBraceAndFirst && hasLineBreakBetweenCloseBraceAndLast)\n                ) {\n                    context.report({\n                        messageId: \"unexpectedLinebreakBeforeClosingBrace\",\n                        node,\n                        loc: closeBrace.loc,\n                        fix(fixer) {\n                            if (hasCommentsLastToken) {\n                                return null;\n                            }\n\n                            return fixer.removeRange([\n                                last.range[1],\n                                closeBrace.range[0]\n                            ]);\n                        }\n                    });\n                }\n            }\n        }\n\n        return {\n            ObjectExpression: check,\n            ObjectPattern: check,\n            ImportDeclaration: check,\n            ExportNamedDeclaration: check\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}