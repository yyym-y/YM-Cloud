{"ast":null,"code":"/**\n * @fileoverview Rule to specify spacing of object literal keys and values\n * @author Brandon Mills\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nrequire(\"core-js/modules/es.array.push.js\");\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether a string contains a line terminator as defined in\n * http://www.ecma-international.org/ecma-262/5.1/#sec-7.3\n * @param {string} str String to test.\n * @returns {boolean} True if str contains a line terminator.\n */\nfunction containsLineTerminator(str) {\n  return astUtils.LINEBREAK_MATCHER.test(str);\n}\n\n/**\n * Gets the last element of an array.\n * @param {Array} arr An array.\n * @returns {any} Last element of arr.\n */\nfunction last(arr) {\n  return arr[arr.length - 1];\n}\n\n/**\n * Checks whether a node is contained on a single line.\n * @param {ASTNode} node AST Node being evaluated.\n * @returns {boolean} True if the node is a single line.\n */\nfunction isSingleLine(node) {\n  return node.loc.end.line === node.loc.start.line;\n}\n\n/**\n * Checks whether the properties on a single line.\n * @param {ASTNode[]} properties List of Property AST nodes.\n * @returns {boolean} True if all properties is on a single line.\n */\nfunction isSingleLineProperties(properties) {\n  const [firstProp] = properties,\n    lastProp = last(properties);\n  return firstProp.loc.start.line === lastProp.loc.end.line;\n}\n\n/**\n * Initializes a single option property from the configuration with defaults for undefined values\n * @param {Object} toOptions Object to be initialized\n * @param {Object} fromOptions Object to be initialized from\n * @returns {Object} The object with correctly initialized options and values\n */\nfunction initOptionProperty(toOptions, fromOptions) {\n  toOptions.mode = fromOptions.mode || \"strict\";\n\n  // Set value of beforeColon\n  if (typeof fromOptions.beforeColon !== \"undefined\") {\n    toOptions.beforeColon = +fromOptions.beforeColon;\n  } else {\n    toOptions.beforeColon = 0;\n  }\n\n  // Set value of afterColon\n  if (typeof fromOptions.afterColon !== \"undefined\") {\n    toOptions.afterColon = +fromOptions.afterColon;\n  } else {\n    toOptions.afterColon = 1;\n  }\n\n  // Set align if exists\n  if (typeof fromOptions.align !== \"undefined\") {\n    if (typeof fromOptions.align === \"object\") {\n      toOptions.align = fromOptions.align;\n    } else {\n      // \"string\"\n      toOptions.align = {\n        on: fromOptions.align,\n        mode: toOptions.mode,\n        beforeColon: toOptions.beforeColon,\n        afterColon: toOptions.afterColon\n      };\n    }\n  }\n  return toOptions;\n}\n\n/**\n * Initializes all the option values (singleLine, multiLine and align) from the configuration with defaults for undefined values\n * @param {Object} toOptions Object to be initialized\n * @param {Object} fromOptions Object to be initialized from\n * @returns {Object} The object with correctly initialized options and values\n */\nfunction initOptions(toOptions, fromOptions) {\n  if (typeof fromOptions.align === \"object\") {\n    // Initialize the alignment configuration\n    toOptions.align = initOptionProperty({}, fromOptions.align);\n    toOptions.align.on = fromOptions.align.on || \"colon\";\n    toOptions.align.mode = fromOptions.align.mode || \"strict\";\n    toOptions.multiLine = initOptionProperty({}, fromOptions.multiLine || fromOptions);\n    toOptions.singleLine = initOptionProperty({}, fromOptions.singleLine || fromOptions);\n  } else {\n    // string or undefined\n    toOptions.multiLine = initOptionProperty({}, fromOptions.multiLine || fromOptions);\n    toOptions.singleLine = initOptionProperty({}, fromOptions.singleLine || fromOptions);\n\n    // If alignment options are defined in multiLine, pull them out into the general align configuration\n    if (toOptions.multiLine.align) {\n      toOptions.align = {\n        on: toOptions.multiLine.align.on,\n        mode: toOptions.multiLine.align.mode || toOptions.multiLine.mode,\n        beforeColon: toOptions.multiLine.align.beforeColon,\n        afterColon: toOptions.multiLine.align.afterColon\n      };\n    }\n  }\n  return toOptions;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce consistent spacing between keys and values in object literal properties\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/key-spacing\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      anyOf: [{\n        type: \"object\",\n        properties: {\n          align: {\n            anyOf: [{\n              enum: [\"colon\", \"value\"]\n            }, {\n              type: \"object\",\n              properties: {\n                mode: {\n                  enum: [\"strict\", \"minimum\"]\n                },\n                on: {\n                  enum: [\"colon\", \"value\"]\n                },\n                beforeColon: {\n                  type: \"boolean\"\n                },\n                afterColon: {\n                  type: \"boolean\"\n                }\n              },\n              additionalProperties: false\n            }]\n          },\n          mode: {\n            enum: [\"strict\", \"minimum\"]\n          },\n          beforeColon: {\n            type: \"boolean\"\n          },\n          afterColon: {\n            type: \"boolean\"\n          }\n        },\n        additionalProperties: false\n      }, {\n        type: \"object\",\n        properties: {\n          singleLine: {\n            type: \"object\",\n            properties: {\n              mode: {\n                enum: [\"strict\", \"minimum\"]\n              },\n              beforeColon: {\n                type: \"boolean\"\n              },\n              afterColon: {\n                type: \"boolean\"\n              }\n            },\n            additionalProperties: false\n          },\n          multiLine: {\n            type: \"object\",\n            properties: {\n              align: {\n                anyOf: [{\n                  enum: [\"colon\", \"value\"]\n                }, {\n                  type: \"object\",\n                  properties: {\n                    mode: {\n                      enum: [\"strict\", \"minimum\"]\n                    },\n                    on: {\n                      enum: [\"colon\", \"value\"]\n                    },\n                    beforeColon: {\n                      type: \"boolean\"\n                    },\n                    afterColon: {\n                      type: \"boolean\"\n                    }\n                  },\n                  additionalProperties: false\n                }]\n              },\n              mode: {\n                enum: [\"strict\", \"minimum\"]\n              },\n              beforeColon: {\n                type: \"boolean\"\n              },\n              afterColon: {\n                type: \"boolean\"\n              }\n            },\n            additionalProperties: false\n          }\n        },\n        additionalProperties: false\n      }, {\n        type: \"object\",\n        properties: {\n          singleLine: {\n            type: \"object\",\n            properties: {\n              mode: {\n                enum: [\"strict\", \"minimum\"]\n              },\n              beforeColon: {\n                type: \"boolean\"\n              },\n              afterColon: {\n                type: \"boolean\"\n              }\n            },\n            additionalProperties: false\n          },\n          multiLine: {\n            type: \"object\",\n            properties: {\n              mode: {\n                enum: [\"strict\", \"minimum\"]\n              },\n              beforeColon: {\n                type: \"boolean\"\n              },\n              afterColon: {\n                type: \"boolean\"\n              }\n            },\n            additionalProperties: false\n          },\n          align: {\n            type: \"object\",\n            properties: {\n              mode: {\n                enum: [\"strict\", \"minimum\"]\n              },\n              on: {\n                enum: [\"colon\", \"value\"]\n              },\n              beforeColon: {\n                type: \"boolean\"\n              },\n              afterColon: {\n                type: \"boolean\"\n              }\n            },\n            additionalProperties: false\n          }\n        },\n        additionalProperties: false\n      }]\n    }],\n    messages: {\n      extraKey: \"Extra space after {{computed}}key '{{key}}'.\",\n      extraValue: \"Extra space before value for {{computed}}key '{{key}}'.\",\n      missingKey: \"Missing space after {{computed}}key '{{key}}'.\",\n      missingValue: \"Missing space before value for {{computed}}key '{{key}}'.\"\n    }\n  },\n  create(context) {\n    /**\n     * OPTIONS\n     * \"key-spacing\": [2, {\n     *     beforeColon: false,\n     *     afterColon: true,\n     *     align: \"colon\" // Optional, or \"value\"\n     * }\n     */\n    const options = context.options[0] || {},\n      ruleOptions = initOptions({}, options),\n      multiLineOptions = ruleOptions.multiLine,\n      singleLineOptions = ruleOptions.singleLine,\n      alignmentOptions = ruleOptions.align || null;\n    const sourceCode = context.getSourceCode();\n\n    /**\n     * Checks whether a property is a member of the property group it follows.\n     * @param {ASTNode} lastMember The last Property known to be in the group.\n     * @param {ASTNode} candidate The next Property that might be in the group.\n     * @returns {boolean} True if the candidate property is part of the group.\n     */\n    function continuesPropertyGroup(lastMember, candidate) {\n      const groupEndLine = lastMember.loc.start.line,\n        candidateStartLine = candidate.loc.start.line;\n      if (candidateStartLine - groupEndLine <= 1) {\n        return true;\n      }\n\n      /*\n       * Check that the first comment is adjacent to the end of the group, the\n       * last comment is adjacent to the candidate property, and that successive\n       * comments are adjacent to each other.\n       */\n      const leadingComments = sourceCode.getCommentsBefore(candidate);\n      if (leadingComments.length && leadingComments[0].loc.start.line - groupEndLine <= 1 && candidateStartLine - last(leadingComments).loc.end.line <= 1) {\n        for (let i = 1; i < leadingComments.length; i++) {\n          if (leadingComments[i].loc.start.line - leadingComments[i - 1].loc.end.line > 1) {\n            return false;\n          }\n        }\n        return true;\n      }\n      return false;\n    }\n\n    /**\n     * Determines if the given property is key-value property.\n     * @param {ASTNode} property Property node to check.\n     * @returns {boolean} Whether the property is a key-value property.\n     */\n    function isKeyValueProperty(property) {\n      return !(property.method || property.shorthand || property.kind !== \"init\" || property.type !== \"Property\" // Could be \"ExperimentalSpreadProperty\" or \"SpreadElement\"\n      );\n    }\n\n    /**\n     * Starting from the given a node (a property.key node here) looks forward\n     * until it finds the last token before a colon punctuator and returns it.\n     * @param {ASTNode} node The node to start looking from.\n     * @returns {ASTNode} The last token before a colon punctuator.\n     */\n    function getLastTokenBeforeColon(node) {\n      const colonToken = sourceCode.getTokenAfter(node, astUtils.isColonToken);\n      return sourceCode.getTokenBefore(colonToken);\n    }\n\n    /**\n     * Starting from the given a node (a property.key node here) looks forward\n     * until it finds the colon punctuator and returns it.\n     * @param {ASTNode} node The node to start looking from.\n     * @returns {ASTNode} The colon punctuator.\n     */\n    function getNextColon(node) {\n      return sourceCode.getTokenAfter(node, astUtils.isColonToken);\n    }\n\n    /**\n     * Gets an object literal property's key as the identifier name or string value.\n     * @param {ASTNode} property Property node whose key to retrieve.\n     * @returns {string} The property's key.\n     */\n    function getKey(property) {\n      const key = property.key;\n      if (property.computed) {\n        return sourceCode.getText().slice(key.range[0], key.range[1]);\n      }\n      return astUtils.getStaticPropertyName(property);\n    }\n\n    /**\n     * Reports an appropriately-formatted error if spacing is incorrect on one\n     * side of the colon.\n     * @param {ASTNode} property Key-value pair in an object literal.\n     * @param {string} side Side being verified - either \"key\" or \"value\".\n     * @param {string} whitespace Actual whitespace string.\n     * @param {int} expected Expected whitespace length.\n     * @param {string} mode Value of the mode as \"strict\" or \"minimum\"\n     * @returns {void}\n     */\n    function report(property, side, whitespace, expected, mode) {\n      const diff = whitespace.length - expected,\n        nextColon = getNextColon(property.key),\n        tokenBeforeColon = sourceCode.getTokenBefore(nextColon, {\n          includeComments: true\n        }),\n        tokenAfterColon = sourceCode.getTokenAfter(nextColon, {\n          includeComments: true\n        }),\n        isKeySide = side === \"key\",\n        isExtra = diff > 0,\n        diffAbs = Math.abs(diff),\n        spaces = Array(diffAbs + 1).join(\" \");\n      const locStart = isKeySide ? tokenBeforeColon.loc.end : nextColon.loc.start;\n      const locEnd = isKeySide ? nextColon.loc.start : tokenAfterColon.loc.start;\n      const missingLoc = isKeySide ? tokenBeforeColon.loc : tokenAfterColon.loc;\n      const loc = isExtra ? {\n        start: locStart,\n        end: locEnd\n      } : missingLoc;\n      if ((diff && mode === \"strict\" || diff < 0 && mode === \"minimum\" || diff > 0 && !expected && mode === \"minimum\") && !(expected && containsLineTerminator(whitespace))) {\n        let fix;\n        if (isExtra) {\n          let range;\n\n          // Remove whitespace\n          if (isKeySide) {\n            range = [tokenBeforeColon.range[1], tokenBeforeColon.range[1] + diffAbs];\n          } else {\n            range = [tokenAfterColon.range[0] - diffAbs, tokenAfterColon.range[0]];\n          }\n          fix = function (fixer) {\n            return fixer.removeRange(range);\n          };\n        } else {\n          // Add whitespace\n          if (isKeySide) {\n            fix = function (fixer) {\n              return fixer.insertTextAfter(tokenBeforeColon, spaces);\n            };\n          } else {\n            fix = function (fixer) {\n              return fixer.insertTextBefore(tokenAfterColon, spaces);\n            };\n          }\n        }\n        let messageId = \"\";\n        if (isExtra) {\n          messageId = side === \"key\" ? \"extraKey\" : \"extraValue\";\n        } else {\n          messageId = side === \"key\" ? \"missingKey\" : \"missingValue\";\n        }\n        context.report({\n          node: property[side],\n          loc,\n          messageId,\n          data: {\n            computed: property.computed ? \"computed \" : \"\",\n            key: getKey(property)\n          },\n          fix\n        });\n      }\n    }\n\n    /**\n     * Gets the number of characters in a key, including quotes around string\n     * keys and braces around computed property keys.\n     * @param {ASTNode} property Property of on object literal.\n     * @returns {int} Width of the key.\n     */\n    function getKeyWidth(property) {\n      const startToken = sourceCode.getFirstToken(property);\n      const endToken = getLastTokenBeforeColon(property.key);\n      return endToken.range[1] - startToken.range[0];\n    }\n\n    /**\n     * Gets the whitespace around the colon in an object literal property.\n     * @param {ASTNode} property Property node from an object literal.\n     * @returns {Object} Whitespace before and after the property's colon.\n     */\n    function getPropertyWhitespace(property) {\n      const whitespace = /(\\s*):(\\s*)/u.exec(sourceCode.getText().slice(property.key.range[1], property.value.range[0]));\n      if (whitespace) {\n        return {\n          beforeColon: whitespace[1],\n          afterColon: whitespace[2]\n        };\n      }\n      return null;\n    }\n\n    /**\n     * Creates groups of properties.\n     * @param  {ASTNode} node ObjectExpression node being evaluated.\n     * @returns {Array.<ASTNode[]>} Groups of property AST node lists.\n     */\n    function createGroups(node) {\n      if (node.properties.length === 1) {\n        return [node.properties];\n      }\n      return node.properties.reduce((groups, property) => {\n        const currentGroup = last(groups),\n          prev = last(currentGroup);\n        if (!prev || continuesPropertyGroup(prev, property)) {\n          currentGroup.push(property);\n        } else {\n          groups.push([property]);\n        }\n        return groups;\n      }, [[]]);\n    }\n\n    /**\n     * Verifies correct vertical alignment of a group of properties.\n     * @param {ASTNode[]} properties List of Property AST nodes.\n     * @returns {void}\n     */\n    function verifyGroupAlignment(properties) {\n      const length = properties.length,\n        widths = properties.map(getKeyWidth),\n        // Width of keys, including quotes\n        align = alignmentOptions.on; // \"value\" or \"colon\"\n      let targetWidth = Math.max(...widths),\n        beforeColon,\n        afterColon,\n        mode;\n      if (alignmentOptions && length > 1) {\n        // When aligning values within a group, use the alignment configuration.\n        beforeColon = alignmentOptions.beforeColon;\n        afterColon = alignmentOptions.afterColon;\n        mode = alignmentOptions.mode;\n      } else {\n        beforeColon = multiLineOptions.beforeColon;\n        afterColon = multiLineOptions.afterColon;\n        mode = alignmentOptions.mode;\n      }\n\n      // Conditionally include one space before or after colon\n      targetWidth += align === \"colon\" ? beforeColon : afterColon;\n      for (let i = 0; i < length; i++) {\n        const property = properties[i];\n        const whitespace = getPropertyWhitespace(property);\n        if (whitespace) {\n          // Object literal getters/setters lack a colon\n          const width = widths[i];\n          if (align === \"value\") {\n            report(property, \"key\", whitespace.beforeColon, beforeColon, mode);\n            report(property, \"value\", whitespace.afterColon, targetWidth - width, mode);\n          } else {\n            // align = \"colon\"\n            report(property, \"key\", whitespace.beforeColon, targetWidth - width, mode);\n            report(property, \"value\", whitespace.afterColon, afterColon, mode);\n          }\n        }\n      }\n    }\n\n    /**\n     * Verifies spacing of property conforms to specified options.\n     * @param  {ASTNode} node Property node being evaluated.\n     * @param {Object} lineOptions Configured singleLine or multiLine options\n     * @returns {void}\n     */\n    function verifySpacing(node, lineOptions) {\n      const actual = getPropertyWhitespace(node);\n      if (actual) {\n        // Object literal getters/setters lack colons\n        report(node, \"key\", actual.beforeColon, lineOptions.beforeColon, lineOptions.mode);\n        report(node, \"value\", actual.afterColon, lineOptions.afterColon, lineOptions.mode);\n      }\n    }\n\n    /**\n     * Verifies spacing of each property in a list.\n     * @param {ASTNode[]} properties List of Property AST nodes.\n     * @param {Object} lineOptions Configured singleLine or multiLine options\n     * @returns {void}\n     */\n    function verifyListSpacing(properties, lineOptions) {\n      const length = properties.length;\n      for (let i = 0; i < length; i++) {\n        verifySpacing(properties[i], lineOptions);\n      }\n    }\n\n    /**\n     * Verifies vertical alignment, taking into account groups of properties.\n     * @param  {ASTNode} node ObjectExpression node being evaluated.\n     * @returns {void}\n     */\n    function verifyAlignment(node) {\n      createGroups(node).forEach(group => {\n        const properties = group.filter(isKeyValueProperty);\n        if (properties.length > 0 && isSingleLineProperties(properties)) {\n          verifyListSpacing(properties, multiLineOptions);\n        } else {\n          verifyGroupAlignment(properties);\n        }\n      });\n    }\n\n    //--------------------------------------------------------------------------\n    // Public API\n    //--------------------------------------------------------------------------\n\n    if (alignmentOptions) {\n      // Verify vertical alignment\n\n      return {\n        ObjectExpression(node) {\n          if (isSingleLine(node)) {\n            verifyListSpacing(node.properties.filter(isKeyValueProperty), singleLineOptions);\n          } else {\n            verifyAlignment(node);\n          }\n        }\n      };\n    }\n\n    // Obey beforeColon and afterColon in each property as configured\n    return {\n      Property(node) {\n        verifySpacing(node, isSingleLine(node.parent) ? singleLineOptions : multiLineOptions);\n      }\n    };\n  }\n};","map":{"version":3,"names":["require","astUtils","containsLineTerminator","str","LINEBREAK_MATCHER","test","last","arr","length","isSingleLine","node","loc","end","line","start","isSingleLineProperties","properties","firstProp","lastProp","initOptionProperty","toOptions","fromOptions","mode","beforeColon","afterColon","align","on","initOptions","multiLine","singleLine","module","exports","meta","type","docs","description","category","recommended","url","fixable","schema","anyOf","enum","additionalProperties","messages","extraKey","extraValue","missingKey","missingValue","create","context","options","ruleOptions","multiLineOptions","singleLineOptions","alignmentOptions","sourceCode","getSourceCode","continuesPropertyGroup","lastMember","candidate","groupEndLine","candidateStartLine","leadingComments","getCommentsBefore","i","isKeyValueProperty","property","method","shorthand","kind","getLastTokenBeforeColon","colonToken","getTokenAfter","isColonToken","getTokenBefore","getNextColon","getKey","key","computed","getText","slice","range","getStaticPropertyName","report","side","whitespace","expected","diff","nextColon","tokenBeforeColon","includeComments","tokenAfterColon","isKeySide","isExtra","diffAbs","Math","abs","spaces","Array","join","locStart","locEnd","missingLoc","fix","fixer","removeRange","insertTextAfter","insertTextBefore","messageId","data","getKeyWidth","startToken","getFirstToken","endToken","getPropertyWhitespace","exec","value","createGroups","reduce","groups","currentGroup","prev","push","verifyGroupAlignment","widths","map","targetWidth","max","width","verifySpacing","lineOptions","actual","verifyListSpacing","verifyAlignment","forEach","group","filter","ObjectExpression","Property","parent"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/key-spacing.js"],"sourcesContent":["/**\n * @fileoverview Rule to specify spacing of object literal keys and values\n * @author Brandon Mills\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether a string contains a line terminator as defined in\n * http://www.ecma-international.org/ecma-262/5.1/#sec-7.3\n * @param {string} str String to test.\n * @returns {boolean} True if str contains a line terminator.\n */\nfunction containsLineTerminator(str) {\n    return astUtils.LINEBREAK_MATCHER.test(str);\n}\n\n/**\n * Gets the last element of an array.\n * @param {Array} arr An array.\n * @returns {any} Last element of arr.\n */\nfunction last(arr) {\n    return arr[arr.length - 1];\n}\n\n/**\n * Checks whether a node is contained on a single line.\n * @param {ASTNode} node AST Node being evaluated.\n * @returns {boolean} True if the node is a single line.\n */\nfunction isSingleLine(node) {\n    return (node.loc.end.line === node.loc.start.line);\n}\n\n/**\n * Checks whether the properties on a single line.\n * @param {ASTNode[]} properties List of Property AST nodes.\n * @returns {boolean} True if all properties is on a single line.\n */\nfunction isSingleLineProperties(properties) {\n    const [firstProp] = properties,\n        lastProp = last(properties);\n\n    return firstProp.loc.start.line === lastProp.loc.end.line;\n}\n\n/**\n * Initializes a single option property from the configuration with defaults for undefined values\n * @param {Object} toOptions Object to be initialized\n * @param {Object} fromOptions Object to be initialized from\n * @returns {Object} The object with correctly initialized options and values\n */\nfunction initOptionProperty(toOptions, fromOptions) {\n    toOptions.mode = fromOptions.mode || \"strict\";\n\n    // Set value of beforeColon\n    if (typeof fromOptions.beforeColon !== \"undefined\") {\n        toOptions.beforeColon = +fromOptions.beforeColon;\n    } else {\n        toOptions.beforeColon = 0;\n    }\n\n    // Set value of afterColon\n    if (typeof fromOptions.afterColon !== \"undefined\") {\n        toOptions.afterColon = +fromOptions.afterColon;\n    } else {\n        toOptions.afterColon = 1;\n    }\n\n    // Set align if exists\n    if (typeof fromOptions.align !== \"undefined\") {\n        if (typeof fromOptions.align === \"object\") {\n            toOptions.align = fromOptions.align;\n        } else { // \"string\"\n            toOptions.align = {\n                on: fromOptions.align,\n                mode: toOptions.mode,\n                beforeColon: toOptions.beforeColon,\n                afterColon: toOptions.afterColon\n            };\n        }\n    }\n\n    return toOptions;\n}\n\n/**\n * Initializes all the option values (singleLine, multiLine and align) from the configuration with defaults for undefined values\n * @param {Object} toOptions Object to be initialized\n * @param {Object} fromOptions Object to be initialized from\n * @returns {Object} The object with correctly initialized options and values\n */\nfunction initOptions(toOptions, fromOptions) {\n    if (typeof fromOptions.align === \"object\") {\n\n        // Initialize the alignment configuration\n        toOptions.align = initOptionProperty({}, fromOptions.align);\n        toOptions.align.on = fromOptions.align.on || \"colon\";\n        toOptions.align.mode = fromOptions.align.mode || \"strict\";\n\n        toOptions.multiLine = initOptionProperty({}, (fromOptions.multiLine || fromOptions));\n        toOptions.singleLine = initOptionProperty({}, (fromOptions.singleLine || fromOptions));\n\n    } else { // string or undefined\n        toOptions.multiLine = initOptionProperty({}, (fromOptions.multiLine || fromOptions));\n        toOptions.singleLine = initOptionProperty({}, (fromOptions.singleLine || fromOptions));\n\n        // If alignment options are defined in multiLine, pull them out into the general align configuration\n        if (toOptions.multiLine.align) {\n            toOptions.align = {\n                on: toOptions.multiLine.align.on,\n                mode: toOptions.multiLine.align.mode || toOptions.multiLine.mode,\n                beforeColon: toOptions.multiLine.align.beforeColon,\n                afterColon: toOptions.multiLine.align.afterColon\n            };\n        }\n    }\n\n    return toOptions;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce consistent spacing between keys and values in object literal properties\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/key-spacing\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [{\n            anyOf: [\n                {\n                    type: \"object\",\n                    properties: {\n                        align: {\n                            anyOf: [\n                                {\n                                    enum: [\"colon\", \"value\"]\n                                },\n                                {\n                                    type: \"object\",\n                                    properties: {\n                                        mode: {\n                                            enum: [\"strict\", \"minimum\"]\n                                        },\n                                        on: {\n                                            enum: [\"colon\", \"value\"]\n                                        },\n                                        beforeColon: {\n                                            type: \"boolean\"\n                                        },\n                                        afterColon: {\n                                            type: \"boolean\"\n                                        }\n                                    },\n                                    additionalProperties: false\n                                }\n                            ]\n                        },\n                        mode: {\n                            enum: [\"strict\", \"minimum\"]\n                        },\n                        beforeColon: {\n                            type: \"boolean\"\n                        },\n                        afterColon: {\n                            type: \"boolean\"\n                        }\n                    },\n                    additionalProperties: false\n                },\n                {\n                    type: \"object\",\n                    properties: {\n                        singleLine: {\n                            type: \"object\",\n                            properties: {\n                                mode: {\n                                    enum: [\"strict\", \"minimum\"]\n                                },\n                                beforeColon: {\n                                    type: \"boolean\"\n                                },\n                                afterColon: {\n                                    type: \"boolean\"\n                                }\n                            },\n                            additionalProperties: false\n                        },\n                        multiLine: {\n                            type: \"object\",\n                            properties: {\n                                align: {\n                                    anyOf: [\n                                        {\n                                            enum: [\"colon\", \"value\"]\n                                        },\n                                        {\n                                            type: \"object\",\n                                            properties: {\n                                                mode: {\n                                                    enum: [\"strict\", \"minimum\"]\n                                                },\n                                                on: {\n                                                    enum: [\"colon\", \"value\"]\n                                                },\n                                                beforeColon: {\n                                                    type: \"boolean\"\n                                                },\n                                                afterColon: {\n                                                    type: \"boolean\"\n                                                }\n                                            },\n                                            additionalProperties: false\n                                        }\n                                    ]\n                                },\n                                mode: {\n                                    enum: [\"strict\", \"minimum\"]\n                                },\n                                beforeColon: {\n                                    type: \"boolean\"\n                                },\n                                afterColon: {\n                                    type: \"boolean\"\n                                }\n                            },\n                            additionalProperties: false\n                        }\n                    },\n                    additionalProperties: false\n                },\n                {\n                    type: \"object\",\n                    properties: {\n                        singleLine: {\n                            type: \"object\",\n                            properties: {\n                                mode: {\n                                    enum: [\"strict\", \"minimum\"]\n                                },\n                                beforeColon: {\n                                    type: \"boolean\"\n                                },\n                                afterColon: {\n                                    type: \"boolean\"\n                                }\n                            },\n                            additionalProperties: false\n                        },\n                        multiLine: {\n                            type: \"object\",\n                            properties: {\n                                mode: {\n                                    enum: [\"strict\", \"minimum\"]\n                                },\n                                beforeColon: {\n                                    type: \"boolean\"\n                                },\n                                afterColon: {\n                                    type: \"boolean\"\n                                }\n                            },\n                            additionalProperties: false\n                        },\n                        align: {\n                            type: \"object\",\n                            properties: {\n                                mode: {\n                                    enum: [\"strict\", \"minimum\"]\n                                },\n                                on: {\n                                    enum: [\"colon\", \"value\"]\n                                },\n                                beforeColon: {\n                                    type: \"boolean\"\n                                },\n                                afterColon: {\n                                    type: \"boolean\"\n                                }\n                            },\n                            additionalProperties: false\n                        }\n                    },\n                    additionalProperties: false\n                }\n            ]\n        }],\n        messages: {\n            extraKey: \"Extra space after {{computed}}key '{{key}}'.\",\n            extraValue: \"Extra space before value for {{computed}}key '{{key}}'.\",\n            missingKey: \"Missing space after {{computed}}key '{{key}}'.\",\n            missingValue: \"Missing space before value for {{computed}}key '{{key}}'.\"\n        }\n    },\n\n    create(context) {\n\n        /**\n         * OPTIONS\n         * \"key-spacing\": [2, {\n         *     beforeColon: false,\n         *     afterColon: true,\n         *     align: \"colon\" // Optional, or \"value\"\n         * }\n         */\n        const options = context.options[0] || {},\n            ruleOptions = initOptions({}, options),\n            multiLineOptions = ruleOptions.multiLine,\n            singleLineOptions = ruleOptions.singleLine,\n            alignmentOptions = ruleOptions.align || null;\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Checks whether a property is a member of the property group it follows.\n         * @param {ASTNode} lastMember The last Property known to be in the group.\n         * @param {ASTNode} candidate The next Property that might be in the group.\n         * @returns {boolean} True if the candidate property is part of the group.\n         */\n        function continuesPropertyGroup(lastMember, candidate) {\n            const groupEndLine = lastMember.loc.start.line,\n                candidateStartLine = candidate.loc.start.line;\n\n            if (candidateStartLine - groupEndLine <= 1) {\n                return true;\n            }\n\n            /*\n             * Check that the first comment is adjacent to the end of the group, the\n             * last comment is adjacent to the candidate property, and that successive\n             * comments are adjacent to each other.\n             */\n            const leadingComments = sourceCode.getCommentsBefore(candidate);\n\n            if (\n                leadingComments.length &&\n                leadingComments[0].loc.start.line - groupEndLine <= 1 &&\n                candidateStartLine - last(leadingComments).loc.end.line <= 1\n            ) {\n                for (let i = 1; i < leadingComments.length; i++) {\n                    if (leadingComments[i].loc.start.line - leadingComments[i - 1].loc.end.line > 1) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n\n            return false;\n        }\n\n        /**\n         * Determines if the given property is key-value property.\n         * @param {ASTNode} property Property node to check.\n         * @returns {boolean} Whether the property is a key-value property.\n         */\n        function isKeyValueProperty(property) {\n            return !(\n                (property.method ||\n                property.shorthand ||\n                property.kind !== \"init\" || property.type !== \"Property\") // Could be \"ExperimentalSpreadProperty\" or \"SpreadElement\"\n            );\n        }\n\n        /**\n         * Starting from the given a node (a property.key node here) looks forward\n         * until it finds the last token before a colon punctuator and returns it.\n         * @param {ASTNode} node The node to start looking from.\n         * @returns {ASTNode} The last token before a colon punctuator.\n         */\n        function getLastTokenBeforeColon(node) {\n            const colonToken = sourceCode.getTokenAfter(node, astUtils.isColonToken);\n\n            return sourceCode.getTokenBefore(colonToken);\n        }\n\n        /**\n         * Starting from the given a node (a property.key node here) looks forward\n         * until it finds the colon punctuator and returns it.\n         * @param {ASTNode} node The node to start looking from.\n         * @returns {ASTNode} The colon punctuator.\n         */\n        function getNextColon(node) {\n            return sourceCode.getTokenAfter(node, astUtils.isColonToken);\n        }\n\n        /**\n         * Gets an object literal property's key as the identifier name or string value.\n         * @param {ASTNode} property Property node whose key to retrieve.\n         * @returns {string} The property's key.\n         */\n        function getKey(property) {\n            const key = property.key;\n\n            if (property.computed) {\n                return sourceCode.getText().slice(key.range[0], key.range[1]);\n            }\n            return astUtils.getStaticPropertyName(property);\n        }\n\n        /**\n         * Reports an appropriately-formatted error if spacing is incorrect on one\n         * side of the colon.\n         * @param {ASTNode} property Key-value pair in an object literal.\n         * @param {string} side Side being verified - either \"key\" or \"value\".\n         * @param {string} whitespace Actual whitespace string.\n         * @param {int} expected Expected whitespace length.\n         * @param {string} mode Value of the mode as \"strict\" or \"minimum\"\n         * @returns {void}\n         */\n        function report(property, side, whitespace, expected, mode) {\n            const diff = whitespace.length - expected,\n                nextColon = getNextColon(property.key),\n                tokenBeforeColon = sourceCode.getTokenBefore(nextColon, { includeComments: true }),\n                tokenAfterColon = sourceCode.getTokenAfter(nextColon, { includeComments: true }),\n                isKeySide = side === \"key\",\n                isExtra = diff > 0,\n                diffAbs = Math.abs(diff),\n                spaces = Array(diffAbs + 1).join(\" \");\n\n            const locStart = isKeySide ? tokenBeforeColon.loc.end : nextColon.loc.start;\n            const locEnd = isKeySide ? nextColon.loc.start : tokenAfterColon.loc.start;\n            const missingLoc = isKeySide ? tokenBeforeColon.loc : tokenAfterColon.loc;\n            const loc = isExtra ? { start: locStart, end: locEnd } : missingLoc;\n\n            if ((\n                diff && mode === \"strict\" ||\n                diff < 0 && mode === \"minimum\" ||\n                diff > 0 && !expected && mode === \"minimum\") &&\n                !(expected && containsLineTerminator(whitespace))\n            ) {\n                let fix;\n\n                if (isExtra) {\n                    let range;\n\n                    // Remove whitespace\n                    if (isKeySide) {\n                        range = [tokenBeforeColon.range[1], tokenBeforeColon.range[1] + diffAbs];\n                    } else {\n                        range = [tokenAfterColon.range[0] - diffAbs, tokenAfterColon.range[0]];\n                    }\n                    fix = function(fixer) {\n                        return fixer.removeRange(range);\n                    };\n                } else {\n\n                    // Add whitespace\n                    if (isKeySide) {\n                        fix = function(fixer) {\n                            return fixer.insertTextAfter(tokenBeforeColon, spaces);\n                        };\n                    } else {\n                        fix = function(fixer) {\n                            return fixer.insertTextBefore(tokenAfterColon, spaces);\n                        };\n                    }\n                }\n\n                let messageId = \"\";\n\n                if (isExtra) {\n                    messageId = side === \"key\" ? \"extraKey\" : \"extraValue\";\n                } else {\n                    messageId = side === \"key\" ? \"missingKey\" : \"missingValue\";\n                }\n\n                context.report({\n                    node: property[side],\n                    loc,\n                    messageId,\n                    data: {\n                        computed: property.computed ? \"computed \" : \"\",\n                        key: getKey(property)\n                    },\n                    fix\n                });\n            }\n        }\n\n        /**\n         * Gets the number of characters in a key, including quotes around string\n         * keys and braces around computed property keys.\n         * @param {ASTNode} property Property of on object literal.\n         * @returns {int} Width of the key.\n         */\n        function getKeyWidth(property) {\n            const startToken = sourceCode.getFirstToken(property);\n            const endToken = getLastTokenBeforeColon(property.key);\n\n            return endToken.range[1] - startToken.range[0];\n        }\n\n        /**\n         * Gets the whitespace around the colon in an object literal property.\n         * @param {ASTNode} property Property node from an object literal.\n         * @returns {Object} Whitespace before and after the property's colon.\n         */\n        function getPropertyWhitespace(property) {\n            const whitespace = /(\\s*):(\\s*)/u.exec(sourceCode.getText().slice(\n                property.key.range[1], property.value.range[0]\n            ));\n\n            if (whitespace) {\n                return {\n                    beforeColon: whitespace[1],\n                    afterColon: whitespace[2]\n                };\n            }\n            return null;\n        }\n\n        /**\n         * Creates groups of properties.\n         * @param  {ASTNode} node ObjectExpression node being evaluated.\n         * @returns {Array.<ASTNode[]>} Groups of property AST node lists.\n         */\n        function createGroups(node) {\n            if (node.properties.length === 1) {\n                return [node.properties];\n            }\n\n            return node.properties.reduce((groups, property) => {\n                const currentGroup = last(groups),\n                    prev = last(currentGroup);\n\n                if (!prev || continuesPropertyGroup(prev, property)) {\n                    currentGroup.push(property);\n                } else {\n                    groups.push([property]);\n                }\n\n                return groups;\n            }, [\n                []\n            ]);\n        }\n\n        /**\n         * Verifies correct vertical alignment of a group of properties.\n         * @param {ASTNode[]} properties List of Property AST nodes.\n         * @returns {void}\n         */\n        function verifyGroupAlignment(properties) {\n            const length = properties.length,\n                widths = properties.map(getKeyWidth), // Width of keys, including quotes\n                align = alignmentOptions.on; // \"value\" or \"colon\"\n            let targetWidth = Math.max(...widths),\n                beforeColon, afterColon, mode;\n\n            if (alignmentOptions && length > 1) { // When aligning values within a group, use the alignment configuration.\n                beforeColon = alignmentOptions.beforeColon;\n                afterColon = alignmentOptions.afterColon;\n                mode = alignmentOptions.mode;\n            } else {\n                beforeColon = multiLineOptions.beforeColon;\n                afterColon = multiLineOptions.afterColon;\n                mode = alignmentOptions.mode;\n            }\n\n            // Conditionally include one space before or after colon\n            targetWidth += (align === \"colon\" ? beforeColon : afterColon);\n\n            for (let i = 0; i < length; i++) {\n                const property = properties[i];\n                const whitespace = getPropertyWhitespace(property);\n\n                if (whitespace) { // Object literal getters/setters lack a colon\n                    const width = widths[i];\n\n                    if (align === \"value\") {\n                        report(property, \"key\", whitespace.beforeColon, beforeColon, mode);\n                        report(property, \"value\", whitespace.afterColon, targetWidth - width, mode);\n                    } else { // align = \"colon\"\n                        report(property, \"key\", whitespace.beforeColon, targetWidth - width, mode);\n                        report(property, \"value\", whitespace.afterColon, afterColon, mode);\n                    }\n                }\n            }\n        }\n\n        /**\n         * Verifies spacing of property conforms to specified options.\n         * @param  {ASTNode} node Property node being evaluated.\n         * @param {Object} lineOptions Configured singleLine or multiLine options\n         * @returns {void}\n         */\n        function verifySpacing(node, lineOptions) {\n            const actual = getPropertyWhitespace(node);\n\n            if (actual) { // Object literal getters/setters lack colons\n                report(node, \"key\", actual.beforeColon, lineOptions.beforeColon, lineOptions.mode);\n                report(node, \"value\", actual.afterColon, lineOptions.afterColon, lineOptions.mode);\n            }\n        }\n\n        /**\n         * Verifies spacing of each property in a list.\n         * @param {ASTNode[]} properties List of Property AST nodes.\n         * @param {Object} lineOptions Configured singleLine or multiLine options\n         * @returns {void}\n         */\n        function verifyListSpacing(properties, lineOptions) {\n            const length = properties.length;\n\n            for (let i = 0; i < length; i++) {\n                verifySpacing(properties[i], lineOptions);\n            }\n        }\n\n        /**\n         * Verifies vertical alignment, taking into account groups of properties.\n         * @param  {ASTNode} node ObjectExpression node being evaluated.\n         * @returns {void}\n         */\n        function verifyAlignment(node) {\n            createGroups(node).forEach(group => {\n                const properties = group.filter(isKeyValueProperty);\n\n                if (properties.length > 0 && isSingleLineProperties(properties)) {\n                    verifyListSpacing(properties, multiLineOptions);\n                } else {\n                    verifyGroupAlignment(properties);\n                }\n            });\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        if (alignmentOptions) { // Verify vertical alignment\n\n            return {\n                ObjectExpression(node) {\n                    if (isSingleLine(node)) {\n                        verifyListSpacing(node.properties.filter(isKeyValueProperty), singleLineOptions);\n                    } else {\n                        verifyAlignment(node);\n                    }\n                }\n            };\n\n        }\n\n        // Obey beforeColon and afterColon in each property as configured\n        return {\n            Property(node) {\n                verifySpacing(node, isSingleLine(node.parent) ? singleLineOptions : multiLineOptions);\n            }\n        };\n\n\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}