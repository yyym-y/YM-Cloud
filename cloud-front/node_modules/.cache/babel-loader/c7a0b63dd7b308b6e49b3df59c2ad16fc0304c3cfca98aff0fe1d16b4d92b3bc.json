{"ast":null,"code":"/**\n * @fileoverview Rule to flag fall-through cases in switch statements.\n * @author Matt DuVall <http://mattduvall.com/>\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\nconst DEFAULT_FALLTHROUGH_COMMENT = /falls?\\s?through/iu;\n\n/**\n * Checks whether or not a given case has a fallthrough comment.\n * @param {ASTNode} caseWhichFallsThrough SwitchCase node which falls through.\n * @param {ASTNode} subsequentCase The case after caseWhichFallsThrough.\n * @param {RuleContext} context A rule context which stores comments.\n * @param {RegExp} fallthroughCommentPattern A pattern to match comment to.\n * @returns {boolean} `true` if the case has a valid fallthrough comment.\n */\nfunction hasFallthroughComment(caseWhichFallsThrough, subsequentCase, context, fallthroughCommentPattern) {\n  const sourceCode = context.getSourceCode();\n  if (caseWhichFallsThrough.consequent.length === 1 && caseWhichFallsThrough.consequent[0].type === \"BlockStatement\") {\n    const trailingCloseBrace = sourceCode.getLastToken(caseWhichFallsThrough.consequent[0]);\n    const commentInBlock = sourceCode.getCommentsBefore(trailingCloseBrace).pop();\n    if (commentInBlock && fallthroughCommentPattern.test(commentInBlock.value)) {\n      return true;\n    }\n  }\n  const comment = sourceCode.getCommentsBefore(subsequentCase).pop();\n  return Boolean(comment && fallthroughCommentPattern.test(comment.value));\n}\n\n/**\n * Checks whether or not a given code path segment is reachable.\n * @param {CodePathSegment} segment A CodePathSegment to check.\n * @returns {boolean} `true` if the segment is reachable.\n */\nfunction isReachable(segment) {\n  return segment.reachable;\n}\n\n/**\n * Checks whether a node and a token are separated by blank lines\n * @param {ASTNode} node The node to check\n * @param {Token} token The token to compare against\n * @returns {boolean} `true` if there are blank lines between node and token\n */\nfunction hasBlankLinesBetween(node, token) {\n  return token.loc.start.line > node.loc.end.line + 1;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow fallthrough of `case` statements\",\n      category: \"Best Practices\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-fallthrough\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        commentPattern: {\n          type: \"string\",\n          default: \"\"\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      case: \"Expected a 'break' statement before 'case'.\",\n      default: \"Expected a 'break' statement before 'default'.\"\n    }\n  },\n  create(context) {\n    const options = context.options[0] || {};\n    let currentCodePath = null;\n    const sourceCode = context.getSourceCode();\n\n    /*\n     * We need to use leading comments of the next SwitchCase node because\n     * trailing comments is wrong if semicolons are omitted.\n     */\n    let fallthroughCase = null;\n    let fallthroughCommentPattern = null;\n    if (options.commentPattern) {\n      fallthroughCommentPattern = new RegExp(options.commentPattern, \"u\");\n    } else {\n      fallthroughCommentPattern = DEFAULT_FALLTHROUGH_COMMENT;\n    }\n    return {\n      onCodePathStart(codePath) {\n        currentCodePath = codePath;\n      },\n      onCodePathEnd() {\n        currentCodePath = currentCodePath.upper;\n      },\n      SwitchCase(node) {\n        /*\n         * Checks whether or not there is a fallthrough comment.\n         * And reports the previous fallthrough node if that does not exist.\n         */\n        if (fallthroughCase && !hasFallthroughComment(fallthroughCase, node, context, fallthroughCommentPattern)) {\n          context.report({\n            messageId: node.test ? \"case\" : \"default\",\n            node\n          });\n        }\n        fallthroughCase = null;\n      },\n      \"SwitchCase:exit\"(node) {\n        const nextToken = sourceCode.getTokenAfter(node);\n\n        /*\n         * `reachable` meant fall through because statements preceded by\n         * `break`, `return`, or `throw` are unreachable.\n         * And allows empty cases and the last case.\n         */\n        if (currentCodePath.currentSegments.some(isReachable) && (node.consequent.length > 0 || hasBlankLinesBetween(node, nextToken)) && node.parent.cases[node.parent.cases.length - 1] !== node) {\n          fallthroughCase = node;\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["DEFAULT_FALLTHROUGH_COMMENT","hasFallthroughComment","caseWhichFallsThrough","subsequentCase","context","fallthroughCommentPattern","sourceCode","getSourceCode","consequent","length","type","trailingCloseBrace","getLastToken","commentInBlock","getCommentsBefore","pop","test","value","comment","Boolean","isReachable","segment","reachable","hasBlankLinesBetween","node","token","loc","start","line","end","module","exports","meta","docs","description","category","recommended","url","schema","properties","commentPattern","default","additionalProperties","messages","case","create","options","currentCodePath","fallthroughCase","RegExp","onCodePathStart","codePath","onCodePathEnd","upper","SwitchCase","report","messageId","SwitchCase:exit","nextToken","getTokenAfter","currentSegments","some","parent","cases"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/no-fallthrough.js"],"sourcesContent":["/**\n * @fileoverview Rule to flag fall-through cases in switch statements.\n * @author Matt DuVall <http://mattduvall.com/>\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst DEFAULT_FALLTHROUGH_COMMENT = /falls?\\s?through/iu;\n\n/**\n * Checks whether or not a given case has a fallthrough comment.\n * @param {ASTNode} caseWhichFallsThrough SwitchCase node which falls through.\n * @param {ASTNode} subsequentCase The case after caseWhichFallsThrough.\n * @param {RuleContext} context A rule context which stores comments.\n * @param {RegExp} fallthroughCommentPattern A pattern to match comment to.\n * @returns {boolean} `true` if the case has a valid fallthrough comment.\n */\nfunction hasFallthroughComment(caseWhichFallsThrough, subsequentCase, context, fallthroughCommentPattern) {\n    const sourceCode = context.getSourceCode();\n\n    if (caseWhichFallsThrough.consequent.length === 1 && caseWhichFallsThrough.consequent[0].type === \"BlockStatement\") {\n        const trailingCloseBrace = sourceCode.getLastToken(caseWhichFallsThrough.consequent[0]);\n        const commentInBlock = sourceCode.getCommentsBefore(trailingCloseBrace).pop();\n\n        if (commentInBlock && fallthroughCommentPattern.test(commentInBlock.value)) {\n            return true;\n        }\n    }\n\n    const comment = sourceCode.getCommentsBefore(subsequentCase).pop();\n\n    return Boolean(comment && fallthroughCommentPattern.test(comment.value));\n}\n\n/**\n * Checks whether or not a given code path segment is reachable.\n * @param {CodePathSegment} segment A CodePathSegment to check.\n * @returns {boolean} `true` if the segment is reachable.\n */\nfunction isReachable(segment) {\n    return segment.reachable;\n}\n\n/**\n * Checks whether a node and a token are separated by blank lines\n * @param {ASTNode} node The node to check\n * @param {Token} token The token to compare against\n * @returns {boolean} `true` if there are blank lines between node and token\n */\nfunction hasBlankLinesBetween(node, token) {\n    return token.loc.start.line > node.loc.end.line + 1;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow fallthrough of `case` statements\",\n            category: \"Best Practices\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-fallthrough\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    commentPattern: {\n                        type: \"string\",\n                        default: \"\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n        messages: {\n            case: \"Expected a 'break' statement before 'case'.\",\n            default: \"Expected a 'break' statement before 'default'.\"\n        }\n    },\n\n    create(context) {\n        const options = context.options[0] || {};\n        let currentCodePath = null;\n        const sourceCode = context.getSourceCode();\n\n        /*\n         * We need to use leading comments of the next SwitchCase node because\n         * trailing comments is wrong if semicolons are omitted.\n         */\n        let fallthroughCase = null;\n        let fallthroughCommentPattern = null;\n\n        if (options.commentPattern) {\n            fallthroughCommentPattern = new RegExp(options.commentPattern, \"u\");\n        } else {\n            fallthroughCommentPattern = DEFAULT_FALLTHROUGH_COMMENT;\n        }\n\n        return {\n            onCodePathStart(codePath) {\n                currentCodePath = codePath;\n            },\n            onCodePathEnd() {\n                currentCodePath = currentCodePath.upper;\n            },\n\n            SwitchCase(node) {\n\n                /*\n                 * Checks whether or not there is a fallthrough comment.\n                 * And reports the previous fallthrough node if that does not exist.\n                 */\n                if (fallthroughCase && !hasFallthroughComment(fallthroughCase, node, context, fallthroughCommentPattern)) {\n                    context.report({\n                        messageId: node.test ? \"case\" : \"default\",\n                        node\n                    });\n                }\n                fallthroughCase = null;\n            },\n\n            \"SwitchCase:exit\"(node) {\n                const nextToken = sourceCode.getTokenAfter(node);\n\n                /*\n                 * `reachable` meant fall through because statements preceded by\n                 * `break`, `return`, or `throw` are unreachable.\n                 * And allows empty cases and the last case.\n                 */\n                if (currentCodePath.currentSegments.some(isReachable) &&\n                    (node.consequent.length > 0 || hasBlankLinesBetween(node, nextToken)) &&\n                    node.parent.cases[node.parent.cases.length - 1] !== node) {\n                    fallthroughCase = node;\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}