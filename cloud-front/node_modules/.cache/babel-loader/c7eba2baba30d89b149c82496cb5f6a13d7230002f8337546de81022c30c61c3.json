{"ast":null,"code":"/**\n * @fileoverview Object to handle access and retrieval of tokens.\n * @author Brandon Mills\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nrequire(\"core-js/modules/es.array.push.js\");\nconst assert = require(\"assert\");\nconst {\n  isCommentToken\n} = require(\"eslint-utils\");\nconst cursors = require(\"./cursors\");\nconst ForwardTokenCursor = require(\"./forward-token-cursor\");\nconst PaddedTokenCursor = require(\"./padded-token-cursor\");\nconst utils = require(\"./utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst TOKENS = Symbol(\"tokens\");\nconst COMMENTS = Symbol(\"comments\");\nconst INDEX_MAP = Symbol(\"indexMap\");\n\n/**\n * Creates the map from locations to indices in `tokens`.\n *\n * The first/last location of tokens is mapped to the index of the token.\n * The first/last location of comments is mapped to the index of the next token of each comment.\n * @param {Token[]} tokens The array of tokens.\n * @param {Comment[]} comments The array of comments.\n * @returns {Object} The map from locations to indices in `tokens`.\n * @private\n */\nfunction createIndexMap(tokens, comments) {\n  const map = Object.create(null);\n  let tokenIndex = 0;\n  let commentIndex = 0;\n  let nextStart = 0;\n  let range = null;\n  while (tokenIndex < tokens.length || commentIndex < comments.length) {\n    nextStart = commentIndex < comments.length ? comments[commentIndex].range[0] : Number.MAX_SAFE_INTEGER;\n    while (tokenIndex < tokens.length && (range = tokens[tokenIndex].range)[0] < nextStart) {\n      map[range[0]] = tokenIndex;\n      map[range[1] - 1] = tokenIndex;\n      tokenIndex += 1;\n    }\n    nextStart = tokenIndex < tokens.length ? tokens[tokenIndex].range[0] : Number.MAX_SAFE_INTEGER;\n    while (commentIndex < comments.length && (range = comments[commentIndex].range)[0] < nextStart) {\n      map[range[0]] = tokenIndex;\n      map[range[1] - 1] = tokenIndex;\n      commentIndex += 1;\n    }\n  }\n  return map;\n}\n\n/**\n * Creates the cursor iterates tokens with options.\n * @param {CursorFactory} factory The cursor factory to initialize cursor.\n * @param {Token[]} tokens The array of tokens.\n * @param {Comment[]} comments The array of comments.\n * @param {Object} indexMap The map from locations to indices in `tokens`.\n * @param {number} startLoc The start location of the iteration range.\n * @param {number} endLoc The end location of the iteration range.\n * @param {number|Function|Object} [opts=0] The option object. If this is a number then it's `opts.skip`. If this is a function then it's `opts.filter`.\n * @param {boolean} [opts.includeComments=false] The flag to iterate comments as well.\n * @param {Function|null} [opts.filter=null] The predicate function to choose tokens.\n * @param {number} [opts.skip=0] The count of tokens the cursor skips.\n * @returns {Cursor} The created cursor.\n * @private\n */\nfunction createCursorWithSkip(factory, tokens, comments, indexMap, startLoc, endLoc, opts) {\n  let includeComments = false;\n  let skip = 0;\n  let filter = null;\n  if (typeof opts === \"number\") {\n    skip = opts | 0;\n  } else if (typeof opts === \"function\") {\n    filter = opts;\n  } else if (opts) {\n    includeComments = !!opts.includeComments;\n    skip = opts.skip | 0;\n    filter = opts.filter || null;\n  }\n  assert(skip >= 0, \"options.skip should be zero or a positive integer.\");\n  assert(!filter || typeof filter === \"function\", \"options.filter should be a function.\");\n  return factory.createCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments, filter, skip, -1);\n}\n\n/**\n * Creates the cursor iterates tokens with options.\n * @param {CursorFactory} factory The cursor factory to initialize cursor.\n * @param {Token[]} tokens The array of tokens.\n * @param {Comment[]} comments The array of comments.\n * @param {Object} indexMap The map from locations to indices in `tokens`.\n * @param {number} startLoc The start location of the iteration range.\n * @param {number} endLoc The end location of the iteration range.\n * @param {number|Function|Object} [opts=0] The option object. If this is a number then it's `opts.count`. If this is a function then it's `opts.filter`.\n * @param {boolean} [opts.includeComments] The flag to iterate comments as well.\n * @param {Function|null} [opts.filter=null] The predicate function to choose tokens.\n * @param {number} [opts.count=0] The maximum count of tokens the cursor iterates. Zero is no iteration for backward compatibility.\n * @returns {Cursor} The created cursor.\n * @private\n */\nfunction createCursorWithCount(factory, tokens, comments, indexMap, startLoc, endLoc, opts) {\n  let includeComments = false;\n  let count = 0;\n  let countExists = false;\n  let filter = null;\n  if (typeof opts === \"number\") {\n    count = opts | 0;\n    countExists = true;\n  } else if (typeof opts === \"function\") {\n    filter = opts;\n  } else if (opts) {\n    includeComments = !!opts.includeComments;\n    count = opts.count | 0;\n    countExists = typeof opts.count === \"number\";\n    filter = opts.filter || null;\n  }\n  assert(count >= 0, \"options.count should be zero or a positive integer.\");\n  assert(!filter || typeof filter === \"function\", \"options.filter should be a function.\");\n  return factory.createCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments, filter, 0, countExists ? count : -1);\n}\n\n/**\n * Creates the cursor iterates tokens with options.\n * This is overload function of the below.\n * @param {Token[]} tokens The array of tokens.\n * @param {Comment[]} comments The array of comments.\n * @param {Object} indexMap The map from locations to indices in `tokens`.\n * @param {number} startLoc The start location of the iteration range.\n * @param {number} endLoc The end location of the iteration range.\n * @param {Function|Object} opts The option object. If this is a function then it's `opts.filter`.\n * @param {boolean} [opts.includeComments] The flag to iterate comments as well.\n * @param {Function|null} [opts.filter=null] The predicate function to choose tokens.\n * @param {number} [opts.count=0] The maximum count of tokens the cursor iterates. Zero is no iteration for backward compatibility.\n * @returns {Cursor} The created cursor.\n * @private\n */\n/**\n * Creates the cursor iterates tokens with options.\n * @param {Token[]} tokens The array of tokens.\n * @param {Comment[]} comments The array of comments.\n * @param {Object} indexMap The map from locations to indices in `tokens`.\n * @param {number} startLoc The start location of the iteration range.\n * @param {number} endLoc The end location of the iteration range.\n * @param {number} [beforeCount=0] The number of tokens before the node to retrieve.\n * @param {boolean} [afterCount=0] The number of tokens after the node to retrieve.\n * @returns {Cursor} The created cursor.\n * @private\n */\nfunction createCursorWithPadding(tokens, comments, indexMap, startLoc, endLoc, beforeCount, afterCount) {\n  if (typeof beforeCount === \"undefined\" && typeof afterCount === \"undefined\") {\n    return new ForwardTokenCursor(tokens, comments, indexMap, startLoc, endLoc);\n  }\n  if (typeof beforeCount === \"number\" || typeof beforeCount === \"undefined\") {\n    return new PaddedTokenCursor(tokens, comments, indexMap, startLoc, endLoc, beforeCount | 0, afterCount | 0);\n  }\n  return createCursorWithCount(cursors.forward, tokens, comments, indexMap, startLoc, endLoc, beforeCount);\n}\n\n/**\n * Gets comment tokens that are adjacent to the current cursor position.\n * @param {Cursor} cursor A cursor instance.\n * @returns {Array} An array of comment tokens adjacent to the current cursor position.\n * @private\n */\nfunction getAdjacentCommentTokensFromCursor(cursor) {\n  const tokens = [];\n  let currentToken = cursor.getOneToken();\n  while (currentToken && isCommentToken(currentToken)) {\n    tokens.push(currentToken);\n    currentToken = cursor.getOneToken();\n  }\n  return tokens;\n}\n\n//------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\n/**\n * The token store.\n *\n * This class provides methods to get tokens by locations as fast as possible.\n * The methods are a part of public API, so we should be careful if it changes this class.\n *\n * People can get tokens in O(1) by the hash map which is mapping from the location of tokens/comments to tokens.\n * Also people can get a mix of tokens and comments in O(log k), the k is the number of comments.\n * Assuming that comments to be much fewer than tokens, this does not make hash map from token's locations to comments to reduce memory cost.\n * This uses binary-searching instead for comments.\n */\nmodule.exports = class TokenStore {\n  /**\n   * Initializes this token store.\n   * @param {Token[]} tokens The array of tokens.\n   * @param {Comment[]} comments The array of comments.\n   */\n  constructor(tokens, comments) {\n    this[TOKENS] = tokens;\n    this[COMMENTS] = comments;\n    this[INDEX_MAP] = createIndexMap(tokens, comments);\n  }\n\n  //--------------------------------------------------------------------------\n  // Gets single token.\n  //--------------------------------------------------------------------------\n\n  /**\n   * Gets the token starting at the specified index.\n   * @param {number} offset Index of the start of the token's range.\n   * @param {Object} [options=0] The option object.\n   * @param {boolean} [options.includeComments=false] The flag to iterate comments as well.\n   * @returns {Token|null} The token starting at index, or null if no such token.\n   */\n  getTokenByRangeStart(offset, options) {\n    const includeComments = options && options.includeComments;\n    const token = cursors.forward.createBaseCursor(this[TOKENS], this[COMMENTS], this[INDEX_MAP], offset, -1, includeComments).getOneToken();\n    if (token && token.range[0] === offset) {\n      return token;\n    }\n    return null;\n  }\n\n  /**\n   * Gets the first token of the given node.\n   * @param {ASTNode} node The AST node.\n   * @param {number|Function|Object} [options=0] The option object. If this is a number then it's `options.skip`. If this is a function then it's `options.filter`.\n   * @param {boolean} [options.includeComments=false] The flag to iterate comments as well.\n   * @param {Function|null} [options.filter=null] The predicate function to choose tokens.\n   * @param {number} [options.skip=0] The count of tokens the cursor skips.\n   * @returns {Token|null} An object representing the token.\n   */\n  getFirstToken(node, options) {\n    return createCursorWithSkip(cursors.forward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], node.range[0], node.range[1], options).getOneToken();\n  }\n\n  /**\n   * Gets the last token of the given node.\n   * @param {ASTNode} node The AST node.\n   * @param {number|Function|Object} [options=0] The option object. Same options as getFirstToken()\n   * @returns {Token|null} An object representing the token.\n   */\n  getLastToken(node, options) {\n    return createCursorWithSkip(cursors.backward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], node.range[0], node.range[1], options).getOneToken();\n  }\n\n  /**\n   * Gets the token that precedes a given node or token.\n   * @param {ASTNode|Token|Comment} node The AST node or token.\n   * @param {number|Function|Object} [options=0] The option object. Same options as getFirstToken()\n   * @returns {Token|null} An object representing the token.\n   */\n  getTokenBefore(node, options) {\n    return createCursorWithSkip(cursors.backward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], -1, node.range[0], options).getOneToken();\n  }\n\n  /**\n   * Gets the token that follows a given node or token.\n   * @param {ASTNode|Token|Comment} node The AST node or token.\n   * @param {number|Function|Object} [options=0] The option object. Same options as getFirstToken()\n   * @returns {Token|null} An object representing the token.\n   */\n  getTokenAfter(node, options) {\n    return createCursorWithSkip(cursors.forward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], node.range[1], -1, options).getOneToken();\n  }\n\n  /**\n   * Gets the first token between two non-overlapping nodes.\n   * @param {ASTNode|Token|Comment} left Node before the desired token range.\n   * @param {ASTNode|Token|Comment} right Node after the desired token range.\n   * @param {number|Function|Object} [options=0] The option object. Same options as getFirstToken()\n   * @returns {Token|null} An object representing the token.\n   */\n  getFirstTokenBetween(left, right, options) {\n    return createCursorWithSkip(cursors.forward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], left.range[1], right.range[0], options).getOneToken();\n  }\n\n  /**\n   * Gets the last token between two non-overlapping nodes.\n   * @param {ASTNode|Token|Comment} left Node before the desired token range.\n   * @param {ASTNode|Token|Comment} right Node after the desired token range.\n   * @param {number|Function|Object} [options=0] The option object. Same options as getFirstToken()\n   * @returns {Token|null} An object representing the token.\n   */\n  getLastTokenBetween(left, right, options) {\n    return createCursorWithSkip(cursors.backward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], left.range[1], right.range[0], options).getOneToken();\n  }\n\n  /**\n   * Gets the token that precedes a given node or token in the token stream.\n   * This is defined for backward compatibility. Use `includeComments` option instead.\n   * TODO: We have a plan to remove this in a future major version.\n   * @param {ASTNode|Token|Comment} node The AST node or token.\n   * @param {number} [skip=0] A number of tokens to skip.\n   * @returns {Token|null} An object representing the token.\n   * @deprecated\n   */\n  getTokenOrCommentBefore(node, skip) {\n    return this.getTokenBefore(node, {\n      includeComments: true,\n      skip\n    });\n  }\n\n  /**\n   * Gets the token that follows a given node or token in the token stream.\n   * This is defined for backward compatibility. Use `includeComments` option instead.\n   * TODO: We have a plan to remove this in a future major version.\n   * @param {ASTNode|Token|Comment} node The AST node or token.\n   * @param {number} [skip=0] A number of tokens to skip.\n   * @returns {Token|null} An object representing the token.\n   * @deprecated\n   */\n  getTokenOrCommentAfter(node, skip) {\n    return this.getTokenAfter(node, {\n      includeComments: true,\n      skip\n    });\n  }\n\n  //--------------------------------------------------------------------------\n  // Gets multiple tokens.\n  //--------------------------------------------------------------------------\n\n  /**\n   * Gets the first `count` tokens of the given node.\n   * @param {ASTNode} node The AST node.\n   * @param {number|Function|Object} [options=0] The option object. If this is a number then it's `options.count`. If this is a function then it's `options.filter`.\n   * @param {boolean} [options.includeComments=false] The flag to iterate comments as well.\n   * @param {Function|null} [options.filter=null] The predicate function to choose tokens.\n   * @param {number} [options.count=0] The maximum count of tokens the cursor iterates.\n   * @returns {Token[]} Tokens.\n   */\n  getFirstTokens(node, options) {\n    return createCursorWithCount(cursors.forward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], node.range[0], node.range[1], options).getAllTokens();\n  }\n\n  /**\n   * Gets the last `count` tokens of the given node.\n   * @param {ASTNode} node The AST node.\n   * @param {number|Function|Object} [options=0] The option object. Same options as getFirstTokens()\n   * @returns {Token[]} Tokens.\n   */\n  getLastTokens(node, options) {\n    return createCursorWithCount(cursors.backward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], node.range[0], node.range[1], options).getAllTokens().reverse();\n  }\n\n  /**\n   * Gets the `count` tokens that precedes a given node or token.\n   * @param {ASTNode|Token|Comment} node The AST node or token.\n   * @param {number|Function|Object} [options=0] The option object. Same options as getFirstTokens()\n   * @returns {Token[]} Tokens.\n   */\n  getTokensBefore(node, options) {\n    return createCursorWithCount(cursors.backward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], -1, node.range[0], options).getAllTokens().reverse();\n  }\n\n  /**\n   * Gets the `count` tokens that follows a given node or token.\n   * @param {ASTNode|Token|Comment} node The AST node or token.\n   * @param {number|Function|Object} [options=0] The option object. Same options as getFirstTokens()\n   * @returns {Token[]} Tokens.\n   */\n  getTokensAfter(node, options) {\n    return createCursorWithCount(cursors.forward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], node.range[1], -1, options).getAllTokens();\n  }\n\n  /**\n   * Gets the first `count` tokens between two non-overlapping nodes.\n   * @param {ASTNode|Token|Comment} left Node before the desired token range.\n   * @param {ASTNode|Token|Comment} right Node after the desired token range.\n   * @param {number|Function|Object} [options=0] The option object. Same options as getFirstTokens()\n   * @returns {Token[]} Tokens between left and right.\n   */\n  getFirstTokensBetween(left, right, options) {\n    return createCursorWithCount(cursors.forward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], left.range[1], right.range[0], options).getAllTokens();\n  }\n\n  /**\n   * Gets the last `count` tokens between two non-overlapping nodes.\n   * @param {ASTNode|Token|Comment} left Node before the desired token range.\n   * @param {ASTNode|Token|Comment} right Node after the desired token range.\n   * @param {number|Function|Object} [options=0] The option object. Same options as getFirstTokens()\n   * @returns {Token[]} Tokens between left and right.\n   */\n  getLastTokensBetween(left, right, options) {\n    return createCursorWithCount(cursors.backward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], left.range[1], right.range[0], options).getAllTokens().reverse();\n  }\n\n  /**\n   * Gets all tokens that are related to the given node.\n   * @param {ASTNode} node The AST node.\n   * @param {Function|Object} options The option object. If this is a function then it's `options.filter`.\n   * @param {boolean} [options.includeComments=false] The flag to iterate comments as well.\n   * @param {Function|null} [options.filter=null] The predicate function to choose tokens.\n   * @param {number} [options.count=0] The maximum count of tokens the cursor iterates.\n   * @returns {Token[]} Array of objects representing tokens.\n   */\n  /**\n   * Gets all tokens that are related to the given node.\n   * @param {ASTNode} node The AST node.\n   * @param {int} [beforeCount=0] The number of tokens before the node to retrieve.\n   * @param {int} [afterCount=0] The number of tokens after the node to retrieve.\n   * @returns {Token[]} Array of objects representing tokens.\n   */\n  getTokens(node, beforeCount, afterCount) {\n    return createCursorWithPadding(this[TOKENS], this[COMMENTS], this[INDEX_MAP], node.range[0], node.range[1], beforeCount, afterCount).getAllTokens();\n  }\n\n  /**\n   * Gets all of the tokens between two non-overlapping nodes.\n   * @param {ASTNode|Token|Comment} left Node before the desired token range.\n   * @param {ASTNode|Token|Comment} right Node after the desired token range.\n   * @param {Function|Object} options The option object. If this is a function then it's `options.filter`.\n   * @param {boolean} [options.includeComments=false] The flag to iterate comments as well.\n   * @param {Function|null} [options.filter=null] The predicate function to choose tokens.\n   * @param {number} [options.count=0] The maximum count of tokens the cursor iterates.\n   * @returns {Token[]} Tokens between left and right.\n   */\n  /**\n   * Gets all of the tokens between two non-overlapping nodes.\n   * @param {ASTNode|Token|Comment} left Node before the desired token range.\n   * @param {ASTNode|Token|Comment} right Node after the desired token range.\n   * @param {int} [padding=0] Number of extra tokens on either side of center.\n   * @returns {Token[]} Tokens between left and right.\n   */\n  getTokensBetween(left, right, padding) {\n    return createCursorWithPadding(this[TOKENS], this[COMMENTS], this[INDEX_MAP], left.range[1], right.range[0], padding, padding).getAllTokens();\n  }\n\n  //--------------------------------------------------------------------------\n  // Others.\n  //--------------------------------------------------------------------------\n\n  /**\n   * Checks whether any comments exist or not between the given 2 nodes.\n   * @param {ASTNode} left The node to check.\n   * @param {ASTNode} right The node to check.\n   * @returns {boolean} `true` if one or more comments exist.\n   */\n  commentsExistBetween(left, right) {\n    const index = utils.search(this[COMMENTS], left.range[1]);\n    return index < this[COMMENTS].length && this[COMMENTS][index].range[1] <= right.range[0];\n  }\n\n  /**\n   * Gets all comment tokens directly before the given node or token.\n   * @param {ASTNode|token} nodeOrToken The AST node or token to check for adjacent comment tokens.\n   * @returns {Array} An array of comments in occurrence order.\n   */\n  getCommentsBefore(nodeOrToken) {\n    const cursor = createCursorWithCount(cursors.backward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], -1, nodeOrToken.range[0], {\n      includeComments: true\n    });\n    return getAdjacentCommentTokensFromCursor(cursor).reverse();\n  }\n\n  /**\n   * Gets all comment tokens directly after the given node or token.\n   * @param {ASTNode|token} nodeOrToken The AST node or token to check for adjacent comment tokens.\n   * @returns {Array} An array of comments in occurrence order.\n   */\n  getCommentsAfter(nodeOrToken) {\n    const cursor = createCursorWithCount(cursors.forward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], nodeOrToken.range[1], -1, {\n      includeComments: true\n    });\n    return getAdjacentCommentTokensFromCursor(cursor);\n  }\n\n  /**\n   * Gets all comment tokens inside the given node.\n   * @param {ASTNode} node The AST node to get the comments for.\n   * @returns {Array} An array of comments in occurrence order.\n   */\n  getCommentsInside(node) {\n    return this.getTokens(node, {\n      includeComments: true,\n      filter: isCommentToken\n    });\n  }\n};","map":{"version":3,"names":["require","assert","isCommentToken","cursors","ForwardTokenCursor","PaddedTokenCursor","utils","TOKENS","Symbol","COMMENTS","INDEX_MAP","createIndexMap","tokens","comments","map","Object","create","tokenIndex","commentIndex","nextStart","range","length","Number","MAX_SAFE_INTEGER","createCursorWithSkip","factory","indexMap","startLoc","endLoc","opts","includeComments","skip","filter","createCursor","createCursorWithCount","count","countExists","createCursorWithPadding","beforeCount","afterCount","forward","getAdjacentCommentTokensFromCursor","cursor","currentToken","getOneToken","push","module","exports","TokenStore","constructor","getTokenByRangeStart","offset","options","token","createBaseCursor","getFirstToken","node","getLastToken","backward","getTokenBefore","getTokenAfter","getFirstTokenBetween","left","right","getLastTokenBetween","getTokenOrCommentBefore","getTokenOrCommentAfter","getFirstTokens","getAllTokens","getLastTokens","reverse","getTokensBefore","getTokensAfter","getFirstTokensBetween","getLastTokensBetween","getTokens","getTokensBetween","padding","commentsExistBetween","index","search","getCommentsBefore","nodeOrToken","getCommentsAfter","getCommentsInside"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/source-code/token-store/index.js"],"sourcesContent":["/**\n * @fileoverview Object to handle access and retrieval of tokens.\n * @author Brandon Mills\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst assert = require(\"assert\");\nconst { isCommentToken } = require(\"eslint-utils\");\nconst cursors = require(\"./cursors\");\nconst ForwardTokenCursor = require(\"./forward-token-cursor\");\nconst PaddedTokenCursor = require(\"./padded-token-cursor\");\nconst utils = require(\"./utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst TOKENS = Symbol(\"tokens\");\nconst COMMENTS = Symbol(\"comments\");\nconst INDEX_MAP = Symbol(\"indexMap\");\n\n/**\n * Creates the map from locations to indices in `tokens`.\n *\n * The first/last location of tokens is mapped to the index of the token.\n * The first/last location of comments is mapped to the index of the next token of each comment.\n * @param {Token[]} tokens The array of tokens.\n * @param {Comment[]} comments The array of comments.\n * @returns {Object} The map from locations to indices in `tokens`.\n * @private\n */\nfunction createIndexMap(tokens, comments) {\n    const map = Object.create(null);\n    let tokenIndex = 0;\n    let commentIndex = 0;\n    let nextStart = 0;\n    let range = null;\n\n    while (tokenIndex < tokens.length || commentIndex < comments.length) {\n        nextStart = (commentIndex < comments.length) ? comments[commentIndex].range[0] : Number.MAX_SAFE_INTEGER;\n        while (tokenIndex < tokens.length && (range = tokens[tokenIndex].range)[0] < nextStart) {\n            map[range[0]] = tokenIndex;\n            map[range[1] - 1] = tokenIndex;\n            tokenIndex += 1;\n        }\n\n        nextStart = (tokenIndex < tokens.length) ? tokens[tokenIndex].range[0] : Number.MAX_SAFE_INTEGER;\n        while (commentIndex < comments.length && (range = comments[commentIndex].range)[0] < nextStart) {\n            map[range[0]] = tokenIndex;\n            map[range[1] - 1] = tokenIndex;\n            commentIndex += 1;\n        }\n    }\n\n    return map;\n}\n\n/**\n * Creates the cursor iterates tokens with options.\n * @param {CursorFactory} factory The cursor factory to initialize cursor.\n * @param {Token[]} tokens The array of tokens.\n * @param {Comment[]} comments The array of comments.\n * @param {Object} indexMap The map from locations to indices in `tokens`.\n * @param {number} startLoc The start location of the iteration range.\n * @param {number} endLoc The end location of the iteration range.\n * @param {number|Function|Object} [opts=0] The option object. If this is a number then it's `opts.skip`. If this is a function then it's `opts.filter`.\n * @param {boolean} [opts.includeComments=false] The flag to iterate comments as well.\n * @param {Function|null} [opts.filter=null] The predicate function to choose tokens.\n * @param {number} [opts.skip=0] The count of tokens the cursor skips.\n * @returns {Cursor} The created cursor.\n * @private\n */\nfunction createCursorWithSkip(factory, tokens, comments, indexMap, startLoc, endLoc, opts) {\n    let includeComments = false;\n    let skip = 0;\n    let filter = null;\n\n    if (typeof opts === \"number\") {\n        skip = opts | 0;\n    } else if (typeof opts === \"function\") {\n        filter = opts;\n    } else if (opts) {\n        includeComments = !!opts.includeComments;\n        skip = opts.skip | 0;\n        filter = opts.filter || null;\n    }\n    assert(skip >= 0, \"options.skip should be zero or a positive integer.\");\n    assert(!filter || typeof filter === \"function\", \"options.filter should be a function.\");\n\n    return factory.createCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments, filter, skip, -1);\n}\n\n/**\n * Creates the cursor iterates tokens with options.\n * @param {CursorFactory} factory The cursor factory to initialize cursor.\n * @param {Token[]} tokens The array of tokens.\n * @param {Comment[]} comments The array of comments.\n * @param {Object} indexMap The map from locations to indices in `tokens`.\n * @param {number} startLoc The start location of the iteration range.\n * @param {number} endLoc The end location of the iteration range.\n * @param {number|Function|Object} [opts=0] The option object. If this is a number then it's `opts.count`. If this is a function then it's `opts.filter`.\n * @param {boolean} [opts.includeComments] The flag to iterate comments as well.\n * @param {Function|null} [opts.filter=null] The predicate function to choose tokens.\n * @param {number} [opts.count=0] The maximum count of tokens the cursor iterates. Zero is no iteration for backward compatibility.\n * @returns {Cursor} The created cursor.\n * @private\n */\nfunction createCursorWithCount(factory, tokens, comments, indexMap, startLoc, endLoc, opts) {\n    let includeComments = false;\n    let count = 0;\n    let countExists = false;\n    let filter = null;\n\n    if (typeof opts === \"number\") {\n        count = opts | 0;\n        countExists = true;\n    } else if (typeof opts === \"function\") {\n        filter = opts;\n    } else if (opts) {\n        includeComments = !!opts.includeComments;\n        count = opts.count | 0;\n        countExists = typeof opts.count === \"number\";\n        filter = opts.filter || null;\n    }\n    assert(count >= 0, \"options.count should be zero or a positive integer.\");\n    assert(!filter || typeof filter === \"function\", \"options.filter should be a function.\");\n\n    return factory.createCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments, filter, 0, countExists ? count : -1);\n}\n\n/**\n * Creates the cursor iterates tokens with options.\n * This is overload function of the below.\n * @param {Token[]} tokens The array of tokens.\n * @param {Comment[]} comments The array of comments.\n * @param {Object} indexMap The map from locations to indices in `tokens`.\n * @param {number} startLoc The start location of the iteration range.\n * @param {number} endLoc The end location of the iteration range.\n * @param {Function|Object} opts The option object. If this is a function then it's `opts.filter`.\n * @param {boolean} [opts.includeComments] The flag to iterate comments as well.\n * @param {Function|null} [opts.filter=null] The predicate function to choose tokens.\n * @param {number} [opts.count=0] The maximum count of tokens the cursor iterates. Zero is no iteration for backward compatibility.\n * @returns {Cursor} The created cursor.\n * @private\n */\n/**\n * Creates the cursor iterates tokens with options.\n * @param {Token[]} tokens The array of tokens.\n * @param {Comment[]} comments The array of comments.\n * @param {Object} indexMap The map from locations to indices in `tokens`.\n * @param {number} startLoc The start location of the iteration range.\n * @param {number} endLoc The end location of the iteration range.\n * @param {number} [beforeCount=0] The number of tokens before the node to retrieve.\n * @param {boolean} [afterCount=0] The number of tokens after the node to retrieve.\n * @returns {Cursor} The created cursor.\n * @private\n */\nfunction createCursorWithPadding(tokens, comments, indexMap, startLoc, endLoc, beforeCount, afterCount) {\n    if (typeof beforeCount === \"undefined\" && typeof afterCount === \"undefined\") {\n        return new ForwardTokenCursor(tokens, comments, indexMap, startLoc, endLoc);\n    }\n    if (typeof beforeCount === \"number\" || typeof beforeCount === \"undefined\") {\n        return new PaddedTokenCursor(tokens, comments, indexMap, startLoc, endLoc, beforeCount | 0, afterCount | 0);\n    }\n    return createCursorWithCount(cursors.forward, tokens, comments, indexMap, startLoc, endLoc, beforeCount);\n}\n\n/**\n * Gets comment tokens that are adjacent to the current cursor position.\n * @param {Cursor} cursor A cursor instance.\n * @returns {Array} An array of comment tokens adjacent to the current cursor position.\n * @private\n */\nfunction getAdjacentCommentTokensFromCursor(cursor) {\n    const tokens = [];\n    let currentToken = cursor.getOneToken();\n\n    while (currentToken && isCommentToken(currentToken)) {\n        tokens.push(currentToken);\n        currentToken = cursor.getOneToken();\n    }\n\n    return tokens;\n}\n\n//------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\n/**\n * The token store.\n *\n * This class provides methods to get tokens by locations as fast as possible.\n * The methods are a part of public API, so we should be careful if it changes this class.\n *\n * People can get tokens in O(1) by the hash map which is mapping from the location of tokens/comments to tokens.\n * Also people can get a mix of tokens and comments in O(log k), the k is the number of comments.\n * Assuming that comments to be much fewer than tokens, this does not make hash map from token's locations to comments to reduce memory cost.\n * This uses binary-searching instead for comments.\n */\nmodule.exports = class TokenStore {\n\n    /**\n     * Initializes this token store.\n     * @param {Token[]} tokens The array of tokens.\n     * @param {Comment[]} comments The array of comments.\n     */\n    constructor(tokens, comments) {\n        this[TOKENS] = tokens;\n        this[COMMENTS] = comments;\n        this[INDEX_MAP] = createIndexMap(tokens, comments);\n    }\n\n    //--------------------------------------------------------------------------\n    // Gets single token.\n    //--------------------------------------------------------------------------\n\n    /**\n     * Gets the token starting at the specified index.\n     * @param {number} offset Index of the start of the token's range.\n     * @param {Object} [options=0] The option object.\n     * @param {boolean} [options.includeComments=false] The flag to iterate comments as well.\n     * @returns {Token|null} The token starting at index, or null if no such token.\n     */\n    getTokenByRangeStart(offset, options) {\n        const includeComments = options && options.includeComments;\n        const token = cursors.forward.createBaseCursor(\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            offset,\n            -1,\n            includeComments\n        ).getOneToken();\n\n        if (token && token.range[0] === offset) {\n            return token;\n        }\n        return null;\n    }\n\n    /**\n     * Gets the first token of the given node.\n     * @param {ASTNode} node The AST node.\n     * @param {number|Function|Object} [options=0] The option object. If this is a number then it's `options.skip`. If this is a function then it's `options.filter`.\n     * @param {boolean} [options.includeComments=false] The flag to iterate comments as well.\n     * @param {Function|null} [options.filter=null] The predicate function to choose tokens.\n     * @param {number} [options.skip=0] The count of tokens the cursor skips.\n     * @returns {Token|null} An object representing the token.\n     */\n    getFirstToken(node, options) {\n        return createCursorWithSkip(\n            cursors.forward,\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            node.range[0],\n            node.range[1],\n            options\n        ).getOneToken();\n    }\n\n    /**\n     * Gets the last token of the given node.\n     * @param {ASTNode} node The AST node.\n     * @param {number|Function|Object} [options=0] The option object. Same options as getFirstToken()\n     * @returns {Token|null} An object representing the token.\n     */\n    getLastToken(node, options) {\n        return createCursorWithSkip(\n            cursors.backward,\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            node.range[0],\n            node.range[1],\n            options\n        ).getOneToken();\n    }\n\n    /**\n     * Gets the token that precedes a given node or token.\n     * @param {ASTNode|Token|Comment} node The AST node or token.\n     * @param {number|Function|Object} [options=0] The option object. Same options as getFirstToken()\n     * @returns {Token|null} An object representing the token.\n     */\n    getTokenBefore(node, options) {\n        return createCursorWithSkip(\n            cursors.backward,\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            -1,\n            node.range[0],\n            options\n        ).getOneToken();\n    }\n\n    /**\n     * Gets the token that follows a given node or token.\n     * @param {ASTNode|Token|Comment} node The AST node or token.\n     * @param {number|Function|Object} [options=0] The option object. Same options as getFirstToken()\n     * @returns {Token|null} An object representing the token.\n     */\n    getTokenAfter(node, options) {\n        return createCursorWithSkip(\n            cursors.forward,\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            node.range[1],\n            -1,\n            options\n        ).getOneToken();\n    }\n\n    /**\n     * Gets the first token between two non-overlapping nodes.\n     * @param {ASTNode|Token|Comment} left Node before the desired token range.\n     * @param {ASTNode|Token|Comment} right Node after the desired token range.\n     * @param {number|Function|Object} [options=0] The option object. Same options as getFirstToken()\n     * @returns {Token|null} An object representing the token.\n     */\n    getFirstTokenBetween(left, right, options) {\n        return createCursorWithSkip(\n            cursors.forward,\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            left.range[1],\n            right.range[0],\n            options\n        ).getOneToken();\n    }\n\n    /**\n     * Gets the last token between two non-overlapping nodes.\n     * @param {ASTNode|Token|Comment} left Node before the desired token range.\n     * @param {ASTNode|Token|Comment} right Node after the desired token range.\n     * @param {number|Function|Object} [options=0] The option object. Same options as getFirstToken()\n     * @returns {Token|null} An object representing the token.\n     */\n    getLastTokenBetween(left, right, options) {\n        return createCursorWithSkip(\n            cursors.backward,\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            left.range[1],\n            right.range[0],\n            options\n        ).getOneToken();\n    }\n\n    /**\n     * Gets the token that precedes a given node or token in the token stream.\n     * This is defined for backward compatibility. Use `includeComments` option instead.\n     * TODO: We have a plan to remove this in a future major version.\n     * @param {ASTNode|Token|Comment} node The AST node or token.\n     * @param {number} [skip=0] A number of tokens to skip.\n     * @returns {Token|null} An object representing the token.\n     * @deprecated\n     */\n    getTokenOrCommentBefore(node, skip) {\n        return this.getTokenBefore(node, { includeComments: true, skip });\n    }\n\n    /**\n     * Gets the token that follows a given node or token in the token stream.\n     * This is defined for backward compatibility. Use `includeComments` option instead.\n     * TODO: We have a plan to remove this in a future major version.\n     * @param {ASTNode|Token|Comment} node The AST node or token.\n     * @param {number} [skip=0] A number of tokens to skip.\n     * @returns {Token|null} An object representing the token.\n     * @deprecated\n     */\n    getTokenOrCommentAfter(node, skip) {\n        return this.getTokenAfter(node, { includeComments: true, skip });\n    }\n\n    //--------------------------------------------------------------------------\n    // Gets multiple tokens.\n    //--------------------------------------------------------------------------\n\n    /**\n     * Gets the first `count` tokens of the given node.\n     * @param {ASTNode} node The AST node.\n     * @param {number|Function|Object} [options=0] The option object. If this is a number then it's `options.count`. If this is a function then it's `options.filter`.\n     * @param {boolean} [options.includeComments=false] The flag to iterate comments as well.\n     * @param {Function|null} [options.filter=null] The predicate function to choose tokens.\n     * @param {number} [options.count=0] The maximum count of tokens the cursor iterates.\n     * @returns {Token[]} Tokens.\n     */\n    getFirstTokens(node, options) {\n        return createCursorWithCount(\n            cursors.forward,\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            node.range[0],\n            node.range[1],\n            options\n        ).getAllTokens();\n    }\n\n    /**\n     * Gets the last `count` tokens of the given node.\n     * @param {ASTNode} node The AST node.\n     * @param {number|Function|Object} [options=0] The option object. Same options as getFirstTokens()\n     * @returns {Token[]} Tokens.\n     */\n    getLastTokens(node, options) {\n        return createCursorWithCount(\n            cursors.backward,\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            node.range[0],\n            node.range[1],\n            options\n        ).getAllTokens().reverse();\n    }\n\n    /**\n     * Gets the `count` tokens that precedes a given node or token.\n     * @param {ASTNode|Token|Comment} node The AST node or token.\n     * @param {number|Function|Object} [options=0] The option object. Same options as getFirstTokens()\n     * @returns {Token[]} Tokens.\n     */\n    getTokensBefore(node, options) {\n        return createCursorWithCount(\n            cursors.backward,\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            -1,\n            node.range[0],\n            options\n        ).getAllTokens().reverse();\n    }\n\n    /**\n     * Gets the `count` tokens that follows a given node or token.\n     * @param {ASTNode|Token|Comment} node The AST node or token.\n     * @param {number|Function|Object} [options=0] The option object. Same options as getFirstTokens()\n     * @returns {Token[]} Tokens.\n     */\n    getTokensAfter(node, options) {\n        return createCursorWithCount(\n            cursors.forward,\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            node.range[1],\n            -1,\n            options\n        ).getAllTokens();\n    }\n\n    /**\n     * Gets the first `count` tokens between two non-overlapping nodes.\n     * @param {ASTNode|Token|Comment} left Node before the desired token range.\n     * @param {ASTNode|Token|Comment} right Node after the desired token range.\n     * @param {number|Function|Object} [options=0] The option object. Same options as getFirstTokens()\n     * @returns {Token[]} Tokens between left and right.\n     */\n    getFirstTokensBetween(left, right, options) {\n        return createCursorWithCount(\n            cursors.forward,\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            left.range[1],\n            right.range[0],\n            options\n        ).getAllTokens();\n    }\n\n    /**\n     * Gets the last `count` tokens between two non-overlapping nodes.\n     * @param {ASTNode|Token|Comment} left Node before the desired token range.\n     * @param {ASTNode|Token|Comment} right Node after the desired token range.\n     * @param {number|Function|Object} [options=0] The option object. Same options as getFirstTokens()\n     * @returns {Token[]} Tokens between left and right.\n     */\n    getLastTokensBetween(left, right, options) {\n        return createCursorWithCount(\n            cursors.backward,\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            left.range[1],\n            right.range[0],\n            options\n        ).getAllTokens().reverse();\n    }\n\n    /**\n     * Gets all tokens that are related to the given node.\n     * @param {ASTNode} node The AST node.\n     * @param {Function|Object} options The option object. If this is a function then it's `options.filter`.\n     * @param {boolean} [options.includeComments=false] The flag to iterate comments as well.\n     * @param {Function|null} [options.filter=null] The predicate function to choose tokens.\n     * @param {number} [options.count=0] The maximum count of tokens the cursor iterates.\n     * @returns {Token[]} Array of objects representing tokens.\n     */\n    /**\n     * Gets all tokens that are related to the given node.\n     * @param {ASTNode} node The AST node.\n     * @param {int} [beforeCount=0] The number of tokens before the node to retrieve.\n     * @param {int} [afterCount=0] The number of tokens after the node to retrieve.\n     * @returns {Token[]} Array of objects representing tokens.\n     */\n    getTokens(node, beforeCount, afterCount) {\n        return createCursorWithPadding(\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            node.range[0],\n            node.range[1],\n            beforeCount,\n            afterCount\n        ).getAllTokens();\n    }\n\n    /**\n     * Gets all of the tokens between two non-overlapping nodes.\n     * @param {ASTNode|Token|Comment} left Node before the desired token range.\n     * @param {ASTNode|Token|Comment} right Node after the desired token range.\n     * @param {Function|Object} options The option object. If this is a function then it's `options.filter`.\n     * @param {boolean} [options.includeComments=false] The flag to iterate comments as well.\n     * @param {Function|null} [options.filter=null] The predicate function to choose tokens.\n     * @param {number} [options.count=0] The maximum count of tokens the cursor iterates.\n     * @returns {Token[]} Tokens between left and right.\n     */\n    /**\n     * Gets all of the tokens between two non-overlapping nodes.\n     * @param {ASTNode|Token|Comment} left Node before the desired token range.\n     * @param {ASTNode|Token|Comment} right Node after the desired token range.\n     * @param {int} [padding=0] Number of extra tokens on either side of center.\n     * @returns {Token[]} Tokens between left and right.\n     */\n    getTokensBetween(left, right, padding) {\n        return createCursorWithPadding(\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            left.range[1],\n            right.range[0],\n            padding,\n            padding\n        ).getAllTokens();\n    }\n\n    //--------------------------------------------------------------------------\n    // Others.\n    //--------------------------------------------------------------------------\n\n    /**\n     * Checks whether any comments exist or not between the given 2 nodes.\n     * @param {ASTNode} left The node to check.\n     * @param {ASTNode} right The node to check.\n     * @returns {boolean} `true` if one or more comments exist.\n     */\n    commentsExistBetween(left, right) {\n        const index = utils.search(this[COMMENTS], left.range[1]);\n\n        return (\n            index < this[COMMENTS].length &&\n            this[COMMENTS][index].range[1] <= right.range[0]\n        );\n    }\n\n    /**\n     * Gets all comment tokens directly before the given node or token.\n     * @param {ASTNode|token} nodeOrToken The AST node or token to check for adjacent comment tokens.\n     * @returns {Array} An array of comments in occurrence order.\n     */\n    getCommentsBefore(nodeOrToken) {\n        const cursor = createCursorWithCount(\n            cursors.backward,\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            -1,\n            nodeOrToken.range[0],\n            { includeComments: true }\n        );\n\n        return getAdjacentCommentTokensFromCursor(cursor).reverse();\n    }\n\n    /**\n     * Gets all comment tokens directly after the given node or token.\n     * @param {ASTNode|token} nodeOrToken The AST node or token to check for adjacent comment tokens.\n     * @returns {Array} An array of comments in occurrence order.\n     */\n    getCommentsAfter(nodeOrToken) {\n        const cursor = createCursorWithCount(\n            cursors.forward,\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            nodeOrToken.range[1],\n            -1,\n            { includeComments: true }\n        );\n\n        return getAdjacentCommentTokensFromCursor(cursor);\n    }\n\n    /**\n     * Gets all comment tokens inside the given node.\n     * @param {ASTNode} node The AST node to get the comments for.\n     * @returns {Array} An array of comments in occurrence order.\n     */\n    getCommentsInside(node) {\n        return this.getTokens(node, {\n            includeComments: true,\n            filter: isCommentToken\n        });\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}