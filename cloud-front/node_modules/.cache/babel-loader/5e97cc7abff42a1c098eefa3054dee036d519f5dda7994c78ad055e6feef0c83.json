{"ast":null,"code":"/**\n * @fileoverview A rule to disallow the type conversions with shorter notations.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst INDEX_OF_PATTERN = /^(?:i|lastI)ndexOf$/u;\nconst ALLOWABLE_OPERATORS = [\"~\", \"!!\", \"+\", \"*\"];\n\n/**\n * Parses and normalizes an option object.\n * @param {Object} options An option object to parse.\n * @returns {Object} The parsed and normalized option object.\n */\nfunction parseOptions(options) {\n  return {\n    boolean: \"boolean\" in options ? options.boolean : true,\n    number: \"number\" in options ? options.number : true,\n    string: \"string\" in options ? options.string : true,\n    disallowTemplateShorthand: \"disallowTemplateShorthand\" in options ? options.disallowTemplateShorthand : false,\n    allow: options.allow || []\n  };\n}\n\n/**\n * Checks whether or not a node is a double logical nigating.\n * @param {ASTNode} node An UnaryExpression node to check.\n * @returns {boolean} Whether or not the node is a double logical nigating.\n */\nfunction isDoubleLogicalNegating(node) {\n  return node.operator === \"!\" && node.argument.type === \"UnaryExpression\" && node.argument.operator === \"!\";\n}\n\n/**\n * Checks whether or not a node is a binary negating of `.indexOf()` method calling.\n * @param {ASTNode} node An UnaryExpression node to check.\n * @returns {boolean} Whether or not the node is a binary negating of `.indexOf()` method calling.\n */\nfunction isBinaryNegatingOfIndexOf(node) {\n  if (node.operator !== \"~\") {\n    return false;\n  }\n  const callNode = astUtils.skipChainExpression(node.argument);\n  return callNode.type === \"CallExpression\" && astUtils.isSpecificMemberAccess(callNode.callee, null, INDEX_OF_PATTERN);\n}\n\n/**\n * Checks whether or not a node is a multiplying by one.\n * @param {BinaryExpression} node A BinaryExpression node to check.\n * @returns {boolean} Whether or not the node is a multiplying by one.\n */\nfunction isMultiplyByOne(node) {\n  return node.operator === \"*\" && (node.left.type === \"Literal\" && node.left.value === 1 || node.right.type === \"Literal\" && node.right.value === 1);\n}\n\n/**\n * Checks whether the result of a node is numeric or not\n * @param {ASTNode} node The node to test\n * @returns {boolean} true if the node is a number literal or a `Number()`, `parseInt` or `parseFloat` call\n */\nfunction isNumeric(node) {\n  return node.type === \"Literal\" && typeof node.value === \"number\" || node.type === \"CallExpression\" && (node.callee.name === \"Number\" || node.callee.name === \"parseInt\" || node.callee.name === \"parseFloat\");\n}\n\n/**\n * Returns the first non-numeric operand in a BinaryExpression. Designed to be\n * used from bottom to up since it walks up the BinaryExpression trees using\n * node.parent to find the result.\n * @param {BinaryExpression} node The BinaryExpression node to be walked up on\n * @returns {ASTNode|null} The first non-numeric item in the BinaryExpression tree or null\n */\nfunction getNonNumericOperand(node) {\n  const left = node.left,\n    right = node.right;\n  if (right.type !== \"BinaryExpression\" && !isNumeric(right)) {\n    return right;\n  }\n  if (left.type !== \"BinaryExpression\" && !isNumeric(left)) {\n    return left;\n  }\n  return null;\n}\n\n/**\n * Checks whether an expression evaluates to a string.\n * @param {ASTNode} node node that represents the expression to check.\n * @returns {boolean} Whether or not the expression evaluates to a string.\n */\nfunction isStringType(node) {\n  return astUtils.isStringLiteral(node) || node.type === \"CallExpression\" && node.callee.type === \"Identifier\" && node.callee.name === \"String\";\n}\n\n/**\n * Checks whether a node is an empty string literal or not.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} Whether or not the passed in node is an\n * empty string literal or not.\n */\nfunction isEmptyString(node) {\n  return astUtils.isStringLiteral(node) && (node.value === \"\" || node.type === \"TemplateLiteral\" && node.quasis.length === 1 && node.quasis[0].value.cooked === \"\");\n}\n\n/**\n * Checks whether or not a node is a concatenating with an empty string.\n * @param {ASTNode} node A BinaryExpression node to check.\n * @returns {boolean} Whether or not the node is a concatenating with an empty string.\n */\nfunction isConcatWithEmptyString(node) {\n  return node.operator === \"+\" && (isEmptyString(node.left) && !isStringType(node.right) || isEmptyString(node.right) && !isStringType(node.left));\n}\n\n/**\n * Checks whether or not a node is appended with an empty string.\n * @param {ASTNode} node An AssignmentExpression node to check.\n * @returns {boolean} Whether or not the node is appended with an empty string.\n */\nfunction isAppendEmptyString(node) {\n  return node.operator === \"+=\" && isEmptyString(node.right);\n}\n\n/**\n * Returns the operand that is not an empty string from a flagged BinaryExpression.\n * @param {ASTNode} node The flagged BinaryExpression node to check.\n * @returns {ASTNode} The operand that is not an empty string from a flagged BinaryExpression.\n */\nfunction getNonEmptyOperand(node) {\n  return isEmptyString(node.left) ? node.right : node.left;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow shorthand type conversions\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-implicit-coercion\"\n    },\n    fixable: \"code\",\n    schema: [{\n      type: \"object\",\n      properties: {\n        boolean: {\n          type: \"boolean\",\n          default: true\n        },\n        number: {\n          type: \"boolean\",\n          default: true\n        },\n        string: {\n          type: \"boolean\",\n          default: true\n        },\n        disallowTemplateShorthand: {\n          type: \"boolean\",\n          default: false\n        },\n        allow: {\n          type: \"array\",\n          items: {\n            enum: ALLOWABLE_OPERATORS\n          },\n          uniqueItems: true\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      useRecommendation: \"use `{{recommendation}}` instead.\"\n    }\n  },\n  create(context) {\n    const options = parseOptions(context.options[0] || {});\n    const sourceCode = context.getSourceCode();\n\n    /**\n     * Reports an error and autofixes the node\n     * @param {ASTNode} node An ast node to report the error on.\n     * @param {string} recommendation The recommended code for the issue\n     * @param {bool} shouldFix Whether this report should fix the node\n     * @returns {void}\n     */\n    function report(node, recommendation, shouldFix) {\n      context.report({\n        node,\n        messageId: \"useRecommendation\",\n        data: {\n          recommendation\n        },\n        fix(fixer) {\n          if (!shouldFix) {\n            return null;\n          }\n          const tokenBefore = sourceCode.getTokenBefore(node);\n          if (tokenBefore && tokenBefore.range[1] === node.range[0] && !astUtils.canTokensBeAdjacent(tokenBefore, recommendation)) {\n            return fixer.replaceText(node, ` ${recommendation}`);\n          }\n          return fixer.replaceText(node, recommendation);\n        }\n      });\n    }\n    return {\n      UnaryExpression(node) {\n        let operatorAllowed;\n\n        // !!foo\n        operatorAllowed = options.allow.indexOf(\"!!\") >= 0;\n        if (!operatorAllowed && options.boolean && isDoubleLogicalNegating(node)) {\n          const recommendation = `Boolean(${sourceCode.getText(node.argument.argument)})`;\n          report(node, recommendation, true);\n        }\n\n        // ~foo.indexOf(bar)\n        operatorAllowed = options.allow.indexOf(\"~\") >= 0;\n        if (!operatorAllowed && options.boolean && isBinaryNegatingOfIndexOf(node)) {\n          // `foo?.indexOf(bar) !== -1` will be true (== found) if the `foo` is nullish. So use `>= 0` in that case.\n          const comparison = node.argument.type === \"ChainExpression\" ? \">= 0\" : \"!== -1\";\n          const recommendation = `${sourceCode.getText(node.argument)} ${comparison}`;\n          report(node, recommendation, false);\n        }\n\n        // +foo\n        operatorAllowed = options.allow.indexOf(\"+\") >= 0;\n        if (!operatorAllowed && options.number && node.operator === \"+\" && !isNumeric(node.argument)) {\n          const recommendation = `Number(${sourceCode.getText(node.argument)})`;\n          report(node, recommendation, true);\n        }\n      },\n      // Use `:exit` to prevent double reporting\n      \"BinaryExpression:exit\"(node) {\n        let operatorAllowed;\n\n        // 1 * foo\n        operatorAllowed = options.allow.indexOf(\"*\") >= 0;\n        const nonNumericOperand = !operatorAllowed && options.number && isMultiplyByOne(node) && getNonNumericOperand(node);\n        if (nonNumericOperand) {\n          const recommendation = `Number(${sourceCode.getText(nonNumericOperand)})`;\n          report(node, recommendation, true);\n        }\n\n        // \"\" + foo\n        operatorAllowed = options.allow.indexOf(\"+\") >= 0;\n        if (!operatorAllowed && options.string && isConcatWithEmptyString(node)) {\n          const recommendation = `String(${sourceCode.getText(getNonEmptyOperand(node))})`;\n          report(node, recommendation, true);\n        }\n      },\n      AssignmentExpression(node) {\n        // foo += \"\"\n        const operatorAllowed = options.allow.indexOf(\"+\") >= 0;\n        if (!operatorAllowed && options.string && isAppendEmptyString(node)) {\n          const code = sourceCode.getText(getNonEmptyOperand(node));\n          const recommendation = `${code} = String(${code})`;\n          report(node, recommendation, true);\n        }\n      },\n      TemplateLiteral(node) {\n        if (!options.disallowTemplateShorthand) {\n          return;\n        }\n\n        // tag`${foo}`\n        if (node.parent.type === \"TaggedTemplateExpression\") {\n          return;\n        }\n\n        // `` or `${foo}${bar}`\n        if (node.expressions.length !== 1) {\n          return;\n        }\n\n        //  `prefix${foo}`\n        if (node.quasis[0].value.cooked !== \"\") {\n          return;\n        }\n\n        //  `${foo}postfix`\n        if (node.quasis[1].value.cooked !== \"\") {\n          return;\n        }\n\n        // if the expression is already a string, then this isn't a coercion\n        if (isStringType(node.expressions[0])) {\n          return;\n        }\n        const code = sourceCode.getText(node.expressions[0]);\n        const recommendation = `String(${code})`;\n        report(node, recommendation, true);\n      }\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","INDEX_OF_PATTERN","ALLOWABLE_OPERATORS","parseOptions","options","boolean","number","string","disallowTemplateShorthand","allow","isDoubleLogicalNegating","node","operator","argument","type","isBinaryNegatingOfIndexOf","callNode","skipChainExpression","isSpecificMemberAccess","callee","isMultiplyByOne","left","value","right","isNumeric","name","getNonNumericOperand","isStringType","isStringLiteral","isEmptyString","quasis","length","cooked","isConcatWithEmptyString","isAppendEmptyString","getNonEmptyOperand","module","exports","meta","docs","description","category","recommended","url","fixable","schema","properties","default","items","enum","uniqueItems","additionalProperties","messages","useRecommendation","create","context","sourceCode","getSourceCode","report","recommendation","shouldFix","messageId","data","fix","fixer","tokenBefore","getTokenBefore","range","canTokensBeAdjacent","replaceText","UnaryExpression","operatorAllowed","indexOf","getText","comparison","BinaryExpression:exit","nonNumericOperand","AssignmentExpression","code","TemplateLiteral","parent","expressions"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/no-implicit-coercion.js"],"sourcesContent":["/**\n * @fileoverview A rule to disallow the type conversions with shorter notations.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst INDEX_OF_PATTERN = /^(?:i|lastI)ndexOf$/u;\nconst ALLOWABLE_OPERATORS = [\"~\", \"!!\", \"+\", \"*\"];\n\n/**\n * Parses and normalizes an option object.\n * @param {Object} options An option object to parse.\n * @returns {Object} The parsed and normalized option object.\n */\nfunction parseOptions(options) {\n    return {\n        boolean: \"boolean\" in options ? options.boolean : true,\n        number: \"number\" in options ? options.number : true,\n        string: \"string\" in options ? options.string : true,\n        disallowTemplateShorthand: \"disallowTemplateShorthand\" in options ? options.disallowTemplateShorthand : false,\n        allow: options.allow || []\n    };\n}\n\n/**\n * Checks whether or not a node is a double logical nigating.\n * @param {ASTNode} node An UnaryExpression node to check.\n * @returns {boolean} Whether or not the node is a double logical nigating.\n */\nfunction isDoubleLogicalNegating(node) {\n    return (\n        node.operator === \"!\" &&\n        node.argument.type === \"UnaryExpression\" &&\n        node.argument.operator === \"!\"\n    );\n}\n\n/**\n * Checks whether or not a node is a binary negating of `.indexOf()` method calling.\n * @param {ASTNode} node An UnaryExpression node to check.\n * @returns {boolean} Whether or not the node is a binary negating of `.indexOf()` method calling.\n */\nfunction isBinaryNegatingOfIndexOf(node) {\n    if (node.operator !== \"~\") {\n        return false;\n    }\n    const callNode = astUtils.skipChainExpression(node.argument);\n\n    return (\n        callNode.type === \"CallExpression\" &&\n        astUtils.isSpecificMemberAccess(callNode.callee, null, INDEX_OF_PATTERN)\n    );\n}\n\n/**\n * Checks whether or not a node is a multiplying by one.\n * @param {BinaryExpression} node A BinaryExpression node to check.\n * @returns {boolean} Whether or not the node is a multiplying by one.\n */\nfunction isMultiplyByOne(node) {\n    return node.operator === \"*\" && (\n        node.left.type === \"Literal\" && node.left.value === 1 ||\n        node.right.type === \"Literal\" && node.right.value === 1\n    );\n}\n\n/**\n * Checks whether the result of a node is numeric or not\n * @param {ASTNode} node The node to test\n * @returns {boolean} true if the node is a number literal or a `Number()`, `parseInt` or `parseFloat` call\n */\nfunction isNumeric(node) {\n    return (\n        node.type === \"Literal\" && typeof node.value === \"number\" ||\n        node.type === \"CallExpression\" && (\n            node.callee.name === \"Number\" ||\n            node.callee.name === \"parseInt\" ||\n            node.callee.name === \"parseFloat\"\n        )\n    );\n}\n\n/**\n * Returns the first non-numeric operand in a BinaryExpression. Designed to be\n * used from bottom to up since it walks up the BinaryExpression trees using\n * node.parent to find the result.\n * @param {BinaryExpression} node The BinaryExpression node to be walked up on\n * @returns {ASTNode|null} The first non-numeric item in the BinaryExpression tree or null\n */\nfunction getNonNumericOperand(node) {\n    const left = node.left,\n        right = node.right;\n\n    if (right.type !== \"BinaryExpression\" && !isNumeric(right)) {\n        return right;\n    }\n\n    if (left.type !== \"BinaryExpression\" && !isNumeric(left)) {\n        return left;\n    }\n\n    return null;\n}\n\n/**\n * Checks whether an expression evaluates to a string.\n * @param {ASTNode} node node that represents the expression to check.\n * @returns {boolean} Whether or not the expression evaluates to a string.\n */\nfunction isStringType(node) {\n    return astUtils.isStringLiteral(node) ||\n        (\n            node.type === \"CallExpression\" &&\n            node.callee.type === \"Identifier\" &&\n            node.callee.name === \"String\"\n        );\n}\n\n/**\n * Checks whether a node is an empty string literal or not.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} Whether or not the passed in node is an\n * empty string literal or not.\n */\nfunction isEmptyString(node) {\n    return astUtils.isStringLiteral(node) && (node.value === \"\" || (node.type === \"TemplateLiteral\" && node.quasis.length === 1 && node.quasis[0].value.cooked === \"\"));\n}\n\n/**\n * Checks whether or not a node is a concatenating with an empty string.\n * @param {ASTNode} node A BinaryExpression node to check.\n * @returns {boolean} Whether or not the node is a concatenating with an empty string.\n */\nfunction isConcatWithEmptyString(node) {\n    return node.operator === \"+\" && (\n        (isEmptyString(node.left) && !isStringType(node.right)) ||\n        (isEmptyString(node.right) && !isStringType(node.left))\n    );\n}\n\n/**\n * Checks whether or not a node is appended with an empty string.\n * @param {ASTNode} node An AssignmentExpression node to check.\n * @returns {boolean} Whether or not the node is appended with an empty string.\n */\nfunction isAppendEmptyString(node) {\n    return node.operator === \"+=\" && isEmptyString(node.right);\n}\n\n/**\n * Returns the operand that is not an empty string from a flagged BinaryExpression.\n * @param {ASTNode} node The flagged BinaryExpression node to check.\n * @returns {ASTNode} The operand that is not an empty string from a flagged BinaryExpression.\n */\nfunction getNonEmptyOperand(node) {\n    return isEmptyString(node.left) ? node.right : node.left;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow shorthand type conversions\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-implicit-coercion\"\n        },\n\n        fixable: \"code\",\n\n        schema: [{\n            type: \"object\",\n            properties: {\n                boolean: {\n                    type: \"boolean\",\n                    default: true\n                },\n                number: {\n                    type: \"boolean\",\n                    default: true\n                },\n                string: {\n                    type: \"boolean\",\n                    default: true\n                },\n                disallowTemplateShorthand: {\n                    type: \"boolean\",\n                    default: false\n                },\n                allow: {\n                    type: \"array\",\n                    items: {\n                        enum: ALLOWABLE_OPERATORS\n                    },\n                    uniqueItems: true\n                }\n            },\n            additionalProperties: false\n        }],\n\n        messages: {\n            useRecommendation: \"use `{{recommendation}}` instead.\"\n        }\n    },\n\n    create(context) {\n        const options = parseOptions(context.options[0] || {});\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Reports an error and autofixes the node\n         * @param {ASTNode} node An ast node to report the error on.\n         * @param {string} recommendation The recommended code for the issue\n         * @param {bool} shouldFix Whether this report should fix the node\n         * @returns {void}\n         */\n        function report(node, recommendation, shouldFix) {\n            context.report({\n                node,\n                messageId: \"useRecommendation\",\n                data: {\n                    recommendation\n                },\n                fix(fixer) {\n                    if (!shouldFix) {\n                        return null;\n                    }\n\n                    const tokenBefore = sourceCode.getTokenBefore(node);\n\n                    if (\n                        tokenBefore &&\n                        tokenBefore.range[1] === node.range[0] &&\n                        !astUtils.canTokensBeAdjacent(tokenBefore, recommendation)\n                    ) {\n                        return fixer.replaceText(node, ` ${recommendation}`);\n                    }\n                    return fixer.replaceText(node, recommendation);\n                }\n            });\n        }\n\n        return {\n            UnaryExpression(node) {\n                let operatorAllowed;\n\n                // !!foo\n                operatorAllowed = options.allow.indexOf(\"!!\") >= 0;\n                if (!operatorAllowed && options.boolean && isDoubleLogicalNegating(node)) {\n                    const recommendation = `Boolean(${sourceCode.getText(node.argument.argument)})`;\n\n                    report(node, recommendation, true);\n                }\n\n                // ~foo.indexOf(bar)\n                operatorAllowed = options.allow.indexOf(\"~\") >= 0;\n                if (!operatorAllowed && options.boolean && isBinaryNegatingOfIndexOf(node)) {\n\n                    // `foo?.indexOf(bar) !== -1` will be true (== found) if the `foo` is nullish. So use `>= 0` in that case.\n                    const comparison = node.argument.type === \"ChainExpression\" ? \">= 0\" : \"!== -1\";\n                    const recommendation = `${sourceCode.getText(node.argument)} ${comparison}`;\n\n                    report(node, recommendation, false);\n                }\n\n                // +foo\n                operatorAllowed = options.allow.indexOf(\"+\") >= 0;\n                if (!operatorAllowed && options.number && node.operator === \"+\" && !isNumeric(node.argument)) {\n                    const recommendation = `Number(${sourceCode.getText(node.argument)})`;\n\n                    report(node, recommendation, true);\n                }\n            },\n\n            // Use `:exit` to prevent double reporting\n            \"BinaryExpression:exit\"(node) {\n                let operatorAllowed;\n\n                // 1 * foo\n                operatorAllowed = options.allow.indexOf(\"*\") >= 0;\n                const nonNumericOperand = !operatorAllowed && options.number && isMultiplyByOne(node) && getNonNumericOperand(node);\n\n                if (nonNumericOperand) {\n                    const recommendation = `Number(${sourceCode.getText(nonNumericOperand)})`;\n\n                    report(node, recommendation, true);\n                }\n\n                // \"\" + foo\n                operatorAllowed = options.allow.indexOf(\"+\") >= 0;\n                if (!operatorAllowed && options.string && isConcatWithEmptyString(node)) {\n                    const recommendation = `String(${sourceCode.getText(getNonEmptyOperand(node))})`;\n\n                    report(node, recommendation, true);\n                }\n            },\n\n            AssignmentExpression(node) {\n\n                // foo += \"\"\n                const operatorAllowed = options.allow.indexOf(\"+\") >= 0;\n\n                if (!operatorAllowed && options.string && isAppendEmptyString(node)) {\n                    const code = sourceCode.getText(getNonEmptyOperand(node));\n                    const recommendation = `${code} = String(${code})`;\n\n                    report(node, recommendation, true);\n                }\n            },\n\n            TemplateLiteral(node) {\n                if (!options.disallowTemplateShorthand) {\n                    return;\n                }\n\n                // tag`${foo}`\n                if (node.parent.type === \"TaggedTemplateExpression\") {\n                    return;\n                }\n\n                // `` or `${foo}${bar}`\n                if (node.expressions.length !== 1) {\n                    return;\n                }\n\n\n                //  `prefix${foo}`\n                if (node.quasis[0].value.cooked !== \"\") {\n                    return;\n                }\n\n                //  `${foo}postfix`\n                if (node.quasis[1].value.cooked !== \"\") {\n                    return;\n                }\n\n                // if the expression is already a string, then this isn't a coercion\n                if (isStringType(node.expressions[0])) {\n                    return;\n                }\n\n                const code = sourceCode.getText(node.expressions[0]);\n                const recommendation = `String(${code})`;\n\n                report(node, recommendation, true);\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}