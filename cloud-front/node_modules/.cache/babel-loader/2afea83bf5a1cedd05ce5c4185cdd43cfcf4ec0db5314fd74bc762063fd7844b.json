{"ast":null,"code":"/**\n * @fileoverview Rule to enforce concise object methods and properties.\n * @author Jamund Ferguson\n */\n\n\"use strict\";\n\nconst OPTIONS = {\n  always: \"always\",\n  never: \"never\",\n  methods: \"methods\",\n  properties: \"properties\",\n  consistent: \"consistent\",\n  consistentAsNeeded: \"consistent-as-needed\"\n};\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require or disallow method and property shorthand syntax for object literals\",\n      category: \"ECMAScript 6\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/object-shorthand\"\n    },\n    fixable: \"code\",\n    schema: {\n      anyOf: [{\n        type: \"array\",\n        items: [{\n          enum: [\"always\", \"methods\", \"properties\", \"never\", \"consistent\", \"consistent-as-needed\"]\n        }],\n        minItems: 0,\n        maxItems: 1\n      }, {\n        type: \"array\",\n        items: [{\n          enum: [\"always\", \"methods\", \"properties\"]\n        }, {\n          type: \"object\",\n          properties: {\n            avoidQuotes: {\n              type: \"boolean\"\n            }\n          },\n          additionalProperties: false\n        }],\n        minItems: 0,\n        maxItems: 2\n      }, {\n        type: \"array\",\n        items: [{\n          enum: [\"always\", \"methods\"]\n        }, {\n          type: \"object\",\n          properties: {\n            ignoreConstructors: {\n              type: \"boolean\"\n            },\n            avoidQuotes: {\n              type: \"boolean\"\n            },\n            avoidExplicitReturnArrows: {\n              type: \"boolean\"\n            }\n          },\n          additionalProperties: false\n        }],\n        minItems: 0,\n        maxItems: 2\n      }]\n    },\n    messages: {\n      expectedAllPropertiesShorthanded: \"Expected shorthand for all properties.\",\n      expectedLiteralMethodLongform: \"Expected longform method syntax for string literal keys.\",\n      expectedPropertyShorthand: \"Expected property shorthand.\",\n      expectedPropertyLongform: \"Expected longform property syntax.\",\n      expectedMethodShorthand: \"Expected method shorthand.\",\n      expectedMethodLongform: \"Expected longform method syntax.\",\n      unexpectedMix: \"Unexpected mix of shorthand and non-shorthand properties.\"\n    }\n  },\n  create(context) {\n    const APPLY = context.options[0] || OPTIONS.always;\n    const APPLY_TO_METHODS = APPLY === OPTIONS.methods || APPLY === OPTIONS.always;\n    const APPLY_TO_PROPS = APPLY === OPTIONS.properties || APPLY === OPTIONS.always;\n    const APPLY_NEVER = APPLY === OPTIONS.never;\n    const APPLY_CONSISTENT = APPLY === OPTIONS.consistent;\n    const APPLY_CONSISTENT_AS_NEEDED = APPLY === OPTIONS.consistentAsNeeded;\n    const PARAMS = context.options[1] || {};\n    const IGNORE_CONSTRUCTORS = PARAMS.ignoreConstructors;\n    const AVOID_QUOTES = PARAMS.avoidQuotes;\n    const AVOID_EXPLICIT_RETURN_ARROWS = !!PARAMS.avoidExplicitReturnArrows;\n    const sourceCode = context.getSourceCode();\n\n    //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    const CTOR_PREFIX_REGEX = /[^_$0-9]/u;\n\n    /**\n     * Determines if the first character of the name is a capital letter.\n     * @param {string} name The name of the node to evaluate.\n     * @returns {boolean} True if the first character of the property name is a capital letter, false if not.\n     * @private\n     */\n    function isConstructor(name) {\n      const match = CTOR_PREFIX_REGEX.exec(name);\n\n      // Not a constructor if name has no characters apart from '_', '$' and digits e.g. '_', '$$', '_8'\n      if (!match) {\n        return false;\n      }\n      const firstChar = name.charAt(match.index);\n      return firstChar === firstChar.toUpperCase();\n    }\n\n    /**\n     * Determines if the property can have a shorthand form.\n     * @param {ASTNode} property Property AST node\n     * @returns {boolean} True if the property can have a shorthand form\n     * @private\n     *\n     */\n    function canHaveShorthand(property) {\n      return property.kind !== \"set\" && property.kind !== \"get\" && property.type !== \"SpreadElement\" && property.type !== \"SpreadProperty\" && property.type !== \"ExperimentalSpreadProperty\";\n    }\n\n    /**\n     * Checks whether a node is a string literal.\n     * @param   {ASTNode} node Any AST node.\n     * @returns {boolean} `true` if it is a string literal.\n     */\n    function isStringLiteral(node) {\n      return node.type === \"Literal\" && typeof node.value === \"string\";\n    }\n\n    /**\n     * Determines if the property is a shorthand or not.\n     * @param {ASTNode} property Property AST node\n     * @returns {boolean} True if the property is considered shorthand, false if not.\n     * @private\n     *\n     */\n    function isShorthand(property) {\n      // property.method is true when `{a(){}}`.\n      return property.shorthand || property.method;\n    }\n\n    /**\n     * Determines if the property's key and method or value are named equally.\n     * @param {ASTNode} property Property AST node\n     * @returns {boolean} True if the key and value are named equally, false if not.\n     * @private\n     *\n     */\n    function isRedundant(property) {\n      const value = property.value;\n      if (value.type === \"FunctionExpression\") {\n        return !value.id; // Only anonymous should be shorthand method.\n      }\n\n      if (value.type === \"Identifier\") {\n        return astUtils.getStaticPropertyName(property) === value.name;\n      }\n      return false;\n    }\n\n    /**\n     * Ensures that an object's properties are consistently shorthand, or not shorthand at all.\n     * @param   {ASTNode} node Property AST node\n     * @param   {boolean} checkRedundancy Whether to check longform redundancy\n     * @returns {void}\n     *\n     */\n    function checkConsistency(node, checkRedundancy) {\n      // We are excluding getters/setters and spread properties as they are considered neither longform nor shorthand.\n      const properties = node.properties.filter(canHaveShorthand);\n\n      // Do we still have properties left after filtering the getters and setters?\n      if (properties.length > 0) {\n        const shorthandProperties = properties.filter(isShorthand);\n\n        /*\n         * If we do not have an equal number of longform properties as\n         * shorthand properties, we are using the annotations inconsistently\n         */\n        if (shorthandProperties.length !== properties.length) {\n          // We have at least 1 shorthand property\n          if (shorthandProperties.length > 0) {\n            context.report({\n              node,\n              messageId: \"unexpectedMix\"\n            });\n          } else if (checkRedundancy) {\n            /*\n             * If all properties of the object contain a method or value with a name matching it's key,\n             * all the keys are redundant.\n             */\n            const canAlwaysUseShorthand = properties.every(isRedundant);\n            if (canAlwaysUseShorthand) {\n              context.report({\n                node,\n                messageId: \"expectedAllPropertiesShorthanded\"\n              });\n            }\n          }\n        }\n      }\n    }\n\n    /**\n     * Fixes a FunctionExpression node by making it into a shorthand property.\n     * @param {SourceCodeFixer} fixer The fixer object\n     * @param {ASTNode} node A `Property` node that has a `FunctionExpression` or `ArrowFunctionExpression` as its value\n     * @returns {Object} A fix for this node\n     */\n    function makeFunctionShorthand(fixer, node) {\n      const firstKeyToken = node.computed ? sourceCode.getFirstToken(node, astUtils.isOpeningBracketToken) : sourceCode.getFirstToken(node.key);\n      const lastKeyToken = node.computed ? sourceCode.getFirstTokenBetween(node.key, node.value, astUtils.isClosingBracketToken) : sourceCode.getLastToken(node.key);\n      const keyText = sourceCode.text.slice(firstKeyToken.range[0], lastKeyToken.range[1]);\n      let keyPrefix = \"\";\n\n      // key: /* */ () => {}\n      if (sourceCode.commentsExistBetween(lastKeyToken, node.value)) {\n        return null;\n      }\n      if (node.value.async) {\n        keyPrefix += \"async \";\n      }\n      if (node.value.generator) {\n        keyPrefix += \"*\";\n      }\n      const fixRange = [firstKeyToken.range[0], node.range[1]];\n      const methodPrefix = keyPrefix + keyText;\n      if (node.value.type === \"FunctionExpression\") {\n        const functionToken = sourceCode.getTokens(node.value).find(token => token.type === \"Keyword\" && token.value === \"function\");\n        const tokenBeforeParams = node.value.generator ? sourceCode.getTokenAfter(functionToken) : functionToken;\n        return fixer.replaceTextRange(fixRange, methodPrefix + sourceCode.text.slice(tokenBeforeParams.range[1], node.value.range[1]));\n      }\n      const arrowToken = sourceCode.getTokenBefore(node.value.body, astUtils.isArrowToken);\n      const fnBody = sourceCode.text.slice(arrowToken.range[1], node.value.range[1]);\n      let shouldAddParensAroundParameters = false;\n      let tokenBeforeParams;\n      if (node.value.params.length === 0) {\n        tokenBeforeParams = sourceCode.getFirstToken(node.value, astUtils.isOpeningParenToken);\n      } else {\n        tokenBeforeParams = sourceCode.getTokenBefore(node.value.params[0]);\n      }\n      if (node.value.params.length === 1) {\n        const hasParen = astUtils.isOpeningParenToken(tokenBeforeParams);\n        const isTokenOutsideNode = tokenBeforeParams.range[0] < node.range[0];\n        shouldAddParensAroundParameters = !hasParen || isTokenOutsideNode;\n      }\n      const sliceStart = shouldAddParensAroundParameters ? node.value.params[0].range[0] : tokenBeforeParams.range[0];\n      const sliceEnd = sourceCode.getTokenBefore(arrowToken).range[1];\n      const oldParamText = sourceCode.text.slice(sliceStart, sliceEnd);\n      const newParamText = shouldAddParensAroundParameters ? `(${oldParamText})` : oldParamText;\n      return fixer.replaceTextRange(fixRange, methodPrefix + newParamText + fnBody);\n    }\n\n    /**\n     * Fixes a FunctionExpression node by making it into a longform property.\n     * @param {SourceCodeFixer} fixer The fixer object\n     * @param {ASTNode} node A `Property` node that has a `FunctionExpression` as its value\n     * @returns {Object} A fix for this node\n     */\n    function makeFunctionLongform(fixer, node) {\n      const firstKeyToken = node.computed ? sourceCode.getTokens(node).find(token => token.value === \"[\") : sourceCode.getFirstToken(node.key);\n      const lastKeyToken = node.computed ? sourceCode.getTokensBetween(node.key, node.value).find(token => token.value === \"]\") : sourceCode.getLastToken(node.key);\n      const keyText = sourceCode.text.slice(firstKeyToken.range[0], lastKeyToken.range[1]);\n      let functionHeader = \"function\";\n      if (node.value.async) {\n        functionHeader = `async ${functionHeader}`;\n      }\n      if (node.value.generator) {\n        functionHeader = `${functionHeader}*`;\n      }\n      return fixer.replaceTextRange([node.range[0], lastKeyToken.range[1]], `${keyText}: ${functionHeader}`);\n    }\n\n    /*\n     * To determine whether a given arrow function has a lexical identifier (`this`, `arguments`, `super`, or `new.target`),\n     * create a stack of functions that define these identifiers (i.e. all functions except arrow functions) as the AST is\n     * traversed. Whenever a new function is encountered, create a new entry on the stack (corresponding to a different lexical\n     * scope of `this`), and whenever a function is exited, pop that entry off the stack. When an arrow function is entered,\n     * keep a reference to it on the current stack entry, and remove that reference when the arrow function is exited.\n     * When a lexical identifier is encountered, mark all the arrow functions on the current stack entry by adding them\n     * to an `arrowsWithLexicalIdentifiers` set. Any arrow function in that set will not be reported by this rule,\n     * because converting it into a method would change the value of one of the lexical identifiers.\n     */\n    const lexicalScopeStack = [];\n    const arrowsWithLexicalIdentifiers = new WeakSet();\n    const argumentsIdentifiers = new WeakSet();\n\n    /**\n     * Enters a function. This creates a new lexical identifier scope, so a new Set of arrow functions is pushed onto the stack.\n     * Also, this marks all `arguments` identifiers so that they can be detected later.\n     * @returns {void}\n     */\n    function enterFunction() {\n      lexicalScopeStack.unshift(new Set());\n      context.getScope().variables.filter(variable => variable.name === \"arguments\").forEach(variable => {\n        variable.references.map(ref => ref.identifier).forEach(identifier => argumentsIdentifiers.add(identifier));\n      });\n    }\n\n    /**\n     * Exits a function. This pops the current set of arrow functions off the lexical scope stack.\n     * @returns {void}\n     */\n    function exitFunction() {\n      lexicalScopeStack.shift();\n    }\n\n    /**\n     * Marks the current function as having a lexical keyword. This implies that all arrow functions\n     * in the current lexical scope contain a reference to this lexical keyword.\n     * @returns {void}\n     */\n    function reportLexicalIdentifier() {\n      lexicalScopeStack[0].forEach(arrowFunction => arrowsWithLexicalIdentifiers.add(arrowFunction));\n    }\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    return {\n      Program: enterFunction,\n      FunctionDeclaration: enterFunction,\n      FunctionExpression: enterFunction,\n      \"Program:exit\": exitFunction,\n      \"FunctionDeclaration:exit\": exitFunction,\n      \"FunctionExpression:exit\": exitFunction,\n      ArrowFunctionExpression(node) {\n        lexicalScopeStack[0].add(node);\n      },\n      \"ArrowFunctionExpression:exit\"(node) {\n        lexicalScopeStack[0].delete(node);\n      },\n      ThisExpression: reportLexicalIdentifier,\n      Super: reportLexicalIdentifier,\n      MetaProperty(node) {\n        if (node.meta.name === \"new\" && node.property.name === \"target\") {\n          reportLexicalIdentifier();\n        }\n      },\n      Identifier(node) {\n        if (argumentsIdentifiers.has(node)) {\n          reportLexicalIdentifier();\n        }\n      },\n      ObjectExpression(node) {\n        if (APPLY_CONSISTENT) {\n          checkConsistency(node, false);\n        } else if (APPLY_CONSISTENT_AS_NEEDED) {\n          checkConsistency(node, true);\n        }\n      },\n      \"Property:exit\"(node) {\n        const isConciseProperty = node.method || node.shorthand;\n\n        // Ignore destructuring assignment\n        if (node.parent.type === \"ObjectPattern\") {\n          return;\n        }\n\n        // getters and setters are ignored\n        if (node.kind === \"get\" || node.kind === \"set\") {\n          return;\n        }\n\n        // only computed methods can fail the following checks\n        if (node.computed && node.value.type !== \"FunctionExpression\" && node.value.type !== \"ArrowFunctionExpression\") {\n          return;\n        }\n\n        //--------------------------------------------------------------\n        // Checks for property/method shorthand.\n        if (isConciseProperty) {\n          if (node.method && (APPLY_NEVER || AVOID_QUOTES && isStringLiteral(node.key))) {\n            const messageId = APPLY_NEVER ? \"expectedMethodLongform\" : \"expectedLiteralMethodLongform\";\n\n            // { x() {} } should be written as { x: function() {} }\n            context.report({\n              node,\n              messageId,\n              fix: fixer => makeFunctionLongform(fixer, node)\n            });\n          } else if (APPLY_NEVER) {\n            // { x } should be written as { x: x }\n            context.report({\n              node,\n              messageId: \"expectedPropertyLongform\",\n              fix: fixer => fixer.insertTextAfter(node.key, `: ${node.key.name}`)\n            });\n          }\n        } else if (APPLY_TO_METHODS && !node.value.id && (node.value.type === \"FunctionExpression\" || node.value.type === \"ArrowFunctionExpression\")) {\n          if (IGNORE_CONSTRUCTORS && node.key.type === \"Identifier\" && isConstructor(node.key.name)) {\n            return;\n          }\n          if (AVOID_QUOTES && isStringLiteral(node.key)) {\n            return;\n          }\n\n          // {[x]: function(){}} should be written as {[x]() {}}\n          if (node.value.type === \"FunctionExpression\" || node.value.type === \"ArrowFunctionExpression\" && node.value.body.type === \"BlockStatement\" && AVOID_EXPLICIT_RETURN_ARROWS && !arrowsWithLexicalIdentifiers.has(node.value)) {\n            context.report({\n              node,\n              messageId: \"expectedMethodShorthand\",\n              fix: fixer => makeFunctionShorthand(fixer, node)\n            });\n          }\n        } else if (node.value.type === \"Identifier\" && node.key.name === node.value.name && APPLY_TO_PROPS) {\n          // {x: x} should be written as {x}\n          context.report({\n            node,\n            messageId: \"expectedPropertyShorthand\",\n            fix(fixer) {\n              return fixer.replaceText(node, node.value.name);\n            }\n          });\n        } else if (node.value.type === \"Identifier\" && node.key.type === \"Literal\" && node.key.value === node.value.name && APPLY_TO_PROPS) {\n          if (AVOID_QUOTES) {\n            return;\n          }\n\n          // {\"x\": x} should be written as {x}\n          context.report({\n            node,\n            messageId: \"expectedPropertyShorthand\",\n            fix(fixer) {\n              return fixer.replaceText(node, node.value.name);\n            }\n          });\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["OPTIONS","always","never","methods","properties","consistent","consistentAsNeeded","astUtils","require","module","exports","meta","type","docs","description","category","recommended","url","fixable","schema","anyOf","items","enum","minItems","maxItems","avoidQuotes","additionalProperties","ignoreConstructors","avoidExplicitReturnArrows","messages","expectedAllPropertiesShorthanded","expectedLiteralMethodLongform","expectedPropertyShorthand","expectedPropertyLongform","expectedMethodShorthand","expectedMethodLongform","unexpectedMix","create","context","APPLY","options","APPLY_TO_METHODS","APPLY_TO_PROPS","APPLY_NEVER","APPLY_CONSISTENT","APPLY_CONSISTENT_AS_NEEDED","PARAMS","IGNORE_CONSTRUCTORS","AVOID_QUOTES","AVOID_EXPLICIT_RETURN_ARROWS","sourceCode","getSourceCode","CTOR_PREFIX_REGEX","isConstructor","name","match","exec","firstChar","charAt","index","toUpperCase","canHaveShorthand","property","kind","isStringLiteral","node","value","isShorthand","shorthand","method","isRedundant","id","getStaticPropertyName","checkConsistency","checkRedundancy","filter","length","shorthandProperties","report","messageId","canAlwaysUseShorthand","every","makeFunctionShorthand","fixer","firstKeyToken","computed","getFirstToken","isOpeningBracketToken","key","lastKeyToken","getFirstTokenBetween","isClosingBracketToken","getLastToken","keyText","text","slice","range","keyPrefix","commentsExistBetween","async","generator","fixRange","methodPrefix","functionToken","getTokens","find","token","tokenBeforeParams","getTokenAfter","replaceTextRange","arrowToken","getTokenBefore","body","isArrowToken","fnBody","shouldAddParensAroundParameters","params","isOpeningParenToken","hasParen","isTokenOutsideNode","sliceStart","sliceEnd","oldParamText","newParamText","makeFunctionLongform","getTokensBetween","functionHeader","lexicalScopeStack","arrowsWithLexicalIdentifiers","WeakSet","argumentsIdentifiers","enterFunction","unshift","Set","getScope","variables","variable","forEach","references","map","ref","identifier","add","exitFunction","shift","reportLexicalIdentifier","arrowFunction","Program","FunctionDeclaration","FunctionExpression","ArrowFunctionExpression","ArrowFunctionExpression:exit","delete","ThisExpression","Super","MetaProperty","Identifier","has","ObjectExpression","Property:exit","isConciseProperty","parent","fix","insertTextAfter","replaceText"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/object-shorthand.js"],"sourcesContent":["/**\n * @fileoverview Rule to enforce concise object methods and properties.\n * @author Jamund Ferguson\n */\n\n\"use strict\";\n\nconst OPTIONS = {\n    always: \"always\",\n    never: \"never\",\n    methods: \"methods\",\n    properties: \"properties\",\n    consistent: \"consistent\",\n    consistentAsNeeded: \"consistent-as-needed\"\n};\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require or disallow method and property shorthand syntax for object literals\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/object-shorthand\"\n        },\n\n        fixable: \"code\",\n\n        schema: {\n            anyOf: [\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"always\", \"methods\", \"properties\", \"never\", \"consistent\", \"consistent-as-needed\"]\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 1\n                },\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"always\", \"methods\", \"properties\"]\n                        },\n                        {\n                            type: \"object\",\n                            properties: {\n                                avoidQuotes: {\n                                    type: \"boolean\"\n                                }\n                            },\n                            additionalProperties: false\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 2\n                },\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"always\", \"methods\"]\n                        },\n                        {\n                            type: \"object\",\n                            properties: {\n                                ignoreConstructors: {\n                                    type: \"boolean\"\n                                },\n                                avoidQuotes: {\n                                    type: \"boolean\"\n                                },\n                                avoidExplicitReturnArrows: {\n                                    type: \"boolean\"\n                                }\n                            },\n                            additionalProperties: false\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 2\n                }\n            ]\n        },\n\n        messages: {\n            expectedAllPropertiesShorthanded: \"Expected shorthand for all properties.\",\n            expectedLiteralMethodLongform: \"Expected longform method syntax for string literal keys.\",\n            expectedPropertyShorthand: \"Expected property shorthand.\",\n            expectedPropertyLongform: \"Expected longform property syntax.\",\n            expectedMethodShorthand: \"Expected method shorthand.\",\n            expectedMethodLongform: \"Expected longform method syntax.\",\n            unexpectedMix: \"Unexpected mix of shorthand and non-shorthand properties.\"\n        }\n    },\n\n    create(context) {\n        const APPLY = context.options[0] || OPTIONS.always;\n        const APPLY_TO_METHODS = APPLY === OPTIONS.methods || APPLY === OPTIONS.always;\n        const APPLY_TO_PROPS = APPLY === OPTIONS.properties || APPLY === OPTIONS.always;\n        const APPLY_NEVER = APPLY === OPTIONS.never;\n        const APPLY_CONSISTENT = APPLY === OPTIONS.consistent;\n        const APPLY_CONSISTENT_AS_NEEDED = APPLY === OPTIONS.consistentAsNeeded;\n\n        const PARAMS = context.options[1] || {};\n        const IGNORE_CONSTRUCTORS = PARAMS.ignoreConstructors;\n        const AVOID_QUOTES = PARAMS.avoidQuotes;\n        const AVOID_EXPLICIT_RETURN_ARROWS = !!PARAMS.avoidExplicitReturnArrows;\n        const sourceCode = context.getSourceCode();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        const CTOR_PREFIX_REGEX = /[^_$0-9]/u;\n\n        /**\n         * Determines if the first character of the name is a capital letter.\n         * @param {string} name The name of the node to evaluate.\n         * @returns {boolean} True if the first character of the property name is a capital letter, false if not.\n         * @private\n         */\n        function isConstructor(name) {\n            const match = CTOR_PREFIX_REGEX.exec(name);\n\n            // Not a constructor if name has no characters apart from '_', '$' and digits e.g. '_', '$$', '_8'\n            if (!match) {\n                return false;\n            }\n\n            const firstChar = name.charAt(match.index);\n\n            return firstChar === firstChar.toUpperCase();\n        }\n\n        /**\n         * Determines if the property can have a shorthand form.\n         * @param {ASTNode} property Property AST node\n         * @returns {boolean} True if the property can have a shorthand form\n         * @private\n         *\n         */\n        function canHaveShorthand(property) {\n            return (property.kind !== \"set\" && property.kind !== \"get\" && property.type !== \"SpreadElement\" && property.type !== \"SpreadProperty\" && property.type !== \"ExperimentalSpreadProperty\");\n        }\n\n        /**\n         * Checks whether a node is a string literal.\n         * @param   {ASTNode} node Any AST node.\n         * @returns {boolean} `true` if it is a string literal.\n         */\n        function isStringLiteral(node) {\n            return node.type === \"Literal\" && typeof node.value === \"string\";\n        }\n\n        /**\n         * Determines if the property is a shorthand or not.\n         * @param {ASTNode} property Property AST node\n         * @returns {boolean} True if the property is considered shorthand, false if not.\n         * @private\n         *\n         */\n        function isShorthand(property) {\n\n            // property.method is true when `{a(){}}`.\n            return (property.shorthand || property.method);\n        }\n\n        /**\n         * Determines if the property's key and method or value are named equally.\n         * @param {ASTNode} property Property AST node\n         * @returns {boolean} True if the key and value are named equally, false if not.\n         * @private\n         *\n         */\n        function isRedundant(property) {\n            const value = property.value;\n\n            if (value.type === \"FunctionExpression\") {\n                return !value.id; // Only anonymous should be shorthand method.\n            }\n            if (value.type === \"Identifier\") {\n                return astUtils.getStaticPropertyName(property) === value.name;\n            }\n\n            return false;\n        }\n\n        /**\n         * Ensures that an object's properties are consistently shorthand, or not shorthand at all.\n         * @param   {ASTNode} node Property AST node\n         * @param   {boolean} checkRedundancy Whether to check longform redundancy\n         * @returns {void}\n         *\n         */\n        function checkConsistency(node, checkRedundancy) {\n\n            // We are excluding getters/setters and spread properties as they are considered neither longform nor shorthand.\n            const properties = node.properties.filter(canHaveShorthand);\n\n            // Do we still have properties left after filtering the getters and setters?\n            if (properties.length > 0) {\n                const shorthandProperties = properties.filter(isShorthand);\n\n                /*\n                 * If we do not have an equal number of longform properties as\n                 * shorthand properties, we are using the annotations inconsistently\n                 */\n                if (shorthandProperties.length !== properties.length) {\n\n                    // We have at least 1 shorthand property\n                    if (shorthandProperties.length > 0) {\n                        context.report({ node, messageId: \"unexpectedMix\" });\n                    } else if (checkRedundancy) {\n\n                        /*\n                         * If all properties of the object contain a method or value with a name matching it's key,\n                         * all the keys are redundant.\n                         */\n                        const canAlwaysUseShorthand = properties.every(isRedundant);\n\n                        if (canAlwaysUseShorthand) {\n                            context.report({ node, messageId: \"expectedAllPropertiesShorthanded\" });\n                        }\n                    }\n                }\n            }\n        }\n\n        /**\n         * Fixes a FunctionExpression node by making it into a shorthand property.\n         * @param {SourceCodeFixer} fixer The fixer object\n         * @param {ASTNode} node A `Property` node that has a `FunctionExpression` or `ArrowFunctionExpression` as its value\n         * @returns {Object} A fix for this node\n         */\n        function makeFunctionShorthand(fixer, node) {\n            const firstKeyToken = node.computed\n                ? sourceCode.getFirstToken(node, astUtils.isOpeningBracketToken)\n                : sourceCode.getFirstToken(node.key);\n            const lastKeyToken = node.computed\n                ? sourceCode.getFirstTokenBetween(node.key, node.value, astUtils.isClosingBracketToken)\n                : sourceCode.getLastToken(node.key);\n            const keyText = sourceCode.text.slice(firstKeyToken.range[0], lastKeyToken.range[1]);\n            let keyPrefix = \"\";\n\n            // key: /* */ () => {}\n            if (sourceCode.commentsExistBetween(lastKeyToken, node.value)) {\n                return null;\n            }\n\n            if (node.value.async) {\n                keyPrefix += \"async \";\n            }\n            if (node.value.generator) {\n                keyPrefix += \"*\";\n            }\n\n            const fixRange = [firstKeyToken.range[0], node.range[1]];\n            const methodPrefix = keyPrefix + keyText;\n\n            if (node.value.type === \"FunctionExpression\") {\n                const functionToken = sourceCode.getTokens(node.value).find(token => token.type === \"Keyword\" && token.value === \"function\");\n                const tokenBeforeParams = node.value.generator ? sourceCode.getTokenAfter(functionToken) : functionToken;\n\n                return fixer.replaceTextRange(\n                    fixRange,\n                    methodPrefix + sourceCode.text.slice(tokenBeforeParams.range[1], node.value.range[1])\n                );\n            }\n\n            const arrowToken = sourceCode.getTokenBefore(node.value.body, astUtils.isArrowToken);\n            const fnBody = sourceCode.text.slice(arrowToken.range[1], node.value.range[1]);\n\n            let shouldAddParensAroundParameters = false;\n            let tokenBeforeParams;\n\n            if (node.value.params.length === 0) {\n                tokenBeforeParams = sourceCode.getFirstToken(node.value, astUtils.isOpeningParenToken);\n            } else {\n                tokenBeforeParams = sourceCode.getTokenBefore(node.value.params[0]);\n            }\n\n            if (node.value.params.length === 1) {\n                const hasParen = astUtils.isOpeningParenToken(tokenBeforeParams);\n                const isTokenOutsideNode = tokenBeforeParams.range[0] < node.range[0];\n\n                shouldAddParensAroundParameters = !hasParen || isTokenOutsideNode;\n            }\n\n            const sliceStart = shouldAddParensAroundParameters\n                ? node.value.params[0].range[0]\n                : tokenBeforeParams.range[0];\n            const sliceEnd = sourceCode.getTokenBefore(arrowToken).range[1];\n\n            const oldParamText = sourceCode.text.slice(sliceStart, sliceEnd);\n            const newParamText = shouldAddParensAroundParameters ? `(${oldParamText})` : oldParamText;\n\n            return fixer.replaceTextRange(\n                fixRange,\n                methodPrefix + newParamText + fnBody\n            );\n\n        }\n\n        /**\n         * Fixes a FunctionExpression node by making it into a longform property.\n         * @param {SourceCodeFixer} fixer The fixer object\n         * @param {ASTNode} node A `Property` node that has a `FunctionExpression` as its value\n         * @returns {Object} A fix for this node\n         */\n        function makeFunctionLongform(fixer, node) {\n            const firstKeyToken = node.computed ? sourceCode.getTokens(node).find(token => token.value === \"[\") : sourceCode.getFirstToken(node.key);\n            const lastKeyToken = node.computed ? sourceCode.getTokensBetween(node.key, node.value).find(token => token.value === \"]\") : sourceCode.getLastToken(node.key);\n            const keyText = sourceCode.text.slice(firstKeyToken.range[0], lastKeyToken.range[1]);\n            let functionHeader = \"function\";\n\n            if (node.value.async) {\n                functionHeader = `async ${functionHeader}`;\n            }\n            if (node.value.generator) {\n                functionHeader = `${functionHeader}*`;\n            }\n\n            return fixer.replaceTextRange([node.range[0], lastKeyToken.range[1]], `${keyText}: ${functionHeader}`);\n        }\n\n        /*\n         * To determine whether a given arrow function has a lexical identifier (`this`, `arguments`, `super`, or `new.target`),\n         * create a stack of functions that define these identifiers (i.e. all functions except arrow functions) as the AST is\n         * traversed. Whenever a new function is encountered, create a new entry on the stack (corresponding to a different lexical\n         * scope of `this`), and whenever a function is exited, pop that entry off the stack. When an arrow function is entered,\n         * keep a reference to it on the current stack entry, and remove that reference when the arrow function is exited.\n         * When a lexical identifier is encountered, mark all the arrow functions on the current stack entry by adding them\n         * to an `arrowsWithLexicalIdentifiers` set. Any arrow function in that set will not be reported by this rule,\n         * because converting it into a method would change the value of one of the lexical identifiers.\n         */\n        const lexicalScopeStack = [];\n        const arrowsWithLexicalIdentifiers = new WeakSet();\n        const argumentsIdentifiers = new WeakSet();\n\n        /**\n         * Enters a function. This creates a new lexical identifier scope, so a new Set of arrow functions is pushed onto the stack.\n         * Also, this marks all `arguments` identifiers so that they can be detected later.\n         * @returns {void}\n         */\n        function enterFunction() {\n            lexicalScopeStack.unshift(new Set());\n            context.getScope().variables.filter(variable => variable.name === \"arguments\").forEach(variable => {\n                variable.references.map(ref => ref.identifier).forEach(identifier => argumentsIdentifiers.add(identifier));\n            });\n        }\n\n        /**\n         * Exits a function. This pops the current set of arrow functions off the lexical scope stack.\n         * @returns {void}\n         */\n        function exitFunction() {\n            lexicalScopeStack.shift();\n        }\n\n        /**\n         * Marks the current function as having a lexical keyword. This implies that all arrow functions\n         * in the current lexical scope contain a reference to this lexical keyword.\n         * @returns {void}\n         */\n        function reportLexicalIdentifier() {\n            lexicalScopeStack[0].forEach(arrowFunction => arrowsWithLexicalIdentifiers.add(arrowFunction));\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            Program: enterFunction,\n            FunctionDeclaration: enterFunction,\n            FunctionExpression: enterFunction,\n            \"Program:exit\": exitFunction,\n            \"FunctionDeclaration:exit\": exitFunction,\n            \"FunctionExpression:exit\": exitFunction,\n\n            ArrowFunctionExpression(node) {\n                lexicalScopeStack[0].add(node);\n            },\n            \"ArrowFunctionExpression:exit\"(node) {\n                lexicalScopeStack[0].delete(node);\n            },\n\n            ThisExpression: reportLexicalIdentifier,\n            Super: reportLexicalIdentifier,\n            MetaProperty(node) {\n                if (node.meta.name === \"new\" && node.property.name === \"target\") {\n                    reportLexicalIdentifier();\n                }\n            },\n            Identifier(node) {\n                if (argumentsIdentifiers.has(node)) {\n                    reportLexicalIdentifier();\n                }\n            },\n\n            ObjectExpression(node) {\n                if (APPLY_CONSISTENT) {\n                    checkConsistency(node, false);\n                } else if (APPLY_CONSISTENT_AS_NEEDED) {\n                    checkConsistency(node, true);\n                }\n            },\n\n            \"Property:exit\"(node) {\n                const isConciseProperty = node.method || node.shorthand;\n\n                // Ignore destructuring assignment\n                if (node.parent.type === \"ObjectPattern\") {\n                    return;\n                }\n\n                // getters and setters are ignored\n                if (node.kind === \"get\" || node.kind === \"set\") {\n                    return;\n                }\n\n                // only computed methods can fail the following checks\n                if (node.computed && node.value.type !== \"FunctionExpression\" && node.value.type !== \"ArrowFunctionExpression\") {\n                    return;\n                }\n\n                //--------------------------------------------------------------\n                // Checks for property/method shorthand.\n                if (isConciseProperty) {\n                    if (node.method && (APPLY_NEVER || AVOID_QUOTES && isStringLiteral(node.key))) {\n                        const messageId = APPLY_NEVER ? \"expectedMethodLongform\" : \"expectedLiteralMethodLongform\";\n\n                        // { x() {} } should be written as { x: function() {} }\n                        context.report({\n                            node,\n                            messageId,\n                            fix: fixer => makeFunctionLongform(fixer, node)\n                        });\n                    } else if (APPLY_NEVER) {\n\n                        // { x } should be written as { x: x }\n                        context.report({\n                            node,\n                            messageId: \"expectedPropertyLongform\",\n                            fix: fixer => fixer.insertTextAfter(node.key, `: ${node.key.name}`)\n                        });\n                    }\n                } else if (APPLY_TO_METHODS && !node.value.id && (node.value.type === \"FunctionExpression\" || node.value.type === \"ArrowFunctionExpression\")) {\n                    if (IGNORE_CONSTRUCTORS && node.key.type === \"Identifier\" && isConstructor(node.key.name)) {\n                        return;\n                    }\n                    if (AVOID_QUOTES && isStringLiteral(node.key)) {\n                        return;\n                    }\n\n                    // {[x]: function(){}} should be written as {[x]() {}}\n                    if (node.value.type === \"FunctionExpression\" ||\n                        node.value.type === \"ArrowFunctionExpression\" &&\n                        node.value.body.type === \"BlockStatement\" &&\n                        AVOID_EXPLICIT_RETURN_ARROWS &&\n                        !arrowsWithLexicalIdentifiers.has(node.value)\n                    ) {\n                        context.report({\n                            node,\n                            messageId: \"expectedMethodShorthand\",\n                            fix: fixer => makeFunctionShorthand(fixer, node)\n                        });\n                    }\n                } else if (node.value.type === \"Identifier\" && node.key.name === node.value.name && APPLY_TO_PROPS) {\n\n                    // {x: x} should be written as {x}\n                    context.report({\n                        node,\n                        messageId: \"expectedPropertyShorthand\",\n                        fix(fixer) {\n                            return fixer.replaceText(node, node.value.name);\n                        }\n                    });\n                } else if (node.value.type === \"Identifier\" && node.key.type === \"Literal\" && node.key.value === node.value.name && APPLY_TO_PROPS) {\n                    if (AVOID_QUOTES) {\n                        return;\n                    }\n\n                    // {\"x\": x} should be written as {x}\n                    context.report({\n                        node,\n                        messageId: \"expectedPropertyShorthand\",\n                        fix(fixer) {\n                            return fixer.replaceText(node, node.value.name);\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA,YAAY;;AAEZ,MAAMA,OAAO,GAAG;EACZC,MAAM,EAAE,QAAQ;EAChBC,KAAK,EAAE,OAAO;EACdC,OAAO,EAAE,SAAS;EAClBC,UAAU,EAAE,YAAY;EACxBC,UAAU,EAAE,YAAY;EACxBC,kBAAkB,EAAE;AACxB,CAAC;;AAED;AACA;AACA;AACA,MAAMC,QAAQ,GAAGC,OAAO,CAAC,mBAAmB,CAAC;;AAE7C;AACA;AACA;AACAC,MAAM,CAACC,OAAO,GAAG;EACbC,IAAI,EAAE;IACFC,IAAI,EAAE,YAAY;IAElBC,IAAI,EAAE;MACFC,WAAW,EAAE,8EAA8E;MAC3FC,QAAQ,EAAE,cAAc;MACxBC,WAAW,EAAE,KAAK;MAClBC,GAAG,EAAE;IACT,CAAC;IAEDC,OAAO,EAAE,MAAM;IAEfC,MAAM,EAAE;MACJC,KAAK,EAAE,CACH;QACIR,IAAI,EAAE,OAAO;QACbS,KAAK,EAAE,CACH;UACIC,IAAI,EAAE,CAAC,QAAQ,EAAE,SAAS,EAAE,YAAY,EAAE,OAAO,EAAE,YAAY,EAAE,sBAAsB;QAC3F,CAAC,CACJ;QACDC,QAAQ,EAAE,CAAC;QACXC,QAAQ,EAAE;MACd,CAAC,EACD;QACIZ,IAAI,EAAE,OAAO;QACbS,KAAK,EAAE,CACH;UACIC,IAAI,EAAE,CAAC,QAAQ,EAAE,SAAS,EAAE,YAAY;QAC5C,CAAC,EACD;UACIV,IAAI,EAAE,QAAQ;UACdR,UAAU,EAAE;YACRqB,WAAW,EAAE;cACTb,IAAI,EAAE;YACV;UACJ,CAAC;UACDc,oBAAoB,EAAE;QAC1B,CAAC,CACJ;QACDH,QAAQ,EAAE,CAAC;QACXC,QAAQ,EAAE;MACd,CAAC,EACD;QACIZ,IAAI,EAAE,OAAO;QACbS,KAAK,EAAE,CACH;UACIC,IAAI,EAAE,CAAC,QAAQ,EAAE,SAAS;QAC9B,CAAC,EACD;UACIV,IAAI,EAAE,QAAQ;UACdR,UAAU,EAAE;YACRuB,kBAAkB,EAAE;cAChBf,IAAI,EAAE;YACV,CAAC;YACDa,WAAW,EAAE;cACTb,IAAI,EAAE;YACV,CAAC;YACDgB,yBAAyB,EAAE;cACvBhB,IAAI,EAAE;YACV;UACJ,CAAC;UACDc,oBAAoB,EAAE;QAC1B,CAAC,CACJ;QACDH,QAAQ,EAAE,CAAC;QACXC,QAAQ,EAAE;MACd,CAAC;IAET,CAAC;IAEDK,QAAQ,EAAE;MACNC,gCAAgC,EAAE,wCAAwC;MAC1EC,6BAA6B,EAAE,0DAA0D;MACzFC,yBAAyB,EAAE,8BAA8B;MACzDC,wBAAwB,EAAE,oCAAoC;MAC9DC,uBAAuB,EAAE,4BAA4B;MACrDC,sBAAsB,EAAE,kCAAkC;MAC1DC,aAAa,EAAE;IACnB;EACJ,CAAC;EAEDC,MAAMA,CAACC,OAAO,EAAE;IACZ,MAAMC,KAAK,GAAGD,OAAO,CAACE,OAAO,CAAC,CAAC,CAAC,IAAIxC,OAAO,CAACC,MAAM;IAClD,MAAMwC,gBAAgB,GAAGF,KAAK,KAAKvC,OAAO,CAACG,OAAO,IAAIoC,KAAK,KAAKvC,OAAO,CAACC,MAAM;IAC9E,MAAMyC,cAAc,GAAGH,KAAK,KAAKvC,OAAO,CAACI,UAAU,IAAImC,KAAK,KAAKvC,OAAO,CAACC,MAAM;IAC/E,MAAM0C,WAAW,GAAGJ,KAAK,KAAKvC,OAAO,CAACE,KAAK;IAC3C,MAAM0C,gBAAgB,GAAGL,KAAK,KAAKvC,OAAO,CAACK,UAAU;IACrD,MAAMwC,0BAA0B,GAAGN,KAAK,KAAKvC,OAAO,CAACM,kBAAkB;IAEvE,MAAMwC,MAAM,GAAGR,OAAO,CAACE,OAAO,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;IACvC,MAAMO,mBAAmB,GAAGD,MAAM,CAACnB,kBAAkB;IACrD,MAAMqB,YAAY,GAAGF,MAAM,CAACrB,WAAW;IACvC,MAAMwB,4BAA4B,GAAG,CAAC,CAACH,MAAM,CAAClB,yBAAyB;IACvE,MAAMsB,UAAU,GAAGZ,OAAO,CAACa,aAAa,CAAC,CAAC;;IAE1C;IACA;IACA;;IAEA,MAAMC,iBAAiB,GAAG,WAAW;;IAErC;AACR;AACA;AACA;AACA;AACA;IACQ,SAASC,aAAaA,CAACC,IAAI,EAAE;MACzB,MAAMC,KAAK,GAAGH,iBAAiB,CAACI,IAAI,CAACF,IAAI,CAAC;;MAE1C;MACA,IAAI,CAACC,KAAK,EAAE;QACR,OAAO,KAAK;MAChB;MAEA,MAAME,SAAS,GAAGH,IAAI,CAACI,MAAM,CAACH,KAAK,CAACI,KAAK,CAAC;MAE1C,OAAOF,SAAS,KAAKA,SAAS,CAACG,WAAW,CAAC,CAAC;IAChD;;IAEA;AACR;AACA;AACA;AACA;AACA;AACA;IACQ,SAASC,gBAAgBA,CAACC,QAAQ,EAAE;MAChC,OAAQA,QAAQ,CAACC,IAAI,KAAK,KAAK,IAAID,QAAQ,CAACC,IAAI,KAAK,KAAK,IAAID,QAAQ,CAAClD,IAAI,KAAK,eAAe,IAAIkD,QAAQ,CAAClD,IAAI,KAAK,gBAAgB,IAAIkD,QAAQ,CAAClD,IAAI,KAAK,4BAA4B;IAC3L;;IAEA;AACR;AACA;AACA;AACA;IACQ,SAASoD,eAAeA,CAACC,IAAI,EAAE;MAC3B,OAAOA,IAAI,CAACrD,IAAI,KAAK,SAAS,IAAI,OAAOqD,IAAI,CAACC,KAAK,KAAK,QAAQ;IACpE;;IAEA;AACR;AACA;AACA;AACA;AACA;AACA;IACQ,SAASC,WAAWA,CAACL,QAAQ,EAAE;MAE3B;MACA,OAAQA,QAAQ,CAACM,SAAS,IAAIN,QAAQ,CAACO,MAAM;IACjD;;IAEA;AACR;AACA;AACA;AACA;AACA;AACA;IACQ,SAASC,WAAWA,CAACR,QAAQ,EAAE;MAC3B,MAAMI,KAAK,GAAGJ,QAAQ,CAACI,KAAK;MAE5B,IAAIA,KAAK,CAACtD,IAAI,KAAK,oBAAoB,EAAE;QACrC,OAAO,CAACsD,KAAK,CAACK,EAAE,CAAC,CAAC;MACtB;;MACA,IAAIL,KAAK,CAACtD,IAAI,KAAK,YAAY,EAAE;QAC7B,OAAOL,QAAQ,CAACiE,qBAAqB,CAACV,QAAQ,CAAC,KAAKI,KAAK,CAACZ,IAAI;MAClE;MAEA,OAAO,KAAK;IAChB;;IAEA;AACR;AACA;AACA;AACA;AACA;AACA;IACQ,SAASmB,gBAAgBA,CAACR,IAAI,EAAES,eAAe,EAAE;MAE7C;MACA,MAAMtE,UAAU,GAAG6D,IAAI,CAAC7D,UAAU,CAACuE,MAAM,CAACd,gBAAgB,CAAC;;MAE3D;MACA,IAAIzD,UAAU,CAACwE,MAAM,GAAG,CAAC,EAAE;QACvB,MAAMC,mBAAmB,GAAGzE,UAAU,CAACuE,MAAM,CAACR,WAAW,CAAC;;QAE1D;AAChB;AACA;AACA;QACgB,IAAIU,mBAAmB,CAACD,MAAM,KAAKxE,UAAU,CAACwE,MAAM,EAAE;UAElD;UACA,IAAIC,mBAAmB,CAACD,MAAM,GAAG,CAAC,EAAE;YAChCtC,OAAO,CAACwC,MAAM,CAAC;cAAEb,IAAI;cAAEc,SAAS,EAAE;YAAgB,CAAC,CAAC;UACxD,CAAC,MAAM,IAAIL,eAAe,EAAE;YAExB;AACxB;AACA;AACA;YACwB,MAAMM,qBAAqB,GAAG5E,UAAU,CAAC6E,KAAK,CAACX,WAAW,CAAC;YAE3D,IAAIU,qBAAqB,EAAE;cACvB1C,OAAO,CAACwC,MAAM,CAAC;gBAAEb,IAAI;gBAAEc,SAAS,EAAE;cAAmC,CAAC,CAAC;YAC3E;UACJ;QACJ;MACJ;IACJ;;IAEA;AACR;AACA;AACA;AACA;AACA;IACQ,SAASG,qBAAqBA,CAACC,KAAK,EAAElB,IAAI,EAAE;MACxC,MAAMmB,aAAa,GAAGnB,IAAI,CAACoB,QAAQ,GAC7BnC,UAAU,CAACoC,aAAa,CAACrB,IAAI,EAAE1D,QAAQ,CAACgF,qBAAqB,CAAC,GAC9DrC,UAAU,CAACoC,aAAa,CAACrB,IAAI,CAACuB,GAAG,CAAC;MACxC,MAAMC,YAAY,GAAGxB,IAAI,CAACoB,QAAQ,GAC5BnC,UAAU,CAACwC,oBAAoB,CAACzB,IAAI,CAACuB,GAAG,EAAEvB,IAAI,CAACC,KAAK,EAAE3D,QAAQ,CAACoF,qBAAqB,CAAC,GACrFzC,UAAU,CAAC0C,YAAY,CAAC3B,IAAI,CAACuB,GAAG,CAAC;MACvC,MAAMK,OAAO,GAAG3C,UAAU,CAAC4C,IAAI,CAACC,KAAK,CAACX,aAAa,CAACY,KAAK,CAAC,CAAC,CAAC,EAAEP,YAAY,CAACO,KAAK,CAAC,CAAC,CAAC,CAAC;MACpF,IAAIC,SAAS,GAAG,EAAE;;MAElB;MACA,IAAI/C,UAAU,CAACgD,oBAAoB,CAACT,YAAY,EAAExB,IAAI,CAACC,KAAK,CAAC,EAAE;QAC3D,OAAO,IAAI;MACf;MAEA,IAAID,IAAI,CAACC,KAAK,CAACiC,KAAK,EAAE;QAClBF,SAAS,IAAI,QAAQ;MACzB;MACA,IAAIhC,IAAI,CAACC,KAAK,CAACkC,SAAS,EAAE;QACtBH,SAAS,IAAI,GAAG;MACpB;MAEA,MAAMI,QAAQ,GAAG,CAACjB,aAAa,CAACY,KAAK,CAAC,CAAC,CAAC,EAAE/B,IAAI,CAAC+B,KAAK,CAAC,CAAC,CAAC,CAAC;MACxD,MAAMM,YAAY,GAAGL,SAAS,GAAGJ,OAAO;MAExC,IAAI5B,IAAI,CAACC,KAAK,CAACtD,IAAI,KAAK,oBAAoB,EAAE;QAC1C,MAAM2F,aAAa,GAAGrD,UAAU,CAACsD,SAAS,CAACvC,IAAI,CAACC,KAAK,CAAC,CAACuC,IAAI,CAACC,KAAK,IAAIA,KAAK,CAAC9F,IAAI,KAAK,SAAS,IAAI8F,KAAK,CAACxC,KAAK,KAAK,UAAU,CAAC;QAC5H,MAAMyC,iBAAiB,GAAG1C,IAAI,CAACC,KAAK,CAACkC,SAAS,GAAGlD,UAAU,CAAC0D,aAAa,CAACL,aAAa,CAAC,GAAGA,aAAa;QAExG,OAAOpB,KAAK,CAAC0B,gBAAgB,CACzBR,QAAQ,EACRC,YAAY,GAAGpD,UAAU,CAAC4C,IAAI,CAACC,KAAK,CAACY,iBAAiB,CAACX,KAAK,CAAC,CAAC,CAAC,EAAE/B,IAAI,CAACC,KAAK,CAAC8B,KAAK,CAAC,CAAC,CAAC,CACxF,CAAC;MACL;MAEA,MAAMc,UAAU,GAAG5D,UAAU,CAAC6D,cAAc,CAAC9C,IAAI,CAACC,KAAK,CAAC8C,IAAI,EAAEzG,QAAQ,CAAC0G,YAAY,CAAC;MACpF,MAAMC,MAAM,GAAGhE,UAAU,CAAC4C,IAAI,CAACC,KAAK,CAACe,UAAU,CAACd,KAAK,CAAC,CAAC,CAAC,EAAE/B,IAAI,CAACC,KAAK,CAAC8B,KAAK,CAAC,CAAC,CAAC,CAAC;MAE9E,IAAImB,+BAA+B,GAAG,KAAK;MAC3C,IAAIR,iBAAiB;MAErB,IAAI1C,IAAI,CAACC,KAAK,CAACkD,MAAM,CAACxC,MAAM,KAAK,CAAC,EAAE;QAChC+B,iBAAiB,GAAGzD,UAAU,CAACoC,aAAa,CAACrB,IAAI,CAACC,KAAK,EAAE3D,QAAQ,CAAC8G,mBAAmB,CAAC;MAC1F,CAAC,MAAM;QACHV,iBAAiB,GAAGzD,UAAU,CAAC6D,cAAc,CAAC9C,IAAI,CAACC,KAAK,CAACkD,MAAM,CAAC,CAAC,CAAC,CAAC;MACvE;MAEA,IAAInD,IAAI,CAACC,KAAK,CAACkD,MAAM,CAACxC,MAAM,KAAK,CAAC,EAAE;QAChC,MAAM0C,QAAQ,GAAG/G,QAAQ,CAAC8G,mBAAmB,CAACV,iBAAiB,CAAC;QAChE,MAAMY,kBAAkB,GAAGZ,iBAAiB,CAACX,KAAK,CAAC,CAAC,CAAC,GAAG/B,IAAI,CAAC+B,KAAK,CAAC,CAAC,CAAC;QAErEmB,+BAA+B,GAAG,CAACG,QAAQ,IAAIC,kBAAkB;MACrE;MAEA,MAAMC,UAAU,GAAGL,+BAA+B,GAC5ClD,IAAI,CAACC,KAAK,CAACkD,MAAM,CAAC,CAAC,CAAC,CAACpB,KAAK,CAAC,CAAC,CAAC,GAC7BW,iBAAiB,CAACX,KAAK,CAAC,CAAC,CAAC;MAChC,MAAMyB,QAAQ,GAAGvE,UAAU,CAAC6D,cAAc,CAACD,UAAU,CAAC,CAACd,KAAK,CAAC,CAAC,CAAC;MAE/D,MAAM0B,YAAY,GAAGxE,UAAU,CAAC4C,IAAI,CAACC,KAAK,CAACyB,UAAU,EAAEC,QAAQ,CAAC;MAChE,MAAME,YAAY,GAAGR,+BAA+B,GAAI,IAAGO,YAAa,GAAE,GAAGA,YAAY;MAEzF,OAAOvC,KAAK,CAAC0B,gBAAgB,CACzBR,QAAQ,EACRC,YAAY,GAAGqB,YAAY,GAAGT,MAClC,CAAC;IAEL;;IAEA;AACR;AACA;AACA;AACA;AACA;IACQ,SAASU,oBAAoBA,CAACzC,KAAK,EAAElB,IAAI,EAAE;MACvC,MAAMmB,aAAa,GAAGnB,IAAI,CAACoB,QAAQ,GAAGnC,UAAU,CAACsD,SAAS,CAACvC,IAAI,CAAC,CAACwC,IAAI,CAACC,KAAK,IAAIA,KAAK,CAACxC,KAAK,KAAK,GAAG,CAAC,GAAGhB,UAAU,CAACoC,aAAa,CAACrB,IAAI,CAACuB,GAAG,CAAC;MACxI,MAAMC,YAAY,GAAGxB,IAAI,CAACoB,QAAQ,GAAGnC,UAAU,CAAC2E,gBAAgB,CAAC5D,IAAI,CAACuB,GAAG,EAAEvB,IAAI,CAACC,KAAK,CAAC,CAACuC,IAAI,CAACC,KAAK,IAAIA,KAAK,CAACxC,KAAK,KAAK,GAAG,CAAC,GAAGhB,UAAU,CAAC0C,YAAY,CAAC3B,IAAI,CAACuB,GAAG,CAAC;MAC7J,MAAMK,OAAO,GAAG3C,UAAU,CAAC4C,IAAI,CAACC,KAAK,CAACX,aAAa,CAACY,KAAK,CAAC,CAAC,CAAC,EAAEP,YAAY,CAACO,KAAK,CAAC,CAAC,CAAC,CAAC;MACpF,IAAI8B,cAAc,GAAG,UAAU;MAE/B,IAAI7D,IAAI,CAACC,KAAK,CAACiC,KAAK,EAAE;QAClB2B,cAAc,GAAI,SAAQA,cAAe,EAAC;MAC9C;MACA,IAAI7D,IAAI,CAACC,KAAK,CAACkC,SAAS,EAAE;QACtB0B,cAAc,GAAI,GAAEA,cAAe,GAAE;MACzC;MAEA,OAAO3C,KAAK,CAAC0B,gBAAgB,CAAC,CAAC5C,IAAI,CAAC+B,KAAK,CAAC,CAAC,CAAC,EAAEP,YAAY,CAACO,KAAK,CAAC,CAAC,CAAC,CAAC,EAAG,GAAEH,OAAQ,KAAIiC,cAAe,EAAC,CAAC;IAC1G;;IAEA;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQ,MAAMC,iBAAiB,GAAG,EAAE;IAC5B,MAAMC,4BAA4B,GAAG,IAAIC,OAAO,CAAC,CAAC;IAClD,MAAMC,oBAAoB,GAAG,IAAID,OAAO,CAAC,CAAC;;IAE1C;AACR;AACA;AACA;AACA;IACQ,SAASE,aAAaA,CAAA,EAAG;MACrBJ,iBAAiB,CAACK,OAAO,CAAC,IAAIC,GAAG,CAAC,CAAC,CAAC;MACpC/F,OAAO,CAACgG,QAAQ,CAAC,CAAC,CAACC,SAAS,CAAC5D,MAAM,CAAC6D,QAAQ,IAAIA,QAAQ,CAAClF,IAAI,KAAK,WAAW,CAAC,CAACmF,OAAO,CAACD,QAAQ,IAAI;QAC/FA,QAAQ,CAACE,UAAU,CAACC,GAAG,CAACC,GAAG,IAAIA,GAAG,CAACC,UAAU,CAAC,CAACJ,OAAO,CAACI,UAAU,IAAIX,oBAAoB,CAACY,GAAG,CAACD,UAAU,CAAC,CAAC;MAC9G,CAAC,CAAC;IACN;;IAEA;AACR;AACA;AACA;IACQ,SAASE,YAAYA,CAAA,EAAG;MACpBhB,iBAAiB,CAACiB,KAAK,CAAC,CAAC;IAC7B;;IAEA;AACR;AACA;AACA;AACA;IACQ,SAASC,uBAAuBA,CAAA,EAAG;MAC/BlB,iBAAiB,CAAC,CAAC,CAAC,CAACU,OAAO,CAACS,aAAa,IAAIlB,4BAA4B,CAACc,GAAG,CAACI,aAAa,CAAC,CAAC;IAClG;;IAEA;IACA;IACA;;IAEA,OAAO;MACHC,OAAO,EAAEhB,aAAa;MACtBiB,mBAAmB,EAAEjB,aAAa;MAClCkB,kBAAkB,EAAElB,aAAa;MACjC,cAAc,EAAEY,YAAY;MAC5B,0BAA0B,EAAEA,YAAY;MACxC,yBAAyB,EAAEA,YAAY;MAEvCO,uBAAuBA,CAACrF,IAAI,EAAE;QAC1B8D,iBAAiB,CAAC,CAAC,CAAC,CAACe,GAAG,CAAC7E,IAAI,CAAC;MAClC,CAAC;MACD,8BAA8BsF,CAACtF,IAAI,EAAE;QACjC8D,iBAAiB,CAAC,CAAC,CAAC,CAACyB,MAAM,CAACvF,IAAI,CAAC;MACrC,CAAC;MAEDwF,cAAc,EAAER,uBAAuB;MACvCS,KAAK,EAAET,uBAAuB;MAC9BU,YAAYA,CAAC1F,IAAI,EAAE;QACf,IAAIA,IAAI,CAACtD,IAAI,CAAC2C,IAAI,KAAK,KAAK,IAAIW,IAAI,CAACH,QAAQ,CAACR,IAAI,KAAK,QAAQ,EAAE;UAC7D2F,uBAAuB,CAAC,CAAC;QAC7B;MACJ,CAAC;MACDW,UAAUA,CAAC3F,IAAI,EAAE;QACb,IAAIiE,oBAAoB,CAAC2B,GAAG,CAAC5F,IAAI,CAAC,EAAE;UAChCgF,uBAAuB,CAAC,CAAC;QAC7B;MACJ,CAAC;MAEDa,gBAAgBA,CAAC7F,IAAI,EAAE;QACnB,IAAIrB,gBAAgB,EAAE;UAClB6B,gBAAgB,CAACR,IAAI,EAAE,KAAK,CAAC;QACjC,CAAC,MAAM,IAAIpB,0BAA0B,EAAE;UACnC4B,gBAAgB,CAACR,IAAI,EAAE,IAAI,CAAC;QAChC;MACJ,CAAC;MAED,eAAe8F,CAAC9F,IAAI,EAAE;QAClB,MAAM+F,iBAAiB,GAAG/F,IAAI,CAACI,MAAM,IAAIJ,IAAI,CAACG,SAAS;;QAEvD;QACA,IAAIH,IAAI,CAACgG,MAAM,CAACrJ,IAAI,KAAK,eAAe,EAAE;UACtC;QACJ;;QAEA;QACA,IAAIqD,IAAI,CAACF,IAAI,KAAK,KAAK,IAAIE,IAAI,CAACF,IAAI,KAAK,KAAK,EAAE;UAC5C;QACJ;;QAEA;QACA,IAAIE,IAAI,CAACoB,QAAQ,IAAIpB,IAAI,CAACC,KAAK,CAACtD,IAAI,KAAK,oBAAoB,IAAIqD,IAAI,CAACC,KAAK,CAACtD,IAAI,KAAK,yBAAyB,EAAE;UAC5G;QACJ;;QAEA;QACA;QACA,IAAIoJ,iBAAiB,EAAE;UACnB,IAAI/F,IAAI,CAACI,MAAM,KAAK1B,WAAW,IAAIK,YAAY,IAAIgB,eAAe,CAACC,IAAI,CAACuB,GAAG,CAAC,CAAC,EAAE;YAC3E,MAAMT,SAAS,GAAGpC,WAAW,GAAG,wBAAwB,GAAG,+BAA+B;;YAE1F;YACAL,OAAO,CAACwC,MAAM,CAAC;cACXb,IAAI;cACJc,SAAS;cACTmF,GAAG,EAAE/E,KAAK,IAAIyC,oBAAoB,CAACzC,KAAK,EAAElB,IAAI;YAClD,CAAC,CAAC;UACN,CAAC,MAAM,IAAItB,WAAW,EAAE;YAEpB;YACAL,OAAO,CAACwC,MAAM,CAAC;cACXb,IAAI;cACJc,SAAS,EAAE,0BAA0B;cACrCmF,GAAG,EAAE/E,KAAK,IAAIA,KAAK,CAACgF,eAAe,CAAClG,IAAI,CAACuB,GAAG,EAAG,KAAIvB,IAAI,CAACuB,GAAG,CAAClC,IAAK,EAAC;YACtE,CAAC,CAAC;UACN;QACJ,CAAC,MAAM,IAAIb,gBAAgB,IAAI,CAACwB,IAAI,CAACC,KAAK,CAACK,EAAE,KAAKN,IAAI,CAACC,KAAK,CAACtD,IAAI,KAAK,oBAAoB,IAAIqD,IAAI,CAACC,KAAK,CAACtD,IAAI,KAAK,yBAAyB,CAAC,EAAE;UAC1I,IAAImC,mBAAmB,IAAIkB,IAAI,CAACuB,GAAG,CAAC5E,IAAI,KAAK,YAAY,IAAIyC,aAAa,CAACY,IAAI,CAACuB,GAAG,CAAClC,IAAI,CAAC,EAAE;YACvF;UACJ;UACA,IAAIN,YAAY,IAAIgB,eAAe,CAACC,IAAI,CAACuB,GAAG,CAAC,EAAE;YAC3C;UACJ;;UAEA;UACA,IAAIvB,IAAI,CAACC,KAAK,CAACtD,IAAI,KAAK,oBAAoB,IACxCqD,IAAI,CAACC,KAAK,CAACtD,IAAI,KAAK,yBAAyB,IAC7CqD,IAAI,CAACC,KAAK,CAAC8C,IAAI,CAACpG,IAAI,KAAK,gBAAgB,IACzCqC,4BAA4B,IAC5B,CAAC+E,4BAA4B,CAAC6B,GAAG,CAAC5F,IAAI,CAACC,KAAK,CAAC,EAC/C;YACE5B,OAAO,CAACwC,MAAM,CAAC;cACXb,IAAI;cACJc,SAAS,EAAE,yBAAyB;cACpCmF,GAAG,EAAE/E,KAAK,IAAID,qBAAqB,CAACC,KAAK,EAAElB,IAAI;YACnD,CAAC,CAAC;UACN;QACJ,CAAC,MAAM,IAAIA,IAAI,CAACC,KAAK,CAACtD,IAAI,KAAK,YAAY,IAAIqD,IAAI,CAACuB,GAAG,CAAClC,IAAI,KAAKW,IAAI,CAACC,KAAK,CAACZ,IAAI,IAAIZ,cAAc,EAAE;UAEhG;UACAJ,OAAO,CAACwC,MAAM,CAAC;YACXb,IAAI;YACJc,SAAS,EAAE,2BAA2B;YACtCmF,GAAGA,CAAC/E,KAAK,EAAE;cACP,OAAOA,KAAK,CAACiF,WAAW,CAACnG,IAAI,EAAEA,IAAI,CAACC,KAAK,CAACZ,IAAI,CAAC;YACnD;UACJ,CAAC,CAAC;QACN,CAAC,MAAM,IAAIW,IAAI,CAACC,KAAK,CAACtD,IAAI,KAAK,YAAY,IAAIqD,IAAI,CAACuB,GAAG,CAAC5E,IAAI,KAAK,SAAS,IAAIqD,IAAI,CAACuB,GAAG,CAACtB,KAAK,KAAKD,IAAI,CAACC,KAAK,CAACZ,IAAI,IAAIZ,cAAc,EAAE;UAChI,IAAIM,YAAY,EAAE;YACd;UACJ;;UAEA;UACAV,OAAO,CAACwC,MAAM,CAAC;YACXb,IAAI;YACJc,SAAS,EAAE,2BAA2B;YACtCmF,GAAGA,CAAC/E,KAAK,EAAE;cACP,OAAOA,KAAK,CAACiF,WAAW,CAACnG,IAAI,EAAEA,IAAI,CAACC,KAAK,CAACZ,IAAI,CAAC;YACnD;UACJ,CAAC,CAAC;QACN;MACJ;IACJ,CAAC;EACL;AACJ,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}