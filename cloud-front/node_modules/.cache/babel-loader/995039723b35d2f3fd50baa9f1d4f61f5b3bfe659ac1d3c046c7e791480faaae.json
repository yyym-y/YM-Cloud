{"ast":null,"code":"\"use strict\";\n\n/* eslint-disable no-param-reassign*/\nrequire(\"core-js/modules/es.array.push.js\");\nconst TokenTranslator = require(\"./token-translator\");\nconst {\n  normalizeOptions\n} = require(\"./options\");\nconst STATE = Symbol(\"espree's internal state\");\nconst ESPRIMA_FINISH_NODE = Symbol(\"espree's esprimaFinishNode\");\n\n/**\n * Converts an Acorn comment to a Esprima comment.\n * @param {boolean} block True if it's a block comment, false if not.\n * @param {string} text The text of the comment.\n * @param {int} start The index at which the comment starts.\n * @param {int} end The index at which the comment ends.\n * @param {Location} startLoc The location at which the comment starts.\n * @param {Location} endLoc The location at which the comment ends.\n * @returns {Object} The comment object.\n * @private\n */\nfunction convertAcornCommentToEsprimaComment(block, text, start, end, startLoc, endLoc) {\n  const comment = {\n    type: block ? \"Block\" : \"Line\",\n    value: text\n  };\n  if (typeof start === \"number\") {\n    comment.start = start;\n    comment.end = end;\n    comment.range = [start, end];\n  }\n  if (typeof startLoc === \"object\") {\n    comment.loc = {\n      start: startLoc,\n      end: endLoc\n    };\n  }\n  return comment;\n}\nmodule.exports = () => Parser => {\n  const tokTypes = Object.assign({}, Parser.acorn.tokTypes);\n  if (Parser.acornJsx) {\n    Object.assign(tokTypes, Parser.acornJsx.tokTypes);\n  }\n  return class Espree extends Parser {\n    constructor(opts, code) {\n      if (typeof opts !== \"object\" || opts === null) {\n        opts = {};\n      }\n      if (typeof code !== \"string\" && !(code instanceof String)) {\n        code = String(code);\n      }\n      const options = normalizeOptions(opts);\n      const ecmaFeatures = options.ecmaFeatures || {};\n      const tokenTranslator = options.tokens === true ? new TokenTranslator(tokTypes, code) : null;\n\n      // Initialize acorn parser.\n      super({\n        // TODO: use {...options} when spread is supported(Node.js >= 8.3.0).\n        ecmaVersion: options.ecmaVersion,\n        sourceType: options.sourceType,\n        ranges: options.ranges,\n        locations: options.locations,\n        // Truthy value is true for backward compatibility.\n        allowReturnOutsideFunction: Boolean(ecmaFeatures.globalReturn),\n        // Collect tokens\n        onToken: token => {\n          if (tokenTranslator) {\n            // Use `tokens`, `ecmaVersion`, and `jsxAttrValueToken` in the state.\n            tokenTranslator.onToken(token, this[STATE]);\n          }\n          if (token.type !== tokTypes.eof) {\n            this[STATE].lastToken = token;\n          }\n        },\n        // Collect comments\n        onComment: (block, text, start, end, startLoc, endLoc) => {\n          if (this[STATE].comments) {\n            const comment = convertAcornCommentToEsprimaComment(block, text, start, end, startLoc, endLoc);\n            this[STATE].comments.push(comment);\n          }\n        }\n      }, code);\n\n      // Initialize internal state.\n      this[STATE] = {\n        tokens: tokenTranslator ? [] : null,\n        comments: options.comment === true ? [] : null,\n        impliedStrict: ecmaFeatures.impliedStrict === true && this.options.ecmaVersion >= 5,\n        ecmaVersion: this.options.ecmaVersion,\n        jsxAttrValueToken: false,\n        lastToken: null\n      };\n    }\n    tokenize() {\n      do {\n        this.next();\n      } while (this.type !== tokTypes.eof);\n\n      // Consume the final eof token\n      this.next();\n      const extra = this[STATE];\n      const tokens = extra.tokens;\n      if (extra.comments) {\n        tokens.comments = extra.comments;\n      }\n      return tokens;\n    }\n    finishNode(...args) {\n      const result = super.finishNode(...args);\n      return this[ESPRIMA_FINISH_NODE](result);\n    }\n    finishNodeAt(...args) {\n      const result = super.finishNodeAt(...args);\n      return this[ESPRIMA_FINISH_NODE](result);\n    }\n    parse() {\n      const extra = this[STATE];\n      const program = super.parse();\n      program.sourceType = this.options.sourceType;\n      if (extra.comments) {\n        program.comments = extra.comments;\n      }\n      if (extra.tokens) {\n        program.tokens = extra.tokens;\n      }\n\n      /*\n       * Adjust opening and closing position of program to match Esprima.\n       * Acorn always starts programs at range 0 whereas Esprima starts at the\n       * first AST node's start (the only real difference is when there's leading\n       * whitespace or leading comments). Acorn also counts trailing whitespace\n       * as part of the program whereas Esprima only counts up to the last token.\n       */\n      if (program.range) {\n        program.range[0] = program.body.length ? program.body[0].range[0] : program.range[0];\n        program.range[1] = extra.lastToken ? extra.lastToken.range[1] : program.range[1];\n      }\n      if (program.loc) {\n        program.loc.start = program.body.length ? program.body[0].loc.start : program.loc.start;\n        program.loc.end = extra.lastToken ? extra.lastToken.loc.end : program.loc.end;\n      }\n      return program;\n    }\n    parseTopLevel(node) {\n      if (this[STATE].impliedStrict) {\n        this.strict = true;\n      }\n      return super.parseTopLevel(node);\n    }\n\n    /**\n     * Overwrites the default raise method to throw Esprima-style errors.\n     * @param {int} pos The position of the error.\n     * @param {string} message The error message.\n     * @throws {SyntaxError} A syntax error.\n     * @returns {void}\n     */\n    raise(pos, message) {\n      const loc = Parser.acorn.getLineInfo(this.input, pos);\n      const err = new SyntaxError(message);\n      err.index = pos;\n      err.lineNumber = loc.line;\n      err.column = loc.column + 1; // acorn uses 0-based columns\n      throw err;\n    }\n\n    /**\n     * Overwrites the default raise method to throw Esprima-style errors.\n     * @param {int} pos The position of the error.\n     * @param {string} message The error message.\n     * @throws {SyntaxError} A syntax error.\n     * @returns {void}\n     */\n    raiseRecoverable(pos, message) {\n      this.raise(pos, message);\n    }\n\n    /**\n     * Overwrites the default unexpected method to throw Esprima-style errors.\n     * @param {int} pos The position of the error.\n     * @throws {SyntaxError} A syntax error.\n     * @returns {void}\n     */\n    unexpected(pos) {\n      let message = \"Unexpected token\";\n      if (pos !== null && pos !== void 0) {\n        this.pos = pos;\n        if (this.options.locations) {\n          while (this.pos < this.lineStart) {\n            this.lineStart = this.input.lastIndexOf(\"\\n\", this.lineStart - 2) + 1;\n            --this.curLine;\n          }\n        }\n        this.nextToken();\n      }\n      if (this.end > this.start) {\n        message += ` ${this.input.slice(this.start, this.end)}`;\n      }\n      this.raise(this.start, message);\n    }\n\n    /*\n    * Esprima-FB represents JSX strings as tokens called \"JSXText\", but Acorn-JSX\n    * uses regular tt.string without any distinction between this and regular JS\n    * strings. As such, we intercept an attempt to read a JSX string and set a flag\n    * on extra so that when tokens are converted, the next token will be switched\n    * to JSXText via onToken.\n    */\n    jsx_readString(quote) {\n      // eslint-disable-line camelcase\n      const result = super.jsx_readString(quote);\n      if (this.type === tokTypes.string) {\n        this[STATE].jsxAttrValueToken = true;\n      }\n      return result;\n    }\n\n    /**\n     * Performs last-minute Esprima-specific compatibility checks and fixes.\n     * @param {ASTNode} result The node to check.\n     * @returns {ASTNode} The finished node.\n     */\n    [ESPRIMA_FINISH_NODE](result) {\n      // Acorn doesn't count the opening and closing backticks as part of templates\n      // so we have to adjust ranges/locations appropriately.\n      if (result.type === \"TemplateElement\") {\n        // additional adjustment needed if ${ is the last token\n        const terminalDollarBraceL = this.input.slice(result.end, result.end + 2) === \"${\";\n        if (result.range) {\n          result.range[0]--;\n          result.range[1] += terminalDollarBraceL ? 2 : 1;\n        }\n        if (result.loc) {\n          result.loc.start.column--;\n          result.loc.end.column += terminalDollarBraceL ? 2 : 1;\n        }\n      }\n      if (result.type.indexOf(\"Function\") > -1 && !result.generator) {\n        result.generator = false;\n      }\n      return result;\n    }\n  };\n};","map":{"version":3,"names":["require","TokenTranslator","normalizeOptions","STATE","Symbol","ESPRIMA_FINISH_NODE","convertAcornCommentToEsprimaComment","block","text","start","end","startLoc","endLoc","comment","type","value","range","loc","module","exports","Parser","tokTypes","Object","assign","acorn","acornJsx","Espree","constructor","opts","code","String","options","ecmaFeatures","tokenTranslator","tokens","ecmaVersion","sourceType","ranges","locations","allowReturnOutsideFunction","Boolean","globalReturn","onToken","token","eof","lastToken","onComment","comments","push","impliedStrict","jsxAttrValueToken","tokenize","next","extra","finishNode","args","result","finishNodeAt","parse","program","body","length","parseTopLevel","node","strict","raise","pos","message","getLineInfo","input","err","SyntaxError","index","lineNumber","line","column","raiseRecoverable","unexpected","lineStart","lastIndexOf","curLine","nextToken","slice","jsx_readString","quote","string","terminalDollarBraceL","indexOf","generator"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/espree/lib/espree.js"],"sourcesContent":["\"use strict\";\n\n/* eslint-disable no-param-reassign*/\nconst TokenTranslator = require(\"./token-translator\");\nconst { normalizeOptions } = require(\"./options\");\n\nconst STATE = Symbol(\"espree's internal state\");\nconst ESPRIMA_FINISH_NODE = Symbol(\"espree's esprimaFinishNode\");\n\n\n/**\n * Converts an Acorn comment to a Esprima comment.\n * @param {boolean} block True if it's a block comment, false if not.\n * @param {string} text The text of the comment.\n * @param {int} start The index at which the comment starts.\n * @param {int} end The index at which the comment ends.\n * @param {Location} startLoc The location at which the comment starts.\n * @param {Location} endLoc The location at which the comment ends.\n * @returns {Object} The comment object.\n * @private\n */\nfunction convertAcornCommentToEsprimaComment(block, text, start, end, startLoc, endLoc) {\n    const comment = {\n        type: block ? \"Block\" : \"Line\",\n        value: text\n    };\n\n    if (typeof start === \"number\") {\n        comment.start = start;\n        comment.end = end;\n        comment.range = [start, end];\n    }\n\n    if (typeof startLoc === \"object\") {\n        comment.loc = {\n            start: startLoc,\n            end: endLoc\n        };\n    }\n\n    return comment;\n}\n\nmodule.exports = () => Parser => {\n    const tokTypes = Object.assign({}, Parser.acorn.tokTypes);\n\n    if (Parser.acornJsx) {\n        Object.assign(tokTypes, Parser.acornJsx.tokTypes);\n    }\n\n    return class Espree extends Parser {\n        constructor(opts, code) {\n            if (typeof opts !== \"object\" || opts === null) {\n                opts = {};\n            }\n            if (typeof code !== \"string\" && !(code instanceof String)) {\n                code = String(code);\n            }\n\n            const options = normalizeOptions(opts);\n            const ecmaFeatures = options.ecmaFeatures || {};\n            const tokenTranslator =\n                options.tokens === true\n                    ? new TokenTranslator(tokTypes, code)\n                    : null;\n\n            // Initialize acorn parser.\n            super({\n\n                // TODO: use {...options} when spread is supported(Node.js >= 8.3.0).\n                ecmaVersion: options.ecmaVersion,\n                sourceType: options.sourceType,\n                ranges: options.ranges,\n                locations: options.locations,\n\n                // Truthy value is true for backward compatibility.\n                allowReturnOutsideFunction: Boolean(ecmaFeatures.globalReturn),\n\n                // Collect tokens\n                onToken: token => {\n                    if (tokenTranslator) {\n\n                        // Use `tokens`, `ecmaVersion`, and `jsxAttrValueToken` in the state.\n                        tokenTranslator.onToken(token, this[STATE]);\n                    }\n                    if (token.type !== tokTypes.eof) {\n                        this[STATE].lastToken = token;\n                    }\n                },\n\n                // Collect comments\n                onComment: (block, text, start, end, startLoc, endLoc) => {\n                    if (this[STATE].comments) {\n                        const comment = convertAcornCommentToEsprimaComment(block, text, start, end, startLoc, endLoc);\n\n                        this[STATE].comments.push(comment);\n                    }\n                }\n            }, code);\n\n            // Initialize internal state.\n            this[STATE] = {\n                tokens: tokenTranslator ? [] : null,\n                comments: options.comment === true ? [] : null,\n                impliedStrict: ecmaFeatures.impliedStrict === true && this.options.ecmaVersion >= 5,\n                ecmaVersion: this.options.ecmaVersion,\n                jsxAttrValueToken: false,\n                lastToken: null\n            };\n        }\n\n        tokenize() {\n            do {\n                this.next();\n            } while (this.type !== tokTypes.eof);\n\n            // Consume the final eof token\n            this.next();\n\n            const extra = this[STATE];\n            const tokens = extra.tokens;\n\n            if (extra.comments) {\n                tokens.comments = extra.comments;\n            }\n\n            return tokens;\n        }\n\n        finishNode(...args) {\n            const result = super.finishNode(...args);\n\n            return this[ESPRIMA_FINISH_NODE](result);\n        }\n\n        finishNodeAt(...args) {\n            const result = super.finishNodeAt(...args);\n\n            return this[ESPRIMA_FINISH_NODE](result);\n        }\n\n        parse() {\n            const extra = this[STATE];\n            const program = super.parse();\n\n            program.sourceType = this.options.sourceType;\n\n            if (extra.comments) {\n                program.comments = extra.comments;\n            }\n            if (extra.tokens) {\n                program.tokens = extra.tokens;\n            }\n\n            /*\n             * Adjust opening and closing position of program to match Esprima.\n             * Acorn always starts programs at range 0 whereas Esprima starts at the\n             * first AST node's start (the only real difference is when there's leading\n             * whitespace or leading comments). Acorn also counts trailing whitespace\n             * as part of the program whereas Esprima only counts up to the last token.\n             */\n            if (program.range) {\n                program.range[0] = program.body.length ? program.body[0].range[0] : program.range[0];\n                program.range[1] = extra.lastToken ? extra.lastToken.range[1] : program.range[1];\n            }\n            if (program.loc) {\n                program.loc.start = program.body.length ? program.body[0].loc.start : program.loc.start;\n                program.loc.end = extra.lastToken ? extra.lastToken.loc.end : program.loc.end;\n            }\n\n            return program;\n        }\n\n        parseTopLevel(node) {\n            if (this[STATE].impliedStrict) {\n                this.strict = true;\n            }\n            return super.parseTopLevel(node);\n        }\n\n        /**\n         * Overwrites the default raise method to throw Esprima-style errors.\n         * @param {int} pos The position of the error.\n         * @param {string} message The error message.\n         * @throws {SyntaxError} A syntax error.\n         * @returns {void}\n         */\n        raise(pos, message) {\n            const loc = Parser.acorn.getLineInfo(this.input, pos);\n            const err = new SyntaxError(message);\n\n            err.index = pos;\n            err.lineNumber = loc.line;\n            err.column = loc.column + 1; // acorn uses 0-based columns\n            throw err;\n        }\n\n        /**\n         * Overwrites the default raise method to throw Esprima-style errors.\n         * @param {int} pos The position of the error.\n         * @param {string} message The error message.\n         * @throws {SyntaxError} A syntax error.\n         * @returns {void}\n         */\n        raiseRecoverable(pos, message) {\n            this.raise(pos, message);\n        }\n\n        /**\n         * Overwrites the default unexpected method to throw Esprima-style errors.\n         * @param {int} pos The position of the error.\n         * @throws {SyntaxError} A syntax error.\n         * @returns {void}\n         */\n        unexpected(pos) {\n            let message = \"Unexpected token\";\n\n            if (pos !== null && pos !== void 0) {\n                this.pos = pos;\n\n                if (this.options.locations) {\n                    while (this.pos < this.lineStart) {\n                        this.lineStart = this.input.lastIndexOf(\"\\n\", this.lineStart - 2) + 1;\n                        --this.curLine;\n                    }\n                }\n\n                this.nextToken();\n            }\n\n            if (this.end > this.start) {\n                message += ` ${this.input.slice(this.start, this.end)}`;\n            }\n\n            this.raise(this.start, message);\n        }\n\n        /*\n        * Esprima-FB represents JSX strings as tokens called \"JSXText\", but Acorn-JSX\n        * uses regular tt.string without any distinction between this and regular JS\n        * strings. As such, we intercept an attempt to read a JSX string and set a flag\n        * on extra so that when tokens are converted, the next token will be switched\n        * to JSXText via onToken.\n        */\n        jsx_readString(quote) { // eslint-disable-line camelcase\n            const result = super.jsx_readString(quote);\n\n            if (this.type === tokTypes.string) {\n                this[STATE].jsxAttrValueToken = true;\n            }\n            return result;\n        }\n\n        /**\n         * Performs last-minute Esprima-specific compatibility checks and fixes.\n         * @param {ASTNode} result The node to check.\n         * @returns {ASTNode} The finished node.\n         */\n        [ESPRIMA_FINISH_NODE](result) {\n\n            // Acorn doesn't count the opening and closing backticks as part of templates\n            // so we have to adjust ranges/locations appropriately.\n            if (result.type === \"TemplateElement\") {\n\n                // additional adjustment needed if ${ is the last token\n                const terminalDollarBraceL = this.input.slice(result.end, result.end + 2) === \"${\";\n\n                if (result.range) {\n                    result.range[0]--;\n                    result.range[1] += (terminalDollarBraceL ? 2 : 1);\n                }\n\n                if (result.loc) {\n                    result.loc.start.column--;\n                    result.loc.end.column += (terminalDollarBraceL ? 2 : 1);\n                }\n            }\n\n            if (result.type.indexOf(\"Function\") > -1 && !result.generator) {\n                result.generator = false;\n            }\n\n            return result;\n        }\n    };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}