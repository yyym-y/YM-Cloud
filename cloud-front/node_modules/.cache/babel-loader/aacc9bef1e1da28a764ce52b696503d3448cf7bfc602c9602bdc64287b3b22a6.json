{"ast":null,"code":"/**\n * @fileoverview Rule to require or disallow yoda comparisons\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//--------------------------------------------------------------------------\n// Requirements\n//--------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils\");\n\n//--------------------------------------------------------------------------\n// Helpers\n//--------------------------------------------------------------------------\n\n/**\n * Determines whether an operator is a comparison operator.\n * @param {string} operator The operator to check.\n * @returns {boolean} Whether or not it is a comparison operator.\n */\nfunction isComparisonOperator(operator) {\n  return /^(==|===|!=|!==|<|>|<=|>=)$/u.test(operator);\n}\n\n/**\n * Determines whether an operator is an equality operator.\n * @param {string} operator The operator to check.\n * @returns {boolean} Whether or not it is an equality operator.\n */\nfunction isEqualityOperator(operator) {\n  return /^(==|===)$/u.test(operator);\n}\n\n/**\n * Determines whether an operator is one used in a range test.\n * Allowed operators are `<` and `<=`.\n * @param {string} operator The operator to check.\n * @returns {boolean} Whether the operator is used in range tests.\n */\nfunction isRangeTestOperator(operator) {\n  return [\"<\", \"<=\"].indexOf(operator) >= 0;\n}\n\n/**\n * Determines whether a non-Literal node is a negative number that should be\n * treated as if it were a single Literal node.\n * @param {ASTNode} node Node to test.\n * @returns {boolean} True if the node is a negative number that looks like a\n *                    real literal and should be treated as such.\n */\nfunction isNegativeNumericLiteral(node) {\n  return node.type === \"UnaryExpression\" && node.operator === \"-\" && node.prefix && astUtils.isNumericLiteral(node.argument);\n}\n\n/**\n * Determines whether a node is a Template Literal which can be determined statically.\n * @param {ASTNode} node Node to test\n * @returns {boolean} True if the node is a Template Literal without expression.\n */\nfunction isStaticTemplateLiteral(node) {\n  return node.type === \"TemplateLiteral\" && node.expressions.length === 0;\n}\n\n/**\n * Determines whether a non-Literal node should be treated as a single Literal node.\n * @param {ASTNode} node Node to test\n * @returns {boolean} True if the node should be treated as a single Literal node.\n */\nfunction looksLikeLiteral(node) {\n  return isNegativeNumericLiteral(node) || isStaticTemplateLiteral(node);\n}\n\n/**\n * Attempts to derive a Literal node from nodes that are treated like literals.\n * @param {ASTNode} node Node to normalize.\n * @returns {ASTNode} One of the following options.\n *  1. The original node if the node is already a Literal\n *  2. A normalized Literal node with the negative number as the value if the\n *     node represents a negative number literal.\n *  3. A normalized Literal node with the string as the value if the node is\n *     a Template Literal without expression.\n *  4. Otherwise `null`.\n */\nfunction getNormalizedLiteral(node) {\n  if (node.type === \"Literal\") {\n    return node;\n  }\n  if (isNegativeNumericLiteral(node)) {\n    return {\n      type: \"Literal\",\n      value: -node.argument.value,\n      raw: `-${node.argument.value}`\n    };\n  }\n  if (isStaticTemplateLiteral(node)) {\n    return {\n      type: \"Literal\",\n      value: node.quasis[0].value.cooked,\n      raw: node.quasis[0].value.raw\n    };\n  }\n  return null;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: 'require or disallow \"Yoda\" conditions',\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/yoda\"\n    },\n    schema: [{\n      enum: [\"always\", \"never\"]\n    }, {\n      type: \"object\",\n      properties: {\n        exceptRange: {\n          type: \"boolean\",\n          default: false\n        },\n        onlyEquality: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    fixable: \"code\",\n    messages: {\n      expected: \"Expected literal to be on the {{expectedSide}} side of {{operator}}.\"\n    }\n  },\n  create(context) {\n    // Default to \"never\" (!always) if no option\n    const always = context.options[0] === \"always\";\n    const exceptRange = context.options[1] && context.options[1].exceptRange;\n    const onlyEquality = context.options[1] && context.options[1].onlyEquality;\n    const sourceCode = context.getSourceCode();\n\n    /**\n     * Determines whether node represents a range test.\n     * A range test is a \"between\" test like `(0 <= x && x < 1)` or an \"outside\"\n     * test like `(x < 0 || 1 <= x)`. It must be wrapped in parentheses, and\n     * both operators must be `<` or `<=`. Finally, the literal on the left side\n     * must be less than or equal to the literal on the right side so that the\n     * test makes any sense.\n     * @param {ASTNode} node LogicalExpression node to test.\n     * @returns {boolean} Whether node is a range test.\n     */\n    function isRangeTest(node) {\n      const left = node.left,\n        right = node.right;\n\n      /**\n       * Determines whether node is of the form `0 <= x && x < 1`.\n       * @returns {boolean} Whether node is a \"between\" range test.\n       */\n      function isBetweenTest() {\n        if (node.operator === \"&&\" && astUtils.isSameReference(left.right, right.left)) {\n          const leftLiteral = getNormalizedLiteral(left.left);\n          const rightLiteral = getNormalizedLiteral(right.right);\n          if (leftLiteral === null && rightLiteral === null) {\n            return false;\n          }\n          if (rightLiteral === null || leftLiteral === null) {\n            return true;\n          }\n          if (leftLiteral.value <= rightLiteral.value) {\n            return true;\n          }\n        }\n        return false;\n      }\n\n      /**\n       * Determines whether node is of the form `x < 0 || 1 <= x`.\n       * @returns {boolean} Whether node is an \"outside\" range test.\n       */\n      function isOutsideTest() {\n        if (node.operator === \"||\" && astUtils.isSameReference(left.left, right.right)) {\n          const leftLiteral = getNormalizedLiteral(left.right);\n          const rightLiteral = getNormalizedLiteral(right.left);\n          if (leftLiteral === null && rightLiteral === null) {\n            return false;\n          }\n          if (rightLiteral === null || leftLiteral === null) {\n            return true;\n          }\n          if (leftLiteral.value <= rightLiteral.value) {\n            return true;\n          }\n        }\n        return false;\n      }\n\n      /**\n       * Determines whether node is wrapped in parentheses.\n       * @returns {boolean} Whether node is preceded immediately by an open\n       *                    paren token and followed immediately by a close\n       *                    paren token.\n       */\n      function isParenWrapped() {\n        return astUtils.isParenthesised(sourceCode, node);\n      }\n      return node.type === \"LogicalExpression\" && left.type === \"BinaryExpression\" && right.type === \"BinaryExpression\" && isRangeTestOperator(left.operator) && isRangeTestOperator(right.operator) && (isBetweenTest() || isOutsideTest()) && isParenWrapped();\n    }\n    const OPERATOR_FLIP_MAP = {\n      \"===\": \"===\",\n      \"!==\": \"!==\",\n      \"==\": \"==\",\n      \"!=\": \"!=\",\n      \"<\": \">\",\n      \">\": \"<\",\n      \"<=\": \">=\",\n      \">=\": \"<=\"\n    };\n\n    /**\n     * Returns a string representation of a BinaryExpression node with its sides/operator flipped around.\n     * @param {ASTNode} node The BinaryExpression node\n     * @returns {string} A string representation of the node with the sides and operator flipped\n     */\n    function getFlippedString(node) {\n      const operatorToken = sourceCode.getFirstTokenBetween(node.left, node.right, token => token.value === node.operator);\n      const lastLeftToken = sourceCode.getTokenBefore(operatorToken);\n      const firstRightToken = sourceCode.getTokenAfter(operatorToken);\n      const source = sourceCode.getText();\n      const leftText = source.slice(node.range[0], lastLeftToken.range[1]);\n      const textBeforeOperator = source.slice(lastLeftToken.range[1], operatorToken.range[0]);\n      const textAfterOperator = source.slice(operatorToken.range[1], firstRightToken.range[0]);\n      const rightText = source.slice(firstRightToken.range[0], node.range[1]);\n      const tokenBefore = sourceCode.getTokenBefore(node);\n      const tokenAfter = sourceCode.getTokenAfter(node);\n      let prefix = \"\";\n      let suffix = \"\";\n      if (tokenBefore && tokenBefore.range[1] === node.range[0] && !astUtils.canTokensBeAdjacent(tokenBefore, firstRightToken)) {\n        prefix = \" \";\n      }\n      if (tokenAfter && node.range[1] === tokenAfter.range[0] && !astUtils.canTokensBeAdjacent(lastLeftToken, tokenAfter)) {\n        suffix = \" \";\n      }\n      return prefix + rightText + textBeforeOperator + OPERATOR_FLIP_MAP[operatorToken.value] + textAfterOperator + leftText + suffix;\n    }\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    return {\n      BinaryExpression(node) {\n        const expectedLiteral = always ? node.left : node.right;\n        const expectedNonLiteral = always ? node.right : node.left;\n\n        // If `expectedLiteral` is not a literal, and `expectedNonLiteral` is a literal, raise an error.\n        if ((expectedNonLiteral.type === \"Literal\" || looksLikeLiteral(expectedNonLiteral)) && !(expectedLiteral.type === \"Literal\" || looksLikeLiteral(expectedLiteral)) && !(!isEqualityOperator(node.operator) && onlyEquality) && isComparisonOperator(node.operator) && !(exceptRange && isRangeTest(context.getAncestors().pop()))) {\n          context.report({\n            node,\n            messageId: \"expected\",\n            data: {\n              operator: node.operator,\n              expectedSide: always ? \"left\" : \"right\"\n            },\n            fix: fixer => fixer.replaceText(node, getFlippedString(node))\n          });\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","isComparisonOperator","operator","test","isEqualityOperator","isRangeTestOperator","indexOf","isNegativeNumericLiteral","node","type","prefix","isNumericLiteral","argument","isStaticTemplateLiteral","expressions","length","looksLikeLiteral","getNormalizedLiteral","value","raw","quasis","cooked","module","exports","meta","docs","description","category","recommended","url","schema","enum","properties","exceptRange","default","onlyEquality","additionalProperties","fixable","messages","expected","create","context","always","options","sourceCode","getSourceCode","isRangeTest","left","right","isBetweenTest","isSameReference","leftLiteral","rightLiteral","isOutsideTest","isParenWrapped","isParenthesised","OPERATOR_FLIP_MAP","getFlippedString","operatorToken","getFirstTokenBetween","token","lastLeftToken","getTokenBefore","firstRightToken","getTokenAfter","source","getText","leftText","slice","range","textBeforeOperator","textAfterOperator","rightText","tokenBefore","tokenAfter","suffix","canTokensBeAdjacent","BinaryExpression","expectedLiteral","expectedNonLiteral","getAncestors","pop","report","messageId","data","expectedSide","fix","fixer","replaceText"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/yoda.js"],"sourcesContent":["/**\n * @fileoverview Rule to require or disallow yoda comparisons\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//--------------------------------------------------------------------------\n// Requirements\n//--------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//--------------------------------------------------------------------------\n// Helpers\n//--------------------------------------------------------------------------\n\n/**\n * Determines whether an operator is a comparison operator.\n * @param {string} operator The operator to check.\n * @returns {boolean} Whether or not it is a comparison operator.\n */\nfunction isComparisonOperator(operator) {\n    return /^(==|===|!=|!==|<|>|<=|>=)$/u.test(operator);\n}\n\n/**\n * Determines whether an operator is an equality operator.\n * @param {string} operator The operator to check.\n * @returns {boolean} Whether or not it is an equality operator.\n */\nfunction isEqualityOperator(operator) {\n    return /^(==|===)$/u.test(operator);\n}\n\n/**\n * Determines whether an operator is one used in a range test.\n * Allowed operators are `<` and `<=`.\n * @param {string} operator The operator to check.\n * @returns {boolean} Whether the operator is used in range tests.\n */\nfunction isRangeTestOperator(operator) {\n    return [\"<\", \"<=\"].indexOf(operator) >= 0;\n}\n\n/**\n * Determines whether a non-Literal node is a negative number that should be\n * treated as if it were a single Literal node.\n * @param {ASTNode} node Node to test.\n * @returns {boolean} True if the node is a negative number that looks like a\n *                    real literal and should be treated as such.\n */\nfunction isNegativeNumericLiteral(node) {\n    return (\n        node.type === \"UnaryExpression\" &&\n        node.operator === \"-\" &&\n        node.prefix &&\n        astUtils.isNumericLiteral(node.argument)\n    );\n}\n\n/**\n * Determines whether a node is a Template Literal which can be determined statically.\n * @param {ASTNode} node Node to test\n * @returns {boolean} True if the node is a Template Literal without expression.\n */\nfunction isStaticTemplateLiteral(node) {\n    return node.type === \"TemplateLiteral\" && node.expressions.length === 0;\n}\n\n/**\n * Determines whether a non-Literal node should be treated as a single Literal node.\n * @param {ASTNode} node Node to test\n * @returns {boolean} True if the node should be treated as a single Literal node.\n */\nfunction looksLikeLiteral(node) {\n    return isNegativeNumericLiteral(node) || isStaticTemplateLiteral(node);\n}\n\n/**\n * Attempts to derive a Literal node from nodes that are treated like literals.\n * @param {ASTNode} node Node to normalize.\n * @returns {ASTNode} One of the following options.\n *  1. The original node if the node is already a Literal\n *  2. A normalized Literal node with the negative number as the value if the\n *     node represents a negative number literal.\n *  3. A normalized Literal node with the string as the value if the node is\n *     a Template Literal without expression.\n *  4. Otherwise `null`.\n */\nfunction getNormalizedLiteral(node) {\n    if (node.type === \"Literal\") {\n        return node;\n    }\n\n    if (isNegativeNumericLiteral(node)) {\n        return {\n            type: \"Literal\",\n            value: -node.argument.value,\n            raw: `-${node.argument.value}`\n        };\n    }\n\n    if (isStaticTemplateLiteral(node)) {\n        return {\n            type: \"Literal\",\n            value: node.quasis[0].value.cooked,\n            raw: node.quasis[0].value.raw\n        };\n    }\n\n    return null;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: 'require or disallow \"Yoda\" conditions',\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/yoda\"\n        },\n\n        schema: [\n            {\n                enum: [\"always\", \"never\"]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    exceptRange: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    onlyEquality: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: \"code\",\n        messages: {\n            expected:\n                \"Expected literal to be on the {{expectedSide}} side of {{operator}}.\"\n        }\n    },\n\n    create(context) {\n\n        // Default to \"never\" (!always) if no option\n        const always = context.options[0] === \"always\";\n        const exceptRange =\n            context.options[1] && context.options[1].exceptRange;\n        const onlyEquality =\n            context.options[1] && context.options[1].onlyEquality;\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Determines whether node represents a range test.\n         * A range test is a \"between\" test like `(0 <= x && x < 1)` or an \"outside\"\n         * test like `(x < 0 || 1 <= x)`. It must be wrapped in parentheses, and\n         * both operators must be `<` or `<=`. Finally, the literal on the left side\n         * must be less than or equal to the literal on the right side so that the\n         * test makes any sense.\n         * @param {ASTNode} node LogicalExpression node to test.\n         * @returns {boolean} Whether node is a range test.\n         */\n        function isRangeTest(node) {\n            const left = node.left,\n                right = node.right;\n\n            /**\n             * Determines whether node is of the form `0 <= x && x < 1`.\n             * @returns {boolean} Whether node is a \"between\" range test.\n             */\n            function isBetweenTest() {\n                if (node.operator === \"&&\" && astUtils.isSameReference(left.right, right.left)) {\n                    const leftLiteral = getNormalizedLiteral(left.left);\n                    const rightLiteral = getNormalizedLiteral(right.right);\n\n                    if (leftLiteral === null && rightLiteral === null) {\n                        return false;\n                    }\n\n                    if (rightLiteral === null || leftLiteral === null) {\n                        return true;\n                    }\n\n                    if (leftLiteral.value <= rightLiteral.value) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n\n            /**\n             * Determines whether node is of the form `x < 0 || 1 <= x`.\n             * @returns {boolean} Whether node is an \"outside\" range test.\n             */\n            function isOutsideTest() {\n                if (node.operator === \"||\" && astUtils.isSameReference(left.left, right.right)) {\n                    const leftLiteral = getNormalizedLiteral(left.right);\n                    const rightLiteral = getNormalizedLiteral(right.left);\n\n                    if (leftLiteral === null && rightLiteral === null) {\n                        return false;\n                    }\n\n                    if (rightLiteral === null || leftLiteral === null) {\n                        return true;\n                    }\n\n                    if (leftLiteral.value <= rightLiteral.value) {\n                        return true;\n                    }\n                }\n\n                return false;\n            }\n\n            /**\n             * Determines whether node is wrapped in parentheses.\n             * @returns {boolean} Whether node is preceded immediately by an open\n             *                    paren token and followed immediately by a close\n             *                    paren token.\n             */\n            function isParenWrapped() {\n                return astUtils.isParenthesised(sourceCode, node);\n            }\n\n            return (\n                node.type === \"LogicalExpression\" &&\n                left.type === \"BinaryExpression\" &&\n                right.type === \"BinaryExpression\" &&\n                isRangeTestOperator(left.operator) &&\n                isRangeTestOperator(right.operator) &&\n                (isBetweenTest() || isOutsideTest()) &&\n                isParenWrapped()\n            );\n        }\n\n        const OPERATOR_FLIP_MAP = {\n            \"===\": \"===\",\n            \"!==\": \"!==\",\n            \"==\": \"==\",\n            \"!=\": \"!=\",\n            \"<\": \">\",\n            \">\": \"<\",\n            \"<=\": \">=\",\n            \">=\": \"<=\"\n        };\n\n        /**\n         * Returns a string representation of a BinaryExpression node with its sides/operator flipped around.\n         * @param {ASTNode} node The BinaryExpression node\n         * @returns {string} A string representation of the node with the sides and operator flipped\n         */\n        function getFlippedString(node) {\n            const operatorToken = sourceCode.getFirstTokenBetween(\n                node.left,\n                node.right,\n                token => token.value === node.operator\n            );\n            const lastLeftToken = sourceCode.getTokenBefore(operatorToken);\n            const firstRightToken = sourceCode.getTokenAfter(operatorToken);\n\n            const source = sourceCode.getText();\n\n            const leftText = source.slice(\n                node.range[0],\n                lastLeftToken.range[1]\n            );\n            const textBeforeOperator = source.slice(\n                lastLeftToken.range[1],\n                operatorToken.range[0]\n            );\n            const textAfterOperator = source.slice(\n                operatorToken.range[1],\n                firstRightToken.range[0]\n            );\n            const rightText = source.slice(\n                firstRightToken.range[0],\n                node.range[1]\n            );\n\n            const tokenBefore = sourceCode.getTokenBefore(node);\n            const tokenAfter = sourceCode.getTokenAfter(node);\n            let prefix = \"\";\n            let suffix = \"\";\n\n            if (\n                tokenBefore &&\n                tokenBefore.range[1] === node.range[0] &&\n                !astUtils.canTokensBeAdjacent(tokenBefore, firstRightToken)\n            ) {\n                prefix = \" \";\n            }\n\n            if (\n                tokenAfter &&\n                node.range[1] === tokenAfter.range[0] &&\n                !astUtils.canTokensBeAdjacent(lastLeftToken, tokenAfter)\n            ) {\n                suffix = \" \";\n            }\n\n            return (\n                prefix +\n                rightText +\n                textBeforeOperator +\n                OPERATOR_FLIP_MAP[operatorToken.value] +\n                textAfterOperator +\n                leftText +\n                suffix\n            );\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            BinaryExpression(node) {\n                const expectedLiteral = always ? node.left : node.right;\n                const expectedNonLiteral = always ? node.right : node.left;\n\n                // If `expectedLiteral` is not a literal, and `expectedNonLiteral` is a literal, raise an error.\n                if (\n                    (expectedNonLiteral.type === \"Literal\" ||\n                        looksLikeLiteral(expectedNonLiteral)) &&\n                    !(\n                        expectedLiteral.type === \"Literal\" ||\n                        looksLikeLiteral(expectedLiteral)\n                    ) &&\n                    !(!isEqualityOperator(node.operator) && onlyEquality) &&\n                    isComparisonOperator(node.operator) &&\n                    !(exceptRange && isRangeTest(context.getAncestors().pop()))\n                ) {\n                    context.report({\n                        node,\n                        messageId: \"expected\",\n                        data: {\n                            operator: node.operator,\n                            expectedSide: always ? \"left\" : \"right\"\n                        },\n                        fix: fixer =>\n                            fixer.replaceText(node, getFlippedString(node))\n                    });\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}