{"ast":null,"code":"/**\n * @fileoverview Rule to flag creation of function inside a loop\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Gets the containing loop node of a specified node.\n *\n * We don't need to check nested functions, so this ignores those.\n * `Scope.through` contains references of nested functions.\n * @param {ASTNode} node An AST node to get.\n * @returns {ASTNode|null} The containing loop node of the specified node, or\n *      `null`.\n */\nfunction getContainingLoopNode(node) {\n  for (let currentNode = node; currentNode.parent; currentNode = currentNode.parent) {\n    const parent = currentNode.parent;\n    switch (parent.type) {\n      case \"WhileStatement\":\n      case \"DoWhileStatement\":\n        return parent;\n      case \"ForStatement\":\n        // `init` is outside of the loop.\n        if (parent.init !== currentNode) {\n          return parent;\n        }\n        break;\n      case \"ForInStatement\":\n      case \"ForOfStatement\":\n        // `right` is outside of the loop.\n        if (parent.right !== currentNode) {\n          return parent;\n        }\n        break;\n      case \"ArrowFunctionExpression\":\n      case \"FunctionExpression\":\n      case \"FunctionDeclaration\":\n        // We don't need to check nested functions.\n        return null;\n      default:\n        break;\n    }\n  }\n  return null;\n}\n\n/**\n * Gets the containing loop node of a given node.\n * If the loop was nested, this returns the most outer loop.\n * @param {ASTNode} node A node to get. This is a loop node.\n * @param {ASTNode|null} excludedNode A node that the result node should not\n *      include.\n * @returns {ASTNode} The most outer loop node.\n */\nfunction getTopLoopNode(node, excludedNode) {\n  const border = excludedNode ? excludedNode.range[1] : 0;\n  let retv = node;\n  let containingLoopNode = node;\n  while (containingLoopNode && containingLoopNode.range[0] >= border) {\n    retv = containingLoopNode;\n    containingLoopNode = getContainingLoopNode(containingLoopNode);\n  }\n  return retv;\n}\n\n/**\n * Checks whether a given reference which refers to an upper scope's variable is\n * safe or not.\n * @param {ASTNode} loopNode A containing loop node.\n * @param {eslint-scope.Reference} reference A reference to check.\n * @returns {boolean} `true` if the reference is safe or not.\n */\nfunction isSafe(loopNode, reference) {\n  const variable = reference.resolved;\n  const definition = variable && variable.defs[0];\n  const declaration = definition && definition.parent;\n  const kind = declaration && declaration.type === \"VariableDeclaration\" ? declaration.kind : \"\";\n\n  // Variables which are declared by `const` is safe.\n  if (kind === \"const\") {\n    return true;\n  }\n\n  /*\n   * Variables which are declared by `let` in the loop is safe.\n   * It's a different instance from the next loop step's.\n   */\n  if (kind === \"let\" && declaration.range[0] > loopNode.range[0] && declaration.range[1] < loopNode.range[1]) {\n    return true;\n  }\n\n  /*\n   * WriteReferences which exist after this border are unsafe because those\n   * can modify the variable.\n   */\n  const border = getTopLoopNode(loopNode, kind === \"let\" ? declaration : null).range[0];\n\n  /**\n   * Checks whether a given reference is safe or not.\n   * The reference is every reference of the upper scope's variable we are\n   * looking now.\n   *\n   * It's safeafe if the reference matches one of the following condition.\n   * - is readonly.\n   * - doesn't exist inside a local function and after the border.\n   * @param {eslint-scope.Reference} upperRef A reference to check.\n   * @returns {boolean} `true` if the reference is safe.\n   */\n  function isSafeReference(upperRef) {\n    const id = upperRef.identifier;\n    return !upperRef.isWrite() || variable.scope.variableScope === upperRef.from.variableScope && id.range[0] < border;\n  }\n  return Boolean(variable) && variable.references.every(isSafeReference);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow function declarations that contain unsafe references inside loop statements\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-loop-func\"\n    },\n    schema: [],\n    messages: {\n      unsafeRefs: \"Function declared in a loop contains unsafe references to variable(s) {{ varNames }}.\"\n    }\n  },\n  create(context) {\n    /**\n     * Reports functions which match the following condition:\n     *\n     * - has a loop node in ancestors.\n     * - has any references which refers to an unsafe variable.\n     * @param {ASTNode} node The AST node to check.\n     * @returns {boolean} Whether or not the node is within a loop.\n     */\n    function checkForLoops(node) {\n      const loopNode = getContainingLoopNode(node);\n      if (!loopNode) {\n        return;\n      }\n      const references = context.getScope().through;\n      const unsafeRefs = references.filter(r => !isSafe(loopNode, r)).map(r => r.identifier.name);\n      if (unsafeRefs.length > 0) {\n        context.report({\n          node,\n          messageId: \"unsafeRefs\",\n          data: {\n            varNames: `'${unsafeRefs.join(\"', '\")}'`\n          }\n        });\n      }\n    }\n    return {\n      ArrowFunctionExpression: checkForLoops,\n      FunctionExpression: checkForLoops,\n      FunctionDeclaration: checkForLoops\n    };\n  }\n};","map":{"version":3,"names":["getContainingLoopNode","node","currentNode","parent","type","init","right","getTopLoopNode","excludedNode","border","range","retv","containingLoopNode","isSafe","loopNode","reference","variable","resolved","definition","defs","declaration","kind","isSafeReference","upperRef","id","identifier","isWrite","scope","variableScope","from","Boolean","references","every","module","exports","meta","docs","description","category","recommended","url","schema","messages","unsafeRefs","create","context","checkForLoops","getScope","through","filter","r","map","name","length","report","messageId","data","varNames","join","ArrowFunctionExpression","FunctionExpression","FunctionDeclaration"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/no-loop-func.js"],"sourcesContent":["/**\n * @fileoverview Rule to flag creation of function inside a loop\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Gets the containing loop node of a specified node.\n *\n * We don't need to check nested functions, so this ignores those.\n * `Scope.through` contains references of nested functions.\n * @param {ASTNode} node An AST node to get.\n * @returns {ASTNode|null} The containing loop node of the specified node, or\n *      `null`.\n */\nfunction getContainingLoopNode(node) {\n    for (let currentNode = node; currentNode.parent; currentNode = currentNode.parent) {\n        const parent = currentNode.parent;\n\n        switch (parent.type) {\n            case \"WhileStatement\":\n            case \"DoWhileStatement\":\n                return parent;\n\n            case \"ForStatement\":\n\n                // `init` is outside of the loop.\n                if (parent.init !== currentNode) {\n                    return parent;\n                }\n                break;\n\n            case \"ForInStatement\":\n            case \"ForOfStatement\":\n\n                // `right` is outside of the loop.\n                if (parent.right !== currentNode) {\n                    return parent;\n                }\n                break;\n\n            case \"ArrowFunctionExpression\":\n            case \"FunctionExpression\":\n            case \"FunctionDeclaration\":\n\n                // We don't need to check nested functions.\n                return null;\n\n            default:\n                break;\n        }\n    }\n\n    return null;\n}\n\n/**\n * Gets the containing loop node of a given node.\n * If the loop was nested, this returns the most outer loop.\n * @param {ASTNode} node A node to get. This is a loop node.\n * @param {ASTNode|null} excludedNode A node that the result node should not\n *      include.\n * @returns {ASTNode} The most outer loop node.\n */\nfunction getTopLoopNode(node, excludedNode) {\n    const border = excludedNode ? excludedNode.range[1] : 0;\n    let retv = node;\n    let containingLoopNode = node;\n\n    while (containingLoopNode && containingLoopNode.range[0] >= border) {\n        retv = containingLoopNode;\n        containingLoopNode = getContainingLoopNode(containingLoopNode);\n    }\n\n    return retv;\n}\n\n/**\n * Checks whether a given reference which refers to an upper scope's variable is\n * safe or not.\n * @param {ASTNode} loopNode A containing loop node.\n * @param {eslint-scope.Reference} reference A reference to check.\n * @returns {boolean} `true` if the reference is safe or not.\n */\nfunction isSafe(loopNode, reference) {\n    const variable = reference.resolved;\n    const definition = variable && variable.defs[0];\n    const declaration = definition && definition.parent;\n    const kind = (declaration && declaration.type === \"VariableDeclaration\")\n        ? declaration.kind\n        : \"\";\n\n    // Variables which are declared by `const` is safe.\n    if (kind === \"const\") {\n        return true;\n    }\n\n    /*\n     * Variables which are declared by `let` in the loop is safe.\n     * It's a different instance from the next loop step's.\n     */\n    if (kind === \"let\" &&\n        declaration.range[0] > loopNode.range[0] &&\n        declaration.range[1] < loopNode.range[1]\n    ) {\n        return true;\n    }\n\n    /*\n     * WriteReferences which exist after this border are unsafe because those\n     * can modify the variable.\n     */\n    const border = getTopLoopNode(\n        loopNode,\n        (kind === \"let\") ? declaration : null\n    ).range[0];\n\n    /**\n     * Checks whether a given reference is safe or not.\n     * The reference is every reference of the upper scope's variable we are\n     * looking now.\n     *\n     * It's safeafe if the reference matches one of the following condition.\n     * - is readonly.\n     * - doesn't exist inside a local function and after the border.\n     * @param {eslint-scope.Reference} upperRef A reference to check.\n     * @returns {boolean} `true` if the reference is safe.\n     */\n    function isSafeReference(upperRef) {\n        const id = upperRef.identifier;\n\n        return (\n            !upperRef.isWrite() ||\n            variable.scope.variableScope === upperRef.from.variableScope &&\n            id.range[0] < border\n        );\n    }\n\n    return Boolean(variable) && variable.references.every(isSafeReference);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow function declarations that contain unsafe references inside loop statements\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-loop-func\"\n        },\n\n        schema: [],\n\n        messages: {\n            unsafeRefs: \"Function declared in a loop contains unsafe references to variable(s) {{ varNames }}.\"\n        }\n    },\n\n    create(context) {\n\n        /**\n         * Reports functions which match the following condition:\n         *\n         * - has a loop node in ancestors.\n         * - has any references which refers to an unsafe variable.\n         * @param {ASTNode} node The AST node to check.\n         * @returns {boolean} Whether or not the node is within a loop.\n         */\n        function checkForLoops(node) {\n            const loopNode = getContainingLoopNode(node);\n\n            if (!loopNode) {\n                return;\n            }\n\n            const references = context.getScope().through;\n            const unsafeRefs = references.filter(r => !isSafe(loopNode, r)).map(r => r.identifier.name);\n\n            if (unsafeRefs.length > 0) {\n                context.report({\n                    node,\n                    messageId: \"unsafeRefs\",\n                    data: { varNames: `'${unsafeRefs.join(\"', '\")}'` }\n                });\n            }\n        }\n\n        return {\n            ArrowFunctionExpression: checkForLoops,\n            FunctionExpression: checkForLoops,\n            FunctionDeclaration: checkForLoops\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}