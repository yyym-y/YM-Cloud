{"ast":null,"code":"/**\n * @fileoverview Rule to disallow empty functions.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst ALLOW_OPTIONS = Object.freeze([\"functions\", \"arrowFunctions\", \"generatorFunctions\", \"methods\", \"generatorMethods\", \"getters\", \"setters\", \"constructors\", \"asyncFunctions\", \"asyncMethods\"]);\n\n/**\n * Gets the kind of a given function node.\n * @param {ASTNode} node A function node to get. This is one of\n *      an ArrowFunctionExpression, a FunctionDeclaration, or a\n *      FunctionExpression.\n * @returns {string} The kind of the function. This is one of \"functions\",\n *      \"arrowFunctions\", \"generatorFunctions\", \"asyncFunctions\", \"methods\",\n *      \"generatorMethods\", \"asyncMethods\", \"getters\", \"setters\", and\n *      \"constructors\".\n */\nfunction getKind(node) {\n  const parent = node.parent;\n  let kind = \"\";\n  if (node.type === \"ArrowFunctionExpression\") {\n    return \"arrowFunctions\";\n  }\n\n  // Detects main kind.\n  if (parent.type === \"Property\") {\n    if (parent.kind === \"get\") {\n      return \"getters\";\n    }\n    if (parent.kind === \"set\") {\n      return \"setters\";\n    }\n    kind = parent.method ? \"methods\" : \"functions\";\n  } else if (parent.type === \"MethodDefinition\") {\n    if (parent.kind === \"get\") {\n      return \"getters\";\n    }\n    if (parent.kind === \"set\") {\n      return \"setters\";\n    }\n    if (parent.kind === \"constructor\") {\n      return \"constructors\";\n    }\n    kind = \"methods\";\n  } else {\n    kind = \"functions\";\n  }\n\n  // Detects prefix.\n  let prefix = \"\";\n  if (node.generator) {\n    prefix = \"generator\";\n  } else if (node.async) {\n    prefix = \"async\";\n  } else {\n    return kind;\n  }\n  return prefix + kind[0].toUpperCase() + kind.slice(1);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow empty functions\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-empty-function\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        allow: {\n          type: \"array\",\n          items: {\n            enum: ALLOW_OPTIONS\n          },\n          uniqueItems: true\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unexpected: \"Unexpected empty {{name}}.\"\n    }\n  },\n  create(context) {\n    const options = context.options[0] || {};\n    const allowed = options.allow || [];\n    const sourceCode = context.getSourceCode();\n\n    /**\n     * Reports a given function node if the node matches the following patterns.\n     *\n     * - Not allowed by options.\n     * - The body is empty.\n     * - The body doesn't have any comments.\n     * @param {ASTNode} node A function node to report. This is one of\n     *      an ArrowFunctionExpression, a FunctionDeclaration, or a\n     *      FunctionExpression.\n     * @returns {void}\n     */\n    function reportIfEmpty(node) {\n      const kind = getKind(node);\n      const name = astUtils.getFunctionNameWithKind(node);\n      const innerComments = sourceCode.getTokens(node.body, {\n        includeComments: true,\n        filter: astUtils.isCommentToken\n      });\n      if (allowed.indexOf(kind) === -1 && node.body.type === \"BlockStatement\" && node.body.body.length === 0 && innerComments.length === 0) {\n        context.report({\n          node,\n          loc: node.body.loc,\n          messageId: \"unexpected\",\n          data: {\n            name\n          }\n        });\n      }\n    }\n    return {\n      ArrowFunctionExpression: reportIfEmpty,\n      FunctionDeclaration: reportIfEmpty,\n      FunctionExpression: reportIfEmpty\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","ALLOW_OPTIONS","Object","freeze","getKind","node","parent","kind","type","method","prefix","generator","async","toUpperCase","slice","module","exports","meta","docs","description","category","recommended","url","schema","properties","allow","items","enum","uniqueItems","additionalProperties","messages","unexpected","create","context","options","allowed","sourceCode","getSourceCode","reportIfEmpty","name","getFunctionNameWithKind","innerComments","getTokens","body","includeComments","filter","isCommentToken","indexOf","length","report","loc","messageId","data","ArrowFunctionExpression","FunctionDeclaration","FunctionExpression"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/no-empty-function.js"],"sourcesContent":["/**\n * @fileoverview Rule to disallow empty functions.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst ALLOW_OPTIONS = Object.freeze([\n    \"functions\",\n    \"arrowFunctions\",\n    \"generatorFunctions\",\n    \"methods\",\n    \"generatorMethods\",\n    \"getters\",\n    \"setters\",\n    \"constructors\",\n    \"asyncFunctions\",\n    \"asyncMethods\"\n]);\n\n/**\n * Gets the kind of a given function node.\n * @param {ASTNode} node A function node to get. This is one of\n *      an ArrowFunctionExpression, a FunctionDeclaration, or a\n *      FunctionExpression.\n * @returns {string} The kind of the function. This is one of \"functions\",\n *      \"arrowFunctions\", \"generatorFunctions\", \"asyncFunctions\", \"methods\",\n *      \"generatorMethods\", \"asyncMethods\", \"getters\", \"setters\", and\n *      \"constructors\".\n */\nfunction getKind(node) {\n    const parent = node.parent;\n    let kind = \"\";\n\n    if (node.type === \"ArrowFunctionExpression\") {\n        return \"arrowFunctions\";\n    }\n\n    // Detects main kind.\n    if (parent.type === \"Property\") {\n        if (parent.kind === \"get\") {\n            return \"getters\";\n        }\n        if (parent.kind === \"set\") {\n            return \"setters\";\n        }\n        kind = parent.method ? \"methods\" : \"functions\";\n\n    } else if (parent.type === \"MethodDefinition\") {\n        if (parent.kind === \"get\") {\n            return \"getters\";\n        }\n        if (parent.kind === \"set\") {\n            return \"setters\";\n        }\n        if (parent.kind === \"constructor\") {\n            return \"constructors\";\n        }\n        kind = \"methods\";\n\n    } else {\n        kind = \"functions\";\n    }\n\n    // Detects prefix.\n    let prefix = \"\";\n\n    if (node.generator) {\n        prefix = \"generator\";\n    } else if (node.async) {\n        prefix = \"async\";\n    } else {\n        return kind;\n    }\n    return prefix + kind[0].toUpperCase() + kind.slice(1);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow empty functions\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-empty-function\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allow: {\n                        type: \"array\",\n                        items: { enum: ALLOW_OPTIONS },\n                        uniqueItems: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            unexpected: \"Unexpected empty {{name}}.\"\n        }\n    },\n\n    create(context) {\n        const options = context.options[0] || {};\n        const allowed = options.allow || [];\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Reports a given function node if the node matches the following patterns.\n         *\n         * - Not allowed by options.\n         * - The body is empty.\n         * - The body doesn't have any comments.\n         * @param {ASTNode} node A function node to report. This is one of\n         *      an ArrowFunctionExpression, a FunctionDeclaration, or a\n         *      FunctionExpression.\n         * @returns {void}\n         */\n        function reportIfEmpty(node) {\n            const kind = getKind(node);\n            const name = astUtils.getFunctionNameWithKind(node);\n            const innerComments = sourceCode.getTokens(node.body, {\n                includeComments: true,\n                filter: astUtils.isCommentToken\n            });\n\n            if (allowed.indexOf(kind) === -1 &&\n                node.body.type === \"BlockStatement\" &&\n                node.body.body.length === 0 &&\n                innerComments.length === 0\n            ) {\n                context.report({\n                    node,\n                    loc: node.body.loc,\n                    messageId: \"unexpected\",\n                    data: { name }\n                });\n            }\n        }\n\n        return {\n            ArrowFunctionExpression: reportIfEmpty,\n            FunctionDeclaration: reportIfEmpty,\n            FunctionExpression: reportIfEmpty\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}