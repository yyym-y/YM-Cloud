{"ast":null,"code":"/**\n * @fileoverview Rule to disallow use of the `RegExp` constructor in favor of regular expression literals\n * @author Milos Djermanovic\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils\");\nconst {\n  CALL,\n  CONSTRUCT,\n  ReferenceTracker,\n  findVariable\n} = require(\"eslint-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Determines whether the given node is a string literal.\n * @param {ASTNode} node Node to check.\n * @returns {boolean} True if the node is a string literal.\n */\nfunction isStringLiteral(node) {\n  return node.type === \"Literal\" && typeof node.value === \"string\";\n}\n\n/**\n * Determines whether the given node is a regex literal.\n * @param {ASTNode} node Node to check.\n * @returns {boolean} True if the node is a regex literal.\n */\nfunction isRegexLiteral(node) {\n  return node.type === \"Literal\" && Object.prototype.hasOwnProperty.call(node, \"regex\");\n}\n\n/**\n * Determines whether the given node is a template literal without expressions.\n * @param {ASTNode} node Node to check.\n * @returns {boolean} True if the node is a template literal without expressions.\n */\nfunction isStaticTemplateLiteral(node) {\n  return node.type === \"TemplateLiteral\" && node.expressions.length === 0;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow use of the `RegExp` constructor in favor of regular expression literals\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/prefer-regex-literals\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        disallowRedundantWrapping: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unexpectedRegExp: \"Use a regular expression literal instead of the 'RegExp' constructor.\",\n      unexpectedRedundantRegExp: \"Regular expression literal is unnecessarily wrapped within a 'RegExp' constructor.\",\n      unexpectedRedundantRegExpWithFlags: \"Use regular expression literal with flags instead of the 'RegExp' constructor.\"\n    }\n  },\n  create(context) {\n    const [{\n      disallowRedundantWrapping = false\n    } = {}] = context.options;\n\n    /**\n     * Determines whether the given identifier node is a reference to a global variable.\n     * @param {ASTNode} node `Identifier` node to check.\n     * @returns {boolean} True if the identifier is a reference to a global variable.\n     */\n    function isGlobalReference(node) {\n      const scope = context.getScope();\n      const variable = findVariable(scope, node);\n      return variable !== null && variable.scope.type === \"global\" && variable.defs.length === 0;\n    }\n\n    /**\n     * Determines whether the given node is a String.raw`` tagged template expression\n     * with a static template literal.\n     * @param {ASTNode} node Node to check.\n     * @returns {boolean} True if the node is String.raw`` with a static template.\n     */\n    function isStringRawTaggedStaticTemplateLiteral(node) {\n      return node.type === \"TaggedTemplateExpression\" && astUtils.isSpecificMemberAccess(node.tag, \"String\", \"raw\") && isGlobalReference(astUtils.skipChainExpression(node.tag).object) && isStaticTemplateLiteral(node.quasi);\n    }\n\n    /**\n     * Determines whether the given node is considered to be a static string by the logic of this rule.\n     * @param {ASTNode} node Node to check.\n     * @returns {boolean} True if the node is a static string.\n     */\n    function isStaticString(node) {\n      return isStringLiteral(node) || isStaticTemplateLiteral(node) || isStringRawTaggedStaticTemplateLiteral(node);\n    }\n\n    /**\n     * Determines whether the relevant arguments of the given are all static string literals.\n     * @param {ASTNode} node Node to check.\n     * @returns {boolean} True if all arguments are static strings.\n     */\n    function hasOnlyStaticStringArguments(node) {\n      const args = node.arguments;\n      if ((args.length === 1 || args.length === 2) && args.every(isStaticString)) {\n        return true;\n      }\n      return false;\n    }\n\n    /**\n     * Determines whether the arguments of the given node indicate that a regex literal is unnecessarily wrapped.\n     * @param {ASTNode} node Node to check.\n     * @returns {boolean} True if the node already contains a regex literal argument.\n     */\n    function isUnnecessarilyWrappedRegexLiteral(node) {\n      const args = node.arguments;\n      if (args.length === 1 && isRegexLiteral(args[0])) {\n        return true;\n      }\n      if (args.length === 2 && isRegexLiteral(args[0]) && isStaticString(args[1])) {\n        return true;\n      }\n      return false;\n    }\n    return {\n      Program() {\n        const scope = context.getScope();\n        const tracker = new ReferenceTracker(scope);\n        const traceMap = {\n          RegExp: {\n            [CALL]: true,\n            [CONSTRUCT]: true\n          }\n        };\n        for (const {\n          node\n        } of tracker.iterateGlobalReferences(traceMap)) {\n          if (disallowRedundantWrapping && isUnnecessarilyWrappedRegexLiteral(node)) {\n            if (node.arguments.length === 2) {\n              context.report({\n                node,\n                messageId: \"unexpectedRedundantRegExpWithFlags\"\n              });\n            } else {\n              context.report({\n                node,\n                messageId: \"unexpectedRedundantRegExp\"\n              });\n            }\n          } else if (hasOnlyStaticStringArguments(node)) {\n            context.report({\n              node,\n              messageId: \"unexpectedRegExp\"\n            });\n          }\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","CALL","CONSTRUCT","ReferenceTracker","findVariable","isStringLiteral","node","type","value","isRegexLiteral","Object","prototype","hasOwnProperty","call","isStaticTemplateLiteral","expressions","length","module","exports","meta","docs","description","category","recommended","url","schema","properties","disallowRedundantWrapping","default","additionalProperties","messages","unexpectedRegExp","unexpectedRedundantRegExp","unexpectedRedundantRegExpWithFlags","create","context","options","isGlobalReference","scope","getScope","variable","defs","isStringRawTaggedStaticTemplateLiteral","isSpecificMemberAccess","tag","skipChainExpression","object","quasi","isStaticString","hasOnlyStaticStringArguments","args","arguments","every","isUnnecessarilyWrappedRegexLiteral","Program","tracker","traceMap","RegExp","iterateGlobalReferences","report","messageId"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/prefer-regex-literals.js"],"sourcesContent":["/**\n * @fileoverview Rule to disallow use of the `RegExp` constructor in favor of regular expression literals\n * @author Milos Djermanovic\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\nconst { CALL, CONSTRUCT, ReferenceTracker, findVariable } = require(\"eslint-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Determines whether the given node is a string literal.\n * @param {ASTNode} node Node to check.\n * @returns {boolean} True if the node is a string literal.\n */\nfunction isStringLiteral(node) {\n    return node.type === \"Literal\" && typeof node.value === \"string\";\n}\n\n/**\n * Determines whether the given node is a regex literal.\n * @param {ASTNode} node Node to check.\n * @returns {boolean} True if the node is a regex literal.\n */\nfunction isRegexLiteral(node) {\n    return node.type === \"Literal\" && Object.prototype.hasOwnProperty.call(node, \"regex\");\n}\n\n/**\n * Determines whether the given node is a template literal without expressions.\n * @param {ASTNode} node Node to check.\n * @returns {boolean} True if the node is a template literal without expressions.\n */\nfunction isStaticTemplateLiteral(node) {\n    return node.type === \"TemplateLiteral\" && node.expressions.length === 0;\n}\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow use of the `RegExp` constructor in favor of regular expression literals\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/prefer-regex-literals\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    disallowRedundantWrapping: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            unexpectedRegExp: \"Use a regular expression literal instead of the 'RegExp' constructor.\",\n            unexpectedRedundantRegExp: \"Regular expression literal is unnecessarily wrapped within a 'RegExp' constructor.\",\n            unexpectedRedundantRegExpWithFlags: \"Use regular expression literal with flags instead of the 'RegExp' constructor.\"\n        }\n    },\n\n    create(context) {\n        const [{ disallowRedundantWrapping = false } = {}] = context.options;\n\n        /**\n         * Determines whether the given identifier node is a reference to a global variable.\n         * @param {ASTNode} node `Identifier` node to check.\n         * @returns {boolean} True if the identifier is a reference to a global variable.\n         */\n        function isGlobalReference(node) {\n            const scope = context.getScope();\n            const variable = findVariable(scope, node);\n\n            return variable !== null && variable.scope.type === \"global\" && variable.defs.length === 0;\n        }\n\n        /**\n         * Determines whether the given node is a String.raw`` tagged template expression\n         * with a static template literal.\n         * @param {ASTNode} node Node to check.\n         * @returns {boolean} True if the node is String.raw`` with a static template.\n         */\n        function isStringRawTaggedStaticTemplateLiteral(node) {\n            return node.type === \"TaggedTemplateExpression\" &&\n                astUtils.isSpecificMemberAccess(node.tag, \"String\", \"raw\") &&\n                isGlobalReference(astUtils.skipChainExpression(node.tag).object) &&\n                isStaticTemplateLiteral(node.quasi);\n        }\n\n        /**\n         * Determines whether the given node is considered to be a static string by the logic of this rule.\n         * @param {ASTNode} node Node to check.\n         * @returns {boolean} True if the node is a static string.\n         */\n        function isStaticString(node) {\n            return isStringLiteral(node) ||\n                isStaticTemplateLiteral(node) ||\n                isStringRawTaggedStaticTemplateLiteral(node);\n        }\n\n        /**\n         * Determines whether the relevant arguments of the given are all static string literals.\n         * @param {ASTNode} node Node to check.\n         * @returns {boolean} True if all arguments are static strings.\n         */\n        function hasOnlyStaticStringArguments(node) {\n            const args = node.arguments;\n\n            if ((args.length === 1 || args.length === 2) && args.every(isStaticString)) {\n                return true;\n            }\n\n            return false;\n        }\n\n        /**\n         * Determines whether the arguments of the given node indicate that a regex literal is unnecessarily wrapped.\n         * @param {ASTNode} node Node to check.\n         * @returns {boolean} True if the node already contains a regex literal argument.\n         */\n        function isUnnecessarilyWrappedRegexLiteral(node) {\n            const args = node.arguments;\n\n            if (args.length === 1 && isRegexLiteral(args[0])) {\n                return true;\n            }\n\n            if (args.length === 2 && isRegexLiteral(args[0]) && isStaticString(args[1])) {\n                return true;\n            }\n\n            return false;\n        }\n\n        return {\n            Program() {\n                const scope = context.getScope();\n                const tracker = new ReferenceTracker(scope);\n                const traceMap = {\n                    RegExp: {\n                        [CALL]: true,\n                        [CONSTRUCT]: true\n                    }\n                };\n\n                for (const { node } of tracker.iterateGlobalReferences(traceMap)) {\n                    if (disallowRedundantWrapping && isUnnecessarilyWrappedRegexLiteral(node)) {\n                        if (node.arguments.length === 2) {\n                            context.report({ node, messageId: \"unexpectedRedundantRegExpWithFlags\" });\n                        } else {\n                            context.report({ node, messageId: \"unexpectedRedundantRegExp\" });\n                        }\n                    } else if (hasOnlyStaticStringArguments(node)) {\n                        context.report({ node, messageId: \"unexpectedRegExp\" });\n                    }\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}