{"ast":null,"code":"require(\"core-js/modules/es.array.push.js\");\n// Generated by LiveScript 1.6.0\n(function () {\n  var identifierRegex, tokenRegex;\n  identifierRegex = /[\\$\\w]+/;\n  function peek(tokens) {\n    var token;\n    token = tokens[0];\n    if (token == null) {\n      throw new Error('Unexpected end of input.');\n    }\n    return token;\n  }\n  function consumeIdent(tokens) {\n    var token;\n    token = peek(tokens);\n    if (!identifierRegex.test(token)) {\n      throw new Error(\"Expected text, got '\" + token + \"' instead.\");\n    }\n    return tokens.shift();\n  }\n  function consumeOp(tokens, op) {\n    var token;\n    token = peek(tokens);\n    if (token !== op) {\n      throw new Error(\"Expected '\" + op + \"', got '\" + token + \"' instead.\");\n    }\n    return tokens.shift();\n  }\n  function maybeConsumeOp(tokens, op) {\n    var token;\n    token = tokens[0];\n    if (token === op) {\n      return tokens.shift();\n    } else {\n      return null;\n    }\n  }\n  function consumeArray(tokens) {\n    var types;\n    consumeOp(tokens, '[');\n    if (peek(tokens) === ']') {\n      throw new Error(\"Must specify type of Array - eg. [Type], got [] instead.\");\n    }\n    types = consumeTypes(tokens);\n    consumeOp(tokens, ']');\n    return {\n      structure: 'array',\n      of: types\n    };\n  }\n  function consumeTuple(tokens) {\n    var components;\n    components = [];\n    consumeOp(tokens, '(');\n    if (peek(tokens) === ')') {\n      throw new Error(\"Tuple must be of at least length 1 - eg. (Type), got () instead.\");\n    }\n    for (;;) {\n      components.push(consumeTypes(tokens));\n      maybeConsumeOp(tokens, ',');\n      if (')' === peek(tokens)) {\n        break;\n      }\n    }\n    consumeOp(tokens, ')');\n    return {\n      structure: 'tuple',\n      of: components\n    };\n  }\n  function consumeFields(tokens) {\n    var fields, subset, ref$, key, types;\n    fields = {};\n    consumeOp(tokens, '{');\n    subset = false;\n    for (;;) {\n      if (maybeConsumeOp(tokens, '...')) {\n        subset = true;\n        break;\n      }\n      ref$ = consumeField(tokens), key = ref$[0], types = ref$[1];\n      fields[key] = types;\n      maybeConsumeOp(tokens, ',');\n      if ('}' === peek(tokens)) {\n        break;\n      }\n    }\n    consumeOp(tokens, '}');\n    return {\n      structure: 'fields',\n      of: fields,\n      subset: subset\n    };\n  }\n  function consumeField(tokens) {\n    var key, types;\n    key = consumeIdent(tokens);\n    consumeOp(tokens, ':');\n    types = consumeTypes(tokens);\n    return [key, types];\n  }\n  function maybeConsumeStructure(tokens) {\n    switch (tokens[0]) {\n      case '[':\n        return consumeArray(tokens);\n      case '(':\n        return consumeTuple(tokens);\n      case '{':\n        return consumeFields(tokens);\n    }\n  }\n  function consumeType(tokens) {\n    var token, wildcard, type, structure;\n    token = peek(tokens);\n    wildcard = token === '*';\n    if (wildcard || identifierRegex.test(token)) {\n      type = wildcard ? consumeOp(tokens, '*') : consumeIdent(tokens);\n      structure = maybeConsumeStructure(tokens);\n      if (structure) {\n        return structure.type = type, structure;\n      } else {\n        return {\n          type: type\n        };\n      }\n    } else {\n      structure = maybeConsumeStructure(tokens);\n      if (!structure) {\n        throw new Error(\"Unexpected character: \" + token);\n      }\n      return structure;\n    }\n  }\n  function consumeTypes(tokens) {\n    var lookahead, types, typesSoFar, typeObj, type, structure;\n    if ('::' === peek(tokens)) {\n      throw new Error(\"No comment before comment separator '::' found.\");\n    }\n    lookahead = tokens[1];\n    if (lookahead != null && lookahead === '::') {\n      tokens.shift();\n      tokens.shift();\n    }\n    types = [];\n    typesSoFar = {};\n    if ('Maybe' === peek(tokens)) {\n      tokens.shift();\n      types = [{\n        type: 'Undefined'\n      }, {\n        type: 'Null'\n      }];\n      typesSoFar = {\n        Undefined: true,\n        Null: true\n      };\n    }\n    for (;;) {\n      typeObj = consumeType(tokens), type = typeObj.type, structure = typeObj.structure;\n      if (!typesSoFar[type]) {\n        types.push(typeObj);\n      }\n      if (structure == null) {\n        typesSoFar[type] = true;\n      }\n      if (!maybeConsumeOp(tokens, '|')) {\n        break;\n      }\n    }\n    return types;\n  }\n  tokenRegex = RegExp('\\\\.\\\\.\\\\.|::|->|' + identifierRegex.source + '|\\\\S', 'g');\n  module.exports = function (input) {\n    var tokens, e;\n    if (!input.length) {\n      throw new Error('No type specified.');\n    }\n    tokens = input.match(tokenRegex) || [];\n    if (in$('->', tokens)) {\n      throw new Error(\"Function types are not supported.\\ To validate that something is a function, you may use 'Function'.\");\n    }\n    try {\n      return consumeTypes(tokens);\n    } catch (e$) {\n      e = e$;\n      throw new Error(e.message + \" - Remaining tokens: \" + JSON.stringify(tokens) + \" - Initial input: '\" + input + \"'\");\n    }\n  };\n  function in$(x, xs) {\n    var i = -1,\n      l = xs.length >>> 0;\n    while (++i < l) if (x === xs[i]) return true;\n    return false;\n  }\n}).call(this);","map":{"version":3,"names":["identifierRegex","tokenRegex","peek","tokens","token","Error","consumeIdent","test","shift","consumeOp","op","maybeConsumeOp","consumeArray","types","consumeTypes","structure","of","consumeTuple","components","push","consumeFields","fields","subset","ref$","key","consumeField","maybeConsumeStructure","consumeType","wildcard","type","lookahead","typesSoFar","typeObj","Undefined","Null","RegExp","source","module","exports","input","e","length","match","in$","e$","message","JSON","stringify","x","xs","i","l","call"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/type-check/lib/parse-type.js"],"sourcesContent":["// Generated by LiveScript 1.6.0\n(function(){\n  var identifierRegex, tokenRegex;\n  identifierRegex = /[\\$\\w]+/;\n  function peek(tokens){\n    var token;\n    token = tokens[0];\n    if (token == null) {\n      throw new Error('Unexpected end of input.');\n    }\n    return token;\n  }\n  function consumeIdent(tokens){\n    var token;\n    token = peek(tokens);\n    if (!identifierRegex.test(token)) {\n      throw new Error(\"Expected text, got '\" + token + \"' instead.\");\n    }\n    return tokens.shift();\n  }\n  function consumeOp(tokens, op){\n    var token;\n    token = peek(tokens);\n    if (token !== op) {\n      throw new Error(\"Expected '\" + op + \"', got '\" + token + \"' instead.\");\n    }\n    return tokens.shift();\n  }\n  function maybeConsumeOp(tokens, op){\n    var token;\n    token = tokens[0];\n    if (token === op) {\n      return tokens.shift();\n    } else {\n      return null;\n    }\n  }\n  function consumeArray(tokens){\n    var types;\n    consumeOp(tokens, '[');\n    if (peek(tokens) === ']') {\n      throw new Error(\"Must specify type of Array - eg. [Type], got [] instead.\");\n    }\n    types = consumeTypes(tokens);\n    consumeOp(tokens, ']');\n    return {\n      structure: 'array',\n      of: types\n    };\n  }\n  function consumeTuple(tokens){\n    var components;\n    components = [];\n    consumeOp(tokens, '(');\n    if (peek(tokens) === ')') {\n      throw new Error(\"Tuple must be of at least length 1 - eg. (Type), got () instead.\");\n    }\n    for (;;) {\n      components.push(consumeTypes(tokens));\n      maybeConsumeOp(tokens, ',');\n      if (')' === peek(tokens)) {\n        break;\n      }\n    }\n    consumeOp(tokens, ')');\n    return {\n      structure: 'tuple',\n      of: components\n    };\n  }\n  function consumeFields(tokens){\n    var fields, subset, ref$, key, types;\n    fields = {};\n    consumeOp(tokens, '{');\n    subset = false;\n    for (;;) {\n      if (maybeConsumeOp(tokens, '...')) {\n        subset = true;\n        break;\n      }\n      ref$ = consumeField(tokens), key = ref$[0], types = ref$[1];\n      fields[key] = types;\n      maybeConsumeOp(tokens, ',');\n      if ('}' === peek(tokens)) {\n        break;\n      }\n    }\n    consumeOp(tokens, '}');\n    return {\n      structure: 'fields',\n      of: fields,\n      subset: subset\n    };\n  }\n  function consumeField(tokens){\n    var key, types;\n    key = consumeIdent(tokens);\n    consumeOp(tokens, ':');\n    types = consumeTypes(tokens);\n    return [key, types];\n  }\n  function maybeConsumeStructure(tokens){\n    switch (tokens[0]) {\n    case '[':\n      return consumeArray(tokens);\n    case '(':\n      return consumeTuple(tokens);\n    case '{':\n      return consumeFields(tokens);\n    }\n  }\n  function consumeType(tokens){\n    var token, wildcard, type, structure;\n    token = peek(tokens);\n    wildcard = token === '*';\n    if (wildcard || identifierRegex.test(token)) {\n      type = wildcard\n        ? consumeOp(tokens, '*')\n        : consumeIdent(tokens);\n      structure = maybeConsumeStructure(tokens);\n      if (structure) {\n        return structure.type = type, structure;\n      } else {\n        return {\n          type: type\n        };\n      }\n    } else {\n      structure = maybeConsumeStructure(tokens);\n      if (!structure) {\n        throw new Error(\"Unexpected character: \" + token);\n      }\n      return structure;\n    }\n  }\n  function consumeTypes(tokens){\n    var lookahead, types, typesSoFar, typeObj, type, structure;\n    if ('::' === peek(tokens)) {\n      throw new Error(\"No comment before comment separator '::' found.\");\n    }\n    lookahead = tokens[1];\n    if (lookahead != null && lookahead === '::') {\n      tokens.shift();\n      tokens.shift();\n    }\n    types = [];\n    typesSoFar = {};\n    if ('Maybe' === peek(tokens)) {\n      tokens.shift();\n      types = [\n        {\n          type: 'Undefined'\n        }, {\n          type: 'Null'\n        }\n      ];\n      typesSoFar = {\n        Undefined: true,\n        Null: true\n      };\n    }\n    for (;;) {\n      typeObj = consumeType(tokens), type = typeObj.type, structure = typeObj.structure;\n      if (!typesSoFar[type]) {\n        types.push(typeObj);\n      }\n      if (structure == null) {\n        typesSoFar[type] = true;\n      }\n      if (!maybeConsumeOp(tokens, '|')) {\n        break;\n      }\n    }\n    return types;\n  }\n  tokenRegex = RegExp('\\\\.\\\\.\\\\.|::|->|' + identifierRegex.source + '|\\\\S', 'g');\n  module.exports = function(input){\n    var tokens, e;\n    if (!input.length) {\n      throw new Error('No type specified.');\n    }\n    tokens = input.match(tokenRegex) || [];\n    if (in$('->', tokens)) {\n      throw new Error(\"Function types are not supported.\\ To validate that something is a function, you may use 'Function'.\");\n    }\n    try {\n      return consumeTypes(tokens);\n    } catch (e$) {\n      e = e$;\n      throw new Error(e.message + \" - Remaining tokens: \" + JSON.stringify(tokens) + \" - Initial input: '\" + input + \"'\");\n    }\n  };\n  function in$(x, xs){\n    var i = -1, l = xs.length >>> 0;\n    while (++i < l) if (x === xs[i]) return true;\n    return false;\n  }\n}).call(this);\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}