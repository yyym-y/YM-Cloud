{"ast":null,"code":"/**\n * @fileoverview Rule to flag statements without curly braces\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nrequire(\"core-js/modules/es.array.push.js\");\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"enforce consistent brace style for all control statements\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/curly\"\n    },\n    schema: {\n      anyOf: [{\n        type: \"array\",\n        items: [{\n          enum: [\"all\"]\n        }],\n        minItems: 0,\n        maxItems: 1\n      }, {\n        type: \"array\",\n        items: [{\n          enum: [\"multi\", \"multi-line\", \"multi-or-nest\"]\n        }, {\n          enum: [\"consistent\"]\n        }],\n        minItems: 0,\n        maxItems: 2\n      }]\n    },\n    fixable: \"code\",\n    messages: {\n      missingCurlyAfter: \"Expected { after '{{name}}'.\",\n      missingCurlyAfterCondition: \"Expected { after '{{name}}' condition.\",\n      unexpectedCurlyAfter: \"Unnecessary { after '{{name}}'.\",\n      unexpectedCurlyAfterCondition: \"Unnecessary { after '{{name}}' condition.\"\n    }\n  },\n  create(context) {\n    const multiOnly = context.options[0] === \"multi\";\n    const multiLine = context.options[0] === \"multi-line\";\n    const multiOrNest = context.options[0] === \"multi-or-nest\";\n    const consistent = context.options[1] === \"consistent\";\n    const sourceCode = context.getSourceCode();\n\n    //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    /**\n     * Determines if a given node is a one-liner that's on the same line as it's preceding code.\n     * @param {ASTNode} node The node to check.\n     * @returns {boolean} True if the node is a one-liner that's on the same line as it's preceding code.\n     * @private\n     */\n    function isCollapsedOneLiner(node) {\n      const before = sourceCode.getTokenBefore(node);\n      const last = sourceCode.getLastToken(node);\n      const lastExcludingSemicolon = astUtils.isSemicolonToken(last) ? sourceCode.getTokenBefore(last) : last;\n      return before.loc.start.line === lastExcludingSemicolon.loc.end.line;\n    }\n\n    /**\n     * Determines if a given node is a one-liner.\n     * @param {ASTNode} node The node to check.\n     * @returns {boolean} True if the node is a one-liner.\n     * @private\n     */\n    function isOneLiner(node) {\n      if (node.type === \"EmptyStatement\") {\n        return true;\n      }\n      const first = sourceCode.getFirstToken(node);\n      const last = sourceCode.getLastToken(node);\n      const lastExcludingSemicolon = astUtils.isSemicolonToken(last) ? sourceCode.getTokenBefore(last) : last;\n      return first.loc.start.line === lastExcludingSemicolon.loc.end.line;\n    }\n\n    /**\n     * Determines if the given node is a lexical declaration (let, const, function, or class)\n     * @param {ASTNode} node The node to check\n     * @returns {boolean} True if the node is a lexical declaration\n     * @private\n     */\n    function isLexicalDeclaration(node) {\n      if (node.type === \"VariableDeclaration\") {\n        return node.kind === \"const\" || node.kind === \"let\";\n      }\n      return node.type === \"FunctionDeclaration\" || node.type === \"ClassDeclaration\";\n    }\n\n    /**\n     * Checks if the given token is an `else` token or not.\n     * @param {Token} token The token to check.\n     * @returns {boolean} `true` if the token is an `else` token.\n     */\n    function isElseKeywordToken(token) {\n      return token.value === \"else\" && token.type === \"Keyword\";\n    }\n\n    /**\n     * Determines whether the given node has an `else` keyword token as the first token after.\n     * @param {ASTNode} node The node to check.\n     * @returns {boolean} `true` if the node is followed by an `else` keyword token.\n     */\n    function isFollowedByElseKeyword(node) {\n      const nextToken = sourceCode.getTokenAfter(node);\n      return Boolean(nextToken) && isElseKeywordToken(nextToken);\n    }\n\n    /**\n     * Determines if a semicolon needs to be inserted after removing a set of curly brackets, in order to avoid a SyntaxError.\n     * @param {Token} closingBracket The } token\n     * @returns {boolean} `true` if a semicolon needs to be inserted after the last statement in the block.\n     */\n    function needsSemicolon(closingBracket) {\n      const tokenBefore = sourceCode.getTokenBefore(closingBracket);\n      const tokenAfter = sourceCode.getTokenAfter(closingBracket);\n      const lastBlockNode = sourceCode.getNodeByRangeIndex(tokenBefore.range[0]);\n      if (astUtils.isSemicolonToken(tokenBefore)) {\n        // If the last statement already has a semicolon, don't add another one.\n        return false;\n      }\n      if (!tokenAfter) {\n        // If there are no statements after this block, there is no need to add a semicolon.\n        return false;\n      }\n      if (lastBlockNode.type === \"BlockStatement\" && lastBlockNode.parent.type !== \"FunctionExpression\" && lastBlockNode.parent.type !== \"ArrowFunctionExpression\") {\n        /*\n         * If the last node surrounded by curly brackets is a BlockStatement (other than a FunctionExpression or an ArrowFunctionExpression),\n         * don't insert a semicolon. Otherwise, the semicolon would be parsed as a separate statement, which would cause\n         * a SyntaxError if it was followed by `else`.\n         */\n        return false;\n      }\n      if (tokenBefore.loc.end.line === tokenAfter.loc.start.line) {\n        // If the next token is on the same line, insert a semicolon.\n        return true;\n      }\n      if (/^[([/`+-]/u.test(tokenAfter.value)) {\n        // If the next token starts with a character that would disrupt ASI, insert a semicolon.\n        return true;\n      }\n      if (tokenBefore.type === \"Punctuator\" && (tokenBefore.value === \"++\" || tokenBefore.value === \"--\")) {\n        // If the last token is ++ or --, insert a semicolon to avoid disrupting ASI.\n        return true;\n      }\n\n      // Otherwise, do not insert a semicolon.\n      return false;\n    }\n\n    /**\n     * Determines whether the code represented by the given node contains an `if` statement\n     * that would become associated with an `else` keyword directly appended to that code.\n     *\n     * Examples where it returns `true`:\n     *\n     *    if (a)\n     *        foo();\n     *\n     *    if (a) {\n     *        foo();\n     *    }\n     *\n     *    if (a)\n     *        foo();\n     *    else if (b)\n     *        bar();\n     *\n     *    while (a)\n     *        if (b)\n     *            if(c)\n     *                foo();\n     *            else\n     *                bar();\n     *\n     * Examples where it returns `false`:\n     *\n     *    if (a)\n     *        foo();\n     *    else\n     *        bar();\n     *\n     *    while (a) {\n     *        if (b)\n     *            if(c)\n     *                foo();\n     *            else\n     *                bar();\n     *    }\n     *\n     *    while (a)\n     *        if (b) {\n     *            if(c)\n     *                foo();\n     *        }\n     *        else\n     *            bar();\n     * @param {ASTNode} node Node representing the code to check.\n     * @returns {boolean} `true` if an `if` statement within the code would become associated with an `else` appended to that code.\n     */\n    function hasUnsafeIf(node) {\n      switch (node.type) {\n        case \"IfStatement\":\n          if (!node.alternate) {\n            return true;\n          }\n          return hasUnsafeIf(node.alternate);\n        case \"ForStatement\":\n        case \"ForInStatement\":\n        case \"ForOfStatement\":\n        case \"LabeledStatement\":\n        case \"WithStatement\":\n        case \"WhileStatement\":\n          return hasUnsafeIf(node.body);\n        default:\n          return false;\n      }\n    }\n\n    /**\n     * Determines whether the existing curly braces around the single statement are necessary to preserve the semantics of the code.\n     * The braces, which make the given block body, are necessary in either of the following situations:\n     *\n     * 1. The statement is a lexical declaration.\n     * 2. Without the braces, an `if` within the statement would become associated with an `else` after the closing brace:\n     *\n     *     if (a) {\n     *         if (b)\n     *             foo();\n     *     }\n     *     else\n     *         bar();\n     *\n     *     if (a)\n     *         while (b)\n     *             while (c) {\n     *                 while (d)\n     *                     if (e)\n     *                         while(f)\n     *                             foo();\n     *            }\n     *     else\n     *         bar();\n     * @param {ASTNode} node `BlockStatement` body with exactly one statement directly inside. The statement can have its own nested statements.\n     * @returns {boolean} `true` if the braces are necessary - removing them (replacing the given `BlockStatement` body with its single statement content)\n     * would change the semantics of the code or produce a syntax error.\n     */\n    function areBracesNecessary(node) {\n      const statement = node.body[0];\n      return isLexicalDeclaration(statement) || hasUnsafeIf(statement) && isFollowedByElseKeyword(node);\n    }\n\n    /**\n     * Prepares to check the body of a node to see if it's a block statement.\n     * @param {ASTNode} node The node to report if there's a problem.\n     * @param {ASTNode} body The body node to check for blocks.\n     * @param {string} name The name to report if there's a problem.\n     * @param {{ condition: boolean }} opts Options to pass to the report functions\n     * @returns {Object} a prepared check object, with \"actual\", \"expected\", \"check\" properties.\n     *   \"actual\" will be `true` or `false` whether the body is already a block statement.\n     *   \"expected\" will be `true` or `false` if the body should be a block statement or not, or\n     *   `null` if it doesn't matter, depending on the rule options. It can be modified to change\n     *   the final behavior of \"check\".\n     *   \"check\" will be a function reporting appropriate problems depending on the other\n     *   properties.\n     */\n    function prepareCheck(node, body, name, opts) {\n      const hasBlock = body.type === \"BlockStatement\";\n      let expected = null;\n      if (hasBlock && (body.body.length !== 1 || areBracesNecessary(body))) {\n        expected = true;\n      } else if (multiOnly) {\n        expected = false;\n      } else if (multiLine) {\n        if (!isCollapsedOneLiner(body)) {\n          expected = true;\n        }\n\n        // otherwise, the body is allowed to have braces or not to have braces\n      } else if (multiOrNest) {\n        if (hasBlock) {\n          const statement = body.body[0];\n          const leadingCommentsInBlock = sourceCode.getCommentsBefore(statement);\n          expected = !isOneLiner(statement) || leadingCommentsInBlock.length > 0;\n        } else {\n          expected = !isOneLiner(body);\n        }\n      } else {\n        // default \"all\"\n        expected = true;\n      }\n      return {\n        actual: hasBlock,\n        expected,\n        check() {\n          if (this.expected !== null && this.expected !== this.actual) {\n            if (this.expected) {\n              context.report({\n                node,\n                loc: body.loc,\n                messageId: opts && opts.condition ? \"missingCurlyAfterCondition\" : \"missingCurlyAfter\",\n                data: {\n                  name\n                },\n                fix: fixer => fixer.replaceText(body, `{${sourceCode.getText(body)}}`)\n              });\n            } else {\n              context.report({\n                node,\n                loc: body.loc,\n                messageId: opts && opts.condition ? \"unexpectedCurlyAfterCondition\" : \"unexpectedCurlyAfter\",\n                data: {\n                  name\n                },\n                fix(fixer) {\n                  /*\n                   * `do while` expressions sometimes need a space to be inserted after `do`.\n                   * e.g. `do{foo()} while (bar)` should be corrected to `do foo() while (bar)`\n                   */\n                  const needsPrecedingSpace = node.type === \"DoWhileStatement\" && sourceCode.getTokenBefore(body).range[1] === body.range[0] && !astUtils.canTokensBeAdjacent(\"do\", sourceCode.getFirstToken(body, {\n                    skip: 1\n                  }));\n                  const openingBracket = sourceCode.getFirstToken(body);\n                  const closingBracket = sourceCode.getLastToken(body);\n                  const lastTokenInBlock = sourceCode.getTokenBefore(closingBracket);\n                  if (needsSemicolon(closingBracket)) {\n                    /*\n                     * If removing braces would cause a SyntaxError due to multiple statements on the same line (or\n                     * change the semantics of the code due to ASI), don't perform a fix.\n                     */\n                    return null;\n                  }\n                  const resultingBodyText = sourceCode.getText().slice(openingBracket.range[1], lastTokenInBlock.range[0]) + sourceCode.getText(lastTokenInBlock) + sourceCode.getText().slice(lastTokenInBlock.range[1], closingBracket.range[0]);\n                  return fixer.replaceText(body, (needsPrecedingSpace ? \" \" : \"\") + resultingBodyText);\n                }\n              });\n            }\n          }\n        }\n      };\n    }\n\n    /**\n     * Prepares to check the bodies of a \"if\", \"else if\" and \"else\" chain.\n     * @param {ASTNode} node The first IfStatement node of the chain.\n     * @returns {Object[]} prepared checks for each body of the chain. See `prepareCheck` for more\n     *   information.\n     */\n    function prepareIfChecks(node) {\n      const preparedChecks = [];\n      for (let currentNode = node; currentNode; currentNode = currentNode.alternate) {\n        preparedChecks.push(prepareCheck(currentNode, currentNode.consequent, \"if\", {\n          condition: true\n        }));\n        if (currentNode.alternate && currentNode.alternate.type !== \"IfStatement\") {\n          preparedChecks.push(prepareCheck(currentNode, currentNode.alternate, \"else\"));\n          break;\n        }\n      }\n      if (consistent) {\n        /*\n         * If any node should have or already have braces, make sure they\n         * all have braces.\n         * If all nodes shouldn't have braces, make sure they don't.\n         */\n        const expected = preparedChecks.some(preparedCheck => {\n          if (preparedCheck.expected !== null) {\n            return preparedCheck.expected;\n          }\n          return preparedCheck.actual;\n        });\n        preparedChecks.forEach(preparedCheck => {\n          preparedCheck.expected = expected;\n        });\n      }\n      return preparedChecks;\n    }\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    return {\n      IfStatement(node) {\n        const parent = node.parent;\n        const isElseIf = parent.type === \"IfStatement\" && parent.alternate === node;\n        if (!isElseIf) {\n          // This is a top `if`, check the whole `if-else-if` chain\n          prepareIfChecks(node).forEach(preparedCheck => {\n            preparedCheck.check();\n          });\n        }\n\n        // Skip `else if`, it's already checked (when the top `if` was visited)\n      },\n\n      WhileStatement(node) {\n        prepareCheck(node, node.body, \"while\", {\n          condition: true\n        }).check();\n      },\n      DoWhileStatement(node) {\n        prepareCheck(node, node.body, \"do\").check();\n      },\n      ForStatement(node) {\n        prepareCheck(node, node.body, \"for\", {\n          condition: true\n        }).check();\n      },\n      ForInStatement(node) {\n        prepareCheck(node, node.body, \"for-in\").check();\n      },\n      ForOfStatement(node) {\n        prepareCheck(node, node.body, \"for-of\").check();\n      }\n    };\n  }\n};","map":{"version":3,"names":["require","astUtils","module","exports","meta","type","docs","description","category","recommended","url","schema","anyOf","items","enum","minItems","maxItems","fixable","messages","missingCurlyAfter","missingCurlyAfterCondition","unexpectedCurlyAfter","unexpectedCurlyAfterCondition","create","context","multiOnly","options","multiLine","multiOrNest","consistent","sourceCode","getSourceCode","isCollapsedOneLiner","node","before","getTokenBefore","last","getLastToken","lastExcludingSemicolon","isSemicolonToken","loc","start","line","end","isOneLiner","first","getFirstToken","isLexicalDeclaration","kind","isElseKeywordToken","token","value","isFollowedByElseKeyword","nextToken","getTokenAfter","Boolean","needsSemicolon","closingBracket","tokenBefore","tokenAfter","lastBlockNode","getNodeByRangeIndex","range","parent","test","hasUnsafeIf","alternate","body","areBracesNecessary","statement","prepareCheck","name","opts","hasBlock","expected","length","leadingCommentsInBlock","getCommentsBefore","actual","check","report","messageId","condition","data","fix","fixer","replaceText","getText","needsPrecedingSpace","canTokensBeAdjacent","skip","openingBracket","lastTokenInBlock","resultingBodyText","slice","prepareIfChecks","preparedChecks","currentNode","push","consequent","some","preparedCheck","forEach","IfStatement","isElseIf","WhileStatement","DoWhileStatement","ForStatement","ForInStatement","ForOfStatement"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/curly.js"],"sourcesContent":["/**\n * @fileoverview Rule to flag statements without curly braces\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce consistent brace style for all control statements\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/curly\"\n        },\n\n        schema: {\n            anyOf: [\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"all\"]\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 1\n                },\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"multi\", \"multi-line\", \"multi-or-nest\"]\n                        },\n                        {\n                            enum: [\"consistent\"]\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 2\n                }\n            ]\n        },\n\n        fixable: \"code\",\n\n        messages: {\n            missingCurlyAfter: \"Expected { after '{{name}}'.\",\n            missingCurlyAfterCondition: \"Expected { after '{{name}}' condition.\",\n            unexpectedCurlyAfter: \"Unnecessary { after '{{name}}'.\",\n            unexpectedCurlyAfterCondition: \"Unnecessary { after '{{name}}' condition.\"\n        }\n    },\n\n    create(context) {\n\n        const multiOnly = (context.options[0] === \"multi\");\n        const multiLine = (context.options[0] === \"multi-line\");\n        const multiOrNest = (context.options[0] === \"multi-or-nest\");\n        const consistent = (context.options[1] === \"consistent\");\n\n        const sourceCode = context.getSourceCode();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Determines if a given node is a one-liner that's on the same line as it's preceding code.\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} True if the node is a one-liner that's on the same line as it's preceding code.\n         * @private\n         */\n        function isCollapsedOneLiner(node) {\n            const before = sourceCode.getTokenBefore(node);\n            const last = sourceCode.getLastToken(node);\n            const lastExcludingSemicolon = astUtils.isSemicolonToken(last) ? sourceCode.getTokenBefore(last) : last;\n\n            return before.loc.start.line === lastExcludingSemicolon.loc.end.line;\n        }\n\n        /**\n         * Determines if a given node is a one-liner.\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} True if the node is a one-liner.\n         * @private\n         */\n        function isOneLiner(node) {\n            if (node.type === \"EmptyStatement\") {\n                return true;\n            }\n\n            const first = sourceCode.getFirstToken(node);\n            const last = sourceCode.getLastToken(node);\n            const lastExcludingSemicolon = astUtils.isSemicolonToken(last) ? sourceCode.getTokenBefore(last) : last;\n\n            return first.loc.start.line === lastExcludingSemicolon.loc.end.line;\n        }\n\n        /**\n         * Determines if the given node is a lexical declaration (let, const, function, or class)\n         * @param {ASTNode} node The node to check\n         * @returns {boolean} True if the node is a lexical declaration\n         * @private\n         */\n        function isLexicalDeclaration(node) {\n            if (node.type === \"VariableDeclaration\") {\n                return node.kind === \"const\" || node.kind === \"let\";\n            }\n\n            return node.type === \"FunctionDeclaration\" || node.type === \"ClassDeclaration\";\n        }\n\n        /**\n         * Checks if the given token is an `else` token or not.\n         * @param {Token} token The token to check.\n         * @returns {boolean} `true` if the token is an `else` token.\n         */\n        function isElseKeywordToken(token) {\n            return token.value === \"else\" && token.type === \"Keyword\";\n        }\n\n        /**\n         * Determines whether the given node has an `else` keyword token as the first token after.\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} `true` if the node is followed by an `else` keyword token.\n         */\n        function isFollowedByElseKeyword(node) {\n            const nextToken = sourceCode.getTokenAfter(node);\n\n            return Boolean(nextToken) && isElseKeywordToken(nextToken);\n        }\n\n        /**\n         * Determines if a semicolon needs to be inserted after removing a set of curly brackets, in order to avoid a SyntaxError.\n         * @param {Token} closingBracket The } token\n         * @returns {boolean} `true` if a semicolon needs to be inserted after the last statement in the block.\n         */\n        function needsSemicolon(closingBracket) {\n            const tokenBefore = sourceCode.getTokenBefore(closingBracket);\n            const tokenAfter = sourceCode.getTokenAfter(closingBracket);\n            const lastBlockNode = sourceCode.getNodeByRangeIndex(tokenBefore.range[0]);\n\n            if (astUtils.isSemicolonToken(tokenBefore)) {\n\n                // If the last statement already has a semicolon, don't add another one.\n                return false;\n            }\n\n            if (!tokenAfter) {\n\n                // If there are no statements after this block, there is no need to add a semicolon.\n                return false;\n            }\n\n            if (lastBlockNode.type === \"BlockStatement\" && lastBlockNode.parent.type !== \"FunctionExpression\" && lastBlockNode.parent.type !== \"ArrowFunctionExpression\") {\n\n                /*\n                 * If the last node surrounded by curly brackets is a BlockStatement (other than a FunctionExpression or an ArrowFunctionExpression),\n                 * don't insert a semicolon. Otherwise, the semicolon would be parsed as a separate statement, which would cause\n                 * a SyntaxError if it was followed by `else`.\n                 */\n                return false;\n            }\n\n            if (tokenBefore.loc.end.line === tokenAfter.loc.start.line) {\n\n                // If the next token is on the same line, insert a semicolon.\n                return true;\n            }\n\n            if (/^[([/`+-]/u.test(tokenAfter.value)) {\n\n                // If the next token starts with a character that would disrupt ASI, insert a semicolon.\n                return true;\n            }\n\n            if (tokenBefore.type === \"Punctuator\" && (tokenBefore.value === \"++\" || tokenBefore.value === \"--\")) {\n\n                // If the last token is ++ or --, insert a semicolon to avoid disrupting ASI.\n                return true;\n            }\n\n            // Otherwise, do not insert a semicolon.\n            return false;\n        }\n\n        /**\n         * Determines whether the code represented by the given node contains an `if` statement\n         * that would become associated with an `else` keyword directly appended to that code.\n         *\n         * Examples where it returns `true`:\n         *\n         *    if (a)\n         *        foo();\n         *\n         *    if (a) {\n         *        foo();\n         *    }\n         *\n         *    if (a)\n         *        foo();\n         *    else if (b)\n         *        bar();\n         *\n         *    while (a)\n         *        if (b)\n         *            if(c)\n         *                foo();\n         *            else\n         *                bar();\n         *\n         * Examples where it returns `false`:\n         *\n         *    if (a)\n         *        foo();\n         *    else\n         *        bar();\n         *\n         *    while (a) {\n         *        if (b)\n         *            if(c)\n         *                foo();\n         *            else\n         *                bar();\n         *    }\n         *\n         *    while (a)\n         *        if (b) {\n         *            if(c)\n         *                foo();\n         *        }\n         *        else\n         *            bar();\n         * @param {ASTNode} node Node representing the code to check.\n         * @returns {boolean} `true` if an `if` statement within the code would become associated with an `else` appended to that code.\n         */\n        function hasUnsafeIf(node) {\n            switch (node.type) {\n                case \"IfStatement\":\n                    if (!node.alternate) {\n                        return true;\n                    }\n                    return hasUnsafeIf(node.alternate);\n                case \"ForStatement\":\n                case \"ForInStatement\":\n                case \"ForOfStatement\":\n                case \"LabeledStatement\":\n                case \"WithStatement\":\n                case \"WhileStatement\":\n                    return hasUnsafeIf(node.body);\n                default:\n                    return false;\n            }\n        }\n\n        /**\n         * Determines whether the existing curly braces around the single statement are necessary to preserve the semantics of the code.\n         * The braces, which make the given block body, are necessary in either of the following situations:\n         *\n         * 1. The statement is a lexical declaration.\n         * 2. Without the braces, an `if` within the statement would become associated with an `else` after the closing brace:\n         *\n         *     if (a) {\n         *         if (b)\n         *             foo();\n         *     }\n         *     else\n         *         bar();\n         *\n         *     if (a)\n         *         while (b)\n         *             while (c) {\n         *                 while (d)\n         *                     if (e)\n         *                         while(f)\n         *                             foo();\n         *            }\n         *     else\n         *         bar();\n         * @param {ASTNode} node `BlockStatement` body with exactly one statement directly inside. The statement can have its own nested statements.\n         * @returns {boolean} `true` if the braces are necessary - removing them (replacing the given `BlockStatement` body with its single statement content)\n         * would change the semantics of the code or produce a syntax error.\n         */\n        function areBracesNecessary(node) {\n            const statement = node.body[0];\n\n            return isLexicalDeclaration(statement) ||\n                hasUnsafeIf(statement) && isFollowedByElseKeyword(node);\n        }\n\n        /**\n         * Prepares to check the body of a node to see if it's a block statement.\n         * @param {ASTNode} node The node to report if there's a problem.\n         * @param {ASTNode} body The body node to check for blocks.\n         * @param {string} name The name to report if there's a problem.\n         * @param {{ condition: boolean }} opts Options to pass to the report functions\n         * @returns {Object} a prepared check object, with \"actual\", \"expected\", \"check\" properties.\n         *   \"actual\" will be `true` or `false` whether the body is already a block statement.\n         *   \"expected\" will be `true` or `false` if the body should be a block statement or not, or\n         *   `null` if it doesn't matter, depending on the rule options. It can be modified to change\n         *   the final behavior of \"check\".\n         *   \"check\" will be a function reporting appropriate problems depending on the other\n         *   properties.\n         */\n        function prepareCheck(node, body, name, opts) {\n            const hasBlock = (body.type === \"BlockStatement\");\n            let expected = null;\n\n            if (hasBlock && (body.body.length !== 1 || areBracesNecessary(body))) {\n                expected = true;\n            } else if (multiOnly) {\n                expected = false;\n            } else if (multiLine) {\n                if (!isCollapsedOneLiner(body)) {\n                    expected = true;\n                }\n\n                // otherwise, the body is allowed to have braces or not to have braces\n\n            } else if (multiOrNest) {\n                if (hasBlock) {\n                    const statement = body.body[0];\n                    const leadingCommentsInBlock = sourceCode.getCommentsBefore(statement);\n\n                    expected = !isOneLiner(statement) || leadingCommentsInBlock.length > 0;\n                } else {\n                    expected = !isOneLiner(body);\n                }\n            } else {\n\n                // default \"all\"\n                expected = true;\n            }\n\n            return {\n                actual: hasBlock,\n                expected,\n                check() {\n                    if (this.expected !== null && this.expected !== this.actual) {\n                        if (this.expected) {\n                            context.report({\n                                node,\n                                loc: body.loc,\n                                messageId: opts && opts.condition ? \"missingCurlyAfterCondition\" : \"missingCurlyAfter\",\n                                data: {\n                                    name\n                                },\n                                fix: fixer => fixer.replaceText(body, `{${sourceCode.getText(body)}}`)\n                            });\n                        } else {\n                            context.report({\n                                node,\n                                loc: body.loc,\n                                messageId: opts && opts.condition ? \"unexpectedCurlyAfterCondition\" : \"unexpectedCurlyAfter\",\n                                data: {\n                                    name\n                                },\n                                fix(fixer) {\n\n                                    /*\n                                     * `do while` expressions sometimes need a space to be inserted after `do`.\n                                     * e.g. `do{foo()} while (bar)` should be corrected to `do foo() while (bar)`\n                                     */\n                                    const needsPrecedingSpace = node.type === \"DoWhileStatement\" &&\n                                        sourceCode.getTokenBefore(body).range[1] === body.range[0] &&\n                                        !astUtils.canTokensBeAdjacent(\"do\", sourceCode.getFirstToken(body, { skip: 1 }));\n\n                                    const openingBracket = sourceCode.getFirstToken(body);\n                                    const closingBracket = sourceCode.getLastToken(body);\n                                    const lastTokenInBlock = sourceCode.getTokenBefore(closingBracket);\n\n                                    if (needsSemicolon(closingBracket)) {\n\n                                        /*\n                                         * If removing braces would cause a SyntaxError due to multiple statements on the same line (or\n                                         * change the semantics of the code due to ASI), don't perform a fix.\n                                         */\n                                        return null;\n                                    }\n\n                                    const resultingBodyText = sourceCode.getText().slice(openingBracket.range[1], lastTokenInBlock.range[0]) +\n                                        sourceCode.getText(lastTokenInBlock) +\n                                        sourceCode.getText().slice(lastTokenInBlock.range[1], closingBracket.range[0]);\n\n                                    return fixer.replaceText(body, (needsPrecedingSpace ? \" \" : \"\") + resultingBodyText);\n                                }\n                            });\n                        }\n                    }\n                }\n            };\n        }\n\n        /**\n         * Prepares to check the bodies of a \"if\", \"else if\" and \"else\" chain.\n         * @param {ASTNode} node The first IfStatement node of the chain.\n         * @returns {Object[]} prepared checks for each body of the chain. See `prepareCheck` for more\n         *   information.\n         */\n        function prepareIfChecks(node) {\n            const preparedChecks = [];\n\n            for (let currentNode = node; currentNode; currentNode = currentNode.alternate) {\n                preparedChecks.push(prepareCheck(currentNode, currentNode.consequent, \"if\", { condition: true }));\n                if (currentNode.alternate && currentNode.alternate.type !== \"IfStatement\") {\n                    preparedChecks.push(prepareCheck(currentNode, currentNode.alternate, \"else\"));\n                    break;\n                }\n            }\n\n            if (consistent) {\n\n                /*\n                 * If any node should have or already have braces, make sure they\n                 * all have braces.\n                 * If all nodes shouldn't have braces, make sure they don't.\n                 */\n                const expected = preparedChecks.some(preparedCheck => {\n                    if (preparedCheck.expected !== null) {\n                        return preparedCheck.expected;\n                    }\n                    return preparedCheck.actual;\n                });\n\n                preparedChecks.forEach(preparedCheck => {\n                    preparedCheck.expected = expected;\n                });\n            }\n\n            return preparedChecks;\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            IfStatement(node) {\n                const parent = node.parent;\n                const isElseIf = parent.type === \"IfStatement\" && parent.alternate === node;\n\n                if (!isElseIf) {\n\n                    // This is a top `if`, check the whole `if-else-if` chain\n                    prepareIfChecks(node).forEach(preparedCheck => {\n                        preparedCheck.check();\n                    });\n                }\n\n                // Skip `else if`, it's already checked (when the top `if` was visited)\n            },\n\n            WhileStatement(node) {\n                prepareCheck(node, node.body, \"while\", { condition: true }).check();\n            },\n\n            DoWhileStatement(node) {\n                prepareCheck(node, node.body, \"do\").check();\n            },\n\n            ForStatement(node) {\n                prepareCheck(node, node.body, \"for\", { condition: true }).check();\n            },\n\n            ForInStatement(node) {\n                prepareCheck(node, node.body, \"for-in\").check();\n            },\n\n            ForOfStatement(node) {\n                prepareCheck(node, node.body, \"for-of\").check();\n            }\n        };\n    }\n};\n"],"mappings":"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CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQ,SAASc,WAAWA,CAAChC,IAAI,EAAE;MACvB,QAAQA,IAAI,CAAC5B,IAAI;QACb,KAAK,aAAa;UACd,IAAI,CAAC4B,IAAI,CAACiC,SAAS,EAAE;YACjB,OAAO,IAAI;UACf;UACA,OAAOD,WAAW,CAAChC,IAAI,CAACiC,SAAS,CAAC;QACtC,KAAK,cAAc;QACnB,KAAK,gBAAgB;QACrB,KAAK,gBAAgB;QACrB,KAAK,kBAAkB;QACvB,KAAK,eAAe;QACpB,KAAK,gBAAgB;UACjB,OAAOD,WAAW,CAAChC,IAAI,CAACkC,IAAI,CAAC;QACjC;UACI,OAAO,KAAK;MACpB;IACJ;;IAEA;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQ,SAASC,kBAAkBA,CAACnC,IAAI,EAAE;MAC9B,MAAMoC,SAAS,GAAGpC,IAAI,CAACkC,IAAI,CAAC,CAAC,CAAC;MAE9B,OAAOpB,oBAAoB,CAACsB,SAAS,CAAC,IAClCJ,WAAW,CAACI,SAAS,CAAC,IAAIjB,uBAAuB,CAACnB,IAAI,CAAC;IAC/D;;IAEA;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQ,SAASqC,YAAYA,CAACrC,IAAI,EAAEkC,IAAI,EAAEI,IAAI,EAAEC,IAAI,EAAE;MAC1C,MAAMC,QAAQ,GAAIN,IAAI,CAAC9D,IAAI,KAAK,gBAAiB;MACjD,IAAIqE,QAAQ,GAAG,IAAI;MAEnB,IAAID,QAAQ,KAAKN,IAAI,CAACA,IAAI,CAACQ,MAAM,KAAK,C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"},"metadata":{},"sourceType":"script","externalDependencies":[]}