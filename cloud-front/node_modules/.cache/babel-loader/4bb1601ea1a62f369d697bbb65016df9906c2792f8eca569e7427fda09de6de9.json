{"ast":null,"code":"/**\n * @fileoverview A rule to suggest using arrow functions as callbacks.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\nrequire(\"core-js/modules/es.array.push.js\");\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given variable is a function name.\n * @param {eslint-scope.Variable} variable A variable to check.\n * @returns {boolean} `true` if the variable is a function name.\n */\nfunction isFunctionName(variable) {\n  return variable && variable.defs[0].type === \"FunctionName\";\n}\n\n/**\n * Checks whether or not a given MetaProperty node equals to a given value.\n * @param {ASTNode} node A MetaProperty node to check.\n * @param {string} metaName The name of `MetaProperty.meta`.\n * @param {string} propertyName The name of `MetaProperty.property`.\n * @returns {boolean} `true` if the node is the specific value.\n */\nfunction checkMetaProperty(node, metaName, propertyName) {\n  return node.meta.name === metaName && node.property.name === propertyName;\n}\n\n/**\n * Gets the variable object of `arguments` which is defined implicitly.\n * @param {eslint-scope.Scope} scope A scope to get.\n * @returns {eslint-scope.Variable} The found variable object.\n */\nfunction getVariableOfArguments(scope) {\n  const variables = scope.variables;\n  for (let i = 0; i < variables.length; ++i) {\n    const variable = variables[i];\n    if (variable.name === \"arguments\") {\n      /*\n       * If there was a parameter which is named \"arguments\", the\n       * implicit \"arguments\" is not defined.\n       * So does fast return with null.\n       */\n      return variable.identifiers.length === 0 ? variable : null;\n    }\n  }\n\n  /* istanbul ignore next */\n  return null;\n}\n\n/**\n * Checks whether or not a given node is a callback.\n * @param {ASTNode} node A node to check.\n * @returns {Object}\n *   {boolean} retv.isCallback - `true` if the node is a callback.\n *   {boolean} retv.isLexicalThis - `true` if the node is with `.bind(this)`.\n */\nfunction getCallbackInfo(node) {\n  const retv = {\n    isCallback: false,\n    isLexicalThis: false\n  };\n  let currentNode = node;\n  let parent = node.parent;\n  let bound = false;\n  while (currentNode) {\n    switch (parent.type) {\n      // Checks parents recursively.\n\n      case \"LogicalExpression\":\n      case \"ChainExpression\":\n      case \"ConditionalExpression\":\n        break;\n\n      // Checks whether the parent node is `.bind(this)` call.\n      case \"MemberExpression\":\n        if (parent.object === currentNode && !parent.property.computed && parent.property.type === \"Identifier\" && parent.property.name === \"bind\") {\n          const maybeCallee = parent.parent.type === \"ChainExpression\" ? parent.parent : parent;\n          if (astUtils.isCallee(maybeCallee)) {\n            if (!bound) {\n              bound = true; // Use only the first `.bind()` to make `isLexicalThis` value.\n              retv.isLexicalThis = maybeCallee.parent.arguments.length === 1 && maybeCallee.parent.arguments[0].type === \"ThisExpression\";\n            }\n            parent = maybeCallee.parent;\n          } else {\n            return retv;\n          }\n        } else {\n          return retv;\n        }\n        break;\n\n      // Checks whether the node is a callback.\n      case \"CallExpression\":\n      case \"NewExpression\":\n        if (parent.callee !== currentNode) {\n          retv.isCallback = true;\n        }\n        return retv;\n      default:\n        return retv;\n    }\n    currentNode = parent;\n    parent = parent.parent;\n  }\n\n  /* istanbul ignore next */\n  throw new Error(\"unreachable\");\n}\n\n/**\n * Checks whether a simple list of parameters contains any duplicates. This does not handle complex\n * parameter lists (e.g. with destructuring), since complex parameter lists are a SyntaxError with duplicate\n * parameter names anyway. Instead, it always returns `false` for complex parameter lists.\n * @param {ASTNode[]} paramsList The list of parameters for a function\n * @returns {boolean} `true` if the list of parameters contains any duplicates\n */\nfunction hasDuplicateParams(paramsList) {\n  return paramsList.every(param => param.type === \"Identifier\") && paramsList.length !== new Set(paramsList.map(param => param.name)).size;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require using arrow functions for callbacks\",\n      category: \"ECMAScript 6\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/prefer-arrow-callback\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        allowNamedFunctions: {\n          type: \"boolean\",\n          default: false\n        },\n        allowUnboundThis: {\n          type: \"boolean\",\n          default: true\n        }\n      },\n      additionalProperties: false\n    }],\n    fixable: \"code\",\n    messages: {\n      preferArrowCallback: \"Unexpected function expression.\"\n    }\n  },\n  create(context) {\n    const options = context.options[0] || {};\n    const allowUnboundThis = options.allowUnboundThis !== false; // default to true\n    const allowNamedFunctions = options.allowNamedFunctions;\n    const sourceCode = context.getSourceCode();\n\n    /*\n     * {Array<{this: boolean, super: boolean, meta: boolean}>}\n     * - this - A flag which shows there are one or more ThisExpression.\n     * - super - A flag which shows there are one or more Super.\n     * - meta - A flag which shows there are one or more MethProperty.\n     */\n    let stack = [];\n\n    /**\n     * Pushes new function scope with all `false` flags.\n     * @returns {void}\n     */\n    function enterScope() {\n      stack.push({\n        this: false,\n        super: false,\n        meta: false\n      });\n    }\n\n    /**\n     * Pops a function scope from the stack.\n     * @returns {{this: boolean, super: boolean, meta: boolean}} The information of the last scope.\n     */\n    function exitScope() {\n      return stack.pop();\n    }\n    return {\n      // Reset internal state.\n      Program() {\n        stack = [];\n      },\n      // If there are below, it cannot replace with arrow functions merely.\n      ThisExpression() {\n        const info = stack[stack.length - 1];\n        if (info) {\n          info.this = true;\n        }\n      },\n      Super() {\n        const info = stack[stack.length - 1];\n        if (info) {\n          info.super = true;\n        }\n      },\n      MetaProperty(node) {\n        const info = stack[stack.length - 1];\n        if (info && checkMetaProperty(node, \"new\", \"target\")) {\n          info.meta = true;\n        }\n      },\n      // To skip nested scopes.\n      FunctionDeclaration: enterScope,\n      \"FunctionDeclaration:exit\": exitScope,\n      // Main.\n      FunctionExpression: enterScope,\n      \"FunctionExpression:exit\"(node) {\n        const scopeInfo = exitScope();\n\n        // Skip named function expressions\n        if (allowNamedFunctions && node.id && node.id.name) {\n          return;\n        }\n\n        // Skip generators.\n        if (node.generator) {\n          return;\n        }\n\n        // Skip recursive functions.\n        const nameVar = context.getDeclaredVariables(node)[0];\n        if (isFunctionName(nameVar) && nameVar.references.length > 0) {\n          return;\n        }\n\n        // Skip if it's using arguments.\n        const variable = getVariableOfArguments(context.getScope());\n        if (variable && variable.references.length > 0) {\n          return;\n        }\n\n        // Reports if it's a callback which can replace with arrows.\n        const callbackInfo = getCallbackInfo(node);\n        if (callbackInfo.isCallback && (!allowUnboundThis || !scopeInfo.this || callbackInfo.isLexicalThis) && !scopeInfo.super && !scopeInfo.meta) {\n          context.report({\n            node,\n            messageId: \"preferArrowCallback\",\n            *fix(fixer) {\n              if (!callbackInfo.isLexicalThis && scopeInfo.this || hasDuplicateParams(node.params)) {\n                /*\n                 * If the callback function does not have .bind(this) and contains a reference to `this`, there\n                 * is no way to determine what `this` should be, so don't perform any fixes.\n                 * If the callback function has duplicates in its list of parameters (possible in sloppy mode),\n                 * don't replace it with an arrow function, because this is a SyntaxError with arrow functions.\n                 */\n                return;\n              }\n\n              // Remove `.bind(this)` if exists.\n              if (callbackInfo.isLexicalThis) {\n                const memberNode = node.parent;\n\n                /*\n                 * If `.bind(this)` exists but the parent is not `.bind(this)`, don't remove it automatically.\n                 * E.g. `(foo || function(){}).bind(this)`\n                 */\n                if (memberNode.type !== \"MemberExpression\") {\n                  return;\n                }\n                const callNode = memberNode.parent;\n                const firstTokenToRemove = sourceCode.getTokenAfter(memberNode.object, astUtils.isNotClosingParenToken);\n                const lastTokenToRemove = sourceCode.getLastToken(callNode);\n\n                /*\n                 * If the member expression is parenthesized, don't remove the right paren.\n                 * E.g. `(function(){}.bind)(this)`\n                 *                    ^^^^^^^^^^^^\n                 */\n                if (astUtils.isParenthesised(sourceCode, memberNode)) {\n                  return;\n                }\n\n                // If comments exist in the `.bind(this)`, don't remove those.\n                if (sourceCode.commentsExistBetween(firstTokenToRemove, lastTokenToRemove)) {\n                  return;\n                }\n                yield fixer.removeRange([firstTokenToRemove.range[0], lastTokenToRemove.range[1]]);\n              }\n\n              // Convert the function expression to an arrow function.\n              const functionToken = sourceCode.getFirstToken(node, node.async ? 1 : 0);\n              const leftParenToken = sourceCode.getTokenAfter(functionToken, astUtils.isOpeningParenToken);\n              if (sourceCode.commentsExistBetween(functionToken, leftParenToken)) {\n                // Remove only extra tokens to keep comments.\n                yield fixer.remove(functionToken);\n                if (node.id) {\n                  yield fixer.remove(node.id);\n                }\n              } else {\n                // Remove extra tokens and spaces.\n                yield fixer.removeRange([functionToken.range[0], leftParenToken.range[0]]);\n              }\n              yield fixer.insertTextBefore(node.body, \"=> \");\n\n              // Get the node that will become the new arrow function.\n              let replacedNode = callbackInfo.isLexicalThis ? node.parent.parent : node;\n              if (replacedNode.type === \"ChainExpression\") {\n                replacedNode = replacedNode.parent;\n              }\n\n              /*\n               * If the replaced node is part of a BinaryExpression, LogicalExpression, or MemberExpression, then\n               * the arrow function needs to be parenthesized, because `foo || () => {}` is invalid syntax even\n               * though `foo || function() {}` is valid.\n               */\n              if (replacedNode.parent.type !== \"CallExpression\" && replacedNode.parent.type !== \"ConditionalExpression\" && !astUtils.isParenthesised(sourceCode, replacedNode) && !astUtils.isParenthesised(sourceCode, node)) {\n                yield fixer.insertTextBefore(replacedNode, \"(\");\n                yield fixer.insertTextAfter(replacedNode, \")\");\n              }\n            }\n          });\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["require","astUtils","isFunctionName","variable","defs","type","checkMetaProperty","node","metaName","propertyName","meta","name","property","getVariableOfArguments","scope","variables","i","length","identifiers","getCallbackInfo","retv","isCallback","isLexicalThis","currentNode","parent","bound","object","computed","maybeCallee","isCallee","arguments","callee","Error","hasDuplicateParams","paramsList","every","param","Set","map","size","module","exports","docs","description","category","recommended","url","schema","properties","allowNamedFunctions","default","allowUnboundThis","additionalProperties","fixable","messages","preferArrowCallback","create","context","options","sourceCode","getSourceCode","stack","enterScope","push","this","super","exitScope","pop","Program","ThisExpression","info","Super","MetaProperty","FunctionDeclaration","FunctionExpression","FunctionExpression:exit","scopeInfo","id","generator","nameVar","getDeclaredVariables","references","getScope","callbackInfo","report","messageId","fix","fixer","params","memberNode","callNode","firstTokenToRemove","getTokenAfter","isNotClosingParenToken","lastTokenToRemove","getLastToken","isParenthesised","commentsExistBetween","removeRange","range","functionToken","getFirstToken","async","leftParenToken","isOpeningParenToken","remove","insertTextBefore","body","replacedNode","insertTextAfter"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/prefer-arrow-callback.js"],"sourcesContent":["/**\n * @fileoverview A rule to suggest using arrow functions as callbacks.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given variable is a function name.\n * @param {eslint-scope.Variable} variable A variable to check.\n * @returns {boolean} `true` if the variable is a function name.\n */\nfunction isFunctionName(variable) {\n    return variable && variable.defs[0].type === \"FunctionName\";\n}\n\n/**\n * Checks whether or not a given MetaProperty node equals to a given value.\n * @param {ASTNode} node A MetaProperty node to check.\n * @param {string} metaName The name of `MetaProperty.meta`.\n * @param {string} propertyName The name of `MetaProperty.property`.\n * @returns {boolean} `true` if the node is the specific value.\n */\nfunction checkMetaProperty(node, metaName, propertyName) {\n    return node.meta.name === metaName && node.property.name === propertyName;\n}\n\n/**\n * Gets the variable object of `arguments` which is defined implicitly.\n * @param {eslint-scope.Scope} scope A scope to get.\n * @returns {eslint-scope.Variable} The found variable object.\n */\nfunction getVariableOfArguments(scope) {\n    const variables = scope.variables;\n\n    for (let i = 0; i < variables.length; ++i) {\n        const variable = variables[i];\n\n        if (variable.name === \"arguments\") {\n\n            /*\n             * If there was a parameter which is named \"arguments\", the\n             * implicit \"arguments\" is not defined.\n             * So does fast return with null.\n             */\n            return (variable.identifiers.length === 0) ? variable : null;\n        }\n    }\n\n    /* istanbul ignore next */\n    return null;\n}\n\n/**\n * Checks whether or not a given node is a callback.\n * @param {ASTNode} node A node to check.\n * @returns {Object}\n *   {boolean} retv.isCallback - `true` if the node is a callback.\n *   {boolean} retv.isLexicalThis - `true` if the node is with `.bind(this)`.\n */\nfunction getCallbackInfo(node) {\n    const retv = { isCallback: false, isLexicalThis: false };\n    let currentNode = node;\n    let parent = node.parent;\n    let bound = false;\n\n    while (currentNode) {\n        switch (parent.type) {\n\n            // Checks parents recursively.\n\n            case \"LogicalExpression\":\n            case \"ChainExpression\":\n            case \"ConditionalExpression\":\n                break;\n\n            // Checks whether the parent node is `.bind(this)` call.\n            case \"MemberExpression\":\n                if (\n                    parent.object === currentNode &&\n                    !parent.property.computed &&\n                    parent.property.type === \"Identifier\" &&\n                    parent.property.name === \"bind\"\n                ) {\n                    const maybeCallee = parent.parent.type === \"ChainExpression\"\n                        ? parent.parent\n                        : parent;\n\n                    if (astUtils.isCallee(maybeCallee)) {\n                        if (!bound) {\n                            bound = true; // Use only the first `.bind()` to make `isLexicalThis` value.\n                            retv.isLexicalThis = (\n                                maybeCallee.parent.arguments.length === 1 &&\n                                maybeCallee.parent.arguments[0].type === \"ThisExpression\"\n                            );\n                        }\n                        parent = maybeCallee.parent;\n                    } else {\n                        return retv;\n                    }\n                } else {\n                    return retv;\n                }\n                break;\n\n            // Checks whether the node is a callback.\n            case \"CallExpression\":\n            case \"NewExpression\":\n                if (parent.callee !== currentNode) {\n                    retv.isCallback = true;\n                }\n                return retv;\n\n            default:\n                return retv;\n        }\n\n        currentNode = parent;\n        parent = parent.parent;\n    }\n\n    /* istanbul ignore next */\n    throw new Error(\"unreachable\");\n}\n\n/**\n * Checks whether a simple list of parameters contains any duplicates. This does not handle complex\n * parameter lists (e.g. with destructuring), since complex parameter lists are a SyntaxError with duplicate\n * parameter names anyway. Instead, it always returns `false` for complex parameter lists.\n * @param {ASTNode[]} paramsList The list of parameters for a function\n * @returns {boolean} `true` if the list of parameters contains any duplicates\n */\nfunction hasDuplicateParams(paramsList) {\n    return paramsList.every(param => param.type === \"Identifier\") && paramsList.length !== new Set(paramsList.map(param => param.name)).size;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require using arrow functions for callbacks\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/prefer-arrow-callback\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allowNamedFunctions: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    allowUnboundThis: {\n                        type: \"boolean\",\n                        default: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: \"code\",\n\n        messages: {\n            preferArrowCallback: \"Unexpected function expression.\"\n        }\n    },\n\n    create(context) {\n        const options = context.options[0] || {};\n\n        const allowUnboundThis = options.allowUnboundThis !== false; // default to true\n        const allowNamedFunctions = options.allowNamedFunctions;\n        const sourceCode = context.getSourceCode();\n\n        /*\n         * {Array<{this: boolean, super: boolean, meta: boolean}>}\n         * - this - A flag which shows there are one or more ThisExpression.\n         * - super - A flag which shows there are one or more Super.\n         * - meta - A flag which shows there are one or more MethProperty.\n         */\n        let stack = [];\n\n        /**\n         * Pushes new function scope with all `false` flags.\n         * @returns {void}\n         */\n        function enterScope() {\n            stack.push({ this: false, super: false, meta: false });\n        }\n\n        /**\n         * Pops a function scope from the stack.\n         * @returns {{this: boolean, super: boolean, meta: boolean}} The information of the last scope.\n         */\n        function exitScope() {\n            return stack.pop();\n        }\n\n        return {\n\n            // Reset internal state.\n            Program() {\n                stack = [];\n            },\n\n            // If there are below, it cannot replace with arrow functions merely.\n            ThisExpression() {\n                const info = stack[stack.length - 1];\n\n                if (info) {\n                    info.this = true;\n                }\n            },\n\n            Super() {\n                const info = stack[stack.length - 1];\n\n                if (info) {\n                    info.super = true;\n                }\n            },\n\n            MetaProperty(node) {\n                const info = stack[stack.length - 1];\n\n                if (info && checkMetaProperty(node, \"new\", \"target\")) {\n                    info.meta = true;\n                }\n            },\n\n            // To skip nested scopes.\n            FunctionDeclaration: enterScope,\n            \"FunctionDeclaration:exit\": exitScope,\n\n            // Main.\n            FunctionExpression: enterScope,\n            \"FunctionExpression:exit\"(node) {\n                const scopeInfo = exitScope();\n\n                // Skip named function expressions\n                if (allowNamedFunctions && node.id && node.id.name) {\n                    return;\n                }\n\n                // Skip generators.\n                if (node.generator) {\n                    return;\n                }\n\n                // Skip recursive functions.\n                const nameVar = context.getDeclaredVariables(node)[0];\n\n                if (isFunctionName(nameVar) && nameVar.references.length > 0) {\n                    return;\n                }\n\n                // Skip if it's using arguments.\n                const variable = getVariableOfArguments(context.getScope());\n\n                if (variable && variable.references.length > 0) {\n                    return;\n                }\n\n                // Reports if it's a callback which can replace with arrows.\n                const callbackInfo = getCallbackInfo(node);\n\n                if (callbackInfo.isCallback &&\n                    (!allowUnboundThis || !scopeInfo.this || callbackInfo.isLexicalThis) &&\n                    !scopeInfo.super &&\n                    !scopeInfo.meta\n                ) {\n                    context.report({\n                        node,\n                        messageId: \"preferArrowCallback\",\n                        *fix(fixer) {\n                            if ((!callbackInfo.isLexicalThis && scopeInfo.this) || hasDuplicateParams(node.params)) {\n\n                                /*\n                                 * If the callback function does not have .bind(this) and contains a reference to `this`, there\n                                 * is no way to determine what `this` should be, so don't perform any fixes.\n                                 * If the callback function has duplicates in its list of parameters (possible in sloppy mode),\n                                 * don't replace it with an arrow function, because this is a SyntaxError with arrow functions.\n                                 */\n                                return;\n                            }\n\n                            // Remove `.bind(this)` if exists.\n                            if (callbackInfo.isLexicalThis) {\n                                const memberNode = node.parent;\n\n                                /*\n                                 * If `.bind(this)` exists but the parent is not `.bind(this)`, don't remove it automatically.\n                                 * E.g. `(foo || function(){}).bind(this)`\n                                 */\n                                if (memberNode.type !== \"MemberExpression\") {\n                                    return;\n                                }\n\n                                const callNode = memberNode.parent;\n                                const firstTokenToRemove = sourceCode.getTokenAfter(memberNode.object, astUtils.isNotClosingParenToken);\n                                const lastTokenToRemove = sourceCode.getLastToken(callNode);\n\n                                /*\n                                 * If the member expression is parenthesized, don't remove the right paren.\n                                 * E.g. `(function(){}.bind)(this)`\n                                 *                    ^^^^^^^^^^^^\n                                 */\n                                if (astUtils.isParenthesised(sourceCode, memberNode)) {\n                                    return;\n                                }\n\n                                // If comments exist in the `.bind(this)`, don't remove those.\n                                if (sourceCode.commentsExistBetween(firstTokenToRemove, lastTokenToRemove)) {\n                                    return;\n                                }\n\n                                yield fixer.removeRange([firstTokenToRemove.range[0], lastTokenToRemove.range[1]]);\n                            }\n\n                            // Convert the function expression to an arrow function.\n                            const functionToken = sourceCode.getFirstToken(node, node.async ? 1 : 0);\n                            const leftParenToken = sourceCode.getTokenAfter(functionToken, astUtils.isOpeningParenToken);\n\n                            if (sourceCode.commentsExistBetween(functionToken, leftParenToken)) {\n\n                                // Remove only extra tokens to keep comments.\n                                yield fixer.remove(functionToken);\n                                if (node.id) {\n                                    yield fixer.remove(node.id);\n                                }\n                            } else {\n\n                                // Remove extra tokens and spaces.\n                                yield fixer.removeRange([functionToken.range[0], leftParenToken.range[0]]);\n                            }\n                            yield fixer.insertTextBefore(node.body, \"=> \");\n\n                            // Get the node that will become the new arrow function.\n                            let replacedNode = callbackInfo.isLexicalThis ? node.parent.parent : node;\n\n                            if (replacedNode.type === \"ChainExpression\") {\n                                replacedNode = replacedNode.parent;\n                            }\n\n                            /*\n                             * If the replaced node is part of a BinaryExpression, LogicalExpression, or MemberExpression, then\n                             * the arrow function needs to be parenthesized, because `foo || () => {}` is invalid syntax even\n                             * though `foo || function() {}` is valid.\n                             */\n                            if (\n                                replacedNode.parent.type !== \"CallExpression\" &&\n                                replacedNode.parent.type !== \"ConditionalExpression\" &&\n                                !astUtils.isParenthesised(sourceCode, replacedNode) &&\n                                !astUtils.isParenthesised(sourceCode, node)\n                            ) {\n                                yield fixer.insertTextBefore(replacedNode, \"(\");\n                                yield fixer.insertTextAfter(replacedNode, \")\");\n                            }\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}