{"ast":null,"code":"/**\n * @fileoverview Rule to flag adding properties to native object's prototypes.\n * @author David Nelson\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils\");\nconst globals = require(\"globals\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow extending native types\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-extend-native\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        exceptions: {\n          type: \"array\",\n          items: {\n            type: \"string\"\n          },\n          uniqueItems: true\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unexpected: \"{{builtin}} prototype is read only, properties should not be added.\"\n    }\n  },\n  create(context) {\n    const config = context.options[0] || {};\n    const exceptions = new Set(config.exceptions || []);\n    const modifiedBuiltins = new Set(Object.keys(globals.builtin).filter(builtin => builtin[0].toUpperCase() === builtin[0]).filter(builtin => !exceptions.has(builtin)));\n\n    /**\n     * Reports a lint error for the given node.\n     * @param {ASTNode} node The node to report.\n     * @param {string} builtin The name of the native builtin being extended.\n     * @returns {void}\n     */\n    function reportNode(node, builtin) {\n      context.report({\n        node,\n        messageId: \"unexpected\",\n        data: {\n          builtin\n        }\n      });\n    }\n\n    /**\n     * Check to see if the `prototype` property of the given object\n     * identifier node is being accessed.\n     * @param {ASTNode} identifierNode The Identifier representing the object\n     * to check.\n     * @returns {boolean} True if the identifier is the object of a\n     * MemberExpression and its `prototype` property is being accessed,\n     * false otherwise.\n     */\n    function isPrototypePropertyAccessed(identifierNode) {\n      return Boolean(identifierNode && identifierNode.parent && identifierNode.parent.type === \"MemberExpression\" && identifierNode.parent.object === identifierNode && astUtils.getStaticPropertyName(identifierNode.parent) === \"prototype\");\n    }\n\n    /**\n     * Check if it's an assignment to the property of the given node.\n     * Example: `*.prop = 0` // the `*` is the given node.\n     * @param {ASTNode} node The node to check.\n     * @returns {boolean} True if an assignment to the property of the node.\n     */\n    function isAssigningToPropertyOf(node) {\n      return node.parent.type === \"MemberExpression\" && node.parent.object === node && node.parent.parent.type === \"AssignmentExpression\" && node.parent.parent.left === node.parent;\n    }\n\n    /**\n     * Checks if the given node is at the first argument of the method call of `Object.defineProperty()` or `Object.defineProperties()`.\n     * @param {ASTNode} node The node to check.\n     * @returns {boolean} True if the node is at the first argument of the method call of `Object.defineProperty()` or `Object.defineProperties()`.\n     */\n    function isInDefinePropertyCall(node) {\n      return node.parent.type === \"CallExpression\" && node.parent.arguments[0] === node && astUtils.isSpecificMemberAccess(node.parent.callee, \"Object\", /^definePropert(?:y|ies)$/u);\n    }\n\n    /**\n     * Check to see if object prototype access is part of a prototype\n     * extension. There are three ways a prototype can be extended:\n     * 1. Assignment to prototype property (Object.prototype.foo = 1)\n     * 2. Object.defineProperty()/Object.defineProperties() on a prototype\n     * If prototype extension is detected, report the AssignmentExpression\n     * or CallExpression node.\n     * @param {ASTNode} identifierNode The Identifier representing the object\n     * which prototype is being accessed and possibly extended.\n     * @returns {void}\n     */\n    function checkAndReportPrototypeExtension(identifierNode) {\n      if (!isPrototypePropertyAccessed(identifierNode)) {\n        return; // This is not `*.prototype` access.\n      }\n\n      /*\n       * `identifierNode.parent` is a MemberExpression `*.prototype`.\n       * If it's an optional member access, it may be wrapped by a `ChainExpression` node.\n       */\n      const prototypeNode = identifierNode.parent.parent.type === \"ChainExpression\" ? identifierNode.parent.parent : identifierNode.parent;\n      if (isAssigningToPropertyOf(prototypeNode)) {\n        // `*.prototype` -> MemberExpression -> AssignmentExpression\n        reportNode(prototypeNode.parent.parent, identifierNode.name);\n      } else if (isInDefinePropertyCall(prototypeNode)) {\n        // `*.prototype` -> CallExpression\n        reportNode(prototypeNode.parent, identifierNode.name);\n      }\n    }\n    return {\n      \"Program:exit\"() {\n        const globalScope = context.getScope();\n        modifiedBuiltins.forEach(builtin => {\n          const builtinVar = globalScope.set.get(builtin);\n          if (builtinVar && builtinVar.references) {\n            builtinVar.references.map(ref => ref.identifier).forEach(checkAndReportPrototypeExtension);\n          }\n        });\n      }\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","globals","module","exports","meta","type","docs","description","category","recommended","url","schema","properties","exceptions","items","uniqueItems","additionalProperties","messages","unexpected","create","context","config","options","Set","modifiedBuiltins","Object","keys","builtin","filter","toUpperCase","has","reportNode","node","report","messageId","data","isPrototypePropertyAccessed","identifierNode","Boolean","parent","object","getStaticPropertyName","isAssigningToPropertyOf","left","isInDefinePropertyCall","arguments","isSpecificMemberAccess","callee","checkAndReportPrototypeExtension","prototypeNode","name","Program:exit","globalScope","getScope","forEach","builtinVar","set","get","references","map","ref","identifier"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/no-extend-native.js"],"sourcesContent":["/**\n * @fileoverview Rule to flag adding properties to native object's prototypes.\n * @author David Nelson\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\nconst globals = require(\"globals\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow extending native types\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-extend-native\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    exceptions: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        },\n                        uniqueItems: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            unexpected: \"{{builtin}} prototype is read only, properties should not be added.\"\n        }\n    },\n\n    create(context) {\n\n        const config = context.options[0] || {};\n        const exceptions = new Set(config.exceptions || []);\n        const modifiedBuiltins = new Set(\n            Object.keys(globals.builtin)\n                .filter(builtin => builtin[0].toUpperCase() === builtin[0])\n                .filter(builtin => !exceptions.has(builtin))\n        );\n\n        /**\n         * Reports a lint error for the given node.\n         * @param {ASTNode} node The node to report.\n         * @param {string} builtin The name of the native builtin being extended.\n         * @returns {void}\n         */\n        function reportNode(node, builtin) {\n            context.report({\n                node,\n                messageId: \"unexpected\",\n                data: {\n                    builtin\n                }\n            });\n        }\n\n        /**\n         * Check to see if the `prototype` property of the given object\n         * identifier node is being accessed.\n         * @param {ASTNode} identifierNode The Identifier representing the object\n         * to check.\n         * @returns {boolean} True if the identifier is the object of a\n         * MemberExpression and its `prototype` property is being accessed,\n         * false otherwise.\n         */\n        function isPrototypePropertyAccessed(identifierNode) {\n            return Boolean(\n                identifierNode &&\n                identifierNode.parent &&\n                identifierNode.parent.type === \"MemberExpression\" &&\n                identifierNode.parent.object === identifierNode &&\n                astUtils.getStaticPropertyName(identifierNode.parent) === \"prototype\"\n            );\n        }\n\n        /**\n         * Check if it's an assignment to the property of the given node.\n         * Example: `*.prop = 0` // the `*` is the given node.\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} True if an assignment to the property of the node.\n         */\n        function isAssigningToPropertyOf(node) {\n            return (\n                node.parent.type === \"MemberExpression\" &&\n                node.parent.object === node &&\n                node.parent.parent.type === \"AssignmentExpression\" &&\n                node.parent.parent.left === node.parent\n            );\n        }\n\n        /**\n         * Checks if the given node is at the first argument of the method call of `Object.defineProperty()` or `Object.defineProperties()`.\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} True if the node is at the first argument of the method call of `Object.defineProperty()` or `Object.defineProperties()`.\n         */\n        function isInDefinePropertyCall(node) {\n            return (\n                node.parent.type === \"CallExpression\" &&\n                node.parent.arguments[0] === node &&\n                astUtils.isSpecificMemberAccess(node.parent.callee, \"Object\", /^definePropert(?:y|ies)$/u)\n            );\n        }\n\n        /**\n         * Check to see if object prototype access is part of a prototype\n         * extension. There are three ways a prototype can be extended:\n         * 1. Assignment to prototype property (Object.prototype.foo = 1)\n         * 2. Object.defineProperty()/Object.defineProperties() on a prototype\n         * If prototype extension is detected, report the AssignmentExpression\n         * or CallExpression node.\n         * @param {ASTNode} identifierNode The Identifier representing the object\n         * which prototype is being accessed and possibly extended.\n         * @returns {void}\n         */\n        function checkAndReportPrototypeExtension(identifierNode) {\n            if (!isPrototypePropertyAccessed(identifierNode)) {\n                return; // This is not `*.prototype` access.\n            }\n\n            /*\n             * `identifierNode.parent` is a MemberExpression `*.prototype`.\n             * If it's an optional member access, it may be wrapped by a `ChainExpression` node.\n             */\n            const prototypeNode =\n                identifierNode.parent.parent.type === \"ChainExpression\"\n                    ? identifierNode.parent.parent\n                    : identifierNode.parent;\n\n            if (isAssigningToPropertyOf(prototypeNode)) {\n\n                // `*.prototype` -> MemberExpression -> AssignmentExpression\n                reportNode(prototypeNode.parent.parent, identifierNode.name);\n            } else if (isInDefinePropertyCall(prototypeNode)) {\n\n                // `*.prototype` -> CallExpression\n                reportNode(prototypeNode.parent, identifierNode.name);\n            }\n        }\n\n        return {\n\n            \"Program:exit\"() {\n                const globalScope = context.getScope();\n\n                modifiedBuiltins.forEach(builtin => {\n                    const builtinVar = globalScope.set.get(builtin);\n\n                    if (builtinVar && builtinVar.references) {\n                        builtinVar.references\n                            .map(ref => ref.identifier)\n                            .forEach(checkAndReportPrototypeExtension);\n                    }\n                });\n            }\n        };\n\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}