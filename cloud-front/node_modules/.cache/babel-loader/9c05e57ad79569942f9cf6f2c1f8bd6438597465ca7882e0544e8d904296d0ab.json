{"ast":null,"code":"/**\n * @fileoverview Rule to warn about using dot notation instead of square bracket notation when possible.\n * @author Josh Perez\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils\");\nconst keywords = require(\"./utils/keywords\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst validIdentifier = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/u;\n\n// `null` literal must be handled separately.\nconst literalTypesToCheck = new Set([\"string\", \"boolean\"]);\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"enforce dot notation whenever possible\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/dot-notation\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        allowKeywords: {\n          type: \"boolean\",\n          default: true\n        },\n        allowPattern: {\n          type: \"string\",\n          default: \"\"\n        }\n      },\n      additionalProperties: false\n    }],\n    fixable: \"code\",\n    messages: {\n      useDot: \"[{{key}}] is better written in dot notation.\",\n      useBrackets: \".{{key}} is a syntax error.\"\n    }\n  },\n  create(context) {\n    const options = context.options[0] || {};\n    const allowKeywords = options.allowKeywords === void 0 || options.allowKeywords;\n    const sourceCode = context.getSourceCode();\n    let allowPattern;\n    if (options.allowPattern) {\n      allowPattern = new RegExp(options.allowPattern, \"u\");\n    }\n\n    /**\n     * Check if the property is valid dot notation\n     * @param {ASTNode} node The dot notation node\n     * @param {string} value Value which is to be checked\n     * @returns {void}\n     */\n    function checkComputedProperty(node, value) {\n      if (validIdentifier.test(value) && (allowKeywords || keywords.indexOf(String(value)) === -1) && !(allowPattern && allowPattern.test(value))) {\n        const formattedValue = node.property.type === \"Literal\" ? JSON.stringify(value) : `\\`${value}\\``;\n        context.report({\n          node: node.property,\n          messageId: \"useDot\",\n          data: {\n            key: formattedValue\n          },\n          *fix(fixer) {\n            const leftBracket = sourceCode.getTokenAfter(node.object, astUtils.isOpeningBracketToken);\n            const rightBracket = sourceCode.getLastToken(node);\n            const nextToken = sourceCode.getTokenAfter(node);\n\n            // Don't perform any fixes if there are comments inside the brackets.\n            if (sourceCode.commentsExistBetween(leftBracket, rightBracket)) {\n              return;\n            }\n\n            // Replace the brackets by an identifier.\n            if (!node.optional) {\n              yield fixer.insertTextBefore(leftBracket, astUtils.isDecimalInteger(node.object) ? \" .\" : \".\");\n            }\n            yield fixer.replaceTextRange([leftBracket.range[0], rightBracket.range[1]], value);\n\n            // Insert a space after the property if it will be connected to the next token.\n            if (nextToken && rightBracket.range[1] === nextToken.range[0] && !astUtils.canTokensBeAdjacent(String(value), nextToken)) {\n              yield fixer.insertTextAfter(node, \" \");\n            }\n          }\n        });\n      }\n    }\n    return {\n      MemberExpression(node) {\n        if (node.computed && node.property.type === \"Literal\" && (literalTypesToCheck.has(typeof node.property.value) || astUtils.isNullLiteral(node.property))) {\n          checkComputedProperty(node, node.property.value);\n        }\n        if (node.computed && node.property.type === \"TemplateLiteral\" && node.property.expressions.length === 0) {\n          checkComputedProperty(node, node.property.quasis[0].value.cooked);\n        }\n        if (!allowKeywords && !node.computed && keywords.indexOf(String(node.property.name)) !== -1) {\n          context.report({\n            node: node.property,\n            messageId: \"useBrackets\",\n            data: {\n              key: node.property.name\n            },\n            *fix(fixer) {\n              const dotToken = sourceCode.getTokenBefore(node.property);\n\n              // A statement that starts with `let[` is parsed as a destructuring variable declaration, not a MemberExpression.\n              if (node.object.type === \"Identifier\" && node.object.name === \"let\" && !node.optional) {\n                return;\n              }\n\n              // Don't perform any fixes if there are comments between the dot and the property name.\n              if (sourceCode.commentsExistBetween(dotToken, node.property)) {\n                return;\n              }\n\n              // Replace the identifier to brackets.\n              if (!node.optional) {\n                yield fixer.remove(dotToken);\n              }\n              yield fixer.replaceText(node.property, `[\"${node.property.name}\"]`);\n            }\n          });\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","keywords","validIdentifier","literalTypesToCheck","Set","module","exports","meta","type","docs","description","category","recommended","url","schema","properties","allowKeywords","default","allowPattern","additionalProperties","fixable","messages","useDot","useBrackets","create","context","options","sourceCode","getSourceCode","RegExp","checkComputedProperty","node","value","test","indexOf","String","formattedValue","property","JSON","stringify","report","messageId","data","key","fix","fixer","leftBracket","getTokenAfter","object","isOpeningBracketToken","rightBracket","getLastToken","nextToken","commentsExistBetween","optional","insertTextBefore","isDecimalInteger","replaceTextRange","range","canTokensBeAdjacent","insertTextAfter","MemberExpression","computed","has","isNullLiteral","expressions","length","quasis","cooked","name","dotToken","getTokenBefore","remove","replaceText"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/dot-notation.js"],"sourcesContent":["/**\n * @fileoverview Rule to warn about using dot notation instead of square bracket notation when possible.\n * @author Josh Perez\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\nconst keywords = require(\"./utils/keywords\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst validIdentifier = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/u;\n\n// `null` literal must be handled separately.\nconst literalTypesToCheck = new Set([\"string\", \"boolean\"]);\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce dot notation whenever possible\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/dot-notation\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allowKeywords: {\n                        type: \"boolean\",\n                        default: true\n                    },\n                    allowPattern: {\n                        type: \"string\",\n                        default: \"\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: \"code\",\n\n        messages: {\n            useDot: \"[{{key}}] is better written in dot notation.\",\n            useBrackets: \".{{key}} is a syntax error.\"\n        }\n    },\n\n    create(context) {\n        const options = context.options[0] || {};\n        const allowKeywords = options.allowKeywords === void 0 || options.allowKeywords;\n        const sourceCode = context.getSourceCode();\n\n        let allowPattern;\n\n        if (options.allowPattern) {\n            allowPattern = new RegExp(options.allowPattern, \"u\");\n        }\n\n        /**\n         * Check if the property is valid dot notation\n         * @param {ASTNode} node The dot notation node\n         * @param {string} value Value which is to be checked\n         * @returns {void}\n         */\n        function checkComputedProperty(node, value) {\n            if (\n                validIdentifier.test(value) &&\n                (allowKeywords || keywords.indexOf(String(value)) === -1) &&\n                !(allowPattern && allowPattern.test(value))\n            ) {\n                const formattedValue = node.property.type === \"Literal\" ? JSON.stringify(value) : `\\`${value}\\``;\n\n                context.report({\n                    node: node.property,\n                    messageId: \"useDot\",\n                    data: {\n                        key: formattedValue\n                    },\n                    *fix(fixer) {\n                        const leftBracket = sourceCode.getTokenAfter(node.object, astUtils.isOpeningBracketToken);\n                        const rightBracket = sourceCode.getLastToken(node);\n                        const nextToken = sourceCode.getTokenAfter(node);\n\n                        // Don't perform any fixes if there are comments inside the brackets.\n                        if (sourceCode.commentsExistBetween(leftBracket, rightBracket)) {\n                            return;\n                        }\n\n                        // Replace the brackets by an identifier.\n                        if (!node.optional) {\n                            yield fixer.insertTextBefore(\n                                leftBracket,\n                                astUtils.isDecimalInteger(node.object) ? \" .\" : \".\"\n                            );\n                        }\n                        yield fixer.replaceTextRange(\n                            [leftBracket.range[0], rightBracket.range[1]],\n                            value\n                        );\n\n                        // Insert a space after the property if it will be connected to the next token.\n                        if (\n                            nextToken &&\n                            rightBracket.range[1] === nextToken.range[0] &&\n                            !astUtils.canTokensBeAdjacent(String(value), nextToken)\n                        ) {\n                            yield fixer.insertTextAfter(node, \" \");\n                        }\n                    }\n                });\n            }\n        }\n\n        return {\n            MemberExpression(node) {\n                if (\n                    node.computed &&\n                    node.property.type === \"Literal\" &&\n                    (literalTypesToCheck.has(typeof node.property.value) || astUtils.isNullLiteral(node.property))\n                ) {\n                    checkComputedProperty(node, node.property.value);\n                }\n                if (\n                    node.computed &&\n                    node.property.type === \"TemplateLiteral\" &&\n                    node.property.expressions.length === 0\n                ) {\n                    checkComputedProperty(node, node.property.quasis[0].value.cooked);\n                }\n                if (\n                    !allowKeywords &&\n                    !node.computed &&\n                    keywords.indexOf(String(node.property.name)) !== -1\n                ) {\n                    context.report({\n                        node: node.property,\n                        messageId: \"useBrackets\",\n                        data: {\n                            key: node.property.name\n                        },\n                        *fix(fixer) {\n                            const dotToken = sourceCode.getTokenBefore(node.property);\n\n                            // A statement that starts with `let[` is parsed as a destructuring variable declaration, not a MemberExpression.\n                            if (node.object.type === \"Identifier\" && node.object.name === \"let\" && !node.optional) {\n                                return;\n                            }\n\n                            // Don't perform any fixes if there are comments between the dot and the property name.\n                            if (sourceCode.commentsExistBetween(dotToken, node.property)) {\n                                return;\n                            }\n\n                            // Replace the identifier to brackets.\n                            if (!node.optional) {\n                                yield fixer.remove(dotToken);\n                            }\n                            yield fixer.replaceText(node.property, `[\"${node.property.name}\"]`);\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}