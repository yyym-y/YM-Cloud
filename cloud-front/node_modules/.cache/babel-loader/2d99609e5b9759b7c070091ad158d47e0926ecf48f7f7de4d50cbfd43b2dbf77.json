{"ast":null,"code":"/**\n * @fileoverview A class to operate forking.\n *\n * This is state of forking.\n * This has a fork list and manages it.\n *\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nrequire(\"core-js/modules/es.array.push.js\");\nconst assert = require(\"assert\"),\n  CodePathSegment = require(\"./code-path-segment\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Gets whether or not a given segment is reachable.\n * @param {CodePathSegment} segment A segment to get.\n * @returns {boolean} `true` if the segment is reachable.\n */\nfunction isReachable(segment) {\n  return segment.reachable;\n}\n\n/**\n * Creates new segments from the specific range of `context.segmentsList`.\n *\n * When `context.segmentsList` is `[[a, b], [c, d], [e, f]]`, `begin` is `0`, and\n * `end` is `-1`, this creates `[g, h]`. This `g` is from `a`, `c`, and `e`.\n * This `h` is from `b`, `d`, and `f`.\n * @param {ForkContext} context An instance.\n * @param {number} begin The first index of the previous segments.\n * @param {number} end The last index of the previous segments.\n * @param {Function} create A factory function of new segments.\n * @returns {CodePathSegment[]} New segments.\n */\nfunction makeSegments(context, begin, end, create) {\n  const list = context.segmentsList;\n  const normalizedBegin = begin >= 0 ? begin : list.length + begin;\n  const normalizedEnd = end >= 0 ? end : list.length + end;\n  const segments = [];\n  for (let i = 0; i < context.count; ++i) {\n    const allPrevSegments = [];\n    for (let j = normalizedBegin; j <= normalizedEnd; ++j) {\n      allPrevSegments.push(list[j][i]);\n    }\n    segments.push(create(context.idGenerator.next(), allPrevSegments));\n  }\n  return segments;\n}\n\n/**\n * `segments` becomes doubly in a `finally` block. Then if a code path exits by a\n * control statement (such as `break`, `continue`) from the `finally` block, the\n * destination's segments may be half of the source segments. In that case, this\n * merges segments.\n * @param {ForkContext} context An instance.\n * @param {CodePathSegment[]} segments Segments to merge.\n * @returns {CodePathSegment[]} The merged segments.\n */\nfunction mergeExtraSegments(context, segments) {\n  let currentSegments = segments;\n  while (currentSegments.length > context.count) {\n    const merged = [];\n    for (let i = 0, length = currentSegments.length / 2 | 0; i < length; ++i) {\n      merged.push(CodePathSegment.newNext(context.idGenerator.next(), [currentSegments[i], currentSegments[i + length]]));\n    }\n    currentSegments = merged;\n  }\n  return currentSegments;\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * A class to manage forking.\n */\nclass ForkContext {\n  // eslint-disable-next-line jsdoc/require-description\n  /**\n   * @param {IdGenerator} idGenerator An identifier generator for segments.\n   * @param {ForkContext|null} upper An upper fork context.\n   * @param {number} count A number of parallel segments.\n   */\n  constructor(idGenerator, upper, count) {\n    this.idGenerator = idGenerator;\n    this.upper = upper;\n    this.count = count;\n    this.segmentsList = [];\n  }\n\n  /**\n   * The head segments.\n   * @type {CodePathSegment[]}\n   */\n  get head() {\n    const list = this.segmentsList;\n    return list.length === 0 ? [] : list[list.length - 1];\n  }\n\n  /**\n   * A flag which shows empty.\n   * @type {boolean}\n   */\n  get empty() {\n    return this.segmentsList.length === 0;\n  }\n\n  /**\n   * A flag which shows reachable.\n   * @type {boolean}\n   */\n  get reachable() {\n    const segments = this.head;\n    return segments.length > 0 && segments.some(isReachable);\n  }\n\n  /**\n   * Creates new segments from this context.\n   * @param {number} begin The first index of previous segments.\n   * @param {number} end The last index of previous segments.\n   * @returns {CodePathSegment[]} New segments.\n   */\n  makeNext(begin, end) {\n    return makeSegments(this, begin, end, CodePathSegment.newNext);\n  }\n\n  /**\n   * Creates new segments from this context.\n   * The new segments is always unreachable.\n   * @param {number} begin The first index of previous segments.\n   * @param {number} end The last index of previous segments.\n   * @returns {CodePathSegment[]} New segments.\n   */\n  makeUnreachable(begin, end) {\n    return makeSegments(this, begin, end, CodePathSegment.newUnreachable);\n  }\n\n  /**\n   * Creates new segments from this context.\n   * The new segments don't have connections for previous segments.\n   * But these inherit the reachable flag from this context.\n   * @param {number} begin The first index of previous segments.\n   * @param {number} end The last index of previous segments.\n   * @returns {CodePathSegment[]} New segments.\n   */\n  makeDisconnected(begin, end) {\n    return makeSegments(this, begin, end, CodePathSegment.newDisconnected);\n  }\n\n  /**\n   * Adds segments into this context.\n   * The added segments become the head.\n   * @param {CodePathSegment[]} segments Segments to add.\n   * @returns {void}\n   */\n  add(segments) {\n    assert(segments.length >= this.count, `${segments.length} >= ${this.count}`);\n    this.segmentsList.push(mergeExtraSegments(this, segments));\n  }\n\n  /**\n   * Replaces the head segments with given segments.\n   * The current head segments are removed.\n   * @param {CodePathSegment[]} segments Segments to add.\n   * @returns {void}\n   */\n  replaceHead(segments) {\n    assert(segments.length >= this.count, `${segments.length} >= ${this.count}`);\n    this.segmentsList.splice(-1, 1, mergeExtraSegments(this, segments));\n  }\n\n  /**\n   * Adds all segments of a given fork context into this context.\n   * @param {ForkContext} context A fork context to add.\n   * @returns {void}\n   */\n  addAll(context) {\n    assert(context.count === this.count);\n    const source = context.segmentsList;\n    for (let i = 0; i < source.length; ++i) {\n      this.segmentsList.push(source[i]);\n    }\n  }\n\n  /**\n   * Clears all segments in this context.\n   * @returns {void}\n   */\n  clear() {\n    this.segmentsList = [];\n  }\n\n  /**\n   * Creates the root fork context.\n   * @param {IdGenerator} idGenerator An identifier generator for segments.\n   * @returns {ForkContext} New fork context.\n   */\n  static newRoot(idGenerator) {\n    const context = new ForkContext(idGenerator, null, 1);\n    context.add([CodePathSegment.newRoot(idGenerator.next())]);\n    return context;\n  }\n\n  /**\n   * Creates an empty fork context preceded by a given context.\n   * @param {ForkContext} parentContext The parent fork context.\n   * @param {boolean} forkLeavingPath A flag which shows inside of `finally` block.\n   * @returns {ForkContext} New fork context.\n   */\n  static newEmpty(parentContext, forkLeavingPath) {\n    return new ForkContext(parentContext.idGenerator, parentContext, (forkLeavingPath ? 2 : 1) * parentContext.count);\n  }\n}\nmodule.exports = ForkContext;","map":{"version":3,"names":["require","assert","CodePathSegment","isReachable","segment","reachable","makeSegments","context","begin","end","create","list","segmentsList","normalizedBegin","length","normalizedEnd","segments","i","count","allPrevSegments","j","push","idGenerator","next","mergeExtraSegments","currentSegments","merged","newNext","ForkContext","constructor","upper","head","empty","some","makeNext","makeUnreachable","newUnreachable","makeDisconnected","newDisconnected","add","replaceHead","splice","addAll","source","clear","newRoot","newEmpty","parentContext","forkLeavingPath","module","exports"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/linter/code-path-analysis/fork-context.js"],"sourcesContent":["/**\n * @fileoverview A class to operate forking.\n *\n * This is state of forking.\n * This has a fork list and manages it.\n *\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst assert = require(\"assert\"),\n    CodePathSegment = require(\"./code-path-segment\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Gets whether or not a given segment is reachable.\n * @param {CodePathSegment} segment A segment to get.\n * @returns {boolean} `true` if the segment is reachable.\n */\nfunction isReachable(segment) {\n    return segment.reachable;\n}\n\n/**\n * Creates new segments from the specific range of `context.segmentsList`.\n *\n * When `context.segmentsList` is `[[a, b], [c, d], [e, f]]`, `begin` is `0`, and\n * `end` is `-1`, this creates `[g, h]`. This `g` is from `a`, `c`, and `e`.\n * This `h` is from `b`, `d`, and `f`.\n * @param {ForkContext} context An instance.\n * @param {number} begin The first index of the previous segments.\n * @param {number} end The last index of the previous segments.\n * @param {Function} create A factory function of new segments.\n * @returns {CodePathSegment[]} New segments.\n */\nfunction makeSegments(context, begin, end, create) {\n    const list = context.segmentsList;\n\n    const normalizedBegin = begin >= 0 ? begin : list.length + begin;\n    const normalizedEnd = end >= 0 ? end : list.length + end;\n\n    const segments = [];\n\n    for (let i = 0; i < context.count; ++i) {\n        const allPrevSegments = [];\n\n        for (let j = normalizedBegin; j <= normalizedEnd; ++j) {\n            allPrevSegments.push(list[j][i]);\n        }\n\n        segments.push(create(context.idGenerator.next(), allPrevSegments));\n    }\n\n    return segments;\n}\n\n/**\n * `segments` becomes doubly in a `finally` block. Then if a code path exits by a\n * control statement (such as `break`, `continue`) from the `finally` block, the\n * destination's segments may be half of the source segments. In that case, this\n * merges segments.\n * @param {ForkContext} context An instance.\n * @param {CodePathSegment[]} segments Segments to merge.\n * @returns {CodePathSegment[]} The merged segments.\n */\nfunction mergeExtraSegments(context, segments) {\n    let currentSegments = segments;\n\n    while (currentSegments.length > context.count) {\n        const merged = [];\n\n        for (let i = 0, length = currentSegments.length / 2 | 0; i < length; ++i) {\n            merged.push(CodePathSegment.newNext(\n                context.idGenerator.next(),\n                [currentSegments[i], currentSegments[i + length]]\n            ));\n        }\n        currentSegments = merged;\n    }\n    return currentSegments;\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * A class to manage forking.\n */\nclass ForkContext {\n\n    // eslint-disable-next-line jsdoc/require-description\n    /**\n     * @param {IdGenerator} idGenerator An identifier generator for segments.\n     * @param {ForkContext|null} upper An upper fork context.\n     * @param {number} count A number of parallel segments.\n     */\n    constructor(idGenerator, upper, count) {\n        this.idGenerator = idGenerator;\n        this.upper = upper;\n        this.count = count;\n        this.segmentsList = [];\n    }\n\n    /**\n     * The head segments.\n     * @type {CodePathSegment[]}\n     */\n    get head() {\n        const list = this.segmentsList;\n\n        return list.length === 0 ? [] : list[list.length - 1];\n    }\n\n    /**\n     * A flag which shows empty.\n     * @type {boolean}\n     */\n    get empty() {\n        return this.segmentsList.length === 0;\n    }\n\n    /**\n     * A flag which shows reachable.\n     * @type {boolean}\n     */\n    get reachable() {\n        const segments = this.head;\n\n        return segments.length > 0 && segments.some(isReachable);\n    }\n\n    /**\n     * Creates new segments from this context.\n     * @param {number} begin The first index of previous segments.\n     * @param {number} end The last index of previous segments.\n     * @returns {CodePathSegment[]} New segments.\n     */\n    makeNext(begin, end) {\n        return makeSegments(this, begin, end, CodePathSegment.newNext);\n    }\n\n    /**\n     * Creates new segments from this context.\n     * The new segments is always unreachable.\n     * @param {number} begin The first index of previous segments.\n     * @param {number} end The last index of previous segments.\n     * @returns {CodePathSegment[]} New segments.\n     */\n    makeUnreachable(begin, end) {\n        return makeSegments(this, begin, end, CodePathSegment.newUnreachable);\n    }\n\n    /**\n     * Creates new segments from this context.\n     * The new segments don't have connections for previous segments.\n     * But these inherit the reachable flag from this context.\n     * @param {number} begin The first index of previous segments.\n     * @param {number} end The last index of previous segments.\n     * @returns {CodePathSegment[]} New segments.\n     */\n    makeDisconnected(begin, end) {\n        return makeSegments(this, begin, end, CodePathSegment.newDisconnected);\n    }\n\n    /**\n     * Adds segments into this context.\n     * The added segments become the head.\n     * @param {CodePathSegment[]} segments Segments to add.\n     * @returns {void}\n     */\n    add(segments) {\n        assert(segments.length >= this.count, `${segments.length} >= ${this.count}`);\n\n        this.segmentsList.push(mergeExtraSegments(this, segments));\n    }\n\n    /**\n     * Replaces the head segments with given segments.\n     * The current head segments are removed.\n     * @param {CodePathSegment[]} segments Segments to add.\n     * @returns {void}\n     */\n    replaceHead(segments) {\n        assert(segments.length >= this.count, `${segments.length} >= ${this.count}`);\n\n        this.segmentsList.splice(-1, 1, mergeExtraSegments(this, segments));\n    }\n\n    /**\n     * Adds all segments of a given fork context into this context.\n     * @param {ForkContext} context A fork context to add.\n     * @returns {void}\n     */\n    addAll(context) {\n        assert(context.count === this.count);\n\n        const source = context.segmentsList;\n\n        for (let i = 0; i < source.length; ++i) {\n            this.segmentsList.push(source[i]);\n        }\n    }\n\n    /**\n     * Clears all segments in this context.\n     * @returns {void}\n     */\n    clear() {\n        this.segmentsList = [];\n    }\n\n    /**\n     * Creates the root fork context.\n     * @param {IdGenerator} idGenerator An identifier generator for segments.\n     * @returns {ForkContext} New fork context.\n     */\n    static newRoot(idGenerator) {\n        const context = new ForkContext(idGenerator, null, 1);\n\n        context.add([CodePathSegment.newRoot(idGenerator.next())]);\n\n        return context;\n    }\n\n    /**\n     * Creates an empty fork context preceded by a given context.\n     * @param {ForkContext} parentContext The parent fork context.\n     * @param {boolean} forkLeavingPath A flag which shows inside of `finally` block.\n     * @returns {ForkContext} New fork context.\n     */\n    static newEmpty(parentContext, forkLeavingPath) {\n        return new ForkContext(\n            parentContext.idGenerator,\n            parentContext,\n            (forkLeavingPath ? 2 : 1) * parentContext.count\n        );\n    }\n}\n\nmodule.exports = ForkContext;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}