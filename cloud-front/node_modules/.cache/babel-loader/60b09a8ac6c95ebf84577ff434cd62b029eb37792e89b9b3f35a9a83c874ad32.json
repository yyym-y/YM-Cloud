{"ast":null,"code":"/**\n * @fileoverview Rule to ensure newline per method call when chaining calls\n * @author Rajendra Patil\n * @author Burak Yigit Kaya\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"require a newline after each call in a method chain\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/newline-per-chained-call\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      type: \"object\",\n      properties: {\n        ignoreChainWithDepth: {\n          type: \"integer\",\n          minimum: 1,\n          maximum: 10,\n          default: 2\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      expected: \"Expected line break before `{{callee}}`.\"\n    }\n  },\n  create(context) {\n    const options = context.options[0] || {},\n      ignoreChainWithDepth = options.ignoreChainWithDepth || 2;\n    const sourceCode = context.getSourceCode();\n\n    /**\n     * Get the prefix of a given MemberExpression node.\n     * If the MemberExpression node is a computed value it returns a\n     * left bracket. If not it returns a period.\n     * @param  {ASTNode} node A MemberExpression node to get\n     * @returns {string} The prefix of the node.\n     */\n    function getPrefix(node) {\n      if (node.computed) {\n        if (node.optional) {\n          return \"?.[\";\n        }\n        return \"[\";\n      }\n      if (node.optional) {\n        return \"?.\";\n      }\n      return \".\";\n    }\n\n    /**\n     * Gets the property text of a given MemberExpression node.\n     * If the text is multiline, this returns only the first line.\n     * @param {ASTNode} node A MemberExpression node to get.\n     * @returns {string} The property text of the node.\n     */\n    function getPropertyText(node) {\n      const prefix = getPrefix(node);\n      const lines = sourceCode.getText(node.property).split(astUtils.LINEBREAK_MATCHER);\n      const suffix = node.computed && lines.length === 1 ? \"]\" : \"\";\n      return prefix + lines[0] + suffix;\n    }\n    return {\n      \"CallExpression:exit\"(node) {\n        const callee = astUtils.skipChainExpression(node.callee);\n        if (callee.type !== \"MemberExpression\") {\n          return;\n        }\n        let parent = astUtils.skipChainExpression(callee.object);\n        let depth = 1;\n        while (parent && parent.callee) {\n          depth += 1;\n          parent = astUtils.skipChainExpression(astUtils.skipChainExpression(parent.callee).object);\n        }\n        if (depth > ignoreChainWithDepth && astUtils.isTokenOnSameLine(callee.object, callee.property)) {\n          const firstTokenAfterObject = sourceCode.getTokenAfter(callee.object, astUtils.isNotClosingParenToken);\n          context.report({\n            node: callee.property,\n            loc: {\n              start: firstTokenAfterObject.loc.start,\n              end: callee.loc.end\n            },\n            messageId: \"expected\",\n            data: {\n              callee: getPropertyText(callee)\n            },\n            fix(fixer) {\n              return fixer.insertTextBefore(firstTokenAfterObject, \"\\n\");\n            }\n          });\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","module","exports","meta","type","docs","description","category","recommended","url","fixable","schema","properties","ignoreChainWithDepth","minimum","maximum","default","additionalProperties","messages","expected","create","context","options","sourceCode","getSourceCode","getPrefix","node","computed","optional","getPropertyText","prefix","lines","getText","property","split","LINEBREAK_MATCHER","suffix","length","CallExpression:exit","callee","skipChainExpression","parent","object","depth","isTokenOnSameLine","firstTokenAfterObject","getTokenAfter","isNotClosingParenToken","report","loc","start","end","messageId","data","fix","fixer","insertTextBefore"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/newline-per-chained-call.js"],"sourcesContent":["/**\n * @fileoverview Rule to ensure newline per method call when chaining calls\n * @author Rajendra Patil\n * @author Burak Yigit Kaya\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"require a newline after each call in a method chain\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/newline-per-chained-call\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [{\n            type: \"object\",\n            properties: {\n                ignoreChainWithDepth: {\n                    type: \"integer\",\n                    minimum: 1,\n                    maximum: 10,\n                    default: 2\n                }\n            },\n            additionalProperties: false\n        }],\n        messages: {\n            expected: \"Expected line break before `{{callee}}`.\"\n        }\n    },\n\n    create(context) {\n\n        const options = context.options[0] || {},\n            ignoreChainWithDepth = options.ignoreChainWithDepth || 2;\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Get the prefix of a given MemberExpression node.\n         * If the MemberExpression node is a computed value it returns a\n         * left bracket. If not it returns a period.\n         * @param  {ASTNode} node A MemberExpression node to get\n         * @returns {string} The prefix of the node.\n         */\n        function getPrefix(node) {\n            if (node.computed) {\n                if (node.optional) {\n                    return \"?.[\";\n                }\n                return \"[\";\n            }\n            if (node.optional) {\n                return \"?.\";\n            }\n            return \".\";\n        }\n\n        /**\n         * Gets the property text of a given MemberExpression node.\n         * If the text is multiline, this returns only the first line.\n         * @param {ASTNode} node A MemberExpression node to get.\n         * @returns {string} The property text of the node.\n         */\n        function getPropertyText(node) {\n            const prefix = getPrefix(node);\n            const lines = sourceCode.getText(node.property).split(astUtils.LINEBREAK_MATCHER);\n            const suffix = node.computed && lines.length === 1 ? \"]\" : \"\";\n\n            return prefix + lines[0] + suffix;\n        }\n\n        return {\n            \"CallExpression:exit\"(node) {\n                const callee = astUtils.skipChainExpression(node.callee);\n\n                if (callee.type !== \"MemberExpression\") {\n                    return;\n                }\n\n                let parent = astUtils.skipChainExpression(callee.object);\n                let depth = 1;\n\n                while (parent && parent.callee) {\n                    depth += 1;\n                    parent = astUtils.skipChainExpression(astUtils.skipChainExpression(parent.callee).object);\n                }\n\n                if (depth > ignoreChainWithDepth && astUtils.isTokenOnSameLine(callee.object, callee.property)) {\n                    const firstTokenAfterObject = sourceCode.getTokenAfter(callee.object, astUtils.isNotClosingParenToken);\n\n                    context.report({\n                        node: callee.property,\n                        loc: {\n                            start: firstTokenAfterObject.loc.start,\n                            end: callee.loc.end\n                        },\n                        messageId: \"expected\",\n                        data: {\n                            callee: getPropertyText(callee)\n                        },\n                        fix(fixer) {\n                            return fixer.insertTextBefore(firstTokenAfterObject, \"\\n\");\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}