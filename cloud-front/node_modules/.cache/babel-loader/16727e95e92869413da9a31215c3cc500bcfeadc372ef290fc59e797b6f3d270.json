{"ast":null,"code":"/**\n * @fileoverview enforce a particular style for multiline comments\n * @author Teddy Katz\n */\n\"use strict\";\n\nrequire(\"core-js/modules/es.array.push.js\");\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"enforce a particular style for multiline comments\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/multiline-comment-style\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      enum: [\"starred-block\", \"separate-lines\", \"bare-block\"]\n    }],\n    messages: {\n      expectedBlock: \"Expected a block comment instead of consecutive line comments.\",\n      expectedBareBlock: \"Expected a block comment without padding stars.\",\n      startNewline: \"Expected a linebreak after '/*'.\",\n      endNewline: \"Expected a linebreak before '*/'.\",\n      missingStar: \"Expected a '*' at the start of this line.\",\n      alignment: \"Expected this line to be aligned with the start of the comment.\",\n      expectedLines: \"Expected multiple line comments instead of a block comment.\"\n    }\n  },\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const option = context.options[0] || \"starred-block\";\n\n    //----------------------------------------------------------------------\n    // Helpers\n    //----------------------------------------------------------------------\n\n    /**\n     * Checks if a comment line is starred.\n     * @param {string} line A string representing a comment line.\n     * @returns {boolean} Whether or not the comment line is starred.\n     */\n    function isStarredCommentLine(line) {\n      return /^\\s*\\*/u.test(line);\n    }\n\n    /**\n     * Checks if a comment group is in starred-block form.\n     * @param {Token[]} commentGroup A group of comments, containing either multiple line comments or a single block comment.\n     * @returns {boolean} Whether or not the comment group is in starred block form.\n     */\n    function isStarredBlockComment([firstComment]) {\n      if (firstComment.type !== \"Block\") {\n        return false;\n      }\n      const lines = firstComment.value.split(astUtils.LINEBREAK_MATCHER);\n\n      // The first and last lines can only contain whitespace.\n      return lines.length > 0 && lines.every((line, i) => (i === 0 || i === lines.length - 1 ? /^\\s*$/u : /^\\s*\\*/u).test(line));\n    }\n\n    /**\n     * Checks if a comment group is in JSDoc form.\n     * @param {Token[]} commentGroup A group of comments, containing either multiple line comments or a single block comment.\n     * @returns {boolean} Whether or not the comment group is in JSDoc form.\n     */\n    function isJSDocComment([firstComment]) {\n      if (firstComment.type !== \"Block\") {\n        return false;\n      }\n      const lines = firstComment.value.split(astUtils.LINEBREAK_MATCHER);\n      return /^\\*\\s*$/u.test(lines[0]) && lines.slice(1, -1).every(line => /^\\s* /u.test(line)) && /^\\s*$/u.test(lines[lines.length - 1]);\n    }\n\n    /**\n     * Processes a comment group that is currently in separate-line form, calculating the offset for each line.\n     * @param {Token[]} commentGroup A group of comments containing multiple line comments.\n     * @returns {string[]} An array of the processed lines.\n     */\n    function processSeparateLineComments(commentGroup) {\n      const allLinesHaveLeadingSpace = commentGroup.map(({\n        value\n      }) => value).filter(line => line.trim().length).every(line => line.startsWith(\" \"));\n      return commentGroup.map(({\n        value\n      }) => allLinesHaveLeadingSpace ? value.replace(/^ /u, \"\") : value);\n    }\n\n    /**\n     * Processes a comment group that is currently in starred-block form, calculating the offset for each line.\n     * @param {Token} comment A single block comment token in starred-block form.\n     * @returns {string[]} An array of the processed lines.\n     */\n    function processStarredBlockComment(comment) {\n      const lines = comment.value.split(astUtils.LINEBREAK_MATCHER).filter((line, i, linesArr) => !(i === 0 || i === linesArr.length - 1)).map(line => line.replace(/^\\s*$/u, \"\"));\n      const allLinesHaveLeadingSpace = lines.map(line => line.replace(/\\s*\\*/u, \"\")).filter(line => line.trim().length).every(line => line.startsWith(\" \"));\n      return lines.map(line => line.replace(allLinesHaveLeadingSpace ? /\\s*\\* ?/u : /\\s*\\*/u, \"\"));\n    }\n\n    /**\n     * Processes a comment group that is currently in bare-block form, calculating the offset for each line.\n     * @param {Token} comment A single block comment token in bare-block form.\n     * @returns {string[]} An array of the processed lines.\n     */\n    function processBareBlockComment(comment) {\n      const lines = comment.value.split(astUtils.LINEBREAK_MATCHER).map(line => line.replace(/^\\s*$/u, \"\"));\n      const leadingWhitespace = `${sourceCode.text.slice(comment.range[0] - comment.loc.start.column, comment.range[0])}   `;\n      let offset = \"\";\n\n      /*\n       * Calculate the offset of the least indented line and use that as the basis for offsetting all the lines.\n       * The first line should not be checked because it is inline with the opening block comment delimiter.\n       */\n      for (const [i, line] of lines.entries()) {\n        if (!line.trim().length || i === 0) {\n          continue;\n        }\n        const [, lineOffset] = line.match(/^(\\s*\\*?\\s*)/u);\n        if (lineOffset.length < leadingWhitespace.length) {\n          const newOffset = leadingWhitespace.slice(lineOffset.length - leadingWhitespace.length);\n          if (newOffset.length > offset.length) {\n            offset = newOffset;\n          }\n        }\n      }\n      return lines.map(line => {\n        const match = line.match(/^(\\s*\\*?\\s*)(.*)/u);\n        const [, lineOffset, lineContents] = match;\n        if (lineOffset.length > leadingWhitespace.length) {\n          return `${lineOffset.slice(leadingWhitespace.length - (offset.length + lineOffset.length))}${lineContents}`;\n        }\n        if (lineOffset.length < leadingWhitespace.length) {\n          return `${lineOffset.slice(leadingWhitespace.length)}${lineContents}`;\n        }\n        return lineContents;\n      });\n    }\n\n    /**\n     * Gets a list of comment lines in a group, formatting leading whitespace as necessary.\n     * @param {Token[]} commentGroup A group of comments containing either multiple line comments or a single block comment.\n     * @returns {string[]} A list of comment lines.\n     */\n    function getCommentLines(commentGroup) {\n      const [firstComment] = commentGroup;\n      if (firstComment.type === \"Line\") {\n        return processSeparateLineComments(commentGroup);\n      }\n      if (isStarredBlockComment(commentGroup)) {\n        return processStarredBlockComment(firstComment);\n      }\n      return processBareBlockComment(firstComment);\n    }\n\n    /**\n     * Gets the initial offset (whitespace) from the beginning of a line to a given comment token.\n     * @param {Token} comment The token to check.\n     * @returns {string} The offset from the beginning of a line to the token.\n     */\n    function getInitialOffset(comment) {\n      return sourceCode.text.slice(comment.range[0] - comment.loc.start.column, comment.range[0]);\n    }\n\n    /**\n     * Converts a comment into starred-block form\n     * @param {Token} firstComment The first comment of the group being converted\n     * @param {string[]} commentLinesList A list of lines to appear in the new starred-block comment\n     * @returns {string} A representation of the comment value in starred-block form, excluding start and end markers\n     */\n    function convertToStarredBlock(firstComment, commentLinesList) {\n      const initialOffset = getInitialOffset(firstComment);\n      return `/*\\n${commentLinesList.map(line => `${initialOffset} * ${line}`).join(\"\\n\")}\\n${initialOffset} */`;\n    }\n\n    /**\n     * Converts a comment into separate-line form\n     * @param {Token} firstComment The first comment of the group being converted\n     * @param {string[]} commentLinesList A list of lines to appear in the new starred-block comment\n     * @returns {string} A representation of the comment value in separate-line form\n     */\n    function convertToSeparateLines(firstComment, commentLinesList) {\n      return commentLinesList.map(line => `// ${line}`).join(`\\n${getInitialOffset(firstComment)}`);\n    }\n\n    /**\n     * Converts a comment into bare-block form\n     * @param {Token} firstComment The first comment of the group being converted\n     * @param {string[]} commentLinesList A list of lines to appear in the new starred-block comment\n     * @returns {string} A representation of the comment value in bare-block form\n     */\n    function convertToBlock(firstComment, commentLinesList) {\n      return `/* ${commentLinesList.join(`\\n${getInitialOffset(firstComment)}   `)} */`;\n    }\n\n    /**\n     * Each method checks a group of comments to see if it's valid according to the given option.\n     * @param {Token[]} commentGroup A list of comments that appear together. This will either contain a single\n     * block comment or multiple line comments.\n     * @returns {void}\n     */\n    const commentGroupCheckers = {\n      \"starred-block\"(commentGroup) {\n        const [firstComment] = commentGroup;\n        const commentLines = getCommentLines(commentGroup);\n        if (commentLines.some(value => value.includes(\"*/\"))) {\n          return;\n        }\n        if (commentGroup.length > 1) {\n          context.report({\n            loc: {\n              start: firstComment.loc.start,\n              end: commentGroup[commentGroup.length - 1].loc.end\n            },\n            messageId: \"expectedBlock\",\n            fix(fixer) {\n              const range = [firstComment.range[0], commentGroup[commentGroup.length - 1].range[1]];\n              return commentLines.some(value => value.startsWith(\"/\")) ? null : fixer.replaceTextRange(range, convertToStarredBlock(firstComment, commentLines));\n            }\n          });\n        } else {\n          const lines = firstComment.value.split(astUtils.LINEBREAK_MATCHER);\n          const expectedLeadingWhitespace = getInitialOffset(firstComment);\n          const expectedLinePrefix = `${expectedLeadingWhitespace} *`;\n          if (!/^\\*?\\s*$/u.test(lines[0])) {\n            const start = firstComment.value.startsWith(\"*\") ? firstComment.range[0] + 1 : firstComment.range[0];\n            context.report({\n              loc: {\n                start: firstComment.loc.start,\n                end: {\n                  line: firstComment.loc.start.line,\n                  column: firstComment.loc.start.column + 2\n                }\n              },\n              messageId: \"startNewline\",\n              fix: fixer => fixer.insertTextAfterRange([start, start + 2], `\\n${expectedLinePrefix}`)\n            });\n          }\n          if (!/^\\s*$/u.test(lines[lines.length - 1])) {\n            context.report({\n              loc: {\n                start: {\n                  line: firstComment.loc.end.line,\n                  column: firstComment.loc.end.column - 2\n                },\n                end: firstComment.loc.end\n              },\n              messageId: \"endNewline\",\n              fix: fixer => fixer.replaceTextRange([firstComment.range[1] - 2, firstComment.range[1]], `\\n${expectedLinePrefix}/`)\n            });\n          }\n          for (let lineNumber = firstComment.loc.start.line + 1; lineNumber <= firstComment.loc.end.line; lineNumber++) {\n            const lineText = sourceCode.lines[lineNumber - 1];\n            const errorType = isStarredCommentLine(lineText) ? \"alignment\" : \"missingStar\";\n            if (!lineText.startsWith(expectedLinePrefix)) {\n              context.report({\n                loc: {\n                  start: {\n                    line: lineNumber,\n                    column: 0\n                  },\n                  end: {\n                    line: lineNumber,\n                    column: lineText.length\n                  }\n                },\n                messageId: errorType,\n                fix(fixer) {\n                  const lineStartIndex = sourceCode.getIndexFromLoc({\n                    line: lineNumber,\n                    column: 0\n                  });\n                  if (errorType === \"alignment\") {\n                    const [, commentTextPrefix = \"\"] = lineText.match(/^(\\s*\\*)/u) || [];\n                    const commentTextStartIndex = lineStartIndex + commentTextPrefix.length;\n                    return fixer.replaceTextRange([lineStartIndex, commentTextStartIndex], expectedLinePrefix);\n                  }\n                  const [, commentTextPrefix = \"\"] = lineText.match(/^(\\s*)/u) || [];\n                  const commentTextStartIndex = lineStartIndex + commentTextPrefix.length;\n                  let offset;\n                  for (const [idx, line] of lines.entries()) {\n                    if (!/\\S+/u.test(line)) {\n                      continue;\n                    }\n                    const lineTextToAlignWith = sourceCode.lines[firstComment.loc.start.line - 1 + idx];\n                    const [, prefix = \"\", initialOffset = \"\"] = lineTextToAlignWith.match(/^(\\s*(?:\\/?\\*)?(\\s*))/u) || [];\n                    offset = `${commentTextPrefix.slice(prefix.length)}${initialOffset}`;\n                    if (/^\\s*\\//u.test(lineText) && offset.length === 0) {\n                      offset += \" \";\n                    }\n                    break;\n                  }\n                  return fixer.replaceTextRange([lineStartIndex, commentTextStartIndex], `${expectedLinePrefix}${offset}`);\n                }\n              });\n            }\n          }\n        }\n      },\n      \"separate-lines\"(commentGroup) {\n        const [firstComment] = commentGroup;\n        if (firstComment.type !== \"Block\" || isJSDocComment(commentGroup)) {\n          return;\n        }\n        const commentLines = getCommentLines(commentGroup);\n        const tokenAfter = sourceCode.getTokenAfter(firstComment, {\n          includeComments: true\n        });\n        if (tokenAfter && firstComment.loc.end.line === tokenAfter.loc.start.line) {\n          return;\n        }\n        context.report({\n          loc: {\n            start: firstComment.loc.start,\n            end: {\n              line: firstComment.loc.start.line,\n              column: firstComment.loc.start.column + 2\n            }\n          },\n          messageId: \"expectedLines\",\n          fix(fixer) {\n            return fixer.replaceText(firstComment, convertToSeparateLines(firstComment, commentLines));\n          }\n        });\n      },\n      \"bare-block\"(commentGroup) {\n        if (isJSDocComment(commentGroup)) {\n          return;\n        }\n        const [firstComment] = commentGroup;\n        const commentLines = getCommentLines(commentGroup);\n\n        // Disallows consecutive line comments in favor of using a block comment.\n        if (firstComment.type === \"Line\" && commentLines.length > 1 && !commentLines.some(value => value.includes(\"*/\"))) {\n          context.report({\n            loc: {\n              start: firstComment.loc.start,\n              end: commentGroup[commentGroup.length - 1].loc.end\n            },\n            messageId: \"expectedBlock\",\n            fix(fixer) {\n              return fixer.replaceTextRange([firstComment.range[0], commentGroup[commentGroup.length - 1].range[1]], convertToBlock(firstComment, commentLines));\n            }\n          });\n        }\n\n        // Prohibits block comments from having a * at the beginning of each line.\n        if (isStarredBlockComment(commentGroup)) {\n          context.report({\n            loc: {\n              start: firstComment.loc.start,\n              end: {\n                line: firstComment.loc.start.line,\n                column: firstComment.loc.start.column + 2\n              }\n            },\n            messageId: \"expectedBareBlock\",\n            fix(fixer) {\n              return fixer.replaceText(firstComment, convertToBlock(firstComment, commentLines));\n            }\n          });\n        }\n      }\n    };\n\n    //----------------------------------------------------------------------\n    // Public\n    //----------------------------------------------------------------------\n\n    return {\n      Program() {\n        return sourceCode.getAllComments().filter(comment => comment.type !== \"Shebang\").filter(comment => !astUtils.COMMENTS_IGNORE_PATTERN.test(comment.value)).filter(comment => {\n          const tokenBefore = sourceCode.getTokenBefore(comment, {\n            includeComments: true\n          });\n          return !tokenBefore || tokenBefore.loc.end.line < comment.loc.start.line;\n        }).reduce((commentGroups, comment, index, commentList) => {\n          const tokenBefore = sourceCode.getTokenBefore(comment, {\n            includeComments: true\n          });\n          if (comment.type === \"Line\" && index && commentList[index - 1].type === \"Line\" && tokenBefore && tokenBefore.loc.end.line === comment.loc.start.line - 1 && tokenBefore === commentList[index - 1]) {\n            commentGroups[commentGroups.length - 1].push(comment);\n          } else {\n            commentGroups.push([comment]);\n          }\n          return commentGroups;\n        }, []).filter(commentGroup => !(commentGroup.length === 1 && commentGroup[0].loc.start.line === commentGroup[0].loc.end.line)).forEach(commentGroupCheckers[option]);\n      }\n    };\n  }\n};","map":{"version":3,"names":["require","astUtils","module","exports","meta","type","docs","description","category","recommended","url","fixable","schema","enum","messages","expectedBlock","expectedBareBlock","startNewline","endNewline","missingStar","alignment","expectedLines","create","context","sourceCode","getSourceCode","option","options","isStarredCommentLine","line","test","isStarredBlockComment","firstComment","lines","value","split","LINEBREAK_MATCHER","length","every","i","isJSDocComment","slice","processSeparateLineComments","commentGroup","allLinesHaveLeadingSpace","map","filter","trim","startsWith","replace","processStarredBlockComment","comment","linesArr","processBareBlockComment","leadingWhitespace","text","range","loc","start","column","offset","entries","lineOffset","match","newOffset","lineContents","getCommentLines","getInitialOffset","convertToStarredBlock","commentLinesList","initialOffset","join","convertToSeparateLines","convertToBlock","commentGroupCheckers","starred-block","commentLines","some","includes","report","end","messageId","fix","fixer","replaceTextRange","expectedLeadingWhitespace","expectedLinePrefix","insertTextAfterRange","lineNumber","lineText","errorType","lineStartIndex","getIndexFromLoc","commentTextPrefix","commentTextStartIndex","idx","lineTextToAlignWith","prefix","separate-lines","tokenAfter","getTokenAfter","includeComments","replaceText","bare-block","Program","getAllComments","COMMENTS_IGNORE_PATTERN","tokenBefore","getTokenBefore","reduce","commentGroups","index","commentList","push","forEach"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/multiline-comment-style.js"],"sourcesContent":["/**\n * @fileoverview enforce a particular style for multiline comments\n * @author Teddy Katz\n */\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce a particular style for multiline comments\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/multiline-comment-style\"\n        },\n\n        fixable: \"whitespace\",\n        schema: [{ enum: [\"starred-block\", \"separate-lines\", \"bare-block\"] }],\n        messages: {\n            expectedBlock: \"Expected a block comment instead of consecutive line comments.\",\n            expectedBareBlock: \"Expected a block comment without padding stars.\",\n            startNewline: \"Expected a linebreak after '/*'.\",\n            endNewline: \"Expected a linebreak before '*/'.\",\n            missingStar: \"Expected a '*' at the start of this line.\",\n            alignment: \"Expected this line to be aligned with the start of the comment.\",\n            expectedLines: \"Expected multiple line comments instead of a block comment.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const option = context.options[0] || \"starred-block\";\n\n        //----------------------------------------------------------------------\n        // Helpers\n        //----------------------------------------------------------------------\n\n        /**\n         * Checks if a comment line is starred.\n         * @param {string} line A string representing a comment line.\n         * @returns {boolean} Whether or not the comment line is starred.\n         */\n        function isStarredCommentLine(line) {\n            return /^\\s*\\*/u.test(line);\n        }\n\n        /**\n         * Checks if a comment group is in starred-block form.\n         * @param {Token[]} commentGroup A group of comments, containing either multiple line comments or a single block comment.\n         * @returns {boolean} Whether or not the comment group is in starred block form.\n         */\n        function isStarredBlockComment([firstComment]) {\n            if (firstComment.type !== \"Block\") {\n                return false;\n            }\n\n            const lines = firstComment.value.split(astUtils.LINEBREAK_MATCHER);\n\n            // The first and last lines can only contain whitespace.\n            return lines.length > 0 && lines.every((line, i) => (i === 0 || i === lines.length - 1 ? /^\\s*$/u : /^\\s*\\*/u).test(line));\n        }\n\n        /**\n         * Checks if a comment group is in JSDoc form.\n         * @param {Token[]} commentGroup A group of comments, containing either multiple line comments or a single block comment.\n         * @returns {boolean} Whether or not the comment group is in JSDoc form.\n         */\n        function isJSDocComment([firstComment]) {\n            if (firstComment.type !== \"Block\") {\n                return false;\n            }\n\n            const lines = firstComment.value.split(astUtils.LINEBREAK_MATCHER);\n\n            return /^\\*\\s*$/u.test(lines[0]) &&\n                lines.slice(1, -1).every(line => /^\\s* /u.test(line)) &&\n                /^\\s*$/u.test(lines[lines.length - 1]);\n        }\n\n        /**\n         * Processes a comment group that is currently in separate-line form, calculating the offset for each line.\n         * @param {Token[]} commentGroup A group of comments containing multiple line comments.\n         * @returns {string[]} An array of the processed lines.\n         */\n        function processSeparateLineComments(commentGroup) {\n            const allLinesHaveLeadingSpace = commentGroup\n                .map(({ value }) => value)\n                .filter(line => line.trim().length)\n                .every(line => line.startsWith(\" \"));\n\n            return commentGroup.map(({ value }) => (allLinesHaveLeadingSpace ? value.replace(/^ /u, \"\") : value));\n        }\n\n        /**\n         * Processes a comment group that is currently in starred-block form, calculating the offset for each line.\n         * @param {Token} comment A single block comment token in starred-block form.\n         * @returns {string[]} An array of the processed lines.\n         */\n        function processStarredBlockComment(comment) {\n            const lines = comment.value.split(astUtils.LINEBREAK_MATCHER)\n                .filter((line, i, linesArr) => !(i === 0 || i === linesArr.length - 1))\n                .map(line => line.replace(/^\\s*$/u, \"\"));\n            const allLinesHaveLeadingSpace = lines\n                .map(line => line.replace(/\\s*\\*/u, \"\"))\n                .filter(line => line.trim().length)\n                .every(line => line.startsWith(\" \"));\n\n            return lines.map(line => line.replace(allLinesHaveLeadingSpace ? /\\s*\\* ?/u : /\\s*\\*/u, \"\"));\n        }\n\n        /**\n         * Processes a comment group that is currently in bare-block form, calculating the offset for each line.\n         * @param {Token} comment A single block comment token in bare-block form.\n         * @returns {string[]} An array of the processed lines.\n         */\n        function processBareBlockComment(comment) {\n            const lines = comment.value.split(astUtils.LINEBREAK_MATCHER).map(line => line.replace(/^\\s*$/u, \"\"));\n            const leadingWhitespace = `${sourceCode.text.slice(comment.range[0] - comment.loc.start.column, comment.range[0])}   `;\n            let offset = \"\";\n\n            /*\n             * Calculate the offset of the least indented line and use that as the basis for offsetting all the lines.\n             * The first line should not be checked because it is inline with the opening block comment delimiter.\n             */\n            for (const [i, line] of lines.entries()) {\n                if (!line.trim().length || i === 0) {\n                    continue;\n                }\n\n                const [, lineOffset] = line.match(/^(\\s*\\*?\\s*)/u);\n\n                if (lineOffset.length < leadingWhitespace.length) {\n                    const newOffset = leadingWhitespace.slice(lineOffset.length - leadingWhitespace.length);\n\n                    if (newOffset.length > offset.length) {\n                        offset = newOffset;\n                    }\n                }\n            }\n\n            return lines.map(line => {\n                const match = line.match(/^(\\s*\\*?\\s*)(.*)/u);\n                const [, lineOffset, lineContents] = match;\n\n                if (lineOffset.length > leadingWhitespace.length) {\n                    return `${lineOffset.slice(leadingWhitespace.length - (offset.length + lineOffset.length))}${lineContents}`;\n                }\n\n                if (lineOffset.length < leadingWhitespace.length) {\n                    return `${lineOffset.slice(leadingWhitespace.length)}${lineContents}`;\n                }\n\n                return lineContents;\n            });\n        }\n\n        /**\n         * Gets a list of comment lines in a group, formatting leading whitespace as necessary.\n         * @param {Token[]} commentGroup A group of comments containing either multiple line comments or a single block comment.\n         * @returns {string[]} A list of comment lines.\n         */\n        function getCommentLines(commentGroup) {\n            const [firstComment] = commentGroup;\n\n            if (firstComment.type === \"Line\") {\n                return processSeparateLineComments(commentGroup);\n            }\n\n            if (isStarredBlockComment(commentGroup)) {\n                return processStarredBlockComment(firstComment);\n            }\n\n            return processBareBlockComment(firstComment);\n        }\n\n        /**\n         * Gets the initial offset (whitespace) from the beginning of a line to a given comment token.\n         * @param {Token} comment The token to check.\n         * @returns {string} The offset from the beginning of a line to the token.\n         */\n        function getInitialOffset(comment) {\n            return sourceCode.text.slice(comment.range[0] - comment.loc.start.column, comment.range[0]);\n        }\n\n        /**\n         * Converts a comment into starred-block form\n         * @param {Token} firstComment The first comment of the group being converted\n         * @param {string[]} commentLinesList A list of lines to appear in the new starred-block comment\n         * @returns {string} A representation of the comment value in starred-block form, excluding start and end markers\n         */\n        function convertToStarredBlock(firstComment, commentLinesList) {\n            const initialOffset = getInitialOffset(firstComment);\n\n            return `/*\\n${commentLinesList.map(line => `${initialOffset} * ${line}`).join(\"\\n\")}\\n${initialOffset} */`;\n        }\n\n        /**\n         * Converts a comment into separate-line form\n         * @param {Token} firstComment The first comment of the group being converted\n         * @param {string[]} commentLinesList A list of lines to appear in the new starred-block comment\n         * @returns {string} A representation of the comment value in separate-line form\n         */\n        function convertToSeparateLines(firstComment, commentLinesList) {\n            return commentLinesList.map(line => `// ${line}`).join(`\\n${getInitialOffset(firstComment)}`);\n        }\n\n        /**\n         * Converts a comment into bare-block form\n         * @param {Token} firstComment The first comment of the group being converted\n         * @param {string[]} commentLinesList A list of lines to appear in the new starred-block comment\n         * @returns {string} A representation of the comment value in bare-block form\n         */\n        function convertToBlock(firstComment, commentLinesList) {\n            return `/* ${commentLinesList.join(`\\n${getInitialOffset(firstComment)}   `)} */`;\n        }\n\n        /**\n         * Each method checks a group of comments to see if it's valid according to the given option.\n         * @param {Token[]} commentGroup A list of comments that appear together. This will either contain a single\n         * block comment or multiple line comments.\n         * @returns {void}\n         */\n        const commentGroupCheckers = {\n            \"starred-block\"(commentGroup) {\n                const [firstComment] = commentGroup;\n                const commentLines = getCommentLines(commentGroup);\n\n                if (commentLines.some(value => value.includes(\"*/\"))) {\n                    return;\n                }\n\n                if (commentGroup.length > 1) {\n                    context.report({\n                        loc: {\n                            start: firstComment.loc.start,\n                            end: commentGroup[commentGroup.length - 1].loc.end\n                        },\n                        messageId: \"expectedBlock\",\n                        fix(fixer) {\n                            const range = [firstComment.range[0], commentGroup[commentGroup.length - 1].range[1]];\n\n                            return commentLines.some(value => value.startsWith(\"/\"))\n                                ? null\n                                : fixer.replaceTextRange(range, convertToStarredBlock(firstComment, commentLines));\n                        }\n                    });\n                } else {\n                    const lines = firstComment.value.split(astUtils.LINEBREAK_MATCHER);\n                    const expectedLeadingWhitespace = getInitialOffset(firstComment);\n                    const expectedLinePrefix = `${expectedLeadingWhitespace} *`;\n\n                    if (!/^\\*?\\s*$/u.test(lines[0])) {\n                        const start = firstComment.value.startsWith(\"*\") ? firstComment.range[0] + 1 : firstComment.range[0];\n\n                        context.report({\n                            loc: {\n                                start: firstComment.loc.start,\n                                end: { line: firstComment.loc.start.line, column: firstComment.loc.start.column + 2 }\n                            },\n                            messageId: \"startNewline\",\n                            fix: fixer => fixer.insertTextAfterRange([start, start + 2], `\\n${expectedLinePrefix}`)\n                        });\n                    }\n\n                    if (!/^\\s*$/u.test(lines[lines.length - 1])) {\n                        context.report({\n                            loc: {\n                                start: { line: firstComment.loc.end.line, column: firstComment.loc.end.column - 2 },\n                                end: firstComment.loc.end\n                            },\n                            messageId: \"endNewline\",\n                            fix: fixer => fixer.replaceTextRange([firstComment.range[1] - 2, firstComment.range[1]], `\\n${expectedLinePrefix}/`)\n                        });\n                    }\n\n                    for (let lineNumber = firstComment.loc.start.line + 1; lineNumber <= firstComment.loc.end.line; lineNumber++) {\n                        const lineText = sourceCode.lines[lineNumber - 1];\n                        const errorType = isStarredCommentLine(lineText)\n                            ? \"alignment\"\n                            : \"missingStar\";\n\n                        if (!lineText.startsWith(expectedLinePrefix)) {\n                            context.report({\n                                loc: {\n                                    start: { line: lineNumber, column: 0 },\n                                    end: { line: lineNumber, column: lineText.length }\n                                },\n                                messageId: errorType,\n                                fix(fixer) {\n                                    const lineStartIndex = sourceCode.getIndexFromLoc({ line: lineNumber, column: 0 });\n\n                                    if (errorType === \"alignment\") {\n                                        const [, commentTextPrefix = \"\"] = lineText.match(/^(\\s*\\*)/u) || [];\n                                        const commentTextStartIndex = lineStartIndex + commentTextPrefix.length;\n\n                                        return fixer.replaceTextRange([lineStartIndex, commentTextStartIndex], expectedLinePrefix);\n                                    }\n\n                                    const [, commentTextPrefix = \"\"] = lineText.match(/^(\\s*)/u) || [];\n                                    const commentTextStartIndex = lineStartIndex + commentTextPrefix.length;\n                                    let offset;\n\n                                    for (const [idx, line] of lines.entries()) {\n                                        if (!/\\S+/u.test(line)) {\n                                            continue;\n                                        }\n\n                                        const lineTextToAlignWith = sourceCode.lines[firstComment.loc.start.line - 1 + idx];\n                                        const [, prefix = \"\", initialOffset = \"\"] = lineTextToAlignWith.match(/^(\\s*(?:\\/?\\*)?(\\s*))/u) || [];\n\n                                        offset = `${commentTextPrefix.slice(prefix.length)}${initialOffset}`;\n\n                                        if (/^\\s*\\//u.test(lineText) && offset.length === 0) {\n                                            offset += \" \";\n                                        }\n                                        break;\n                                    }\n\n                                    return fixer.replaceTextRange([lineStartIndex, commentTextStartIndex], `${expectedLinePrefix}${offset}`);\n                                }\n                            });\n                        }\n                    }\n                }\n            },\n            \"separate-lines\"(commentGroup) {\n                const [firstComment] = commentGroup;\n\n                if (firstComment.type !== \"Block\" || isJSDocComment(commentGroup)) {\n                    return;\n                }\n\n                const commentLines = getCommentLines(commentGroup);\n                const tokenAfter = sourceCode.getTokenAfter(firstComment, { includeComments: true });\n\n                if (tokenAfter && firstComment.loc.end.line === tokenAfter.loc.start.line) {\n                    return;\n                }\n\n                context.report({\n                    loc: {\n                        start: firstComment.loc.start,\n                        end: { line: firstComment.loc.start.line, column: firstComment.loc.start.column + 2 }\n                    },\n                    messageId: \"expectedLines\",\n                    fix(fixer) {\n                        return fixer.replaceText(firstComment, convertToSeparateLines(firstComment, commentLines));\n                    }\n                });\n            },\n            \"bare-block\"(commentGroup) {\n                if (isJSDocComment(commentGroup)) {\n                    return;\n                }\n\n                const [firstComment] = commentGroup;\n                const commentLines = getCommentLines(commentGroup);\n\n                // Disallows consecutive line comments in favor of using a block comment.\n                if (firstComment.type === \"Line\" && commentLines.length > 1 &&\n                    !commentLines.some(value => value.includes(\"*/\"))) {\n                    context.report({\n                        loc: {\n                            start: firstComment.loc.start,\n                            end: commentGroup[commentGroup.length - 1].loc.end\n                        },\n                        messageId: \"expectedBlock\",\n                        fix(fixer) {\n                            return fixer.replaceTextRange(\n                                [firstComment.range[0], commentGroup[commentGroup.length - 1].range[1]],\n                                convertToBlock(firstComment, commentLines)\n                            );\n                        }\n                    });\n                }\n\n                // Prohibits block comments from having a * at the beginning of each line.\n                if (isStarredBlockComment(commentGroup)) {\n                    context.report({\n                        loc: {\n                            start: firstComment.loc.start,\n                            end: { line: firstComment.loc.start.line, column: firstComment.loc.start.column + 2 }\n                        },\n                        messageId: \"expectedBareBlock\",\n                        fix(fixer) {\n                            return fixer.replaceText(firstComment, convertToBlock(firstComment, commentLines));\n                        }\n                    });\n                }\n            }\n        };\n\n        //----------------------------------------------------------------------\n        // Public\n        //----------------------------------------------------------------------\n\n        return {\n            Program() {\n                return sourceCode.getAllComments()\n                    .filter(comment => comment.type !== \"Shebang\")\n                    .filter(comment => !astUtils.COMMENTS_IGNORE_PATTERN.test(comment.value))\n                    .filter(comment => {\n                        const tokenBefore = sourceCode.getTokenBefore(comment, { includeComments: true });\n\n                        return !tokenBefore || tokenBefore.loc.end.line < comment.loc.start.line;\n                    })\n                    .reduce((commentGroups, comment, index, commentList) => {\n                        const tokenBefore = sourceCode.getTokenBefore(comment, { includeComments: true });\n\n                        if (\n                            comment.type === \"Line\" &&\n                            index && commentList[index - 1].type === \"Line\" &&\n                            tokenBefore && tokenBefore.loc.end.line === comment.loc.start.line - 1 &&\n                            tokenBefore === commentList[index - 1]\n                        ) {\n                            commentGroups[commentGroups.length - 1].push(comment);\n                        } else {\n                            commentGroups.push([comment]);\n                        }\n\n                        return commentGroups;\n                    }, [])\n                    .filter(commentGroup => !(commentGroup.length === 1 && commentGroup[0].loc.start.line === commentGroup[0].loc.end.line))\n                    .forEach(commentGroupCheckers[option]);\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}