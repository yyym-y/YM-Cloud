{"ast":null,"code":"/**\n * @fileoverview Rule to validate spacing before function paren.\n * @author Mathias Schreck <https://github.com/lo1tuma>\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce consistent spacing before `function` definition opening parenthesis\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/space-before-function-paren\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      oneOf: [{\n        enum: [\"always\", \"never\"]\n      }, {\n        type: \"object\",\n        properties: {\n          anonymous: {\n            enum: [\"always\", \"never\", \"ignore\"]\n          },\n          named: {\n            enum: [\"always\", \"never\", \"ignore\"]\n          },\n          asyncArrow: {\n            enum: [\"always\", \"never\", \"ignore\"]\n          }\n        },\n        additionalProperties: false\n      }]\n    }],\n    messages: {\n      unexpectedSpace: \"Unexpected space before function parentheses.\",\n      missingSpace: \"Missing space before function parentheses.\"\n    }\n  },\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const baseConfig = typeof context.options[0] === \"string\" ? context.options[0] : \"always\";\n    const overrideConfig = typeof context.options[0] === \"object\" ? context.options[0] : {};\n\n    /**\n     * Determines whether a function has a name.\n     * @param {ASTNode} node The function node.\n     * @returns {boolean} Whether the function has a name.\n     */\n    function isNamedFunction(node) {\n      if (node.id) {\n        return true;\n      }\n      const parent = node.parent;\n      return parent.type === \"MethodDefinition\" || parent.type === \"Property\" && (parent.kind === \"get\" || parent.kind === \"set\" || parent.method);\n    }\n\n    /**\n     * Gets the config for a given function\n     * @param {ASTNode} node The function node\n     * @returns {string} \"always\", \"never\", or \"ignore\"\n     */\n    function getConfigForFunction(node) {\n      if (node.type === \"ArrowFunctionExpression\") {\n        // Always ignore non-async functions and arrow functions without parens, e.g. async foo => bar\n        if (node.async && astUtils.isOpeningParenToken(sourceCode.getFirstToken(node, {\n          skip: 1\n        }))) {\n          return overrideConfig.asyncArrow || baseConfig;\n        }\n      } else if (isNamedFunction(node)) {\n        return overrideConfig.named || baseConfig;\n\n        // `generator-star-spacing` should warn anonymous generators. E.g. `function* () {}`\n      } else if (!node.generator) {\n        return overrideConfig.anonymous || baseConfig;\n      }\n      return \"ignore\";\n    }\n\n    /**\n     * Checks the parens of a function node\n     * @param {ASTNode} node A function node\n     * @returns {void}\n     */\n    function checkFunction(node) {\n      const functionConfig = getConfigForFunction(node);\n      if (functionConfig === \"ignore\") {\n        return;\n      }\n      const rightToken = sourceCode.getFirstToken(node, astUtils.isOpeningParenToken);\n      const leftToken = sourceCode.getTokenBefore(rightToken);\n      const hasSpacing = sourceCode.isSpaceBetweenTokens(leftToken, rightToken);\n      if (hasSpacing && functionConfig === \"never\") {\n        context.report({\n          node,\n          loc: {\n            start: leftToken.loc.end,\n            end: rightToken.loc.start\n          },\n          messageId: \"unexpectedSpace\",\n          fix(fixer) {\n            const comments = sourceCode.getCommentsBefore(rightToken);\n\n            // Don't fix anything if there's a single line comment between the left and the right token\n            if (comments.some(comment => comment.type === \"Line\")) {\n              return null;\n            }\n            return fixer.replaceTextRange([leftToken.range[1], rightToken.range[0]], comments.reduce((text, comment) => text + sourceCode.getText(comment), \"\"));\n          }\n        });\n      } else if (!hasSpacing && functionConfig === \"always\") {\n        context.report({\n          node,\n          loc: rightToken.loc,\n          messageId: \"missingSpace\",\n          fix: fixer => fixer.insertTextAfter(leftToken, \" \")\n        });\n      }\n    }\n    return {\n      ArrowFunctionExpression: checkFunction,\n      FunctionDeclaration: checkFunction,\n      FunctionExpression: checkFunction\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","module","exports","meta","type","docs","description","category","recommended","url","fixable","schema","oneOf","enum","properties","anonymous","named","asyncArrow","additionalProperties","messages","unexpectedSpace","missingSpace","create","context","sourceCode","getSourceCode","baseConfig","options","overrideConfig","isNamedFunction","node","id","parent","kind","method","getConfigForFunction","async","isOpeningParenToken","getFirstToken","skip","generator","checkFunction","functionConfig","rightToken","leftToken","getTokenBefore","hasSpacing","isSpaceBetweenTokens","report","loc","start","end","messageId","fix","fixer","comments","getCommentsBefore","some","comment","replaceTextRange","range","reduce","text","getText","insertTextAfter","ArrowFunctionExpression","FunctionDeclaration","FunctionExpression"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/space-before-function-paren.js"],"sourcesContent":["/**\n * @fileoverview Rule to validate spacing before function paren.\n * @author Mathias Schreck <https://github.com/lo1tuma>\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce consistent spacing before `function` definition opening parenthesis\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/space-before-function-paren\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"always\", \"never\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            anonymous: {\n                                enum: [\"always\", \"never\", \"ignore\"]\n                            },\n                            named: {\n                                enum: [\"always\", \"never\", \"ignore\"]\n                            },\n                            asyncArrow: {\n                                enum: [\"always\", \"never\", \"ignore\"]\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ],\n\n        messages: {\n            unexpectedSpace: \"Unexpected space before function parentheses.\",\n            missingSpace: \"Missing space before function parentheses.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const baseConfig = typeof context.options[0] === \"string\" ? context.options[0] : \"always\";\n        const overrideConfig = typeof context.options[0] === \"object\" ? context.options[0] : {};\n\n        /**\n         * Determines whether a function has a name.\n         * @param {ASTNode} node The function node.\n         * @returns {boolean} Whether the function has a name.\n         */\n        function isNamedFunction(node) {\n            if (node.id) {\n                return true;\n            }\n\n            const parent = node.parent;\n\n            return parent.type === \"MethodDefinition\" ||\n                (parent.type === \"Property\" &&\n                    (\n                        parent.kind === \"get\" ||\n                        parent.kind === \"set\" ||\n                        parent.method\n                    )\n                );\n        }\n\n        /**\n         * Gets the config for a given function\n         * @param {ASTNode} node The function node\n         * @returns {string} \"always\", \"never\", or \"ignore\"\n         */\n        function getConfigForFunction(node) {\n            if (node.type === \"ArrowFunctionExpression\") {\n\n                // Always ignore non-async functions and arrow functions without parens, e.g. async foo => bar\n                if (node.async && astUtils.isOpeningParenToken(sourceCode.getFirstToken(node, { skip: 1 }))) {\n                    return overrideConfig.asyncArrow || baseConfig;\n                }\n            } else if (isNamedFunction(node)) {\n                return overrideConfig.named || baseConfig;\n\n            // `generator-star-spacing` should warn anonymous generators. E.g. `function* () {}`\n            } else if (!node.generator) {\n                return overrideConfig.anonymous || baseConfig;\n            }\n\n            return \"ignore\";\n        }\n\n        /**\n         * Checks the parens of a function node\n         * @param {ASTNode} node A function node\n         * @returns {void}\n         */\n        function checkFunction(node) {\n            const functionConfig = getConfigForFunction(node);\n\n            if (functionConfig === \"ignore\") {\n                return;\n            }\n\n            const rightToken = sourceCode.getFirstToken(node, astUtils.isOpeningParenToken);\n            const leftToken = sourceCode.getTokenBefore(rightToken);\n            const hasSpacing = sourceCode.isSpaceBetweenTokens(leftToken, rightToken);\n\n            if (hasSpacing && functionConfig === \"never\") {\n                context.report({\n                    node,\n                    loc: {\n                        start: leftToken.loc.end,\n                        end: rightToken.loc.start\n                    },\n                    messageId: \"unexpectedSpace\",\n                    fix(fixer) {\n                        const comments = sourceCode.getCommentsBefore(rightToken);\n\n                        // Don't fix anything if there's a single line comment between the left and the right token\n                        if (comments.some(comment => comment.type === \"Line\")) {\n                            return null;\n                        }\n                        return fixer.replaceTextRange(\n                            [leftToken.range[1], rightToken.range[0]],\n                            comments.reduce((text, comment) => text + sourceCode.getText(comment), \"\")\n                        );\n                    }\n                });\n            } else if (!hasSpacing && functionConfig === \"always\") {\n                context.report({\n                    node,\n                    loc: rightToken.loc,\n                    messageId: \"missingSpace\",\n                    fix: fixer => fixer.insertTextAfter(leftToken, \" \")\n                });\n            }\n        }\n\n        return {\n            ArrowFunctionExpression: checkFunction,\n            FunctionDeclaration: checkFunction,\n            FunctionExpression: checkFunction\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}