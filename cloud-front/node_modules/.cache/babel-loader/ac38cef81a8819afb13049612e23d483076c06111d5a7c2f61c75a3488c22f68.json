{"ast":null,"code":"/**\n * @fileoverview Main API Class\n * @author Kai Cataldo\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nrequire(\"core-js/modules/es.array.push.js\");\nconst path = require(\"path\");\nconst fs = require(\"fs\");\nconst {\n  promisify\n} = require(\"util\");\nconst {\n  CLIEngine,\n  getCLIEngineInternalSlots\n} = require(\"../cli-engine/cli-engine\");\nconst BuiltinRules = require(\"../rules\");\nconst {\n  Legacy: {\n    ConfigOps: {\n      getRuleSeverity\n    }\n  }\n} = require(\"@eslint/eslintrc\");\nconst {\n  version\n} = require(\"../../package.json\");\n\n//------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/** @typedef {import(\"../cli-engine/cli-engine\").LintReport} CLIEngineLintReport */\n/** @typedef {import(\"../shared/types\").DeprecatedRuleInfo} DeprecatedRuleInfo */\n/** @typedef {import(\"../shared/types\").ConfigData} ConfigData */\n/** @typedef {import(\"../shared/types\").LintMessage} LintMessage */\n/** @typedef {import(\"../shared/types\").Plugin} Plugin */\n/** @typedef {import(\"../shared/types\").Rule} Rule */\n/** @typedef {import(\"./load-formatter\").Formatter} Formatter */\n\n/**\n * The options with which to configure the ESLint instance.\n * @typedef {Object} ESLintOptions\n * @property {boolean} [allowInlineConfig] Enable or disable inline configuration comments.\n * @property {ConfigData} [baseConfig] Base config object, extended by all configs used with this instance\n * @property {boolean} [cache] Enable result caching.\n * @property {string} [cacheLocation] The cache file to use instead of .eslintcache.\n * @property {\"metadata\" | \"content\"} [cacheStrategy] The strategy used to detect changed files.\n * @property {string} [cwd] The value to use for the current working directory.\n * @property {boolean} [errorOnUnmatchedPattern] If `false` then `ESLint#lintFiles()` doesn't throw even if no target files found. Defaults to `true`.\n * @property {string[]} [extensions] An array of file extensions to check.\n * @property {boolean|Function} [fix] Execute in autofix mode. If a function, should return a boolean.\n * @property {string[]} [fixTypes] Array of rule types to apply fixes for.\n * @property {boolean} [globInputPaths] Set to false to skip glob resolution of input file paths to lint (default: true). If false, each input file paths is assumed to be a non-glob path to an existing file.\n * @property {boolean} [ignore] False disables use of .eslintignore.\n * @property {string} [ignorePath] The ignore file to use instead of .eslintignore.\n * @property {ConfigData} [overrideConfig] Override config object, overrides all configs used with this instance\n * @property {string} [overrideConfigFile] The configuration file to use.\n * @property {Record<string,Plugin>} [plugins] An array of plugin implementations.\n * @property {\"error\" | \"warn\" | \"off\"} [reportUnusedDisableDirectives] the severity to report unused eslint-disable directives.\n * @property {string} [resolvePluginsRelativeTo] The folder where plugins should be resolved from, defaulting to the CWD.\n * @property {string[]} [rulePaths] An array of directories to load custom rules from.\n * @property {boolean} [useEslintrc] False disables looking for .eslintrc.* files.\n */\n\n/**\n * A rules metadata object.\n * @typedef {Object} RulesMeta\n * @property {string} id The plugin ID.\n * @property {Object} definition The plugin definition.\n */\n\n/**\n * A linting result.\n * @typedef {Object} LintResult\n * @property {string} filePath The path to the file that was linted.\n * @property {LintMessage[]} messages All of the messages for the result.\n * @property {number} errorCount Number of errors for the result.\n * @property {number} warningCount Number of warnings for the result.\n * @property {number} fixableErrorCount Number of fixable errors for the result.\n * @property {number} fixableWarningCount Number of fixable warnings for the result.\n * @property {string} [source] The source code of the file that was linted.\n * @property {string} [output] The source code of the file that was linted, with as many fixes applied as possible.\n * @property {DeprecatedRuleInfo[]} usedDeprecatedRules The list of used deprecated rules.\n */\n\n/**\n * Private members for the `ESLint` instance.\n * @typedef {Object} ESLintPrivateMembers\n * @property {CLIEngine} cliEngine The wrapped CLIEngine instance.\n * @property {ESLintOptions} options The options used to instantiate the ESLint instance.\n */\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst writeFile = promisify(fs.writeFile);\n\n/**\n * The map with which to store private class members.\n * @type {WeakMap<ESLint, ESLintPrivateMembers>}\n */\nconst privateMembersMap = new WeakMap();\n\n/**\n * Check if a given value is a non-empty string or not.\n * @param {any} x The value to check.\n * @returns {boolean} `true` if `x` is a non-empty string.\n */\nfunction isNonEmptyString(x) {\n  return typeof x === \"string\" && x.trim() !== \"\";\n}\n\n/**\n * Check if a given value is an array of non-empty stringss or not.\n * @param {any} x The value to check.\n * @returns {boolean} `true` if `x` is an array of non-empty stringss.\n */\nfunction isArrayOfNonEmptyString(x) {\n  return Array.isArray(x) && x.every(isNonEmptyString);\n}\n\n/**\n * Check if a given value is a valid fix type or not.\n * @param {any} x The value to check.\n * @returns {boolean} `true` if `x` is valid fix type.\n */\nfunction isFixType(x) {\n  return x === \"problem\" || x === \"suggestion\" || x === \"layout\";\n}\n\n/**\n * Check if a given value is an array of fix types or not.\n * @param {any} x The value to check.\n * @returns {boolean} `true` if `x` is an array of fix types.\n */\nfunction isFixTypeArray(x) {\n  return Array.isArray(x) && x.every(isFixType);\n}\n\n/**\n * The error for invalid options.\n */\nclass ESLintInvalidOptionsError extends Error {\n  constructor(messages) {\n    super(`Invalid Options:\\n- ${messages.join(\"\\n- \")}`);\n    this.code = \"ESLINT_INVALID_OPTIONS\";\n    Error.captureStackTrace(this, ESLintInvalidOptionsError);\n  }\n}\n\n/**\n * Validates and normalizes options for the wrapped CLIEngine instance.\n * @param {ESLintOptions} options The options to process.\n * @returns {ESLintOptions} The normalized options.\n */\nfunction processOptions({\n  allowInlineConfig = true,\n  // ← we cannot use `overrideConfig.noInlineConfig` instead because `allowInlineConfig` has side-effect that suppress warnings that show inline configs are ignored.\n  baseConfig = null,\n  cache = false,\n  cacheLocation = \".eslintcache\",\n  cacheStrategy = \"metadata\",\n  cwd = process.cwd(),\n  errorOnUnmatchedPattern = true,\n  extensions = null,\n  // ← should be null by default because if it's an array then it suppresses RFC20 feature.\n  fix = false,\n  fixTypes = null,\n  // ← should be null by default because if it's an array then it suppresses rules that don't have the `meta.type` property.\n  globInputPaths = true,\n  ignore = true,\n  ignorePath = null,\n  // ← should be null by default because if it's a string then it may throw ENOENT.\n  overrideConfig = null,\n  overrideConfigFile = null,\n  plugins = {},\n  reportUnusedDisableDirectives = null,\n  // ← should be null by default because if it's a string then it overrides the 'reportUnusedDisableDirectives' setting in config files. And we cannot use `overrideConfig.reportUnusedDisableDirectives` instead because we cannot configure the `error` severity with that.\n  resolvePluginsRelativeTo = null,\n  // ← should be null by default because if it's a string then it suppresses RFC47 feature.\n  rulePaths = [],\n  useEslintrc = true,\n  ...unknownOptions\n}) {\n  const errors = [];\n  const unknownOptionKeys = Object.keys(unknownOptions);\n  if (unknownOptionKeys.length >= 1) {\n    errors.push(`Unknown options: ${unknownOptionKeys.join(\", \")}`);\n    if (unknownOptionKeys.includes(\"cacheFile\")) {\n      errors.push(\"'cacheFile' has been removed. Please use the 'cacheLocation' option instead.\");\n    }\n    if (unknownOptionKeys.includes(\"configFile\")) {\n      errors.push(\"'configFile' has been removed. Please use the 'overrideConfigFile' option instead.\");\n    }\n    if (unknownOptionKeys.includes(\"envs\")) {\n      errors.push(\"'envs' has been removed. Please use the 'overrideConfig.env' option instead.\");\n    }\n    if (unknownOptionKeys.includes(\"globals\")) {\n      errors.push(\"'globals' has been removed. Please use the 'overrideConfig.globals' option instead.\");\n    }\n    if (unknownOptionKeys.includes(\"ignorePattern\")) {\n      errors.push(\"'ignorePattern' has been removed. Please use the 'overrideConfig.ignorePatterns' option instead.\");\n    }\n    if (unknownOptionKeys.includes(\"parser\")) {\n      errors.push(\"'parser' has been removed. Please use the 'overrideConfig.parser' option instead.\");\n    }\n    if (unknownOptionKeys.includes(\"parserOptions\")) {\n      errors.push(\"'parserOptions' has been removed. Please use the 'overrideConfig.parserOptions' option instead.\");\n    }\n    if (unknownOptionKeys.includes(\"rules\")) {\n      errors.push(\"'rules' has been removed. Please use the 'overrideConfig.rules' option instead.\");\n    }\n  }\n  if (typeof allowInlineConfig !== \"boolean\") {\n    errors.push(\"'allowInlineConfig' must be a boolean.\");\n  }\n  if (typeof baseConfig !== \"object\") {\n    errors.push(\"'baseConfig' must be an object or null.\");\n  }\n  if (typeof cache !== \"boolean\") {\n    errors.push(\"'cache' must be a boolean.\");\n  }\n  if (!isNonEmptyString(cacheLocation)) {\n    errors.push(\"'cacheLocation' must be a non-empty string.\");\n  }\n  if (cacheStrategy !== \"metadata\" && cacheStrategy !== \"content\") {\n    errors.push(\"'cacheStrategy' must be any of \\\"metadata\\\", \\\"content\\\".\");\n  }\n  if (!isNonEmptyString(cwd) || !path.isAbsolute(cwd)) {\n    errors.push(\"'cwd' must be an absolute path.\");\n  }\n  if (typeof errorOnUnmatchedPattern !== \"boolean\") {\n    errors.push(\"'errorOnUnmatchedPattern' must be a boolean.\");\n  }\n  if (!isArrayOfNonEmptyString(extensions) && extensions !== null) {\n    errors.push(\"'extensions' must be an array of non-empty strings or null.\");\n  }\n  if (typeof fix !== \"boolean\" && typeof fix !== \"function\") {\n    errors.push(\"'fix' must be a boolean or a function.\");\n  }\n  if (fixTypes !== null && !isFixTypeArray(fixTypes)) {\n    errors.push(\"'fixTypes' must be an array of any of \\\"problem\\\", \\\"suggestion\\\", and \\\"layout\\\".\");\n  }\n  if (typeof globInputPaths !== \"boolean\") {\n    errors.push(\"'globInputPaths' must be a boolean.\");\n  }\n  if (typeof ignore !== \"boolean\") {\n    errors.push(\"'ignore' must be a boolean.\");\n  }\n  if (!isNonEmptyString(ignorePath) && ignorePath !== null) {\n    errors.push(\"'ignorePath' must be a non-empty string or null.\");\n  }\n  if (typeof overrideConfig !== \"object\") {\n    errors.push(\"'overrideConfig' must be an object or null.\");\n  }\n  if (!isNonEmptyString(overrideConfigFile) && overrideConfigFile !== null) {\n    errors.push(\"'overrideConfigFile' must be a non-empty string or null.\");\n  }\n  if (typeof plugins !== \"object\") {\n    errors.push(\"'plugins' must be an object or null.\");\n  } else if (plugins !== null && Object.keys(plugins).includes(\"\")) {\n    errors.push(\"'plugins' must not include an empty string.\");\n  }\n  if (Array.isArray(plugins)) {\n    errors.push(\"'plugins' doesn't add plugins to configuration to load. Please use the 'overrideConfig.plugins' option instead.\");\n  }\n  if (reportUnusedDisableDirectives !== \"error\" && reportUnusedDisableDirectives !== \"warn\" && reportUnusedDisableDirectives !== \"off\" && reportUnusedDisableDirectives !== null) {\n    errors.push(\"'reportUnusedDisableDirectives' must be any of \\\"error\\\", \\\"warn\\\", \\\"off\\\", and null.\");\n  }\n  if (!isNonEmptyString(resolvePluginsRelativeTo) && resolvePluginsRelativeTo !== null) {\n    errors.push(\"'resolvePluginsRelativeTo' must be a non-empty string or null.\");\n  }\n  if (!isArrayOfNonEmptyString(rulePaths)) {\n    errors.push(\"'rulePaths' must be an array of non-empty strings.\");\n  }\n  if (typeof useEslintrc !== \"boolean\") {\n    errors.push(\"'useEslintrc' must be a boolean.\");\n  }\n  if (errors.length > 0) {\n    throw new ESLintInvalidOptionsError(errors);\n  }\n  return {\n    allowInlineConfig,\n    baseConfig,\n    cache,\n    cacheLocation,\n    cacheStrategy,\n    configFile: overrideConfigFile,\n    cwd,\n    errorOnUnmatchedPattern,\n    extensions,\n    fix,\n    fixTypes,\n    globInputPaths,\n    ignore,\n    ignorePath,\n    reportUnusedDisableDirectives,\n    resolvePluginsRelativeTo,\n    rulePaths,\n    useEslintrc\n  };\n}\n\n/**\n * Check if a value has one or more properties and that value is not undefined.\n * @param {any} obj The value to check.\n * @returns {boolean} `true` if `obj` has one or more properties that that value is not undefined.\n */\nfunction hasDefinedProperty(obj) {\n  if (typeof obj === \"object\" && obj !== null) {\n    for (const key in obj) {\n      if (typeof obj[key] !== \"undefined\") {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\n/**\n * Create rulesMeta object.\n * @param {Map<string,Rule>} rules a map of rules from which to generate the object.\n * @returns {Object} metadata for all enabled rules.\n */\nfunction createRulesMeta(rules) {\n  return Array.from(rules).reduce((retVal, [id, rule]) => {\n    retVal[id] = rule.meta;\n    return retVal;\n  }, {});\n}\n\n/** @type {WeakMap<ExtractedConfig, DeprecatedRuleInfo[]>} */\nconst usedDeprecatedRulesCache = new WeakMap();\n\n/**\n * Create used deprecated rule list.\n * @param {CLIEngine} cliEngine The CLIEngine instance.\n * @param {string} maybeFilePath The absolute path to a lint target file or `\"<text>\"`.\n * @returns {DeprecatedRuleInfo[]} The used deprecated rule list.\n */\nfunction getOrFindUsedDeprecatedRules(cliEngine, maybeFilePath) {\n  const {\n    configArrayFactory,\n    options: {\n      cwd\n    }\n  } = getCLIEngineInternalSlots(cliEngine);\n  const filePath = path.isAbsolute(maybeFilePath) ? maybeFilePath : path.join(cwd, \"__placeholder__.js\");\n  const configArray = configArrayFactory.getConfigArrayForFile(filePath);\n  const config = configArray.extractConfig(filePath);\n\n  // Most files use the same config, so cache it.\n  if (!usedDeprecatedRulesCache.has(config)) {\n    const pluginRules = configArray.pluginRules;\n    const retv = [];\n    for (const [ruleId, ruleConf] of Object.entries(config.rules)) {\n      if (getRuleSeverity(ruleConf) === 0) {\n        continue;\n      }\n      const rule = pluginRules.get(ruleId) || BuiltinRules.get(ruleId);\n      const meta = rule && rule.meta;\n      if (meta && meta.deprecated) {\n        retv.push({\n          ruleId,\n          replacedBy: meta.replacedBy || []\n        });\n      }\n    }\n    usedDeprecatedRulesCache.set(config, Object.freeze(retv));\n  }\n  return usedDeprecatedRulesCache.get(config);\n}\n\n/**\n * Processes the linting results generated by a CLIEngine linting report to\n * match the ESLint class's API.\n * @param {CLIEngine} cliEngine The CLIEngine instance.\n * @param {CLIEngineLintReport} report The CLIEngine linting report to process.\n * @returns {LintResult[]} The processed linting results.\n */\nfunction processCLIEngineLintReport(cliEngine, {\n  results\n}) {\n  const descriptor = {\n    configurable: true,\n    enumerable: true,\n    get() {\n      return getOrFindUsedDeprecatedRules(cliEngine, this.filePath);\n    }\n  };\n  for (const result of results) {\n    Object.defineProperty(result, \"usedDeprecatedRules\", descriptor);\n  }\n  return results;\n}\n\n/**\n * An Array.prototype.sort() compatible compare function to order results by their file path.\n * @param {LintResult} a The first lint result.\n * @param {LintResult} b The second lint result.\n * @returns {number} An integer representing the order in which the two results should occur.\n */\nfunction compareResultsByFilePath(a, b) {\n  if (a.filePath < b.filePath) {\n    return -1;\n  }\n  if (a.filePath > b.filePath) {\n    return 1;\n  }\n  return 0;\n}\nclass ESLint {\n  /**\n   * Creates a new instance of the main ESLint API.\n   * @param {ESLintOptions} options The options for this instance.\n   */\n  constructor(options = {}) {\n    const processedOptions = processOptions(options);\n    const cliEngine = new CLIEngine(processedOptions);\n    const {\n      additionalPluginPool,\n      configArrayFactory,\n      lastConfigArrays\n    } = getCLIEngineInternalSlots(cliEngine);\n    let updated = false;\n\n    /*\n     * Address `plugins` to add plugin implementations.\n     * Operate the `additionalPluginPool` internal slot directly to avoid\n     * using `addPlugin(id, plugin)` method that resets cache everytime.\n     */\n    if (options.plugins) {\n      for (const [id, plugin] of Object.entries(options.plugins)) {\n        additionalPluginPool.set(id, plugin);\n        updated = true;\n      }\n    }\n\n    /*\n     * Address `overrideConfig` to set override config.\n     * Operate the `configArrayFactory` internal slot directly because this\n     * functionality doesn't exist as the public API of CLIEngine.\n     */\n    if (hasDefinedProperty(options.overrideConfig)) {\n      configArrayFactory.setOverrideConfig(options.overrideConfig);\n      updated = true;\n    }\n\n    // Update caches.\n    if (updated) {\n      configArrayFactory.clearCache();\n      lastConfigArrays[0] = configArrayFactory.getConfigArrayForFile();\n    }\n\n    // Initialize private properties.\n    privateMembersMap.set(this, {\n      cliEngine,\n      options: processedOptions\n    });\n  }\n\n  /**\n   * The version text.\n   * @type {string}\n   */\n  static get version() {\n    return version;\n  }\n\n  /**\n   * Outputs fixes from the given results to files.\n   * @param {LintResult[]} results The lint results.\n   * @returns {Promise<void>} Returns a promise that is used to track side effects.\n   */\n  static async outputFixes(results) {\n    if (!Array.isArray(results)) {\n      throw new Error(\"'results' must be an array\");\n    }\n    await Promise.all(results.filter(result => {\n      if (typeof result !== \"object\" || result === null) {\n        throw new Error(\"'results' must include only objects\");\n      }\n      return typeof result.output === \"string\" && path.isAbsolute(result.filePath);\n    }).map(r => writeFile(r.filePath, r.output)));\n  }\n\n  /**\n   * Returns results that only contains errors.\n   * @param {LintResult[]} results The results to filter.\n   * @returns {LintResult[]} The filtered results.\n   */\n  static getErrorResults(results) {\n    return CLIEngine.getErrorResults(results);\n  }\n\n  /**\n   * Returns meta objects for each rule represented in the lint results.\n   * @param {LintResult[]} results The results to fetch rules meta for.\n   * @returns {Object} A mapping of ruleIds to rule meta objects.\n   */\n  getRulesMetaForResults(results) {\n    const resultRuleIds = new Set();\n\n    // first gather all ruleIds from all results\n\n    for (const result of results) {\n      for (const {\n        ruleId\n      } of result.messages) {\n        resultRuleIds.add(ruleId);\n      }\n    }\n\n    // create a map of all rules in the results\n\n    const {\n      cliEngine\n    } = privateMembersMap.get(this);\n    const rules = cliEngine.getRules();\n    const resultRules = new Map();\n    for (const [ruleId, rule] of rules) {\n      if (resultRuleIds.has(ruleId)) {\n        resultRules.set(ruleId, rule);\n      }\n    }\n    return createRulesMeta(resultRules);\n  }\n\n  /**\n   * Executes the current configuration on an array of file and directory names.\n   * @param {string[]} patterns An array of file and directory names.\n   * @returns {Promise<LintResult[]>} The results of linting the file patterns given.\n   */\n  async lintFiles(patterns) {\n    if (!isNonEmptyString(patterns) && !isArrayOfNonEmptyString(patterns)) {\n      throw new Error(\"'patterns' must be a non-empty string or an array of non-empty strings\");\n    }\n    const {\n      cliEngine\n    } = privateMembersMap.get(this);\n    return processCLIEngineLintReport(cliEngine, cliEngine.executeOnFiles(patterns));\n  }\n\n  /**\n   * Executes the current configuration on text.\n   * @param {string} code A string of JavaScript code to lint.\n   * @param {Object} [options] The options.\n   * @param {string} [options.filePath] The path to the file of the source code.\n   * @param {boolean} [options.warnIgnored] When set to true, warn if given filePath is an ignored path.\n   * @returns {Promise<LintResult[]>} The results of linting the string of code given.\n   */\n  async lintText(code, options = {}) {\n    if (typeof code !== \"string\") {\n      throw new Error(\"'code' must be a string\");\n    }\n    if (typeof options !== \"object\") {\n      throw new Error(\"'options' must be an object, null, or undefined\");\n    }\n    const {\n      filePath,\n      warnIgnored = false,\n      ...unknownOptions\n    } = options || {};\n    const unknownOptionKeys = Object.keys(unknownOptions);\n    if (unknownOptionKeys.length > 0) {\n      throw new Error(`'options' must not include the unknown option(s): ${unknownOptionKeys.join(\", \")}`);\n    }\n    if (filePath !== void 0 && !isNonEmptyString(filePath)) {\n      throw new Error(\"'options.filePath' must be a non-empty string or undefined\");\n    }\n    if (typeof warnIgnored !== \"boolean\") {\n      throw new Error(\"'options.warnIgnored' must be a boolean or undefined\");\n    }\n    const {\n      cliEngine\n    } = privateMembersMap.get(this);\n    return processCLIEngineLintReport(cliEngine, cliEngine.executeOnText(code, filePath, warnIgnored));\n  }\n\n  /**\n   * Returns the formatter representing the given formatter name.\n   * @param {string} [name] The name of the formatter to load.\n   * The following values are allowed:\n   * - `undefined` ... Load `stylish` builtin formatter.\n   * - A builtin formatter name ... Load the builtin formatter.\n   * - A thirdparty formatter name:\n   *   - `foo` → `eslint-formatter-foo`\n   *   - `@foo` → `@foo/eslint-formatter`\n   *   - `@foo/bar` → `@foo/eslint-formatter-bar`\n   * - A file path ... Load the file.\n   * @returns {Promise<Formatter>} A promise resolving to the formatter object.\n   * This promise will be rejected if the given formatter was not found or not\n   * a function.\n   */\n  async loadFormatter(name = \"stylish\") {\n    if (typeof name !== \"string\") {\n      throw new Error(\"'name' must be a string\");\n    }\n    const {\n      cliEngine\n    } = privateMembersMap.get(this);\n    const formatter = cliEngine.getFormatter(name);\n    if (typeof formatter !== \"function\") {\n      throw new Error(`Formatter must be a function, but got a ${typeof formatter}.`);\n    }\n    return {\n      /**\n       * The main formatter method.\n       * @param {LintResults[]} results The lint results to format.\n       * @returns {string} The formatted lint results.\n       */\n      format(results) {\n        let rulesMeta = null;\n        results.sort(compareResultsByFilePath);\n        return formatter(results, {\n          get rulesMeta() {\n            if (!rulesMeta) {\n              rulesMeta = createRulesMeta(cliEngine.getRules());\n            }\n            return rulesMeta;\n          }\n        });\n      }\n    };\n  }\n\n  /**\n   * Returns a configuration object for the given file based on the CLI options.\n   * This is the same logic used by the ESLint CLI executable to determine\n   * configuration for each file it processes.\n   * @param {string} filePath The path of the file to retrieve a config object for.\n   * @returns {Promise<ConfigData>} A configuration object for the file.\n   */\n  async calculateConfigForFile(filePath) {\n    if (!isNonEmptyString(filePath)) {\n      throw new Error(\"'filePath' must be a non-empty string\");\n    }\n    const {\n      cliEngine\n    } = privateMembersMap.get(this);\n    return cliEngine.getConfigForFile(filePath);\n  }\n\n  /**\n   * Checks if a given path is ignored by ESLint.\n   * @param {string} filePath The path of the file to check.\n   * @returns {Promise<boolean>} Whether or not the given path is ignored.\n   */\n  async isPathIgnored(filePath) {\n    if (!isNonEmptyString(filePath)) {\n      throw new Error(\"'filePath' must be a non-empty string\");\n    }\n    const {\n      cliEngine\n    } = privateMembersMap.get(this);\n    return cliEngine.isPathIgnored(filePath);\n  }\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  ESLint,\n  /**\n   * Get the private class members of a given ESLint instance for tests.\n   * @param {ESLint} instance The ESLint instance to get.\n   * @returns {ESLintPrivateMembers} The instance's private class members.\n   */\n  getESLintPrivateMembers(instance) {\n    return privateMembersMap.get(instance);\n  }\n};","map":{"version":3,"names":["require","path","fs","promisify","CLIEngine","getCLIEngineInternalSlots","BuiltinRules","Legacy","ConfigOps","getRuleSeverity","version","writeFile","privateMembersMap","WeakMap","isNonEmptyString","x","trim","isArrayOfNonEmptyString","Array","isArray","every","isFixType","isFixTypeArray","ESLintInvalidOptionsError","Error","constructor","messages","join","code","captureStackTrace","processOptions","allowInlineConfig","baseConfig","cache","cacheLocation","cacheStrategy","cwd","process","errorOnUnmatchedPattern","extensions","fix","fixTypes","globInputPaths","ignore","ignorePath","overrideConfig","overrideConfigFile","plugins","reportUnusedDisableDirectives","resolvePluginsRelativeTo","rulePaths","useEslintrc","unknownOptions","errors","unknownOptionKeys","Object","keys","length","push","includes","isAbsolute","configFile","hasDefinedProperty","obj","key","createRulesMeta","rules","from","reduce","retVal","id","rule","meta","usedDeprecatedRulesCache","getOrFindUsedDeprecatedRules","cliEngine","maybeFilePath","configArrayFactory","options","filePath","configArray","getConfigArrayForFile","config","extractConfig","has","pluginRules","retv","ruleId","ruleConf","entries","get","deprecated","replacedBy","set","freeze","processCLIEngineLintReport","results","descriptor","configurable","enumerable","result","defineProperty","compareResultsByFilePath","a","b","ESLint","processedOptions","additionalPluginPool","lastConfigArrays","updated","plugin","setOverrideConfig","clearCache","outputFixes","Promise","all","filter","output","map","r","getErrorResults","getRulesMetaForResults","resultRuleIds","Set","add","getRules","resultRules","Map","lintFiles","patterns","executeOnFiles","lintText","warnIgnored","executeOnText","loadFormatter","name","formatter","getFormatter","format","rulesMeta","sort","calculateConfigForFile","getConfigForFile","isPathIgnored","module","exports","getESLintPrivateMembers","instance"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/eslint/eslint.js"],"sourcesContent":["/**\n * @fileoverview Main API Class\n * @author Kai Cataldo\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst path = require(\"path\");\nconst fs = require(\"fs\");\nconst { promisify } = require(\"util\");\nconst { CLIEngine, getCLIEngineInternalSlots } = require(\"../cli-engine/cli-engine\");\nconst BuiltinRules = require(\"../rules\");\nconst {\n    Legacy: {\n        ConfigOps: {\n            getRuleSeverity\n        }\n    }\n} = require(\"@eslint/eslintrc\");\nconst { version } = require(\"../../package.json\");\n\n//------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/** @typedef {import(\"../cli-engine/cli-engine\").LintReport} CLIEngineLintReport */\n/** @typedef {import(\"../shared/types\").DeprecatedRuleInfo} DeprecatedRuleInfo */\n/** @typedef {import(\"../shared/types\").ConfigData} ConfigData */\n/** @typedef {import(\"../shared/types\").LintMessage} LintMessage */\n/** @typedef {import(\"../shared/types\").Plugin} Plugin */\n/** @typedef {import(\"../shared/types\").Rule} Rule */\n/** @typedef {import(\"./load-formatter\").Formatter} Formatter */\n\n/**\n * The options with which to configure the ESLint instance.\n * @typedef {Object} ESLintOptions\n * @property {boolean} [allowInlineConfig] Enable or disable inline configuration comments.\n * @property {ConfigData} [baseConfig] Base config object, extended by all configs used with this instance\n * @property {boolean} [cache] Enable result caching.\n * @property {string} [cacheLocation] The cache file to use instead of .eslintcache.\n * @property {\"metadata\" | \"content\"} [cacheStrategy] The strategy used to detect changed files.\n * @property {string} [cwd] The value to use for the current working directory.\n * @property {boolean} [errorOnUnmatchedPattern] If `false` then `ESLint#lintFiles()` doesn't throw even if no target files found. Defaults to `true`.\n * @property {string[]} [extensions] An array of file extensions to check.\n * @property {boolean|Function} [fix] Execute in autofix mode. If a function, should return a boolean.\n * @property {string[]} [fixTypes] Array of rule types to apply fixes for.\n * @property {boolean} [globInputPaths] Set to false to skip glob resolution of input file paths to lint (default: true). If false, each input file paths is assumed to be a non-glob path to an existing file.\n * @property {boolean} [ignore] False disables use of .eslintignore.\n * @property {string} [ignorePath] The ignore file to use instead of .eslintignore.\n * @property {ConfigData} [overrideConfig] Override config object, overrides all configs used with this instance\n * @property {string} [overrideConfigFile] The configuration file to use.\n * @property {Record<string,Plugin>} [plugins] An array of plugin implementations.\n * @property {\"error\" | \"warn\" | \"off\"} [reportUnusedDisableDirectives] the severity to report unused eslint-disable directives.\n * @property {string} [resolvePluginsRelativeTo] The folder where plugins should be resolved from, defaulting to the CWD.\n * @property {string[]} [rulePaths] An array of directories to load custom rules from.\n * @property {boolean} [useEslintrc] False disables looking for .eslintrc.* files.\n */\n\n/**\n * A rules metadata object.\n * @typedef {Object} RulesMeta\n * @property {string} id The plugin ID.\n * @property {Object} definition The plugin definition.\n */\n\n/**\n * A linting result.\n * @typedef {Object} LintResult\n * @property {string} filePath The path to the file that was linted.\n * @property {LintMessage[]} messages All of the messages for the result.\n * @property {number} errorCount Number of errors for the result.\n * @property {number} warningCount Number of warnings for the result.\n * @property {number} fixableErrorCount Number of fixable errors for the result.\n * @property {number} fixableWarningCount Number of fixable warnings for the result.\n * @property {string} [source] The source code of the file that was linted.\n * @property {string} [output] The source code of the file that was linted, with as many fixes applied as possible.\n * @property {DeprecatedRuleInfo[]} usedDeprecatedRules The list of used deprecated rules.\n */\n\n/**\n * Private members for the `ESLint` instance.\n * @typedef {Object} ESLintPrivateMembers\n * @property {CLIEngine} cliEngine The wrapped CLIEngine instance.\n * @property {ESLintOptions} options The options used to instantiate the ESLint instance.\n */\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst writeFile = promisify(fs.writeFile);\n\n/**\n * The map with which to store private class members.\n * @type {WeakMap<ESLint, ESLintPrivateMembers>}\n */\nconst privateMembersMap = new WeakMap();\n\n/**\n * Check if a given value is a non-empty string or not.\n * @param {any} x The value to check.\n * @returns {boolean} `true` if `x` is a non-empty string.\n */\nfunction isNonEmptyString(x) {\n    return typeof x === \"string\" && x.trim() !== \"\";\n}\n\n/**\n * Check if a given value is an array of non-empty stringss or not.\n * @param {any} x The value to check.\n * @returns {boolean} `true` if `x` is an array of non-empty stringss.\n */\nfunction isArrayOfNonEmptyString(x) {\n    return Array.isArray(x) && x.every(isNonEmptyString);\n}\n\n/**\n * Check if a given value is a valid fix type or not.\n * @param {any} x The value to check.\n * @returns {boolean} `true` if `x` is valid fix type.\n */\nfunction isFixType(x) {\n    return x === \"problem\" || x === \"suggestion\" || x === \"layout\";\n}\n\n/**\n * Check if a given value is an array of fix types or not.\n * @param {any} x The value to check.\n * @returns {boolean} `true` if `x` is an array of fix types.\n */\nfunction isFixTypeArray(x) {\n    return Array.isArray(x) && x.every(isFixType);\n}\n\n/**\n * The error for invalid options.\n */\nclass ESLintInvalidOptionsError extends Error {\n    constructor(messages) {\n        super(`Invalid Options:\\n- ${messages.join(\"\\n- \")}`);\n        this.code = \"ESLINT_INVALID_OPTIONS\";\n        Error.captureStackTrace(this, ESLintInvalidOptionsError);\n    }\n}\n\n/**\n * Validates and normalizes options for the wrapped CLIEngine instance.\n * @param {ESLintOptions} options The options to process.\n * @returns {ESLintOptions} The normalized options.\n */\nfunction processOptions({\n    allowInlineConfig = true, // ← we cannot use `overrideConfig.noInlineConfig` instead because `allowInlineConfig` has side-effect that suppress warnings that show inline configs are ignored.\n    baseConfig = null,\n    cache = false,\n    cacheLocation = \".eslintcache\",\n    cacheStrategy = \"metadata\",\n    cwd = process.cwd(),\n    errorOnUnmatchedPattern = true,\n    extensions = null, // ← should be null by default because if it's an array then it suppresses RFC20 feature.\n    fix = false,\n    fixTypes = null, // ← should be null by default because if it's an array then it suppresses rules that don't have the `meta.type` property.\n    globInputPaths = true,\n    ignore = true,\n    ignorePath = null, // ← should be null by default because if it's a string then it may throw ENOENT.\n    overrideConfig = null,\n    overrideConfigFile = null,\n    plugins = {},\n    reportUnusedDisableDirectives = null, // ← should be null by default because if it's a string then it overrides the 'reportUnusedDisableDirectives' setting in config files. And we cannot use `overrideConfig.reportUnusedDisableDirectives` instead because we cannot configure the `error` severity with that.\n    resolvePluginsRelativeTo = null, // ← should be null by default because if it's a string then it suppresses RFC47 feature.\n    rulePaths = [],\n    useEslintrc = true,\n    ...unknownOptions\n}) {\n    const errors = [];\n    const unknownOptionKeys = Object.keys(unknownOptions);\n\n    if (unknownOptionKeys.length >= 1) {\n        errors.push(`Unknown options: ${unknownOptionKeys.join(\", \")}`);\n        if (unknownOptionKeys.includes(\"cacheFile\")) {\n            errors.push(\"'cacheFile' has been removed. Please use the 'cacheLocation' option instead.\");\n        }\n        if (unknownOptionKeys.includes(\"configFile\")) {\n            errors.push(\"'configFile' has been removed. Please use the 'overrideConfigFile' option instead.\");\n        }\n        if (unknownOptionKeys.includes(\"envs\")) {\n            errors.push(\"'envs' has been removed. Please use the 'overrideConfig.env' option instead.\");\n        }\n        if (unknownOptionKeys.includes(\"globals\")) {\n            errors.push(\"'globals' has been removed. Please use the 'overrideConfig.globals' option instead.\");\n        }\n        if (unknownOptionKeys.includes(\"ignorePattern\")) {\n            errors.push(\"'ignorePattern' has been removed. Please use the 'overrideConfig.ignorePatterns' option instead.\");\n        }\n        if (unknownOptionKeys.includes(\"parser\")) {\n            errors.push(\"'parser' has been removed. Please use the 'overrideConfig.parser' option instead.\");\n        }\n        if (unknownOptionKeys.includes(\"parserOptions\")) {\n            errors.push(\"'parserOptions' has been removed. Please use the 'overrideConfig.parserOptions' option instead.\");\n        }\n        if (unknownOptionKeys.includes(\"rules\")) {\n            errors.push(\"'rules' has been removed. Please use the 'overrideConfig.rules' option instead.\");\n        }\n    }\n    if (typeof allowInlineConfig !== \"boolean\") {\n        errors.push(\"'allowInlineConfig' must be a boolean.\");\n    }\n    if (typeof baseConfig !== \"object\") {\n        errors.push(\"'baseConfig' must be an object or null.\");\n    }\n    if (typeof cache !== \"boolean\") {\n        errors.push(\"'cache' must be a boolean.\");\n    }\n    if (!isNonEmptyString(cacheLocation)) {\n        errors.push(\"'cacheLocation' must be a non-empty string.\");\n    }\n    if (\n        cacheStrategy !== \"metadata\" &&\n        cacheStrategy !== \"content\"\n    ) {\n        errors.push(\"'cacheStrategy' must be any of \\\"metadata\\\", \\\"content\\\".\");\n    }\n    if (!isNonEmptyString(cwd) || !path.isAbsolute(cwd)) {\n        errors.push(\"'cwd' must be an absolute path.\");\n    }\n    if (typeof errorOnUnmatchedPattern !== \"boolean\") {\n        errors.push(\"'errorOnUnmatchedPattern' must be a boolean.\");\n    }\n    if (!isArrayOfNonEmptyString(extensions) && extensions !== null) {\n        errors.push(\"'extensions' must be an array of non-empty strings or null.\");\n    }\n    if (typeof fix !== \"boolean\" && typeof fix !== \"function\") {\n        errors.push(\"'fix' must be a boolean or a function.\");\n    }\n    if (fixTypes !== null && !isFixTypeArray(fixTypes)) {\n        errors.push(\"'fixTypes' must be an array of any of \\\"problem\\\", \\\"suggestion\\\", and \\\"layout\\\".\");\n    }\n    if (typeof globInputPaths !== \"boolean\") {\n        errors.push(\"'globInputPaths' must be a boolean.\");\n    }\n    if (typeof ignore !== \"boolean\") {\n        errors.push(\"'ignore' must be a boolean.\");\n    }\n    if (!isNonEmptyString(ignorePath) && ignorePath !== null) {\n        errors.push(\"'ignorePath' must be a non-empty string or null.\");\n    }\n    if (typeof overrideConfig !== \"object\") {\n        errors.push(\"'overrideConfig' must be an object or null.\");\n    }\n    if (!isNonEmptyString(overrideConfigFile) && overrideConfigFile !== null) {\n        errors.push(\"'overrideConfigFile' must be a non-empty string or null.\");\n    }\n    if (typeof plugins !== \"object\") {\n        errors.push(\"'plugins' must be an object or null.\");\n    } else if (plugins !== null && Object.keys(plugins).includes(\"\")) {\n        errors.push(\"'plugins' must not include an empty string.\");\n    }\n    if (Array.isArray(plugins)) {\n        errors.push(\"'plugins' doesn't add plugins to configuration to load. Please use the 'overrideConfig.plugins' option instead.\");\n    }\n    if (\n        reportUnusedDisableDirectives !== \"error\" &&\n        reportUnusedDisableDirectives !== \"warn\" &&\n        reportUnusedDisableDirectives !== \"off\" &&\n        reportUnusedDisableDirectives !== null\n    ) {\n        errors.push(\"'reportUnusedDisableDirectives' must be any of \\\"error\\\", \\\"warn\\\", \\\"off\\\", and null.\");\n    }\n    if (\n        !isNonEmptyString(resolvePluginsRelativeTo) &&\n        resolvePluginsRelativeTo !== null\n    ) {\n        errors.push(\"'resolvePluginsRelativeTo' must be a non-empty string or null.\");\n    }\n    if (!isArrayOfNonEmptyString(rulePaths)) {\n        errors.push(\"'rulePaths' must be an array of non-empty strings.\");\n    }\n    if (typeof useEslintrc !== \"boolean\") {\n        errors.push(\"'useEslintrc' must be a boolean.\");\n    }\n\n    if (errors.length > 0) {\n        throw new ESLintInvalidOptionsError(errors);\n    }\n\n    return {\n        allowInlineConfig,\n        baseConfig,\n        cache,\n        cacheLocation,\n        cacheStrategy,\n        configFile: overrideConfigFile,\n        cwd,\n        errorOnUnmatchedPattern,\n        extensions,\n        fix,\n        fixTypes,\n        globInputPaths,\n        ignore,\n        ignorePath,\n        reportUnusedDisableDirectives,\n        resolvePluginsRelativeTo,\n        rulePaths,\n        useEslintrc\n    };\n}\n\n/**\n * Check if a value has one or more properties and that value is not undefined.\n * @param {any} obj The value to check.\n * @returns {boolean} `true` if `obj` has one or more properties that that value is not undefined.\n */\nfunction hasDefinedProperty(obj) {\n    if (typeof obj === \"object\" && obj !== null) {\n        for (const key in obj) {\n            if (typeof obj[key] !== \"undefined\") {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\n/**\n * Create rulesMeta object.\n * @param {Map<string,Rule>} rules a map of rules from which to generate the object.\n * @returns {Object} metadata for all enabled rules.\n */\nfunction createRulesMeta(rules) {\n    return Array.from(rules).reduce((retVal, [id, rule]) => {\n        retVal[id] = rule.meta;\n        return retVal;\n    }, {});\n}\n\n/** @type {WeakMap<ExtractedConfig, DeprecatedRuleInfo[]>} */\nconst usedDeprecatedRulesCache = new WeakMap();\n\n/**\n * Create used deprecated rule list.\n * @param {CLIEngine} cliEngine The CLIEngine instance.\n * @param {string} maybeFilePath The absolute path to a lint target file or `\"<text>\"`.\n * @returns {DeprecatedRuleInfo[]} The used deprecated rule list.\n */\nfunction getOrFindUsedDeprecatedRules(cliEngine, maybeFilePath) {\n    const {\n        configArrayFactory,\n        options: { cwd }\n    } = getCLIEngineInternalSlots(cliEngine);\n    const filePath = path.isAbsolute(maybeFilePath)\n        ? maybeFilePath\n        : path.join(cwd, \"__placeholder__.js\");\n    const configArray = configArrayFactory.getConfigArrayForFile(filePath);\n    const config = configArray.extractConfig(filePath);\n\n    // Most files use the same config, so cache it.\n    if (!usedDeprecatedRulesCache.has(config)) {\n        const pluginRules = configArray.pluginRules;\n        const retv = [];\n\n        for (const [ruleId, ruleConf] of Object.entries(config.rules)) {\n            if (getRuleSeverity(ruleConf) === 0) {\n                continue;\n            }\n            const rule = pluginRules.get(ruleId) || BuiltinRules.get(ruleId);\n            const meta = rule && rule.meta;\n\n            if (meta && meta.deprecated) {\n                retv.push({ ruleId, replacedBy: meta.replacedBy || [] });\n            }\n        }\n\n        usedDeprecatedRulesCache.set(config, Object.freeze(retv));\n    }\n\n    return usedDeprecatedRulesCache.get(config);\n}\n\n/**\n * Processes the linting results generated by a CLIEngine linting report to\n * match the ESLint class's API.\n * @param {CLIEngine} cliEngine The CLIEngine instance.\n * @param {CLIEngineLintReport} report The CLIEngine linting report to process.\n * @returns {LintResult[]} The processed linting results.\n */\nfunction processCLIEngineLintReport(cliEngine, { results }) {\n    const descriptor = {\n        configurable: true,\n        enumerable: true,\n        get() {\n            return getOrFindUsedDeprecatedRules(cliEngine, this.filePath);\n        }\n    };\n\n    for (const result of results) {\n        Object.defineProperty(result, \"usedDeprecatedRules\", descriptor);\n    }\n\n    return results;\n}\n\n/**\n * An Array.prototype.sort() compatible compare function to order results by their file path.\n * @param {LintResult} a The first lint result.\n * @param {LintResult} b The second lint result.\n * @returns {number} An integer representing the order in which the two results should occur.\n */\nfunction compareResultsByFilePath(a, b) {\n    if (a.filePath < b.filePath) {\n        return -1;\n    }\n\n    if (a.filePath > b.filePath) {\n        return 1;\n    }\n\n    return 0;\n}\n\nclass ESLint {\n\n    /**\n     * Creates a new instance of the main ESLint API.\n     * @param {ESLintOptions} options The options for this instance.\n     */\n    constructor(options = {}) {\n        const processedOptions = processOptions(options);\n        const cliEngine = new CLIEngine(processedOptions);\n        const {\n            additionalPluginPool,\n            configArrayFactory,\n            lastConfigArrays\n        } = getCLIEngineInternalSlots(cliEngine);\n        let updated = false;\n\n        /*\n         * Address `plugins` to add plugin implementations.\n         * Operate the `additionalPluginPool` internal slot directly to avoid\n         * using `addPlugin(id, plugin)` method that resets cache everytime.\n         */\n        if (options.plugins) {\n            for (const [id, plugin] of Object.entries(options.plugins)) {\n                additionalPluginPool.set(id, plugin);\n                updated = true;\n            }\n        }\n\n        /*\n         * Address `overrideConfig` to set override config.\n         * Operate the `configArrayFactory` internal slot directly because this\n         * functionality doesn't exist as the public API of CLIEngine.\n         */\n        if (hasDefinedProperty(options.overrideConfig)) {\n            configArrayFactory.setOverrideConfig(options.overrideConfig);\n            updated = true;\n        }\n\n        // Update caches.\n        if (updated) {\n            configArrayFactory.clearCache();\n            lastConfigArrays[0] = configArrayFactory.getConfigArrayForFile();\n        }\n\n        // Initialize private properties.\n        privateMembersMap.set(this, {\n            cliEngine,\n            options: processedOptions\n        });\n    }\n\n    /**\n     * The version text.\n     * @type {string}\n     */\n    static get version() {\n        return version;\n    }\n\n    /**\n     * Outputs fixes from the given results to files.\n     * @param {LintResult[]} results The lint results.\n     * @returns {Promise<void>} Returns a promise that is used to track side effects.\n     */\n    static async outputFixes(results) {\n        if (!Array.isArray(results)) {\n            throw new Error(\"'results' must be an array\");\n        }\n\n        await Promise.all(\n            results\n                .filter(result => {\n                    if (typeof result !== \"object\" || result === null) {\n                        throw new Error(\"'results' must include only objects\");\n                    }\n                    return (\n                        typeof result.output === \"string\" &&\n                        path.isAbsolute(result.filePath)\n                    );\n                })\n                .map(r => writeFile(r.filePath, r.output))\n        );\n    }\n\n    /**\n     * Returns results that only contains errors.\n     * @param {LintResult[]} results The results to filter.\n     * @returns {LintResult[]} The filtered results.\n     */\n    static getErrorResults(results) {\n        return CLIEngine.getErrorResults(results);\n    }\n\n    /**\n     * Returns meta objects for each rule represented in the lint results.\n     * @param {LintResult[]} results The results to fetch rules meta for.\n     * @returns {Object} A mapping of ruleIds to rule meta objects.\n     */\n    getRulesMetaForResults(results) {\n\n        const resultRuleIds = new Set();\n\n        // first gather all ruleIds from all results\n\n        for (const result of results) {\n            for (const { ruleId } of result.messages) {\n                resultRuleIds.add(ruleId);\n            }\n        }\n\n        // create a map of all rules in the results\n\n        const { cliEngine } = privateMembersMap.get(this);\n        const rules = cliEngine.getRules();\n        const resultRules = new Map();\n\n        for (const [ruleId, rule] of rules) {\n            if (resultRuleIds.has(ruleId)) {\n                resultRules.set(ruleId, rule);\n            }\n        }\n\n        return createRulesMeta(resultRules);\n\n    }\n\n    /**\n     * Executes the current configuration on an array of file and directory names.\n     * @param {string[]} patterns An array of file and directory names.\n     * @returns {Promise<LintResult[]>} The results of linting the file patterns given.\n     */\n    async lintFiles(patterns) {\n        if (!isNonEmptyString(patterns) && !isArrayOfNonEmptyString(patterns)) {\n            throw new Error(\"'patterns' must be a non-empty string or an array of non-empty strings\");\n        }\n        const { cliEngine } = privateMembersMap.get(this);\n\n        return processCLIEngineLintReport(\n            cliEngine,\n            cliEngine.executeOnFiles(patterns)\n        );\n    }\n\n    /**\n     * Executes the current configuration on text.\n     * @param {string} code A string of JavaScript code to lint.\n     * @param {Object} [options] The options.\n     * @param {string} [options.filePath] The path to the file of the source code.\n     * @param {boolean} [options.warnIgnored] When set to true, warn if given filePath is an ignored path.\n     * @returns {Promise<LintResult[]>} The results of linting the string of code given.\n     */\n    async lintText(code, options = {}) {\n        if (typeof code !== \"string\") {\n            throw new Error(\"'code' must be a string\");\n        }\n        if (typeof options !== \"object\") {\n            throw new Error(\"'options' must be an object, null, or undefined\");\n        }\n        const {\n            filePath,\n            warnIgnored = false,\n            ...unknownOptions\n        } = options || {};\n\n        const unknownOptionKeys = Object.keys(unknownOptions);\n\n        if (unknownOptionKeys.length > 0) {\n            throw new Error(`'options' must not include the unknown option(s): ${unknownOptionKeys.join(\", \")}`);\n        }\n\n        if (filePath !== void 0 && !isNonEmptyString(filePath)) {\n            throw new Error(\"'options.filePath' must be a non-empty string or undefined\");\n        }\n        if (typeof warnIgnored !== \"boolean\") {\n            throw new Error(\"'options.warnIgnored' must be a boolean or undefined\");\n        }\n\n        const { cliEngine } = privateMembersMap.get(this);\n\n        return processCLIEngineLintReport(\n            cliEngine,\n            cliEngine.executeOnText(code, filePath, warnIgnored)\n        );\n    }\n\n    /**\n     * Returns the formatter representing the given formatter name.\n     * @param {string} [name] The name of the formatter to load.\n     * The following values are allowed:\n     * - `undefined` ... Load `stylish` builtin formatter.\n     * - A builtin formatter name ... Load the builtin formatter.\n     * - A thirdparty formatter name:\n     *   - `foo` → `eslint-formatter-foo`\n     *   - `@foo` → `@foo/eslint-formatter`\n     *   - `@foo/bar` → `@foo/eslint-formatter-bar`\n     * - A file path ... Load the file.\n     * @returns {Promise<Formatter>} A promise resolving to the formatter object.\n     * This promise will be rejected if the given formatter was not found or not\n     * a function.\n     */\n    async loadFormatter(name = \"stylish\") {\n        if (typeof name !== \"string\") {\n            throw new Error(\"'name' must be a string\");\n        }\n\n        const { cliEngine } = privateMembersMap.get(this);\n        const formatter = cliEngine.getFormatter(name);\n\n        if (typeof formatter !== \"function\") {\n            throw new Error(`Formatter must be a function, but got a ${typeof formatter}.`);\n        }\n\n        return {\n\n            /**\n             * The main formatter method.\n             * @param {LintResults[]} results The lint results to format.\n             * @returns {string} The formatted lint results.\n             */\n            format(results) {\n                let rulesMeta = null;\n\n                results.sort(compareResultsByFilePath);\n\n                return formatter(results, {\n                    get rulesMeta() {\n                        if (!rulesMeta) {\n                            rulesMeta = createRulesMeta(cliEngine.getRules());\n                        }\n\n                        return rulesMeta;\n                    }\n                });\n            }\n        };\n    }\n\n    /**\n     * Returns a configuration object for the given file based on the CLI options.\n     * This is the same logic used by the ESLint CLI executable to determine\n     * configuration for each file it processes.\n     * @param {string} filePath The path of the file to retrieve a config object for.\n     * @returns {Promise<ConfigData>} A configuration object for the file.\n     */\n    async calculateConfigForFile(filePath) {\n        if (!isNonEmptyString(filePath)) {\n            throw new Error(\"'filePath' must be a non-empty string\");\n        }\n        const { cliEngine } = privateMembersMap.get(this);\n\n        return cliEngine.getConfigForFile(filePath);\n    }\n\n    /**\n     * Checks if a given path is ignored by ESLint.\n     * @param {string} filePath The path of the file to check.\n     * @returns {Promise<boolean>} Whether or not the given path is ignored.\n     */\n    async isPathIgnored(filePath) {\n        if (!isNonEmptyString(filePath)) {\n            throw new Error(\"'filePath' must be a non-empty string\");\n        }\n        const { cliEngine } = privateMembersMap.get(this);\n\n        return cliEngine.isPathIgnored(filePath);\n    }\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    ESLint,\n\n    /**\n     * Get the private class members of a given ESLint instance for tests.\n     * @param {ESLint} instance The ESLint instance to get.\n     * @returns {ESLintPrivateMembers} The instance's private class members.\n     */\n    getESLintPrivateMembers(instance) {\n        return privateMembersMap.get(instance);\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}