{"ast":null,"code":"/**\n * @fileoverview A rule to ensure blank lines within blocks.\n * @author Mathias Schreck <https://github.com/lo1tuma>\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"require or disallow padding within blocks\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/padded-blocks\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      oneOf: [{\n        enum: [\"always\", \"never\"]\n      }, {\n        type: \"object\",\n        properties: {\n          blocks: {\n            enum: [\"always\", \"never\"]\n          },\n          switches: {\n            enum: [\"always\", \"never\"]\n          },\n          classes: {\n            enum: [\"always\", \"never\"]\n          }\n        },\n        additionalProperties: false,\n        minProperties: 1\n      }]\n    }, {\n      type: \"object\",\n      properties: {\n        allowSingleLineBlocks: {\n          type: \"boolean\"\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      alwaysPadBlock: \"Block must be padded by blank lines.\",\n      neverPadBlock: \"Block must not be padded by blank lines.\"\n    }\n  },\n  create(context) {\n    const options = {};\n    const typeOptions = context.options[0] || \"always\";\n    const exceptOptions = context.options[1] || {};\n    if (typeof typeOptions === \"string\") {\n      const shouldHavePadding = typeOptions === \"always\";\n      options.blocks = shouldHavePadding;\n      options.switches = shouldHavePadding;\n      options.classes = shouldHavePadding;\n    } else {\n      if (Object.prototype.hasOwnProperty.call(typeOptions, \"blocks\")) {\n        options.blocks = typeOptions.blocks === \"always\";\n      }\n      if (Object.prototype.hasOwnProperty.call(typeOptions, \"switches\")) {\n        options.switches = typeOptions.switches === \"always\";\n      }\n      if (Object.prototype.hasOwnProperty.call(typeOptions, \"classes\")) {\n        options.classes = typeOptions.classes === \"always\";\n      }\n    }\n    if (Object.prototype.hasOwnProperty.call(exceptOptions, \"allowSingleLineBlocks\")) {\n      options.allowSingleLineBlocks = exceptOptions.allowSingleLineBlocks === true;\n    }\n    const sourceCode = context.getSourceCode();\n\n    /**\n     * Gets the open brace token from a given node.\n     * @param {ASTNode} node A BlockStatement or SwitchStatement node from which to get the open brace.\n     * @returns {Token} The token of the open brace.\n     */\n    function getOpenBrace(node) {\n      if (node.type === \"SwitchStatement\") {\n        return sourceCode.getTokenBefore(node.cases[0]);\n      }\n      return sourceCode.getFirstToken(node);\n    }\n\n    /**\n     * Checks if the given parameter is a comment node\n     * @param {ASTNode|Token} node An AST node or token\n     * @returns {boolean} True if node is a comment\n     */\n    function isComment(node) {\n      return node.type === \"Line\" || node.type === \"Block\";\n    }\n\n    /**\n     * Checks if there is padding between two tokens\n     * @param {Token} first The first token\n     * @param {Token} second The second token\n     * @returns {boolean} True if there is at least a line between the tokens\n     */\n    function isPaddingBetweenTokens(first, second) {\n      return second.loc.start.line - first.loc.end.line >= 2;\n    }\n\n    /**\n     * Checks if the given token has a blank line after it.\n     * @param {Token} token The token to check.\n     * @returns {boolean} Whether or not the token is followed by a blank line.\n     */\n    function getFirstBlockToken(token) {\n      let prev,\n        first = token;\n      do {\n        prev = first;\n        first = sourceCode.getTokenAfter(first, {\n          includeComments: true\n        });\n      } while (isComment(first) && first.loc.start.line === prev.loc.end.line);\n      return first;\n    }\n\n    /**\n     * Checks if the given token is preceded by a blank line.\n     * @param {Token} token The token to check\n     * @returns {boolean} Whether or not the token is preceded by a blank line\n     */\n    function getLastBlockToken(token) {\n      let last = token,\n        next;\n      do {\n        next = last;\n        last = sourceCode.getTokenBefore(last, {\n          includeComments: true\n        });\n      } while (isComment(last) && last.loc.end.line === next.loc.start.line);\n      return last;\n    }\n\n    /**\n     * Checks if a node should be padded, according to the rule config.\n     * @param {ASTNode} node The AST node to check.\n     * @returns {boolean} True if the node should be padded, false otherwise.\n     */\n    function requirePaddingFor(node) {\n      switch (node.type) {\n        case \"BlockStatement\":\n          return options.blocks;\n        case \"SwitchStatement\":\n          return options.switches;\n        case \"ClassBody\":\n          return options.classes;\n\n        /* istanbul ignore next */\n        default:\n          throw new Error(\"unreachable\");\n      }\n    }\n\n    /**\n     * Checks the given BlockStatement node to be padded if the block is not empty.\n     * @param {ASTNode} node The AST node of a BlockStatement.\n     * @returns {void} undefined.\n     */\n    function checkPadding(node) {\n      const openBrace = getOpenBrace(node),\n        firstBlockToken = getFirstBlockToken(openBrace),\n        tokenBeforeFirst = sourceCode.getTokenBefore(firstBlockToken, {\n          includeComments: true\n        }),\n        closeBrace = sourceCode.getLastToken(node),\n        lastBlockToken = getLastBlockToken(closeBrace),\n        tokenAfterLast = sourceCode.getTokenAfter(lastBlockToken, {\n          includeComments: true\n        }),\n        blockHasTopPadding = isPaddingBetweenTokens(tokenBeforeFirst, firstBlockToken),\n        blockHasBottomPadding = isPaddingBetweenTokens(lastBlockToken, tokenAfterLast);\n      if (options.allowSingleLineBlocks && astUtils.isTokenOnSameLine(tokenBeforeFirst, tokenAfterLast)) {\n        return;\n      }\n      if (requirePaddingFor(node)) {\n        if (!blockHasTopPadding) {\n          context.report({\n            node,\n            loc: {\n              start: tokenBeforeFirst.loc.start,\n              end: firstBlockToken.loc.start\n            },\n            fix(fixer) {\n              return fixer.insertTextAfter(tokenBeforeFirst, \"\\n\");\n            },\n            messageId: \"alwaysPadBlock\"\n          });\n        }\n        if (!blockHasBottomPadding) {\n          context.report({\n            node,\n            loc: {\n              end: tokenAfterLast.loc.start,\n              start: lastBlockToken.loc.end\n            },\n            fix(fixer) {\n              return fixer.insertTextBefore(tokenAfterLast, \"\\n\");\n            },\n            messageId: \"alwaysPadBlock\"\n          });\n        }\n      } else {\n        if (blockHasTopPadding) {\n          context.report({\n            node,\n            loc: {\n              start: tokenBeforeFirst.loc.start,\n              end: firstBlockToken.loc.start\n            },\n            fix(fixer) {\n              return fixer.replaceTextRange([tokenBeforeFirst.range[1], firstBlockToken.range[0] - firstBlockToken.loc.start.column], \"\\n\");\n            },\n            messageId: \"neverPadBlock\"\n          });\n        }\n        if (blockHasBottomPadding) {\n          context.report({\n            node,\n            loc: {\n              end: tokenAfterLast.loc.start,\n              start: lastBlockToken.loc.end\n            },\n            messageId: \"neverPadBlock\",\n            fix(fixer) {\n              return fixer.replaceTextRange([lastBlockToken.range[1], tokenAfterLast.range[0] - tokenAfterLast.loc.start.column], \"\\n\");\n            }\n          });\n        }\n      }\n    }\n    const rule = {};\n    if (Object.prototype.hasOwnProperty.call(options, \"switches\")) {\n      rule.SwitchStatement = function (node) {\n        if (node.cases.length === 0) {\n          return;\n        }\n        checkPadding(node);\n      };\n    }\n    if (Object.prototype.hasOwnProperty.call(options, \"blocks\")) {\n      rule.BlockStatement = function (node) {\n        if (node.body.length === 0) {\n          return;\n        }\n        checkPadding(node);\n      };\n    }\n    if (Object.prototype.hasOwnProperty.call(options, \"classes\")) {\n      rule.ClassBody = function (node) {\n        if (node.body.length === 0) {\n          return;\n        }\n        checkPadding(node);\n      };\n    }\n    return rule;\n  }\n};","map":{"version":3,"names":["astUtils","require","module","exports","meta","type","docs","description","category","recommended","url","fixable","schema","oneOf","enum","properties","blocks","switches","classes","additionalProperties","minProperties","allowSingleLineBlocks","messages","alwaysPadBlock","neverPadBlock","create","context","options","typeOptions","exceptOptions","shouldHavePadding","Object","prototype","hasOwnProperty","call","sourceCode","getSourceCode","getOpenBrace","node","getTokenBefore","cases","getFirstToken","isComment","isPaddingBetweenTokens","first","second","loc","start","line","end","getFirstBlockToken","token","prev","getTokenAfter","includeComments","getLastBlockToken","last","next","requirePaddingFor","Error","checkPadding","openBrace","firstBlockToken","tokenBeforeFirst","closeBrace","getLastToken","lastBlockToken","tokenAfterLast","blockHasTopPadding","blockHasBottomPadding","isTokenOnSameLine","report","fix","fixer","insertTextAfter","messageId","insertTextBefore","replaceTextRange","range","column","rule","SwitchStatement","length","BlockStatement","body","ClassBody"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/padded-blocks.js"],"sourcesContent":["/**\n * @fileoverview A rule to ensure blank lines within blocks.\n * @author Mathias Schreck <https://github.com/lo1tuma>\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"require or disallow padding within blocks\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/padded-blocks\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"always\", \"never\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            blocks: {\n                                enum: [\"always\", \"never\"]\n                            },\n                            switches: {\n                                enum: [\"always\", \"never\"]\n                            },\n                            classes: {\n                                enum: [\"always\", \"never\"]\n                            }\n                        },\n                        additionalProperties: false,\n                        minProperties: 1\n                    }\n                ]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    allowSingleLineBlocks: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            alwaysPadBlock: \"Block must be padded by blank lines.\",\n            neverPadBlock: \"Block must not be padded by blank lines.\"\n        }\n    },\n\n    create(context) {\n        const options = {};\n        const typeOptions = context.options[0] || \"always\";\n        const exceptOptions = context.options[1] || {};\n\n        if (typeof typeOptions === \"string\") {\n            const shouldHavePadding = typeOptions === \"always\";\n\n            options.blocks = shouldHavePadding;\n            options.switches = shouldHavePadding;\n            options.classes = shouldHavePadding;\n        } else {\n            if (Object.prototype.hasOwnProperty.call(typeOptions, \"blocks\")) {\n                options.blocks = typeOptions.blocks === \"always\";\n            }\n            if (Object.prototype.hasOwnProperty.call(typeOptions, \"switches\")) {\n                options.switches = typeOptions.switches === \"always\";\n            }\n            if (Object.prototype.hasOwnProperty.call(typeOptions, \"classes\")) {\n                options.classes = typeOptions.classes === \"always\";\n            }\n        }\n\n        if (Object.prototype.hasOwnProperty.call(exceptOptions, \"allowSingleLineBlocks\")) {\n            options.allowSingleLineBlocks = exceptOptions.allowSingleLineBlocks === true;\n        }\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Gets the open brace token from a given node.\n         * @param {ASTNode} node A BlockStatement or SwitchStatement node from which to get the open brace.\n         * @returns {Token} The token of the open brace.\n         */\n        function getOpenBrace(node) {\n            if (node.type === \"SwitchStatement\") {\n                return sourceCode.getTokenBefore(node.cases[0]);\n            }\n            return sourceCode.getFirstToken(node);\n        }\n\n        /**\n         * Checks if the given parameter is a comment node\n         * @param {ASTNode|Token} node An AST node or token\n         * @returns {boolean} True if node is a comment\n         */\n        function isComment(node) {\n            return node.type === \"Line\" || node.type === \"Block\";\n        }\n\n        /**\n         * Checks if there is padding between two tokens\n         * @param {Token} first The first token\n         * @param {Token} second The second token\n         * @returns {boolean} True if there is at least a line between the tokens\n         */\n        function isPaddingBetweenTokens(first, second) {\n            return second.loc.start.line - first.loc.end.line >= 2;\n        }\n\n\n        /**\n         * Checks if the given token has a blank line after it.\n         * @param {Token} token The token to check.\n         * @returns {boolean} Whether or not the token is followed by a blank line.\n         */\n        function getFirstBlockToken(token) {\n            let prev,\n                first = token;\n\n            do {\n                prev = first;\n                first = sourceCode.getTokenAfter(first, { includeComments: true });\n            } while (isComment(first) && first.loc.start.line === prev.loc.end.line);\n\n            return first;\n        }\n\n        /**\n         * Checks if the given token is preceded by a blank line.\n         * @param {Token} token The token to check\n         * @returns {boolean} Whether or not the token is preceded by a blank line\n         */\n        function getLastBlockToken(token) {\n            let last = token,\n                next;\n\n            do {\n                next = last;\n                last = sourceCode.getTokenBefore(last, { includeComments: true });\n            } while (isComment(last) && last.loc.end.line === next.loc.start.line);\n\n            return last;\n        }\n\n        /**\n         * Checks if a node should be padded, according to the rule config.\n         * @param {ASTNode} node The AST node to check.\n         * @returns {boolean} True if the node should be padded, false otherwise.\n         */\n        function requirePaddingFor(node) {\n            switch (node.type) {\n                case \"BlockStatement\":\n                    return options.blocks;\n                case \"SwitchStatement\":\n                    return options.switches;\n                case \"ClassBody\":\n                    return options.classes;\n\n                /* istanbul ignore next */\n                default:\n                    throw new Error(\"unreachable\");\n            }\n        }\n\n        /**\n         * Checks the given BlockStatement node to be padded if the block is not empty.\n         * @param {ASTNode} node The AST node of a BlockStatement.\n         * @returns {void} undefined.\n         */\n        function checkPadding(node) {\n            const openBrace = getOpenBrace(node),\n                firstBlockToken = getFirstBlockToken(openBrace),\n                tokenBeforeFirst = sourceCode.getTokenBefore(firstBlockToken, { includeComments: true }),\n                closeBrace = sourceCode.getLastToken(node),\n                lastBlockToken = getLastBlockToken(closeBrace),\n                tokenAfterLast = sourceCode.getTokenAfter(lastBlockToken, { includeComments: true }),\n                blockHasTopPadding = isPaddingBetweenTokens(tokenBeforeFirst, firstBlockToken),\n                blockHasBottomPadding = isPaddingBetweenTokens(lastBlockToken, tokenAfterLast);\n\n            if (options.allowSingleLineBlocks && astUtils.isTokenOnSameLine(tokenBeforeFirst, tokenAfterLast)) {\n                return;\n            }\n\n            if (requirePaddingFor(node)) {\n\n                if (!blockHasTopPadding) {\n                    context.report({\n                        node,\n                        loc: {\n                            start: tokenBeforeFirst.loc.start,\n                            end: firstBlockToken.loc.start\n                        },\n                        fix(fixer) {\n                            return fixer.insertTextAfter(tokenBeforeFirst, \"\\n\");\n                        },\n                        messageId: \"alwaysPadBlock\"\n                    });\n                }\n                if (!blockHasBottomPadding) {\n                    context.report({\n                        node,\n                        loc: {\n                            end: tokenAfterLast.loc.start,\n                            start: lastBlockToken.loc.end\n                        },\n                        fix(fixer) {\n                            return fixer.insertTextBefore(tokenAfterLast, \"\\n\");\n                        },\n                        messageId: \"alwaysPadBlock\"\n                    });\n                }\n            } else {\n                if (blockHasTopPadding) {\n\n                    context.report({\n                        node,\n                        loc: {\n                            start: tokenBeforeFirst.loc.start,\n                            end: firstBlockToken.loc.start\n                        },\n                        fix(fixer) {\n                            return fixer.replaceTextRange([tokenBeforeFirst.range[1], firstBlockToken.range[0] - firstBlockToken.loc.start.column], \"\\n\");\n                        },\n                        messageId: \"neverPadBlock\"\n                    });\n                }\n\n                if (blockHasBottomPadding) {\n\n                    context.report({\n                        node,\n                        loc: {\n                            end: tokenAfterLast.loc.start,\n                            start: lastBlockToken.loc.end\n                        },\n                        messageId: \"neverPadBlock\",\n                        fix(fixer) {\n                            return fixer.replaceTextRange([lastBlockToken.range[1], tokenAfterLast.range[0] - tokenAfterLast.loc.start.column], \"\\n\");\n                        }\n                    });\n                }\n            }\n        }\n\n        const rule = {};\n\n        if (Object.prototype.hasOwnProperty.call(options, \"switches\")) {\n            rule.SwitchStatement = function(node) {\n                if (node.cases.length === 0) {\n                    return;\n                }\n                checkPadding(node);\n            };\n        }\n\n        if (Object.prototype.hasOwnProperty.call(options, \"blocks\")) {\n            rule.BlockStatement = function(node) {\n                if (node.body.length === 0) {\n                    return;\n                }\n                checkPadding(node);\n            };\n        }\n\n        if (Object.prototype.hasOwnProperty.call(options, \"classes\")) {\n            rule.ClassBody = function(node) {\n                if (node.body.length === 0) {\n                    return;\n                }\n                checkPadding(node);\n            };\n        }\n\n        return rule;\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}