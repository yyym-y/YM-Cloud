{"ast":null,"code":"/**\n * @fileoverview Helpers to debug for code path analysis.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nrequire(\"core-js/modules/es.array.push.js\");\nconst debug = require(\"debug\")(\"eslint:code-path\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Gets id of a given segment.\n * @param {CodePathSegment} segment A segment to get.\n * @returns {string} Id of the segment.\n */\n/* istanbul ignore next */\nfunction getId(segment) {\n  // eslint-disable-line jsdoc/require-jsdoc\n  return segment.id + (segment.reachable ? \"\" : \"!\");\n}\n\n/**\n * Get string for the given node and operation.\n * @param {ASTNode} node The node to convert.\n * @param {\"enter\" | \"exit\" | undefined} label The operation label.\n * @returns {string} The string representation.\n */\nfunction nodeToString(node, label) {\n  const suffix = label ? `:${label}` : \"\";\n  switch (node.type) {\n    case \"Identifier\":\n      return `${node.type}${suffix} (${node.name})`;\n    case \"Literal\":\n      return `${node.type}${suffix} (${node.value})`;\n    default:\n      return `${node.type}${suffix}`;\n  }\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  /**\n   * A flag that debug dumping is enabled or not.\n   * @type {boolean}\n   */\n  enabled: debug.enabled,\n  /**\n   * Dumps given objects.\n   * @param {...any} args objects to dump.\n   * @returns {void}\n   */\n  dump: debug,\n  /**\n   * Dumps the current analyzing state.\n   * @param {ASTNode} node A node to dump.\n   * @param {CodePathState} state A state to dump.\n   * @param {boolean} leaving A flag whether or not it's leaving\n   * @returns {void}\n   */\n  dumpState: !debug.enabled ? debug : /* istanbul ignore next */function (node, state, leaving) {\n    for (let i = 0; i < state.currentSegments.length; ++i) {\n      const segInternal = state.currentSegments[i].internal;\n      if (leaving) {\n        const last = segInternal.nodes.length - 1;\n        if (last >= 0 && segInternal.nodes[last] === nodeToString(node, \"enter\")) {\n          segInternal.nodes[last] = nodeToString(node, void 0);\n        } else {\n          segInternal.nodes.push(nodeToString(node, \"exit\"));\n        }\n      } else {\n        segInternal.nodes.push(nodeToString(node, \"enter\"));\n      }\n    }\n    debug([`${state.currentSegments.map(getId).join(\",\")})`, `${node.type}${leaving ? \":exit\" : \"\"}`].join(\" \"));\n  },\n  /**\n   * Dumps a DOT code of a given code path.\n   * The DOT code can be visualized with Graphvis.\n   * @param {CodePath} codePath A code path to dump.\n   * @returns {void}\n   * @see http://www.graphviz.org\n   * @see http://www.webgraphviz.com\n   */\n  dumpDot: !debug.enabled ? debug : /* istanbul ignore next */function (codePath) {\n    let text = \"\\n\" + \"digraph {\\n\" + \"node[shape=box,style=\\\"rounded,filled\\\",fillcolor=white];\\n\" + \"initial[label=\\\"\\\",shape=circle,style=filled,fillcolor=black,width=0.25,height=0.25];\\n\";\n    if (codePath.returnedSegments.length > 0) {\n      text += \"final[label=\\\"\\\",shape=doublecircle,style=filled,fillcolor=black,width=0.25,height=0.25];\\n\";\n    }\n    if (codePath.thrownSegments.length > 0) {\n      text += \"thrown[label=\\\"✘\\\",shape=circle,width=0.3,height=0.3,fixedsize];\\n\";\n    }\n    const traceMap = Object.create(null);\n    const arrows = this.makeDotArrows(codePath, traceMap);\n    for (const id in traceMap) {\n      // eslint-disable-line guard-for-in\n      const segment = traceMap[id];\n      text += `${id}[`;\n      if (segment.reachable) {\n        text += \"label=\\\"\";\n      } else {\n        text += \"style=\\\"rounded,dashed,filled\\\",fillcolor=\\\"#FF9800\\\",label=\\\"<<unreachable>>\\\\n\";\n      }\n      if (segment.internal.nodes.length > 0) {\n        text += segment.internal.nodes.join(\"\\\\n\");\n      } else {\n        text += \"????\";\n      }\n      text += \"\\\"];\\n\";\n    }\n    text += `${arrows}\\n`;\n    text += \"}\";\n    debug(\"DOT\", text);\n  },\n  /**\n   * Makes a DOT code of a given code path.\n   * The DOT code can be visualized with Graphvis.\n   * @param {CodePath} codePath A code path to make DOT.\n   * @param {Object} traceMap Optional. A map to check whether or not segments had been done.\n   * @returns {string} A DOT code of the code path.\n   */\n  makeDotArrows(codePath, traceMap) {\n    const stack = [[codePath.initialSegment, 0]];\n    const done = traceMap || Object.create(null);\n    let lastId = codePath.initialSegment.id;\n    let text = `initial->${codePath.initialSegment.id}`;\n    while (stack.length > 0) {\n      const item = stack.pop();\n      const segment = item[0];\n      const index = item[1];\n      if (done[segment.id] && index === 0) {\n        continue;\n      }\n      done[segment.id] = segment;\n      const nextSegment = segment.allNextSegments[index];\n      if (!nextSegment) {\n        continue;\n      }\n      if (lastId === segment.id) {\n        text += `->${nextSegment.id}`;\n      } else {\n        text += `;\\n${segment.id}->${nextSegment.id}`;\n      }\n      lastId = nextSegment.id;\n      stack.unshift([segment, 1 + index]);\n      stack.push([nextSegment, 0]);\n    }\n    codePath.returnedSegments.forEach(finalSegment => {\n      if (lastId === finalSegment.id) {\n        text += \"->final\";\n      } else {\n        text += `;\\n${finalSegment.id}->final`;\n      }\n      lastId = null;\n    });\n    codePath.thrownSegments.forEach(finalSegment => {\n      if (lastId === finalSegment.id) {\n        text += \"->thrown\";\n      } else {\n        text += `;\\n${finalSegment.id}->thrown`;\n      }\n      lastId = null;\n    });\n    return `${text};`;\n  }\n};","map":{"version":3,"names":["require","debug","getId","segment","id","reachable","nodeToString","node","label","suffix","type","name","value","module","exports","enabled","dump","dumpState","state","leaving","i","currentSegments","length","segInternal","internal","last","nodes","push","map","join","dumpDot","codePath","text","returnedSegments","thrownSegments","traceMap","Object","create","arrows","makeDotArrows","stack","initialSegment","done","lastId","item","pop","index","nextSegment","allNextSegments","unshift","forEach","finalSegment"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/linter/code-path-analysis/debug-helpers.js"],"sourcesContent":["/**\n * @fileoverview Helpers to debug for code path analysis.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst debug = require(\"debug\")(\"eslint:code-path\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Gets id of a given segment.\n * @param {CodePathSegment} segment A segment to get.\n * @returns {string} Id of the segment.\n */\n/* istanbul ignore next */\nfunction getId(segment) { // eslint-disable-line jsdoc/require-jsdoc\n    return segment.id + (segment.reachable ? \"\" : \"!\");\n}\n\n/**\n * Get string for the given node and operation.\n * @param {ASTNode} node The node to convert.\n * @param {\"enter\" | \"exit\" | undefined} label The operation label.\n * @returns {string} The string representation.\n */\nfunction nodeToString(node, label) {\n    const suffix = label ? `:${label}` : \"\";\n\n    switch (node.type) {\n        case \"Identifier\": return `${node.type}${suffix} (${node.name})`;\n        case \"Literal\": return `${node.type}${suffix} (${node.value})`;\n        default: return `${node.type}${suffix}`;\n    }\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n\n    /**\n     * A flag that debug dumping is enabled or not.\n     * @type {boolean}\n     */\n    enabled: debug.enabled,\n\n    /**\n     * Dumps given objects.\n     * @param {...any} args objects to dump.\n     * @returns {void}\n     */\n    dump: debug,\n\n    /**\n     * Dumps the current analyzing state.\n     * @param {ASTNode} node A node to dump.\n     * @param {CodePathState} state A state to dump.\n     * @param {boolean} leaving A flag whether or not it's leaving\n     * @returns {void}\n     */\n    dumpState: !debug.enabled ? debug : /* istanbul ignore next */ function(node, state, leaving) {\n        for (let i = 0; i < state.currentSegments.length; ++i) {\n            const segInternal = state.currentSegments[i].internal;\n\n            if (leaving) {\n                const last = segInternal.nodes.length - 1;\n\n                if (last >= 0 && segInternal.nodes[last] === nodeToString(node, \"enter\")) {\n                    segInternal.nodes[last] = nodeToString(node, void 0);\n                } else {\n                    segInternal.nodes.push(nodeToString(node, \"exit\"));\n                }\n            } else {\n                segInternal.nodes.push(nodeToString(node, \"enter\"));\n            }\n        }\n\n        debug([\n            `${state.currentSegments.map(getId).join(\",\")})`,\n            `${node.type}${leaving ? \":exit\" : \"\"}`\n        ].join(\" \"));\n    },\n\n    /**\n     * Dumps a DOT code of a given code path.\n     * The DOT code can be visualized with Graphvis.\n     * @param {CodePath} codePath A code path to dump.\n     * @returns {void}\n     * @see http://www.graphviz.org\n     * @see http://www.webgraphviz.com\n     */\n    dumpDot: !debug.enabled ? debug : /* istanbul ignore next */ function(codePath) {\n        let text =\n            \"\\n\" +\n            \"digraph {\\n\" +\n            \"node[shape=box,style=\\\"rounded,filled\\\",fillcolor=white];\\n\" +\n            \"initial[label=\\\"\\\",shape=circle,style=filled,fillcolor=black,width=0.25,height=0.25];\\n\";\n\n        if (codePath.returnedSegments.length > 0) {\n            text += \"final[label=\\\"\\\",shape=doublecircle,style=filled,fillcolor=black,width=0.25,height=0.25];\\n\";\n        }\n        if (codePath.thrownSegments.length > 0) {\n            text += \"thrown[label=\\\"✘\\\",shape=circle,width=0.3,height=0.3,fixedsize];\\n\";\n        }\n\n        const traceMap = Object.create(null);\n        const arrows = this.makeDotArrows(codePath, traceMap);\n\n        for (const id in traceMap) { // eslint-disable-line guard-for-in\n            const segment = traceMap[id];\n\n            text += `${id}[`;\n\n            if (segment.reachable) {\n                text += \"label=\\\"\";\n            } else {\n                text += \"style=\\\"rounded,dashed,filled\\\",fillcolor=\\\"#FF9800\\\",label=\\\"<<unreachable>>\\\\n\";\n            }\n\n            if (segment.internal.nodes.length > 0) {\n                text += segment.internal.nodes.join(\"\\\\n\");\n            } else {\n                text += \"????\";\n            }\n\n            text += \"\\\"];\\n\";\n        }\n\n        text += `${arrows}\\n`;\n        text += \"}\";\n        debug(\"DOT\", text);\n    },\n\n    /**\n     * Makes a DOT code of a given code path.\n     * The DOT code can be visualized with Graphvis.\n     * @param {CodePath} codePath A code path to make DOT.\n     * @param {Object} traceMap Optional. A map to check whether or not segments had been done.\n     * @returns {string} A DOT code of the code path.\n     */\n    makeDotArrows(codePath, traceMap) {\n        const stack = [[codePath.initialSegment, 0]];\n        const done = traceMap || Object.create(null);\n        let lastId = codePath.initialSegment.id;\n        let text = `initial->${codePath.initialSegment.id}`;\n\n        while (stack.length > 0) {\n            const item = stack.pop();\n            const segment = item[0];\n            const index = item[1];\n\n            if (done[segment.id] && index === 0) {\n                continue;\n            }\n            done[segment.id] = segment;\n\n            const nextSegment = segment.allNextSegments[index];\n\n            if (!nextSegment) {\n                continue;\n            }\n\n            if (lastId === segment.id) {\n                text += `->${nextSegment.id}`;\n            } else {\n                text += `;\\n${segment.id}->${nextSegment.id}`;\n            }\n            lastId = nextSegment.id;\n\n            stack.unshift([segment, 1 + index]);\n            stack.push([nextSegment, 0]);\n        }\n\n        codePath.returnedSegments.forEach(finalSegment => {\n            if (lastId === finalSegment.id) {\n                text += \"->final\";\n            } else {\n                text += `;\\n${finalSegment.id}->final`;\n            }\n            lastId = null;\n        });\n\n        codePath.thrownSegments.forEach(finalSegment => {\n            if (lastId === finalSegment.id) {\n                text += \"->thrown\";\n            } else {\n                text += `;\\n${finalSegment.id}->thrown`;\n            }\n            lastId = null;\n        });\n\n        return `${text};`;\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}