{"ast":null,"code":"/**\n * @fileoverview `ConfigArray` class.\n *\n * `ConfigArray` class expresses the full of a configuration. It has the entry\n * config file, base config files that were extended, loaded parsers, and loaded\n * plugins.\n *\n * `ConfigArray` class provides three properties and two methods.\n *\n * - `pluginEnvironments`\n * - `pluginProcessors`\n * - `pluginRules`\n *      The `Map` objects that contain the members of all plugins that this\n *      config array contains. Those map objects don't have mutation methods.\n *      Those keys are the member ID such as `pluginId/memberName`.\n * - `isRoot()`\n *      If `true` then this configuration has `root:true` property.\n * - `extractConfig(filePath)`\n *      Extract the final configuration for a given file. This means merging\n *      every config array element which that `criteria` property matched. The\n *      `filePath` argument must be an absolute path.\n *\n * `ConfigArrayFactory` provides the loading logic of config files.\n *\n * @author Toru Nagashima <https://github.com/mysticatea>\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nrequire(\"core-js/modules/es.array.push.js\");\nconst {\n  ExtractedConfig\n} = require(\"./extracted-config\");\nconst {\n  IgnorePattern\n} = require(\"./ignore-pattern\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n// Define types for VSCode IntelliSense.\n/** @typedef {import(\"../../shared/types\").Environment} Environment */\n/** @typedef {import(\"../../shared/types\").GlobalConf} GlobalConf */\n/** @typedef {import(\"../../shared/types\").RuleConf} RuleConf */\n/** @typedef {import(\"../../shared/types\").Rule} Rule */\n/** @typedef {import(\"../../shared/types\").Plugin} Plugin */\n/** @typedef {import(\"../../shared/types\").Processor} Processor */\n/** @typedef {import(\"./config-dependency\").DependentParser} DependentParser */\n/** @typedef {import(\"./config-dependency\").DependentPlugin} DependentPlugin */\n/** @typedef {import(\"./override-tester\")[\"OverrideTester\"]} OverrideTester */\n\n/**\n * @typedef {Object} ConfigArrayElement\n * @property {string} name The name of this config element.\n * @property {string} filePath The path to the source file of this config element.\n * @property {InstanceType<OverrideTester>|null} criteria The tester for the `files` and `excludedFiles` of this config element.\n * @property {Record<string, boolean>|undefined} env The environment settings.\n * @property {Record<string, GlobalConf>|undefined} globals The global variable settings.\n * @property {IgnorePattern|undefined} ignorePattern The ignore patterns.\n * @property {boolean|undefined} noInlineConfig The flag that disables directive comments.\n * @property {DependentParser|undefined} parser The parser loader.\n * @property {Object|undefined} parserOptions The parser options.\n * @property {Record<string, DependentPlugin>|undefined} plugins The plugin loaders.\n * @property {string|undefined} processor The processor name to refer plugin's processor.\n * @property {boolean|undefined} reportUnusedDisableDirectives The flag to report unused `eslint-disable` comments.\n * @property {boolean|undefined} root The flag to express root.\n * @property {Record<string, RuleConf>|undefined} rules The rule settings\n * @property {Object|undefined} settings The shared settings.\n * @property {\"config\" | \"ignore\" | \"implicit-processor\"} type The element type.\n */\n\n/**\n * @typedef {Object} ConfigArrayInternalSlots\n * @property {Map<string, ExtractedConfig>} cache The cache to extract configs.\n * @property {ReadonlyMap<string, Environment>|null} envMap The map from environment ID to environment definition.\n * @property {ReadonlyMap<string, Processor>|null} processorMap The map from processor ID to environment definition.\n * @property {ReadonlyMap<string, Rule>|null} ruleMap The map from rule ID to rule definition.\n */\n\n/** @type {WeakMap<ConfigArray, ConfigArrayInternalSlots>} */\nconst internalSlotsMap = new class extends WeakMap {\n  get(key) {\n    let value = super.get(key);\n    if (!value) {\n      value = {\n        cache: new Map(),\n        envMap: null,\n        processorMap: null,\n        ruleMap: null\n      };\n      super.set(key, value);\n    }\n    return value;\n  }\n}();\n\n/**\n * Get the indices which are matched to a given file.\n * @param {ConfigArrayElement[]} elements The elements.\n * @param {string} filePath The path to a target file.\n * @returns {number[]} The indices.\n */\nfunction getMatchedIndices(elements, filePath) {\n  const indices = [];\n  for (let i = elements.length - 1; i >= 0; --i) {\n    const element = elements[i];\n    if (!element.criteria || filePath && element.criteria.test(filePath)) {\n      indices.push(i);\n    }\n  }\n  return indices;\n}\n\n/**\n * Check if a value is a non-null object.\n * @param {any} x The value to check.\n * @returns {boolean} `true` if the value is a non-null object.\n */\nfunction isNonNullObject(x) {\n  return typeof x === \"object\" && x !== null;\n}\n\n/**\n * Merge two objects.\n *\n * Assign every property values of `y` to `x` if `x` doesn't have the property.\n * If `x`'s property value is an object, it does recursive.\n * @param {Object} target The destination to merge\n * @param {Object|undefined} source The source to merge.\n * @returns {void}\n */\nfunction mergeWithoutOverwrite(target, source) {\n  if (!isNonNullObject(source)) {\n    return;\n  }\n  for (const key of Object.keys(source)) {\n    if (key === \"__proto__\") {\n      continue;\n    }\n    if (isNonNullObject(target[key])) {\n      mergeWithoutOverwrite(target[key], source[key]);\n    } else if (target[key] === void 0) {\n      if (isNonNullObject(source[key])) {\n        target[key] = Array.isArray(source[key]) ? [] : {};\n        mergeWithoutOverwrite(target[key], source[key]);\n      } else if (source[key] !== void 0) {\n        target[key] = source[key];\n      }\n    }\n  }\n}\n\n/**\n * The error for plugin conflicts.\n */\nclass PluginConflictError extends Error {\n  /**\n   * Initialize this error object.\n   * @param {string} pluginId The plugin ID.\n   * @param {{filePath:string, importerName:string}[]} plugins The resolved plugins.\n   */\n  constructor(pluginId, plugins) {\n    super(`Plugin \"${pluginId}\" was conflicted between ${plugins.map(p => `\"${p.importerName}\"`).join(\" and \")}.`);\n    this.messageTemplate = \"plugin-conflict\";\n    this.messageData = {\n      pluginId,\n      plugins\n    };\n  }\n}\n\n/**\n * Merge plugins.\n * `target`'s definition is prior to `source`'s.\n * @param {Record<string, DependentPlugin>} target The destination to merge\n * @param {Record<string, DependentPlugin>|undefined} source The source to merge.\n * @returns {void}\n */\nfunction mergePlugins(target, source) {\n  if (!isNonNullObject(source)) {\n    return;\n  }\n  for (const key of Object.keys(source)) {\n    if (key === \"__proto__\") {\n      continue;\n    }\n    const targetValue = target[key];\n    const sourceValue = source[key];\n\n    // Adopt the plugin which was found at first.\n    if (targetValue === void 0) {\n      if (sourceValue.error) {\n        throw sourceValue.error;\n      }\n      target[key] = sourceValue;\n    } else if (sourceValue.filePath !== targetValue.filePath) {\n      throw new PluginConflictError(key, [{\n        filePath: targetValue.filePath,\n        importerName: targetValue.importerName\n      }, {\n        filePath: sourceValue.filePath,\n        importerName: sourceValue.importerName\n      }]);\n    }\n  }\n}\n\n/**\n * Merge rule configs.\n * `target`'s definition is prior to `source`'s.\n * @param {Record<string, Array>} target The destination to merge\n * @param {Record<string, RuleConf>|undefined} source The source to merge.\n * @returns {void}\n */\nfunction mergeRuleConfigs(target, source) {\n  if (!isNonNullObject(source)) {\n    return;\n  }\n  for (const key of Object.keys(source)) {\n    if (key === \"__proto__\") {\n      continue;\n    }\n    const targetDef = target[key];\n    const sourceDef = source[key];\n\n    // Adopt the rule config which was found at first.\n    if (targetDef === void 0) {\n      if (Array.isArray(sourceDef)) {\n        target[key] = [...sourceDef];\n      } else {\n        target[key] = [sourceDef];\n      }\n\n      /*\n       * If the first found rule config is severity only and the current rule\n       * config has options, merge the severity and the options.\n       */\n    } else if (targetDef.length === 1 && Array.isArray(sourceDef) && sourceDef.length >= 2) {\n      targetDef.push(...sourceDef.slice(1));\n    }\n  }\n}\n\n/**\n * Create the extracted config.\n * @param {ConfigArray} instance The config elements.\n * @param {number[]} indices The indices to use.\n * @returns {ExtractedConfig} The extracted config.\n */\nfunction createConfig(instance, indices) {\n  const config = new ExtractedConfig();\n  const ignorePatterns = [];\n\n  // Merge elements.\n  for (const index of indices) {\n    const element = instance[index];\n\n    // Adopt the parser which was found at first.\n    if (!config.parser && element.parser) {\n      if (element.parser.error) {\n        throw element.parser.error;\n      }\n      config.parser = element.parser;\n    }\n\n    // Adopt the processor which was found at first.\n    if (!config.processor && element.processor) {\n      config.processor = element.processor;\n    }\n\n    // Adopt the noInlineConfig which was found at first.\n    if (config.noInlineConfig === void 0 && element.noInlineConfig !== void 0) {\n      config.noInlineConfig = element.noInlineConfig;\n      config.configNameOfNoInlineConfig = element.name;\n    }\n\n    // Adopt the reportUnusedDisableDirectives which was found at first.\n    if (config.reportUnusedDisableDirectives === void 0 && element.reportUnusedDisableDirectives !== void 0) {\n      config.reportUnusedDisableDirectives = element.reportUnusedDisableDirectives;\n    }\n\n    // Collect ignorePatterns\n    if (element.ignorePattern) {\n      ignorePatterns.push(element.ignorePattern);\n    }\n\n    // Merge others.\n    mergeWithoutOverwrite(config.env, element.env);\n    mergeWithoutOverwrite(config.globals, element.globals);\n    mergeWithoutOverwrite(config.parserOptions, element.parserOptions);\n    mergeWithoutOverwrite(config.settings, element.settings);\n    mergePlugins(config.plugins, element.plugins);\n    mergeRuleConfigs(config.rules, element.rules);\n  }\n\n  // Create the predicate function for ignore patterns.\n  if (ignorePatterns.length > 0) {\n    config.ignores = IgnorePattern.createIgnore(ignorePatterns.reverse());\n  }\n  return config;\n}\n\n/**\n * Collect definitions.\n * @template T, U\n * @param {string} pluginId The plugin ID for prefix.\n * @param {Record<string,T>} defs The definitions to collect.\n * @param {Map<string, U>} map The map to output.\n * @param {function(T): U} [normalize] The normalize function for each value.\n * @returns {void}\n */\nfunction collect(pluginId, defs, map, normalize) {\n  if (defs) {\n    const prefix = pluginId && `${pluginId}/`;\n    for (const [key, value] of Object.entries(defs)) {\n      map.set(`${prefix}${key}`, normalize ? normalize(value) : value);\n    }\n  }\n}\n\n/**\n * Normalize a rule definition.\n * @param {Function|Rule} rule The rule definition to normalize.\n * @returns {Rule} The normalized rule definition.\n */\nfunction normalizePluginRule(rule) {\n  return typeof rule === \"function\" ? {\n    create: rule\n  } : rule;\n}\n\n/**\n * Delete the mutation methods from a given map.\n * @param {Map<any, any>} map The map object to delete.\n * @returns {void}\n */\nfunction deleteMutationMethods(map) {\n  Object.defineProperties(map, {\n    clear: {\n      configurable: true,\n      value: void 0\n    },\n    delete: {\n      configurable: true,\n      value: void 0\n    },\n    set: {\n      configurable: true,\n      value: void 0\n    }\n  });\n}\n\n/**\n * Create `envMap`, `processorMap`, `ruleMap` with the plugins in the config array.\n * @param {ConfigArrayElement[]} elements The config elements.\n * @param {ConfigArrayInternalSlots} slots The internal slots.\n * @returns {void}\n */\nfunction initPluginMemberMaps(elements, slots) {\n  const processed = new Set();\n  slots.envMap = new Map();\n  slots.processorMap = new Map();\n  slots.ruleMap = new Map();\n  for (const element of elements) {\n    if (!element.plugins) {\n      continue;\n    }\n    for (const [pluginId, value] of Object.entries(element.plugins)) {\n      const plugin = value.definition;\n      if (!plugin || processed.has(pluginId)) {\n        continue;\n      }\n      processed.add(pluginId);\n      collect(pluginId, plugin.environments, slots.envMap);\n      collect(pluginId, plugin.processors, slots.processorMap);\n      collect(pluginId, plugin.rules, slots.ruleMap, normalizePluginRule);\n    }\n  }\n  deleteMutationMethods(slots.envMap);\n  deleteMutationMethods(slots.processorMap);\n  deleteMutationMethods(slots.ruleMap);\n}\n\n/**\n * Create `envMap`, `processorMap`, `ruleMap` with the plugins in the config array.\n * @param {ConfigArray} instance The config elements.\n * @returns {ConfigArrayInternalSlots} The extracted config.\n */\nfunction ensurePluginMemberMaps(instance) {\n  const slots = internalSlotsMap.get(instance);\n  if (!slots.ruleMap) {\n    initPluginMemberMaps(instance, slots);\n  }\n  return slots;\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * The Config Array.\n *\n * `ConfigArray` instance contains all settings, parsers, and plugins.\n * You need to call `ConfigArray#extractConfig(filePath)` method in order to\n * extract, merge and get only the config data which is related to an arbitrary\n * file.\n * @extends {Array<ConfigArrayElement>}\n */\nclass ConfigArray extends Array {\n  /**\n   * Get the plugin environments.\n   * The returned map cannot be mutated.\n   * @type {ReadonlyMap<string, Environment>} The plugin environments.\n   */\n  get pluginEnvironments() {\n    return ensurePluginMemberMaps(this).envMap;\n  }\n\n  /**\n   * Get the plugin processors.\n   * The returned map cannot be mutated.\n   * @type {ReadonlyMap<string, Processor>} The plugin processors.\n   */\n  get pluginProcessors() {\n    return ensurePluginMemberMaps(this).processorMap;\n  }\n\n  /**\n   * Get the plugin rules.\n   * The returned map cannot be mutated.\n   * @returns {ReadonlyMap<string, Rule>} The plugin rules.\n   */\n  get pluginRules() {\n    return ensurePluginMemberMaps(this).ruleMap;\n  }\n\n  /**\n   * Check if this config has `root` flag.\n   * @returns {boolean} `true` if this config array is root.\n   */\n  isRoot() {\n    for (let i = this.length - 1; i >= 0; --i) {\n      const root = this[i].root;\n      if (typeof root === \"boolean\") {\n        return root;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Extract the config data which is related to a given file.\n   * @param {string} filePath The absolute path to the target file.\n   * @returns {ExtractedConfig} The extracted config data.\n   */\n  extractConfig(filePath) {\n    const {\n      cache\n    } = internalSlotsMap.get(this);\n    const indices = getMatchedIndices(this, filePath);\n    const cacheKey = indices.join(\",\");\n    if (!cache.has(cacheKey)) {\n      cache.set(cacheKey, createConfig(this, indices));\n    }\n    return cache.get(cacheKey);\n  }\n\n  /**\n   * Check if a given path is an additional lint target.\n   * @param {string} filePath The absolute path to the target file.\n   * @returns {boolean} `true` if the file is an additional lint target.\n   */\n  isAdditionalTargetPath(filePath) {\n    for (const {\n      criteria,\n      type\n    } of this) {\n      if (type === \"config\" && criteria && !criteria.endsWithWildcard && criteria.test(filePath)) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\nconst exportObject = {\n  ConfigArray,\n  /**\n   * Get the used extracted configs.\n   * CLIEngine will use this method to collect used deprecated rules.\n   * @param {ConfigArray} instance The config array object to get.\n   * @returns {ExtractedConfig[]} The used extracted configs.\n   * @private\n   */\n  getUsedExtractedConfigs(instance) {\n    const {\n      cache\n    } = internalSlotsMap.get(instance);\n    return Array.from(cache.values());\n  }\n};\nmodule.exports = exportObject;","map":{"version":3,"names":["require","ExtractedConfig","IgnorePattern","internalSlotsMap","WeakMap","get","key","value","cache","Map","envMap","processorMap","ruleMap","set","getMatchedIndices","elements","filePath","indices","i","length","element","criteria","test","push","isNonNullObject","x","mergeWithoutOverwrite","target","source","Object","keys","Array","isArray","PluginConflictError","Error","constructor","pluginId","plugins","map","p","importerName","join","messageTemplate","messageData","mergePlugins","targetValue","sourceValue","error","mergeRuleConfigs","targetDef","sourceDef","slice","createConfig","instance","config","ignorePatterns","index","parser","processor","noInlineConfig","configNameOfNoInlineConfig","name","reportUnusedDisableDirectives","ignorePattern","env","globals","parserOptions","settings","rules","ignores","createIgnore","reverse","collect","defs","normalize","prefix","entries","normalizePluginRule","rule","create","deleteMutationMethods","defineProperties","clear","configurable","delete","initPluginMemberMaps","slots","processed","Set","plugin","definition","has","add","environments","processors","ensurePluginMemberMaps","ConfigArray","pluginEnvironments","pluginProcessors","pluginRules","isRoot","root","extractConfig","cacheKey","isAdditionalTargetPath","type","endsWithWildcard","exportObject","getUsedExtractedConfigs","from","values","module","exports"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/@eslint/eslintrc/lib/config-array/config-array.js"],"sourcesContent":["/**\n * @fileoverview `ConfigArray` class.\n *\n * `ConfigArray` class expresses the full of a configuration. It has the entry\n * config file, base config files that were extended, loaded parsers, and loaded\n * plugins.\n *\n * `ConfigArray` class provides three properties and two methods.\n *\n * - `pluginEnvironments`\n * - `pluginProcessors`\n * - `pluginRules`\n *      The `Map` objects that contain the members of all plugins that this\n *      config array contains. Those map objects don't have mutation methods.\n *      Those keys are the member ID such as `pluginId/memberName`.\n * - `isRoot()`\n *      If `true` then this configuration has `root:true` property.\n * - `extractConfig(filePath)`\n *      Extract the final configuration for a given file. This means merging\n *      every config array element which that `criteria` property matched. The\n *      `filePath` argument must be an absolute path.\n *\n * `ConfigArrayFactory` provides the loading logic of config files.\n *\n * @author Toru Nagashima <https://github.com/mysticatea>\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst { ExtractedConfig } = require(\"./extracted-config\");\nconst { IgnorePattern } = require(\"./ignore-pattern\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n// Define types for VSCode IntelliSense.\n/** @typedef {import(\"../../shared/types\").Environment} Environment */\n/** @typedef {import(\"../../shared/types\").GlobalConf} GlobalConf */\n/** @typedef {import(\"../../shared/types\").RuleConf} RuleConf */\n/** @typedef {import(\"../../shared/types\").Rule} Rule */\n/** @typedef {import(\"../../shared/types\").Plugin} Plugin */\n/** @typedef {import(\"../../shared/types\").Processor} Processor */\n/** @typedef {import(\"./config-dependency\").DependentParser} DependentParser */\n/** @typedef {import(\"./config-dependency\").DependentPlugin} DependentPlugin */\n/** @typedef {import(\"./override-tester\")[\"OverrideTester\"]} OverrideTester */\n\n/**\n * @typedef {Object} ConfigArrayElement\n * @property {string} name The name of this config element.\n * @property {string} filePath The path to the source file of this config element.\n * @property {InstanceType<OverrideTester>|null} criteria The tester for the `files` and `excludedFiles` of this config element.\n * @property {Record<string, boolean>|undefined} env The environment settings.\n * @property {Record<string, GlobalConf>|undefined} globals The global variable settings.\n * @property {IgnorePattern|undefined} ignorePattern The ignore patterns.\n * @property {boolean|undefined} noInlineConfig The flag that disables directive comments.\n * @property {DependentParser|undefined} parser The parser loader.\n * @property {Object|undefined} parserOptions The parser options.\n * @property {Record<string, DependentPlugin>|undefined} plugins The plugin loaders.\n * @property {string|undefined} processor The processor name to refer plugin's processor.\n * @property {boolean|undefined} reportUnusedDisableDirectives The flag to report unused `eslint-disable` comments.\n * @property {boolean|undefined} root The flag to express root.\n * @property {Record<string, RuleConf>|undefined} rules The rule settings\n * @property {Object|undefined} settings The shared settings.\n * @property {\"config\" | \"ignore\" | \"implicit-processor\"} type The element type.\n */\n\n/**\n * @typedef {Object} ConfigArrayInternalSlots\n * @property {Map<string, ExtractedConfig>} cache The cache to extract configs.\n * @property {ReadonlyMap<string, Environment>|null} envMap The map from environment ID to environment definition.\n * @property {ReadonlyMap<string, Processor>|null} processorMap The map from processor ID to environment definition.\n * @property {ReadonlyMap<string, Rule>|null} ruleMap The map from rule ID to rule definition.\n */\n\n/** @type {WeakMap<ConfigArray, ConfigArrayInternalSlots>} */\nconst internalSlotsMap = new class extends WeakMap {\n    get(key) {\n        let value = super.get(key);\n\n        if (!value) {\n            value = {\n                cache: new Map(),\n                envMap: null,\n                processorMap: null,\n                ruleMap: null\n            };\n            super.set(key, value);\n        }\n\n        return value;\n    }\n}();\n\n/**\n * Get the indices which are matched to a given file.\n * @param {ConfigArrayElement[]} elements The elements.\n * @param {string} filePath The path to a target file.\n * @returns {number[]} The indices.\n */\nfunction getMatchedIndices(elements, filePath) {\n    const indices = [];\n\n    for (let i = elements.length - 1; i >= 0; --i) {\n        const element = elements[i];\n\n        if (!element.criteria || (filePath && element.criteria.test(filePath))) {\n            indices.push(i);\n        }\n    }\n\n    return indices;\n}\n\n/**\n * Check if a value is a non-null object.\n * @param {any} x The value to check.\n * @returns {boolean} `true` if the value is a non-null object.\n */\nfunction isNonNullObject(x) {\n    return typeof x === \"object\" && x !== null;\n}\n\n/**\n * Merge two objects.\n *\n * Assign every property values of `y` to `x` if `x` doesn't have the property.\n * If `x`'s property value is an object, it does recursive.\n * @param {Object} target The destination to merge\n * @param {Object|undefined} source The source to merge.\n * @returns {void}\n */\nfunction mergeWithoutOverwrite(target, source) {\n    if (!isNonNullObject(source)) {\n        return;\n    }\n\n    for (const key of Object.keys(source)) {\n        if (key === \"__proto__\") {\n            continue;\n        }\n\n        if (isNonNullObject(target[key])) {\n            mergeWithoutOverwrite(target[key], source[key]);\n        } else if (target[key] === void 0) {\n            if (isNonNullObject(source[key])) {\n                target[key] = Array.isArray(source[key]) ? [] : {};\n                mergeWithoutOverwrite(target[key], source[key]);\n            } else if (source[key] !== void 0) {\n                target[key] = source[key];\n            }\n        }\n    }\n}\n\n/**\n * The error for plugin conflicts.\n */\nclass PluginConflictError extends Error {\n\n    /**\n     * Initialize this error object.\n     * @param {string} pluginId The plugin ID.\n     * @param {{filePath:string, importerName:string}[]} plugins The resolved plugins.\n     */\n    constructor(pluginId, plugins) {\n        super(`Plugin \"${pluginId}\" was conflicted between ${plugins.map(p => `\"${p.importerName}\"`).join(\" and \")}.`);\n        this.messageTemplate = \"plugin-conflict\";\n        this.messageData = { pluginId, plugins };\n    }\n}\n\n/**\n * Merge plugins.\n * `target`'s definition is prior to `source`'s.\n * @param {Record<string, DependentPlugin>} target The destination to merge\n * @param {Record<string, DependentPlugin>|undefined} source The source to merge.\n * @returns {void}\n */\nfunction mergePlugins(target, source) {\n    if (!isNonNullObject(source)) {\n        return;\n    }\n\n    for (const key of Object.keys(source)) {\n        if (key === \"__proto__\") {\n            continue;\n        }\n        const targetValue = target[key];\n        const sourceValue = source[key];\n\n        // Adopt the plugin which was found at first.\n        if (targetValue === void 0) {\n            if (sourceValue.error) {\n                throw sourceValue.error;\n            }\n            target[key] = sourceValue;\n        } else if (sourceValue.filePath !== targetValue.filePath) {\n            throw new PluginConflictError(key, [\n                {\n                    filePath: targetValue.filePath,\n                    importerName: targetValue.importerName\n                },\n                {\n                    filePath: sourceValue.filePath,\n                    importerName: sourceValue.importerName\n                }\n            ]);\n        }\n    }\n}\n\n/**\n * Merge rule configs.\n * `target`'s definition is prior to `source`'s.\n * @param {Record<string, Array>} target The destination to merge\n * @param {Record<string, RuleConf>|undefined} source The source to merge.\n * @returns {void}\n */\nfunction mergeRuleConfigs(target, source) {\n    if (!isNonNullObject(source)) {\n        return;\n    }\n\n    for (const key of Object.keys(source)) {\n        if (key === \"__proto__\") {\n            continue;\n        }\n        const targetDef = target[key];\n        const sourceDef = source[key];\n\n        // Adopt the rule config which was found at first.\n        if (targetDef === void 0) {\n            if (Array.isArray(sourceDef)) {\n                target[key] = [...sourceDef];\n            } else {\n                target[key] = [sourceDef];\n            }\n\n        /*\n         * If the first found rule config is severity only and the current rule\n         * config has options, merge the severity and the options.\n         */\n        } else if (\n            targetDef.length === 1 &&\n            Array.isArray(sourceDef) &&\n            sourceDef.length >= 2\n        ) {\n            targetDef.push(...sourceDef.slice(1));\n        }\n    }\n}\n\n/**\n * Create the extracted config.\n * @param {ConfigArray} instance The config elements.\n * @param {number[]} indices The indices to use.\n * @returns {ExtractedConfig} The extracted config.\n */\nfunction createConfig(instance, indices) {\n    const config = new ExtractedConfig();\n    const ignorePatterns = [];\n\n    // Merge elements.\n    for (const index of indices) {\n        const element = instance[index];\n\n        // Adopt the parser which was found at first.\n        if (!config.parser && element.parser) {\n            if (element.parser.error) {\n                throw element.parser.error;\n            }\n            config.parser = element.parser;\n        }\n\n        // Adopt the processor which was found at first.\n        if (!config.processor && element.processor) {\n            config.processor = element.processor;\n        }\n\n        // Adopt the noInlineConfig which was found at first.\n        if (config.noInlineConfig === void 0 && element.noInlineConfig !== void 0) {\n            config.noInlineConfig = element.noInlineConfig;\n            config.configNameOfNoInlineConfig = element.name;\n        }\n\n        // Adopt the reportUnusedDisableDirectives which was found at first.\n        if (config.reportUnusedDisableDirectives === void 0 && element.reportUnusedDisableDirectives !== void 0) {\n            config.reportUnusedDisableDirectives = element.reportUnusedDisableDirectives;\n        }\n\n        // Collect ignorePatterns\n        if (element.ignorePattern) {\n            ignorePatterns.push(element.ignorePattern);\n        }\n\n        // Merge others.\n        mergeWithoutOverwrite(config.env, element.env);\n        mergeWithoutOverwrite(config.globals, element.globals);\n        mergeWithoutOverwrite(config.parserOptions, element.parserOptions);\n        mergeWithoutOverwrite(config.settings, element.settings);\n        mergePlugins(config.plugins, element.plugins);\n        mergeRuleConfigs(config.rules, element.rules);\n    }\n\n    // Create the predicate function for ignore patterns.\n    if (ignorePatterns.length > 0) {\n        config.ignores = IgnorePattern.createIgnore(ignorePatterns.reverse());\n    }\n\n    return config;\n}\n\n/**\n * Collect definitions.\n * @template T, U\n * @param {string} pluginId The plugin ID for prefix.\n * @param {Record<string,T>} defs The definitions to collect.\n * @param {Map<string, U>} map The map to output.\n * @param {function(T): U} [normalize] The normalize function for each value.\n * @returns {void}\n */\nfunction collect(pluginId, defs, map, normalize) {\n    if (defs) {\n        const prefix = pluginId && `${pluginId}/`;\n\n        for (const [key, value] of Object.entries(defs)) {\n            map.set(\n                `${prefix}${key}`,\n                normalize ? normalize(value) : value\n            );\n        }\n    }\n}\n\n/**\n * Normalize a rule definition.\n * @param {Function|Rule} rule The rule definition to normalize.\n * @returns {Rule} The normalized rule definition.\n */\nfunction normalizePluginRule(rule) {\n    return typeof rule === \"function\" ? { create: rule } : rule;\n}\n\n/**\n * Delete the mutation methods from a given map.\n * @param {Map<any, any>} map The map object to delete.\n * @returns {void}\n */\nfunction deleteMutationMethods(map) {\n    Object.defineProperties(map, {\n        clear: { configurable: true, value: void 0 },\n        delete: { configurable: true, value: void 0 },\n        set: { configurable: true, value: void 0 }\n    });\n}\n\n/**\n * Create `envMap`, `processorMap`, `ruleMap` with the plugins in the config array.\n * @param {ConfigArrayElement[]} elements The config elements.\n * @param {ConfigArrayInternalSlots} slots The internal slots.\n * @returns {void}\n */\nfunction initPluginMemberMaps(elements, slots) {\n    const processed = new Set();\n\n    slots.envMap = new Map();\n    slots.processorMap = new Map();\n    slots.ruleMap = new Map();\n\n    for (const element of elements) {\n        if (!element.plugins) {\n            continue;\n        }\n\n        for (const [pluginId, value] of Object.entries(element.plugins)) {\n            const plugin = value.definition;\n\n            if (!plugin || processed.has(pluginId)) {\n                continue;\n            }\n            processed.add(pluginId);\n\n            collect(pluginId, plugin.environments, slots.envMap);\n            collect(pluginId, plugin.processors, slots.processorMap);\n            collect(pluginId, plugin.rules, slots.ruleMap, normalizePluginRule);\n        }\n    }\n\n    deleteMutationMethods(slots.envMap);\n    deleteMutationMethods(slots.processorMap);\n    deleteMutationMethods(slots.ruleMap);\n}\n\n/**\n * Create `envMap`, `processorMap`, `ruleMap` with the plugins in the config array.\n * @param {ConfigArray} instance The config elements.\n * @returns {ConfigArrayInternalSlots} The extracted config.\n */\nfunction ensurePluginMemberMaps(instance) {\n    const slots = internalSlotsMap.get(instance);\n\n    if (!slots.ruleMap) {\n        initPluginMemberMaps(instance, slots);\n    }\n\n    return slots;\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * The Config Array.\n *\n * `ConfigArray` instance contains all settings, parsers, and plugins.\n * You need to call `ConfigArray#extractConfig(filePath)` method in order to\n * extract, merge and get only the config data which is related to an arbitrary\n * file.\n * @extends {Array<ConfigArrayElement>}\n */\nclass ConfigArray extends Array {\n\n    /**\n     * Get the plugin environments.\n     * The returned map cannot be mutated.\n     * @type {ReadonlyMap<string, Environment>} The plugin environments.\n     */\n    get pluginEnvironments() {\n        return ensurePluginMemberMaps(this).envMap;\n    }\n\n    /**\n     * Get the plugin processors.\n     * The returned map cannot be mutated.\n     * @type {ReadonlyMap<string, Processor>} The plugin processors.\n     */\n    get pluginProcessors() {\n        return ensurePluginMemberMaps(this).processorMap;\n    }\n\n    /**\n     * Get the plugin rules.\n     * The returned map cannot be mutated.\n     * @returns {ReadonlyMap<string, Rule>} The plugin rules.\n     */\n    get pluginRules() {\n        return ensurePluginMemberMaps(this).ruleMap;\n    }\n\n    /**\n     * Check if this config has `root` flag.\n     * @returns {boolean} `true` if this config array is root.\n     */\n    isRoot() {\n        for (let i = this.length - 1; i >= 0; --i) {\n            const root = this[i].root;\n\n            if (typeof root === \"boolean\") {\n                return root;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Extract the config data which is related to a given file.\n     * @param {string} filePath The absolute path to the target file.\n     * @returns {ExtractedConfig} The extracted config data.\n     */\n    extractConfig(filePath) {\n        const { cache } = internalSlotsMap.get(this);\n        const indices = getMatchedIndices(this, filePath);\n        const cacheKey = indices.join(\",\");\n\n        if (!cache.has(cacheKey)) {\n            cache.set(cacheKey, createConfig(this, indices));\n        }\n\n        return cache.get(cacheKey);\n    }\n\n    /**\n     * Check if a given path is an additional lint target.\n     * @param {string} filePath The absolute path to the target file.\n     * @returns {boolean} `true` if the file is an additional lint target.\n     */\n    isAdditionalTargetPath(filePath) {\n        for (const { criteria, type } of this) {\n            if (\n                type === \"config\" &&\n                criteria &&\n                !criteria.endsWithWildcard &&\n                criteria.test(filePath)\n            ) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n\nconst exportObject = {\n    ConfigArray,\n\n    /**\n     * Get the used extracted configs.\n     * CLIEngine will use this method to collect used deprecated rules.\n     * @param {ConfigArray} instance The config array object to get.\n     * @returns {ExtractedConfig[]} The used extracted configs.\n     * @private\n     */\n    getUsedExtractedConfigs(instance) {\n        const { cache } = internalSlotsMap.get(instance);\n\n        return Array.from(cache.values());\n    }\n};\n\nmodule.exports = exportObject;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}