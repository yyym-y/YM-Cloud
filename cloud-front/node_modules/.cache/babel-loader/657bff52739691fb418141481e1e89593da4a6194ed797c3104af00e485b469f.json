{"ast":null,"code":"/**\n * @fileoverview Rule to flag no-unneeded-ternary\n * @author Gyandeep Singh\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n// Operators that always result in a boolean value\nconst BOOLEAN_OPERATORS = new Set([\"==\", \"===\", \"!=\", \"!==\", \">\", \">=\", \"<\", \"<=\", \"in\", \"instanceof\"]);\nconst OPERATOR_INVERSES = {\n  \"==\": \"!=\",\n  \"!=\": \"==\",\n  \"===\": \"!==\",\n  \"!==\": \"===\"\n\n  // Operators like < and >= are not true inverses, since both will return false with NaN.\n};\n\nconst OR_PRECEDENCE = astUtils.getPrecedence({\n  type: \"LogicalExpression\",\n  operator: \"||\"\n});\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow ternary operators when simpler alternatives exist\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-unneeded-ternary\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        defaultAssignment: {\n          type: \"boolean\",\n          default: true\n        }\n      },\n      additionalProperties: false\n    }],\n    fixable: \"code\",\n    messages: {\n      unnecessaryConditionalExpression: \"Unnecessary use of boolean literals in conditional expression.\",\n      unnecessaryConditionalAssignment: \"Unnecessary use of conditional expression for default assignment.\"\n    }\n  },\n  create(context) {\n    const options = context.options[0] || {};\n    const defaultAssignment = options.defaultAssignment !== false;\n    const sourceCode = context.getSourceCode();\n\n    /**\n     * Test if the node is a boolean literal\n     * @param {ASTNode} node The node to report.\n     * @returns {boolean} True if the its a boolean literal\n     * @private\n     */\n    function isBooleanLiteral(node) {\n      return node.type === \"Literal\" && typeof node.value === \"boolean\";\n    }\n\n    /**\n     * Creates an expression that represents the boolean inverse of the expression represented by the original node\n     * @param {ASTNode} node A node representing an expression\n     * @returns {string} A string representing an inverted expression\n     */\n    function invertExpression(node) {\n      if (node.type === \"BinaryExpression\" && Object.prototype.hasOwnProperty.call(OPERATOR_INVERSES, node.operator)) {\n        const operatorToken = sourceCode.getFirstTokenBetween(node.left, node.right, token => token.value === node.operator);\n        const text = sourceCode.getText();\n        return text.slice(node.range[0], operatorToken.range[0]) + OPERATOR_INVERSES[node.operator] + text.slice(operatorToken.range[1], node.range[1]);\n      }\n      if (astUtils.getPrecedence(node) < astUtils.getPrecedence({\n        type: \"UnaryExpression\"\n      })) {\n        return `!(${astUtils.getParenthesisedText(sourceCode, node)})`;\n      }\n      return `!${astUtils.getParenthesisedText(sourceCode, node)}`;\n    }\n\n    /**\n     * Tests if a given node always evaluates to a boolean value\n     * @param {ASTNode} node An expression node\n     * @returns {boolean} True if it is determined that the node will always evaluate to a boolean value\n     */\n    function isBooleanExpression(node) {\n      return node.type === \"BinaryExpression\" && BOOLEAN_OPERATORS.has(node.operator) || node.type === \"UnaryExpression\" && node.operator === \"!\";\n    }\n\n    /**\n     * Test if the node matches the pattern id ? id : expression\n     * @param {ASTNode} node The ConditionalExpression to check.\n     * @returns {boolean} True if the pattern is matched, and false otherwise\n     * @private\n     */\n    function matchesDefaultAssignment(node) {\n      return node.test.type === \"Identifier\" && node.consequent.type === \"Identifier\" && node.test.name === node.consequent.name;\n    }\n    return {\n      ConditionalExpression(node) {\n        if (isBooleanLiteral(node.alternate) && isBooleanLiteral(node.consequent)) {\n          context.report({\n            node,\n            messageId: \"unnecessaryConditionalExpression\",\n            fix(fixer) {\n              if (node.consequent.value === node.alternate.value) {\n                // Replace `foo ? true : true` with just `true`, but don't replace `foo() ? true : true`\n                return node.test.type === \"Identifier\" ? fixer.replaceText(node, node.consequent.value.toString()) : null;\n              }\n              if (node.alternate.value) {\n                // Replace `foo() ? false : true` with `!(foo())`\n                return fixer.replaceText(node, invertExpression(node.test));\n              }\n\n              // Replace `foo ? true : false` with `foo` if `foo` is guaranteed to be a boolean, or `!!foo` otherwise.\n\n              return fixer.replaceText(node, isBooleanExpression(node.test) ? astUtils.getParenthesisedText(sourceCode, node.test) : `!${invertExpression(node.test)}`);\n            }\n          });\n        } else if (!defaultAssignment && matchesDefaultAssignment(node)) {\n          context.report({\n            node,\n            messageId: \"unnecessaryConditionalAssignment\",\n            fix: fixer => {\n              const shouldParenthesizeAlternate = (astUtils.getPrecedence(node.alternate) < OR_PRECEDENCE || astUtils.isCoalesceExpression(node.alternate)) && !astUtils.isParenthesised(sourceCode, node.alternate);\n              const alternateText = shouldParenthesizeAlternate ? `(${sourceCode.getText(node.alternate)})` : astUtils.getParenthesisedText(sourceCode, node.alternate);\n              const testText = astUtils.getParenthesisedText(sourceCode, node.test);\n              return fixer.replaceText(node, `${testText} || ${alternateText}`);\n            }\n          });\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","BOOLEAN_OPERATORS","Set","OPERATOR_INVERSES","OR_PRECEDENCE","getPrecedence","type","operator","module","exports","meta","docs","description","category","recommended","url","schema","properties","defaultAssignment","default","additionalProperties","fixable","messages","unnecessaryConditionalExpression","unnecessaryConditionalAssignment","create","context","options","sourceCode","getSourceCode","isBooleanLiteral","node","value","invertExpression","Object","prototype","hasOwnProperty","call","operatorToken","getFirstTokenBetween","left","right","token","text","getText","slice","range","getParenthesisedText","isBooleanExpression","has","matchesDefaultAssignment","test","consequent","name","ConditionalExpression","alternate","report","messageId","fix","fixer","replaceText","toString","shouldParenthesizeAlternate","isCoalesceExpression","isParenthesised","alternateText","testText"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/no-unneeded-ternary.js"],"sourcesContent":["/**\n * @fileoverview Rule to flag no-unneeded-ternary\n * @author Gyandeep Singh\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n// Operators that always result in a boolean value\nconst BOOLEAN_OPERATORS = new Set([\"==\", \"===\", \"!=\", \"!==\", \">\", \">=\", \"<\", \"<=\", \"in\", \"instanceof\"]);\nconst OPERATOR_INVERSES = {\n    \"==\": \"!=\",\n    \"!=\": \"==\",\n    \"===\": \"!==\",\n    \"!==\": \"===\"\n\n    // Operators like < and >= are not true inverses, since both will return false with NaN.\n};\nconst OR_PRECEDENCE = astUtils.getPrecedence({ type: \"LogicalExpression\", operator: \"||\" });\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow ternary operators when simpler alternatives exist\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-unneeded-ternary\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    defaultAssignment: {\n                        type: \"boolean\",\n                        default: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: \"code\",\n\n        messages: {\n            unnecessaryConditionalExpression: \"Unnecessary use of boolean literals in conditional expression.\",\n            unnecessaryConditionalAssignment: \"Unnecessary use of conditional expression for default assignment.\"\n        }\n    },\n\n    create(context) {\n        const options = context.options[0] || {};\n        const defaultAssignment = options.defaultAssignment !== false;\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Test if the node is a boolean literal\n         * @param {ASTNode} node The node to report.\n         * @returns {boolean} True if the its a boolean literal\n         * @private\n         */\n        function isBooleanLiteral(node) {\n            return node.type === \"Literal\" && typeof node.value === \"boolean\";\n        }\n\n        /**\n         * Creates an expression that represents the boolean inverse of the expression represented by the original node\n         * @param {ASTNode} node A node representing an expression\n         * @returns {string} A string representing an inverted expression\n         */\n        function invertExpression(node) {\n            if (node.type === \"BinaryExpression\" && Object.prototype.hasOwnProperty.call(OPERATOR_INVERSES, node.operator)) {\n                const operatorToken = sourceCode.getFirstTokenBetween(\n                    node.left,\n                    node.right,\n                    token => token.value === node.operator\n                );\n                const text = sourceCode.getText();\n\n                return text.slice(node.range[0],\n                    operatorToken.range[0]) + OPERATOR_INVERSES[node.operator] + text.slice(operatorToken.range[1], node.range[1]);\n            }\n\n            if (astUtils.getPrecedence(node) < astUtils.getPrecedence({ type: \"UnaryExpression\" })) {\n                return `!(${astUtils.getParenthesisedText(sourceCode, node)})`;\n            }\n            return `!${astUtils.getParenthesisedText(sourceCode, node)}`;\n        }\n\n        /**\n         * Tests if a given node always evaluates to a boolean value\n         * @param {ASTNode} node An expression node\n         * @returns {boolean} True if it is determined that the node will always evaluate to a boolean value\n         */\n        function isBooleanExpression(node) {\n            return node.type === \"BinaryExpression\" && BOOLEAN_OPERATORS.has(node.operator) ||\n                node.type === \"UnaryExpression\" && node.operator === \"!\";\n        }\n\n        /**\n         * Test if the node matches the pattern id ? id : expression\n         * @param {ASTNode} node The ConditionalExpression to check.\n         * @returns {boolean} True if the pattern is matched, and false otherwise\n         * @private\n         */\n        function matchesDefaultAssignment(node) {\n            return node.test.type === \"Identifier\" &&\n                   node.consequent.type === \"Identifier\" &&\n                   node.test.name === node.consequent.name;\n        }\n\n        return {\n\n            ConditionalExpression(node) {\n                if (isBooleanLiteral(node.alternate) && isBooleanLiteral(node.consequent)) {\n                    context.report({\n                        node,\n                        messageId: \"unnecessaryConditionalExpression\",\n                        fix(fixer) {\n                            if (node.consequent.value === node.alternate.value) {\n\n                                // Replace `foo ? true : true` with just `true`, but don't replace `foo() ? true : true`\n                                return node.test.type === \"Identifier\" ? fixer.replaceText(node, node.consequent.value.toString()) : null;\n                            }\n                            if (node.alternate.value) {\n\n                                // Replace `foo() ? false : true` with `!(foo())`\n                                return fixer.replaceText(node, invertExpression(node.test));\n                            }\n\n                            // Replace `foo ? true : false` with `foo` if `foo` is guaranteed to be a boolean, or `!!foo` otherwise.\n\n                            return fixer.replaceText(node, isBooleanExpression(node.test) ? astUtils.getParenthesisedText(sourceCode, node.test) : `!${invertExpression(node.test)}`);\n                        }\n                    });\n                } else if (!defaultAssignment && matchesDefaultAssignment(node)) {\n                    context.report({\n                        node,\n                        messageId: \"unnecessaryConditionalAssignment\",\n                        fix: fixer => {\n                            const shouldParenthesizeAlternate =\n                                (\n                                    astUtils.getPrecedence(node.alternate) < OR_PRECEDENCE ||\n                                    astUtils.isCoalesceExpression(node.alternate)\n                                ) &&\n                                !astUtils.isParenthesised(sourceCode, node.alternate);\n                            const alternateText = shouldParenthesizeAlternate\n                                ? `(${sourceCode.getText(node.alternate)})`\n                                : astUtils.getParenthesisedText(sourceCode, node.alternate);\n                            const testText = astUtils.getParenthesisedText(sourceCode, node.test);\n\n                            return fixer.replaceText(node, `${testText} || ${alternateText}`);\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}