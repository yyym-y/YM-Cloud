{"ast":null,"code":"/**\n * @fileoverview A rule to verify `super()` callings in constructor.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether a given code path segment is reachable or not.\n * @param {CodePathSegment} segment A code path segment to check.\n * @returns {boolean} `true` if the segment is reachable.\n */\nrequire(\"core-js/modules/es.array.push.js\");\nfunction isReachable(segment) {\n  return segment.reachable;\n}\n\n/**\n * Checks whether or not a given node is a constructor.\n * @param {ASTNode} node A node to check. This node type is one of\n *   `Program`, `FunctionDeclaration`, `FunctionExpression`, and\n *   `ArrowFunctionExpression`.\n * @returns {boolean} `true` if the node is a constructor.\n */\nfunction isConstructorFunction(node) {\n  return node.type === \"FunctionExpression\" && node.parent.type === \"MethodDefinition\" && node.parent.kind === \"constructor\";\n}\n\n/**\n * Checks whether a given node can be a constructor or not.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node can be a constructor.\n */\nfunction isPossibleConstructor(node) {\n  if (!node) {\n    return false;\n  }\n  switch (node.type) {\n    case \"ClassExpression\":\n    case \"FunctionExpression\":\n    case \"ThisExpression\":\n    case \"MemberExpression\":\n    case \"CallExpression\":\n    case \"NewExpression\":\n    case \"ChainExpression\":\n    case \"YieldExpression\":\n    case \"TaggedTemplateExpression\":\n    case \"MetaProperty\":\n      return true;\n    case \"Identifier\":\n      return node.name !== \"undefined\";\n    case \"AssignmentExpression\":\n      if ([\"=\", \"&&=\"].includes(node.operator)) {\n        return isPossibleConstructor(node.right);\n      }\n      if ([\"||=\", \"??=\"].includes(node.operator)) {\n        return isPossibleConstructor(node.left) || isPossibleConstructor(node.right);\n      }\n\n      /**\n       * All other assignment operators are mathematical assignment operators (arithmetic or bitwise).\n       * An assignment expression with a mathematical operator can either evaluate to a primitive value,\n       * or throw, depending on the operands. Thus, it cannot evaluate to a constructor function.\n       */\n      return false;\n    case \"LogicalExpression\":\n      /*\n       * If the && operator short-circuits, the left side was falsy and therefore not a constructor, and if\n       * it doesn't short-circuit, it takes the value from the right side, so the right side must always be a\n       * possible constructor. A future improvement could verify that the left side could be truthy by\n       * excluding falsy literals.\n       */\n      if (node.operator === \"&&\") {\n        return isPossibleConstructor(node.right);\n      }\n      return isPossibleConstructor(node.left) || isPossibleConstructor(node.right);\n    case \"ConditionalExpression\":\n      return isPossibleConstructor(node.alternate) || isPossibleConstructor(node.consequent);\n    case \"SequenceExpression\":\n      {\n        const lastExpression = node.expressions[node.expressions.length - 1];\n        return isPossibleConstructor(lastExpression);\n      }\n    default:\n      return false;\n  }\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"require `super()` calls in constructors\",\n      category: \"ECMAScript 6\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/constructor-super\"\n    },\n    schema: [],\n    messages: {\n      missingSome: \"Lacked a call of 'super()' in some code paths.\",\n      missingAll: \"Expected to call 'super()'.\",\n      duplicate: \"Unexpected duplicate 'super()'.\",\n      badSuper: \"Unexpected 'super()' because 'super' is not a constructor.\",\n      unexpected: \"Unexpected 'super()'.\"\n    }\n  },\n  create(context) {\n    /*\n     * {{hasExtends: boolean, scope: Scope, codePath: CodePath}[]}\n     * Information for each constructor.\n     * - upper:      Information of the upper constructor.\n     * - hasExtends: A flag which shows whether own class has a valid `extends`\n     *               part.\n     * - scope:      The scope of own class.\n     * - codePath:   The code path object of the constructor.\n     */\n    let funcInfo = null;\n\n    /*\n     * {Map<string, {calledInSomePaths: boolean, calledInEveryPaths: boolean}>}\n     * Information for each code path segment.\n     * - calledInSomePaths:  A flag of be called `super()` in some code paths.\n     * - calledInEveryPaths: A flag of be called `super()` in all code paths.\n     * - validNodes:\n     */\n    let segInfoMap = Object.create(null);\n\n    /**\n     * Gets the flag which shows `super()` is called in some paths.\n     * @param {CodePathSegment} segment A code path segment to get.\n     * @returns {boolean} The flag which shows `super()` is called in some paths\n     */\n    function isCalledInSomePath(segment) {\n      return segment.reachable && segInfoMap[segment.id].calledInSomePaths;\n    }\n\n    /**\n     * Gets the flag which shows `super()` is called in all paths.\n     * @param {CodePathSegment} segment A code path segment to get.\n     * @returns {boolean} The flag which shows `super()` is called in all paths.\n     */\n    function isCalledInEveryPath(segment) {\n      /*\n       * If specific segment is the looped segment of the current segment,\n       * skip the segment.\n       * If not skipped, this never becomes true after a loop.\n       */\n      if (segment.nextSegments.length === 1 && segment.nextSegments[0].isLoopedPrevSegment(segment)) {\n        return true;\n      }\n      return segment.reachable && segInfoMap[segment.id].calledInEveryPaths;\n    }\n    return {\n      /**\n       * Stacks a constructor information.\n       * @param {CodePath} codePath A code path which was started.\n       * @param {ASTNode} node The current node.\n       * @returns {void}\n       */\n      onCodePathStart(codePath, node) {\n        if (isConstructorFunction(node)) {\n          // Class > ClassBody > MethodDefinition > FunctionExpression\n          const classNode = node.parent.parent.parent;\n          const superClass = classNode.superClass;\n          funcInfo = {\n            upper: funcInfo,\n            isConstructor: true,\n            hasExtends: Boolean(superClass),\n            superIsConstructor: isPossibleConstructor(superClass),\n            codePath\n          };\n        } else {\n          funcInfo = {\n            upper: funcInfo,\n            isConstructor: false,\n            hasExtends: false,\n            superIsConstructor: false,\n            codePath\n          };\n        }\n      },\n      /**\n       * Pops a constructor information.\n       * And reports if `super()` lacked.\n       * @param {CodePath} codePath A code path which was ended.\n       * @param {ASTNode} node The current node.\n       * @returns {void}\n       */\n      onCodePathEnd(codePath, node) {\n        const hasExtends = funcInfo.hasExtends;\n\n        // Pop.\n        funcInfo = funcInfo.upper;\n        if (!hasExtends) {\n          return;\n        }\n\n        // Reports if `super()` lacked.\n        const segments = codePath.returnedSegments;\n        const calledInEveryPaths = segments.every(isCalledInEveryPath);\n        const calledInSomePaths = segments.some(isCalledInSomePath);\n        if (!calledInEveryPaths) {\n          context.report({\n            messageId: calledInSomePaths ? \"missingSome\" : \"missingAll\",\n            node: node.parent\n          });\n        }\n      },\n      /**\n       * Initialize information of a given code path segment.\n       * @param {CodePathSegment} segment A code path segment to initialize.\n       * @returns {void}\n       */\n      onCodePathSegmentStart(segment) {\n        if (!(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends)) {\n          return;\n        }\n\n        // Initialize info.\n        const info = segInfoMap[segment.id] = {\n          calledInSomePaths: false,\n          calledInEveryPaths: false,\n          validNodes: []\n        };\n\n        // When there are previous segments, aggregates these.\n        const prevSegments = segment.prevSegments;\n        if (prevSegments.length > 0) {\n          info.calledInSomePaths = prevSegments.some(isCalledInSomePath);\n          info.calledInEveryPaths = prevSegments.every(isCalledInEveryPath);\n        }\n      },\n      /**\n       * Update information of the code path segment when a code path was\n       * looped.\n       * @param {CodePathSegment} fromSegment The code path segment of the\n       *      end of a loop.\n       * @param {CodePathSegment} toSegment A code path segment of the head\n       *      of a loop.\n       * @returns {void}\n       */\n      onCodePathSegmentLoop(fromSegment, toSegment) {\n        if (!(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends)) {\n          return;\n        }\n\n        // Update information inside of the loop.\n        const isRealLoop = toSegment.prevSegments.length >= 2;\n        funcInfo.codePath.traverseSegments({\n          first: toSegment,\n          last: fromSegment\n        }, segment => {\n          const info = segInfoMap[segment.id];\n          const prevSegments = segment.prevSegments;\n\n          // Updates flags.\n          info.calledInSomePaths = prevSegments.some(isCalledInSomePath);\n          info.calledInEveryPaths = prevSegments.every(isCalledInEveryPath);\n\n          // If flags become true anew, reports the valid nodes.\n          if (info.calledInSomePaths || isRealLoop) {\n            const nodes = info.validNodes;\n            info.validNodes = [];\n            for (let i = 0; i < nodes.length; ++i) {\n              const node = nodes[i];\n              context.report({\n                messageId: \"duplicate\",\n                node\n              });\n            }\n          }\n        });\n      },\n      /**\n       * Checks for a call of `super()`.\n       * @param {ASTNode} node A CallExpression node to check.\n       * @returns {void}\n       */\n      \"CallExpression:exit\"(node) {\n        if (!(funcInfo && funcInfo.isConstructor)) {\n          return;\n        }\n\n        // Skips except `super()`.\n        if (node.callee.type !== \"Super\") {\n          return;\n        }\n\n        // Reports if needed.\n        if (funcInfo.hasExtends) {\n          const segments = funcInfo.codePath.currentSegments;\n          let duplicate = false;\n          let info = null;\n          for (let i = 0; i < segments.length; ++i) {\n            const segment = segments[i];\n            if (segment.reachable) {\n              info = segInfoMap[segment.id];\n              duplicate = duplicate || info.calledInSomePaths;\n              info.calledInSomePaths = info.calledInEveryPaths = true;\n            }\n          }\n          if (info) {\n            if (duplicate) {\n              context.report({\n                messageId: \"duplicate\",\n                node\n              });\n            } else if (!funcInfo.superIsConstructor) {\n              context.report({\n                messageId: \"badSuper\",\n                node\n              });\n            } else {\n              info.validNodes.push(node);\n            }\n          }\n        } else if (funcInfo.codePath.currentSegments.some(isReachable)) {\n          context.report({\n            messageId: \"unexpected\",\n            node\n          });\n        }\n      },\n      /**\n       * Set the mark to the returned path as `super()` was called.\n       * @param {ASTNode} node A ReturnStatement node to check.\n       * @returns {void}\n       */\n      ReturnStatement(node) {\n        if (!(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends)) {\n          return;\n        }\n\n        // Skips if no argument.\n        if (!node.argument) {\n          return;\n        }\n\n        // Returning argument is a substitute of 'super()'.\n        const segments = funcInfo.codePath.currentSegments;\n        for (let i = 0; i < segments.length; ++i) {\n          const segment = segments[i];\n          if (segment.reachable) {\n            const info = segInfoMap[segment.id];\n            info.calledInSomePaths = info.calledInEveryPaths = true;\n          }\n        }\n      },\n      /**\n       * Resets state.\n       * @returns {void}\n       */\n      \"Program:exit\"() {\n        segInfoMap = Object.create(null);\n      }\n    };\n  }\n};","map":{"version":3,"names":["require","isReachable","segment","reachable","isConstructorFunction","node","type","parent","kind","isPossibleConstructor","name","includes","operator","right","left","alternate","consequent","lastExpression","expressions","length","module","exports","meta","docs","description","category","recommended","url","schema","messages","missingSome","missingAll","duplicate","badSuper","unexpected","create","context","funcInfo","segInfoMap","Object","isCalledInSomePath","id","calledInSomePaths","isCalledInEveryPath","nextSegments","isLoopedPrevSegment","calledInEveryPaths","onCodePathStart","codePath","classNode","superClass","upper","isConstructor","hasExtends","Boolean","superIsConstructor","onCodePathEnd","segments","returnedSegments","every","some","report","messageId","onCodePathSegmentStart","info","validNodes","prevSegments","onCodePathSegmentLoop","fromSegment","toSegment","isRealLoop","traverseSegments","first","last","nodes","i","CallExpression:exit","callee","currentSegments","push","ReturnStatement","argument","Program:exit"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/constructor-super.js"],"sourcesContent":["/**\n * @fileoverview A rule to verify `super()` callings in constructor.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether a given code path segment is reachable or not.\n * @param {CodePathSegment} segment A code path segment to check.\n * @returns {boolean} `true` if the segment is reachable.\n */\nfunction isReachable(segment) {\n    return segment.reachable;\n}\n\n/**\n * Checks whether or not a given node is a constructor.\n * @param {ASTNode} node A node to check. This node type is one of\n *   `Program`, `FunctionDeclaration`, `FunctionExpression`, and\n *   `ArrowFunctionExpression`.\n * @returns {boolean} `true` if the node is a constructor.\n */\nfunction isConstructorFunction(node) {\n    return (\n        node.type === \"FunctionExpression\" &&\n        node.parent.type === \"MethodDefinition\" &&\n        node.parent.kind === \"constructor\"\n    );\n}\n\n/**\n * Checks whether a given node can be a constructor or not.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node can be a constructor.\n */\nfunction isPossibleConstructor(node) {\n    if (!node) {\n        return false;\n    }\n\n    switch (node.type) {\n        case \"ClassExpression\":\n        case \"FunctionExpression\":\n        case \"ThisExpression\":\n        case \"MemberExpression\":\n        case \"CallExpression\":\n        case \"NewExpression\":\n        case \"ChainExpression\":\n        case \"YieldExpression\":\n        case \"TaggedTemplateExpression\":\n        case \"MetaProperty\":\n            return true;\n\n        case \"Identifier\":\n            return node.name !== \"undefined\";\n\n        case \"AssignmentExpression\":\n            if ([\"=\", \"&&=\"].includes(node.operator)) {\n                return isPossibleConstructor(node.right);\n            }\n\n            if ([\"||=\", \"??=\"].includes(node.operator)) {\n                return (\n                    isPossibleConstructor(node.left) ||\n                    isPossibleConstructor(node.right)\n                );\n            }\n\n            /**\n             * All other assignment operators are mathematical assignment operators (arithmetic or bitwise).\n             * An assignment expression with a mathematical operator can either evaluate to a primitive value,\n             * or throw, depending on the operands. Thus, it cannot evaluate to a constructor function.\n             */\n            return false;\n\n        case \"LogicalExpression\":\n\n            /*\n             * If the && operator short-circuits, the left side was falsy and therefore not a constructor, and if\n             * it doesn't short-circuit, it takes the value from the right side, so the right side must always be a\n             * possible constructor. A future improvement could verify that the left side could be truthy by\n             * excluding falsy literals.\n             */\n            if (node.operator === \"&&\") {\n                return isPossibleConstructor(node.right);\n            }\n\n            return (\n                isPossibleConstructor(node.left) ||\n                isPossibleConstructor(node.right)\n            );\n\n        case \"ConditionalExpression\":\n            return (\n                isPossibleConstructor(node.alternate) ||\n                isPossibleConstructor(node.consequent)\n            );\n\n        case \"SequenceExpression\": {\n            const lastExpression = node.expressions[node.expressions.length - 1];\n\n            return isPossibleConstructor(lastExpression);\n        }\n\n        default:\n            return false;\n    }\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"require `super()` calls in constructors\",\n            category: \"ECMAScript 6\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/constructor-super\"\n        },\n\n        schema: [],\n\n        messages: {\n            missingSome: \"Lacked a call of 'super()' in some code paths.\",\n            missingAll: \"Expected to call 'super()'.\",\n\n            duplicate: \"Unexpected duplicate 'super()'.\",\n            badSuper: \"Unexpected 'super()' because 'super' is not a constructor.\",\n            unexpected: \"Unexpected 'super()'.\"\n        }\n    },\n\n    create(context) {\n\n        /*\n         * {{hasExtends: boolean, scope: Scope, codePath: CodePath}[]}\n         * Information for each constructor.\n         * - upper:      Information of the upper constructor.\n         * - hasExtends: A flag which shows whether own class has a valid `extends`\n         *               part.\n         * - scope:      The scope of own class.\n         * - codePath:   The code path object of the constructor.\n         */\n        let funcInfo = null;\n\n        /*\n         * {Map<string, {calledInSomePaths: boolean, calledInEveryPaths: boolean}>}\n         * Information for each code path segment.\n         * - calledInSomePaths:  A flag of be called `super()` in some code paths.\n         * - calledInEveryPaths: A flag of be called `super()` in all code paths.\n         * - validNodes:\n         */\n        let segInfoMap = Object.create(null);\n\n        /**\n         * Gets the flag which shows `super()` is called in some paths.\n         * @param {CodePathSegment} segment A code path segment to get.\n         * @returns {boolean} The flag which shows `super()` is called in some paths\n         */\n        function isCalledInSomePath(segment) {\n            return segment.reachable && segInfoMap[segment.id].calledInSomePaths;\n        }\n\n        /**\n         * Gets the flag which shows `super()` is called in all paths.\n         * @param {CodePathSegment} segment A code path segment to get.\n         * @returns {boolean} The flag which shows `super()` is called in all paths.\n         */\n        function isCalledInEveryPath(segment) {\n\n            /*\n             * If specific segment is the looped segment of the current segment,\n             * skip the segment.\n             * If not skipped, this never becomes true after a loop.\n             */\n            if (segment.nextSegments.length === 1 &&\n                segment.nextSegments[0].isLoopedPrevSegment(segment)\n            ) {\n                return true;\n            }\n            return segment.reachable && segInfoMap[segment.id].calledInEveryPaths;\n        }\n\n        return {\n\n            /**\n             * Stacks a constructor information.\n             * @param {CodePath} codePath A code path which was started.\n             * @param {ASTNode} node The current node.\n             * @returns {void}\n             */\n            onCodePathStart(codePath, node) {\n                if (isConstructorFunction(node)) {\n\n                    // Class > ClassBody > MethodDefinition > FunctionExpression\n                    const classNode = node.parent.parent.parent;\n                    const superClass = classNode.superClass;\n\n                    funcInfo = {\n                        upper: funcInfo,\n                        isConstructor: true,\n                        hasExtends: Boolean(superClass),\n                        superIsConstructor: isPossibleConstructor(superClass),\n                        codePath\n                    };\n                } else {\n                    funcInfo = {\n                        upper: funcInfo,\n                        isConstructor: false,\n                        hasExtends: false,\n                        superIsConstructor: false,\n                        codePath\n                    };\n                }\n            },\n\n            /**\n             * Pops a constructor information.\n             * And reports if `super()` lacked.\n             * @param {CodePath} codePath A code path which was ended.\n             * @param {ASTNode} node The current node.\n             * @returns {void}\n             */\n            onCodePathEnd(codePath, node) {\n                const hasExtends = funcInfo.hasExtends;\n\n                // Pop.\n                funcInfo = funcInfo.upper;\n\n                if (!hasExtends) {\n                    return;\n                }\n\n                // Reports if `super()` lacked.\n                const segments = codePath.returnedSegments;\n                const calledInEveryPaths = segments.every(isCalledInEveryPath);\n                const calledInSomePaths = segments.some(isCalledInSomePath);\n\n                if (!calledInEveryPaths) {\n                    context.report({\n                        messageId: calledInSomePaths\n                            ? \"missingSome\"\n                            : \"missingAll\",\n                        node: node.parent\n                    });\n                }\n            },\n\n            /**\n             * Initialize information of a given code path segment.\n             * @param {CodePathSegment} segment A code path segment to initialize.\n             * @returns {void}\n             */\n            onCodePathSegmentStart(segment) {\n                if (!(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends)) {\n                    return;\n                }\n\n                // Initialize info.\n                const info = segInfoMap[segment.id] = {\n                    calledInSomePaths: false,\n                    calledInEveryPaths: false,\n                    validNodes: []\n                };\n\n                // When there are previous segments, aggregates these.\n                const prevSegments = segment.prevSegments;\n\n                if (prevSegments.length > 0) {\n                    info.calledInSomePaths = prevSegments.some(isCalledInSomePath);\n                    info.calledInEveryPaths = prevSegments.every(isCalledInEveryPath);\n                }\n            },\n\n            /**\n             * Update information of the code path segment when a code path was\n             * looped.\n             * @param {CodePathSegment} fromSegment The code path segment of the\n             *      end of a loop.\n             * @param {CodePathSegment} toSegment A code path segment of the head\n             *      of a loop.\n             * @returns {void}\n             */\n            onCodePathSegmentLoop(fromSegment, toSegment) {\n                if (!(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends)) {\n                    return;\n                }\n\n                // Update information inside of the loop.\n                const isRealLoop = toSegment.prevSegments.length >= 2;\n\n                funcInfo.codePath.traverseSegments(\n                    { first: toSegment, last: fromSegment },\n                    segment => {\n                        const info = segInfoMap[segment.id];\n                        const prevSegments = segment.prevSegments;\n\n                        // Updates flags.\n                        info.calledInSomePaths = prevSegments.some(isCalledInSomePath);\n                        info.calledInEveryPaths = prevSegments.every(isCalledInEveryPath);\n\n                        // If flags become true anew, reports the valid nodes.\n                        if (info.calledInSomePaths || isRealLoop) {\n                            const nodes = info.validNodes;\n\n                            info.validNodes = [];\n\n                            for (let i = 0; i < nodes.length; ++i) {\n                                const node = nodes[i];\n\n                                context.report({\n                                    messageId: \"duplicate\",\n                                    node\n                                });\n                            }\n                        }\n                    }\n                );\n            },\n\n            /**\n             * Checks for a call of `super()`.\n             * @param {ASTNode} node A CallExpression node to check.\n             * @returns {void}\n             */\n            \"CallExpression:exit\"(node) {\n                if (!(funcInfo && funcInfo.isConstructor)) {\n                    return;\n                }\n\n                // Skips except `super()`.\n                if (node.callee.type !== \"Super\") {\n                    return;\n                }\n\n                // Reports if needed.\n                if (funcInfo.hasExtends) {\n                    const segments = funcInfo.codePath.currentSegments;\n                    let duplicate = false;\n                    let info = null;\n\n                    for (let i = 0; i < segments.length; ++i) {\n                        const segment = segments[i];\n\n                        if (segment.reachable) {\n                            info = segInfoMap[segment.id];\n\n                            duplicate = duplicate || info.calledInSomePaths;\n                            info.calledInSomePaths = info.calledInEveryPaths = true;\n                        }\n                    }\n\n                    if (info) {\n                        if (duplicate) {\n                            context.report({\n                                messageId: \"duplicate\",\n                                node\n                            });\n                        } else if (!funcInfo.superIsConstructor) {\n                            context.report({\n                                messageId: \"badSuper\",\n                                node\n                            });\n                        } else {\n                            info.validNodes.push(node);\n                        }\n                    }\n                } else if (funcInfo.codePath.currentSegments.some(isReachable)) {\n                    context.report({\n                        messageId: \"unexpected\",\n                        node\n                    });\n                }\n            },\n\n            /**\n             * Set the mark to the returned path as `super()` was called.\n             * @param {ASTNode} node A ReturnStatement node to check.\n             * @returns {void}\n             */\n            ReturnStatement(node) {\n                if (!(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends)) {\n                    return;\n                }\n\n                // Skips if no argument.\n                if (!node.argument) {\n                    return;\n                }\n\n                // Returning argument is a substitute of 'super()'.\n                const segments = funcInfo.codePath.currentSegments;\n\n                for (let i = 0; i < segments.length; ++i) {\n                    const segment = segments[i];\n\n                    if (segment.reachable) {\n                        const info = segInfoMap[segment.id];\n\n                        info.calledInSomePaths = info.calledInEveryPaths = true;\n                    }\n                }\n            },\n\n            /**\n             * Resets state.\n             * @returns {void}\n             */\n            \"Program:exit\"() {\n                segInfoMap = Object.create(null);\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}