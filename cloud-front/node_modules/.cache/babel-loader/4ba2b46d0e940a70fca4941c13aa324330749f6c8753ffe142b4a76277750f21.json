{"ast":null,"code":"/**\n * @fileoverview Ensures that the results of typeof are compared against a valid string\n * @author Ian Christian Myers\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"enforce comparing `typeof` expressions against valid strings\",\n      category: \"Possible Errors\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/valid-typeof\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        requireStringLiterals: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      invalidValue: \"Invalid typeof comparison value.\",\n      notString: \"Typeof comparisons should be to string literals.\"\n    }\n  },\n  create(context) {\n    const VALID_TYPES = [\"symbol\", \"undefined\", \"object\", \"boolean\", \"number\", \"string\", \"function\", \"bigint\"],\n      OPERATORS = [\"==\", \"===\", \"!=\", \"!==\"];\n    const requireStringLiterals = context.options[0] && context.options[0].requireStringLiterals;\n\n    /**\n     * Determines whether a node is a typeof expression.\n     * @param {ASTNode} node The node\n     * @returns {boolean} `true` if the node is a typeof expression\n     */\n    function isTypeofExpression(node) {\n      return node.type === \"UnaryExpression\" && node.operator === \"typeof\";\n    }\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    return {\n      UnaryExpression(node) {\n        if (isTypeofExpression(node)) {\n          const parent = context.getAncestors().pop();\n          if (parent.type === \"BinaryExpression\" && OPERATORS.indexOf(parent.operator) !== -1) {\n            const sibling = parent.left === node ? parent.right : parent.left;\n            if (sibling.type === \"Literal\" || sibling.type === \"TemplateLiteral\" && !sibling.expressions.length) {\n              const value = sibling.type === \"Literal\" ? sibling.value : sibling.quasis[0].value.cooked;\n              if (VALID_TYPES.indexOf(value) === -1) {\n                context.report({\n                  node: sibling,\n                  messageId: \"invalidValue\"\n                });\n              }\n            } else if (requireStringLiterals && !isTypeofExpression(sibling)) {\n              context.report({\n                node: sibling,\n                messageId: \"notString\"\n              });\n            }\n          }\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["module","exports","meta","type","docs","description","category","recommended","url","schema","properties","requireStringLiterals","default","additionalProperties","messages","invalidValue","notString","create","context","VALID_TYPES","OPERATORS","options","isTypeofExpression","node","operator","UnaryExpression","parent","getAncestors","pop","indexOf","sibling","left","right","expressions","length","value","quasis","cooked","report","messageId"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/valid-typeof.js"],"sourcesContent":["/**\n * @fileoverview Ensures that the results of typeof are compared against a valid string\n * @author Ian Christian Myers\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"enforce comparing `typeof` expressions against valid strings\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/valid-typeof\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    requireStringLiterals: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n        messages: {\n            invalidValue: \"Invalid typeof comparison value.\",\n            notString: \"Typeof comparisons should be to string literals.\"\n        }\n    },\n\n    create(context) {\n\n        const VALID_TYPES = [\"symbol\", \"undefined\", \"object\", \"boolean\", \"number\", \"string\", \"function\", \"bigint\"],\n            OPERATORS = [\"==\", \"===\", \"!=\", \"!==\"];\n\n        const requireStringLiterals = context.options[0] && context.options[0].requireStringLiterals;\n\n        /**\n         * Determines whether a node is a typeof expression.\n         * @param {ASTNode} node The node\n         * @returns {boolean} `true` if the node is a typeof expression\n         */\n        function isTypeofExpression(node) {\n            return node.type === \"UnaryExpression\" && node.operator === \"typeof\";\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n\n            UnaryExpression(node) {\n                if (isTypeofExpression(node)) {\n                    const parent = context.getAncestors().pop();\n\n                    if (parent.type === \"BinaryExpression\" && OPERATORS.indexOf(parent.operator) !== -1) {\n                        const sibling = parent.left === node ? parent.right : parent.left;\n\n                        if (sibling.type === \"Literal\" || sibling.type === \"TemplateLiteral\" && !sibling.expressions.length) {\n                            const value = sibling.type === \"Literal\" ? sibling.value : sibling.quasis[0].value.cooked;\n\n                            if (VALID_TYPES.indexOf(value) === -1) {\n                                context.report({ node: sibling, messageId: \"invalidValue\" });\n                            }\n                        } else if (requireStringLiterals && !isTypeofExpression(sibling)) {\n                            context.report({ node: sibling, messageId: \"notString\" });\n                        }\n                    }\n                }\n            }\n\n        };\n\n    }\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,YAAY;;AAEZ;AACA;AACA;AAEAA,MAAM,CAACC,OAAO,GAAG;EACbC,IAAI,EAAE;IACFC,IAAI,EAAE,SAAS;IAEfC,IAAI,EAAE;MACFC,WAAW,EAAE,8DAA8D;MAC3EC,QAAQ,EAAE,iBAAiB;MAC3BC,WAAW,EAAE,IAAI;MACjBC,GAAG,EAAE;IACT,CAAC;IAEDC,MAAM,EAAE,CACJ;MACIN,IAAI,EAAE,QAAQ;MACdO,UAAU,EAAE;QACRC,qBAAqB,EAAE;UACnBR,IAAI,EAAE,SAAS;UACfS,OAAO,EAAE;QACb;MACJ,CAAC;MACDC,oBAAoB,EAAE;IAC1B,CAAC,CACJ;IACDC,QAAQ,EAAE;MACNC,YAAY,EAAE,kCAAkC;MAChDC,SAAS,EAAE;IACf;EACJ,CAAC;EAEDC,MAAMA,CAACC,OAAO,EAAE;IAEZ,MAAMC,WAAW,GAAG,CAAC,QAAQ,EAAE,WAAW,EAAE,QAAQ,EAAE,SAAS,EAAE,QAAQ,EAAE,QAAQ,EAAE,UAAU,EAAE,QAAQ,CAAC;MACtGC,SAAS,GAAG,CAAC,IAAI,EAAE,KAAK,EAAE,IAAI,EAAE,KAAK,CAAC;IAE1C,MAAMT,qBAAqB,GAAGO,OAAO,CAACG,OAAO,CAAC,CAAC,CAAC,IAAIH,OAAO,CAACG,OAAO,CAAC,CAAC,CAAC,CAACV,qBAAqB;;IAE5F;AACR;AACA;AACA;AACA;IACQ,SAASW,kBAAkBA,CAACC,IAAI,EAAE;MAC9B,OAAOA,IAAI,CAACpB,IAAI,KAAK,iBAAiB,IAAIoB,IAAI,CAACC,QAAQ,KAAK,QAAQ;IACxE;;IAEA;IACA;IACA;;IAEA,OAAO;MAEHC,eAAeA,CAACF,IAAI,EAAE;QAClB,IAAID,kBAAkB,CAACC,IAAI,CAAC,EAAE;UAC1B,MAAMG,MAAM,GAAGR,OAAO,CAACS,YAAY,CAAC,CAAC,CAACC,GAAG,CAAC,CAAC;UAE3C,IAAIF,MAAM,CAACvB,IAAI,KAAK,kBAAkB,IAAIiB,SAAS,CAACS,OAAO,CAACH,MAAM,CAACF,QAAQ,CAAC,KAAK,CAAC,CAAC,EAAE;YACjF,MAAMM,OAAO,GAAGJ,MAAM,CAACK,IAAI,KAAKR,IAAI,GAAGG,MAAM,CAACM,KAAK,GAAGN,MAAM,CAACK,IAAI;YAEjE,IAAID,OAAO,CAAC3B,IAAI,KAAK,SAAS,IAAI2B,OAAO,CAAC3B,IAAI,KAAK,iBAAiB,IAAI,CAAC2B,OAAO,CAACG,WAAW,CAACC,MAAM,EAAE;cACjG,MAAMC,KAAK,GAAGL,OAAO,CAAC3B,IAAI,KAAK,SAAS,GAAG2B,OAAO,CAACK,KAAK,GAAGL,OAAO,CAACM,MAAM,CAAC,CAAC,CAAC,CAACD,KAAK,CAACE,MAAM;cAEzF,IAAIlB,WAAW,CAACU,OAAO,CAACM,KAAK,CAAC,KAAK,CAAC,CAAC,EAAE;gBACnCjB,OAAO,CAACoB,MAAM,CAAC;kBAAEf,IAAI,EAAEO,OAAO;kBAAES,SAAS,EAAE;gBAAe,CAAC,CAAC;cAChE;YACJ,CAAC,MAAM,IAAI5B,qBAAqB,IAAI,CAACW,kBAAkB,CAACQ,OAAO,CAAC,EAAE;cAC9DZ,OAAO,CAACoB,MAAM,CAAC;gBAAEf,IAAI,EAAEO,OAAO;gBAAES,SAAS,EAAE;cAAY,CAAC,CAAC;YAC7D;UACJ;QACJ;MACJ;IAEJ,CAAC;EAEL;AACJ,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}