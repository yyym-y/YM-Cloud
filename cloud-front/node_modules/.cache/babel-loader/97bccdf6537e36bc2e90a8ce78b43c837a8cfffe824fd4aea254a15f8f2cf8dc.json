{"ast":null,"code":"/**\n * @fileoverview Helper class to aid in constructing fix commands.\n * @author Alan Pierce\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./ast-utils\");\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * A helper class to combine fix options into a fix command. Currently, it\n * exposes some \"retain\" methods that extend the range of the text being\n * replaced so that other fixes won't touch that region in the same pass.\n */\nclass FixTracker {\n  /**\n   * Create a new FixTracker.\n   * @param {ruleFixer} fixer A ruleFixer instance.\n   * @param {SourceCode} sourceCode A SourceCode object for the current code.\n   */\n  constructor(fixer, sourceCode) {\n    this.fixer = fixer;\n    this.sourceCode = sourceCode;\n    this.retainedRange = null;\n  }\n\n  /**\n   * Mark the given range as \"retained\", meaning that other fixes may not\n   * may not modify this region in the same pass.\n   * @param {int[]} range The range to retain.\n   * @returns {FixTracker} The same RuleFixer, for chained calls.\n   */\n  retainRange(range) {\n    this.retainedRange = range;\n    return this;\n  }\n\n  /**\n   * Given a node, find the function containing it (or the entire program) and\n   * mark it as retained, meaning that other fixes may not modify it in this\n   * pass. This is useful for avoiding conflicts in fixes that modify control\n   * flow.\n   * @param {ASTNode} node The node to use as a starting point.\n   * @returns {FixTracker} The same RuleFixer, for chained calls.\n   */\n  retainEnclosingFunction(node) {\n    const functionNode = astUtils.getUpperFunction(node);\n    return this.retainRange(functionNode ? functionNode.range : this.sourceCode.ast.range);\n  }\n\n  /**\n   * Given a node or token, find the token before and afterward, and mark that\n   * range as retained, meaning that other fixes may not modify it in this\n   * pass. This is useful for avoiding conflicts in fixes that make a small\n   * change to the code where the AST should not be changed.\n   * @param {ASTNode|Token} nodeOrToken The node or token to use as a starting\n   *      point. The token to the left and right are use in the range.\n   * @returns {FixTracker} The same RuleFixer, for chained calls.\n   */\n  retainSurroundingTokens(nodeOrToken) {\n    const tokenBefore = this.sourceCode.getTokenBefore(nodeOrToken) || nodeOrToken;\n    const tokenAfter = this.sourceCode.getTokenAfter(nodeOrToken) || nodeOrToken;\n    return this.retainRange([tokenBefore.range[0], tokenAfter.range[1]]);\n  }\n\n  /**\n   * Create a fix command that replaces the given range with the given text,\n   * accounting for any retained ranges.\n   * @param {int[]} range The range to remove in the fix.\n   * @param {string} text The text to insert in place of the range.\n   * @returns {Object} The fix command.\n   */\n  replaceTextRange(range, text) {\n    let actualRange;\n    if (this.retainedRange) {\n      actualRange = [Math.min(this.retainedRange[0], range[0]), Math.max(this.retainedRange[1], range[1])];\n    } else {\n      actualRange = range;\n    }\n    return this.fixer.replaceTextRange(actualRange, this.sourceCode.text.slice(actualRange[0], range[0]) + text + this.sourceCode.text.slice(range[1], actualRange[1]));\n  }\n\n  /**\n   * Create a fix command that removes the given node or token, accounting for\n   * any retained ranges.\n   * @param {ASTNode|Token} nodeOrToken The node or token to remove.\n   * @returns {Object} The fix command.\n   */\n  remove(nodeOrToken) {\n    return this.replaceTextRange(nodeOrToken.range, \"\");\n  }\n}\nmodule.exports = FixTracker;","map":{"version":3,"names":["astUtils","require","FixTracker","constructor","fixer","sourceCode","retainedRange","retainRange","range","retainEnclosingFunction","node","functionNode","getUpperFunction","ast","retainSurroundingTokens","nodeOrToken","tokenBefore","getTokenBefore","tokenAfter","getTokenAfter","replaceTextRange","text","actualRange","Math","min","max","slice","remove","module","exports"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/utils/fix-tracker.js"],"sourcesContent":["/**\n * @fileoverview Helper class to aid in constructing fix commands.\n * @author Alan Pierce\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./ast-utils\");\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * A helper class to combine fix options into a fix command. Currently, it\n * exposes some \"retain\" methods that extend the range of the text being\n * replaced so that other fixes won't touch that region in the same pass.\n */\nclass FixTracker {\n\n    /**\n     * Create a new FixTracker.\n     * @param {ruleFixer} fixer A ruleFixer instance.\n     * @param {SourceCode} sourceCode A SourceCode object for the current code.\n     */\n    constructor(fixer, sourceCode) {\n        this.fixer = fixer;\n        this.sourceCode = sourceCode;\n        this.retainedRange = null;\n    }\n\n    /**\n     * Mark the given range as \"retained\", meaning that other fixes may not\n     * may not modify this region in the same pass.\n     * @param {int[]} range The range to retain.\n     * @returns {FixTracker} The same RuleFixer, for chained calls.\n     */\n    retainRange(range) {\n        this.retainedRange = range;\n        return this;\n    }\n\n    /**\n     * Given a node, find the function containing it (or the entire program) and\n     * mark it as retained, meaning that other fixes may not modify it in this\n     * pass. This is useful for avoiding conflicts in fixes that modify control\n     * flow.\n     * @param {ASTNode} node The node to use as a starting point.\n     * @returns {FixTracker} The same RuleFixer, for chained calls.\n     */\n    retainEnclosingFunction(node) {\n        const functionNode = astUtils.getUpperFunction(node);\n\n        return this.retainRange(functionNode ? functionNode.range : this.sourceCode.ast.range);\n    }\n\n    /**\n     * Given a node or token, find the token before and afterward, and mark that\n     * range as retained, meaning that other fixes may not modify it in this\n     * pass. This is useful for avoiding conflicts in fixes that make a small\n     * change to the code where the AST should not be changed.\n     * @param {ASTNode|Token} nodeOrToken The node or token to use as a starting\n     *      point. The token to the left and right are use in the range.\n     * @returns {FixTracker} The same RuleFixer, for chained calls.\n     */\n    retainSurroundingTokens(nodeOrToken) {\n        const tokenBefore = this.sourceCode.getTokenBefore(nodeOrToken) || nodeOrToken;\n        const tokenAfter = this.sourceCode.getTokenAfter(nodeOrToken) || nodeOrToken;\n\n        return this.retainRange([tokenBefore.range[0], tokenAfter.range[1]]);\n    }\n\n    /**\n     * Create a fix command that replaces the given range with the given text,\n     * accounting for any retained ranges.\n     * @param {int[]} range The range to remove in the fix.\n     * @param {string} text The text to insert in place of the range.\n     * @returns {Object} The fix command.\n     */\n    replaceTextRange(range, text) {\n        let actualRange;\n\n        if (this.retainedRange) {\n            actualRange = [\n                Math.min(this.retainedRange[0], range[0]),\n                Math.max(this.retainedRange[1], range[1])\n            ];\n        } else {\n            actualRange = range;\n        }\n\n        return this.fixer.replaceTextRange(\n            actualRange,\n            this.sourceCode.text.slice(actualRange[0], range[0]) +\n                text +\n                this.sourceCode.text.slice(range[1], actualRange[1])\n        );\n    }\n\n    /**\n     * Create a fix command that removes the given node or token, accounting for\n     * any retained ranges.\n     * @param {ASTNode|Token} nodeOrToken The node or token to remove.\n     * @returns {Object} The fix command.\n     */\n    remove(nodeOrToken) {\n        return this.replaceTextRange(nodeOrToken.range, \"\");\n    }\n}\n\nmodule.exports = FixTracker;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,YAAY;;AAEZ;AACA;AACA;AAEA,MAAMA,QAAQ,GAAGC,OAAO,CAAC,aAAa,CAAC;;AAEvC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAMC,UAAU,CAAC;EAEb;AACJ;AACA;AACA;AACA;EACIC,WAAWA,CAACC,KAAK,EAAEC,UAAU,EAAE;IAC3B,IAAI,CAACD,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACC,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACC,aAAa,GAAG,IAAI;EAC7B;;EAEA;AACJ;AACA;AACA;AACA;AACA;EACIC,WAAWA,CAACC,KAAK,EAAE;IACf,IAAI,CAACF,aAAa,GAAGE,KAAK;IAC1B,OAAO,IAAI;EACf;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,uBAAuBA,CAACC,IAAI,EAAE;IAC1B,MAAMC,YAAY,GAAGX,QAAQ,CAACY,gBAAgB,CAACF,IAAI,CAAC;IAEpD,OAAO,IAAI,CAACH,WAAW,CAACI,YAAY,GAAGA,YAAY,CAACH,KAAK,GAAG,IAAI,CAACH,UAAU,CAACQ,GAAG,CAACL,KAAK,CAAC;EAC1F;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIM,uBAAuBA,CAACC,WAAW,EAAE;IACjC,MAAMC,WAAW,GAAG,IAAI,CAACX,UAAU,CAACY,cAAc,CAACF,WAAW,CAAC,IAAIA,WAAW;IAC9E,MAAMG,UAAU,GAAG,IAAI,CAACb,UAAU,CAACc,aAAa,CAACJ,WAAW,CAAC,IAAIA,WAAW;IAE5E,OAAO,IAAI,CAACR,WAAW,CAAC,CAACS,WAAW,CAACR,KAAK,CAAC,CAAC,CAAC,EAAEU,UAAU,CAACV,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;EACxE;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;EACIY,gBAAgBA,CAACZ,KAAK,EAAEa,IAAI,EAAE;IAC1B,IAAIC,WAAW;IAEf,IAAI,IAAI,CAAChB,aAAa,EAAE;MACpBgB,WAAW,GAAG,CACVC,IAAI,CAACC,GAAG,CAAC,IAAI,CAAClB,aAAa,CAAC,CAAC,CAAC,EAAEE,KAAK,CAAC,CAAC,CAAC,CAAC,EACzCe,IAAI,CAACE,GAAG,CAAC,IAAI,CAACnB,aAAa,CAAC,CAAC,CAAC,EAAEE,KAAK,CAAC,CAAC,CAAC,CAAC,CAC5C;IACL,CAAC,MAAM;MACHc,WAAW,GAAGd,KAAK;IACvB;IAEA,OAAO,IAAI,CAACJ,KAAK,CAACgB,gBAAgB,CAC9BE,WAAW,EACX,IAAI,CAACjB,UAAU,CAACgB,IAAI,CAACK,KAAK,CAACJ,WAAW,CAAC,CAAC,CAAC,EAAEd,KAAK,CAAC,CAAC,CAAC,CAAC,GAChDa,IAAI,GACJ,IAAI,CAAChB,UAAU,CAACgB,IAAI,CAACK,KAAK,CAAClB,KAAK,CAAC,CAAC,CAAC,EAAEc,WAAW,CAAC,CAAC,CAAC,CAC3D,CAAC;EACL;;EAEA;AACJ;AACA;AACA;AACA;AACA;EACIK,MAAMA,CAACZ,WAAW,EAAE;IAChB,OAAO,IAAI,CAACK,gBAAgB,CAACL,WAAW,CAACP,KAAK,EAAE,EAAE,CAAC;EACvD;AACJ;AAEAoB,MAAM,CAACC,OAAO,GAAG3B,UAAU"},"metadata":{},"sourceType":"script","externalDependencies":[]}