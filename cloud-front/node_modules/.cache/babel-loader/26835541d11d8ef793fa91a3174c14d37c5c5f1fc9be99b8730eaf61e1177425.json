{"ast":null,"code":"/**\n * @fileoverview Rule to require parens in arrow function arguments.\n * @author Jxck\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Determines if the given arrow function has block body.\n * @param {ASTNode} node `ArrowFunctionExpression` node.\n * @returns {boolean} `true` if the function has block body.\n */\nfunction hasBlockBody(node) {\n  return node.body.type === \"BlockStatement\";\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"require parentheses around arrow function arguments\",\n      category: \"ECMAScript 6\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/arrow-parens\"\n    },\n    fixable: \"code\",\n    schema: [{\n      enum: [\"always\", \"as-needed\"]\n    }, {\n      type: \"object\",\n      properties: {\n        requireForBlockBody: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unexpectedParens: \"Unexpected parentheses around single function argument.\",\n      expectedParens: \"Expected parentheses around arrow function argument.\",\n      unexpectedParensInline: \"Unexpected parentheses around single function argument having a body with no curly braces.\",\n      expectedParensBlock: \"Expected parentheses around arrow function argument having a body with curly braces.\"\n    }\n  },\n  create(context) {\n    const asNeeded = context.options[0] === \"as-needed\";\n    const requireForBlockBody = asNeeded && context.options[1] && context.options[1].requireForBlockBody === true;\n    const sourceCode = context.getSourceCode();\n\n    /**\n     * Finds opening paren of parameters for the given arrow function, if it exists.\n     * It is assumed that the given arrow function has exactly one parameter.\n     * @param {ASTNode} node `ArrowFunctionExpression` node.\n     * @returns {Token|null} the opening paren, or `null` if the given arrow function doesn't have parens of parameters.\n     */\n    function findOpeningParenOfParams(node) {\n      const tokenBeforeParams = sourceCode.getTokenBefore(node.params[0]);\n      if (tokenBeforeParams && astUtils.isOpeningParenToken(tokenBeforeParams) && node.range[0] <= tokenBeforeParams.range[0]) {\n        return tokenBeforeParams;\n      }\n      return null;\n    }\n\n    /**\n     * Finds closing paren of parameters for the given arrow function.\n     * It is assumed that the given arrow function has parens of parameters and that it has exactly one parameter.\n     * @param {ASTNode} node `ArrowFunctionExpression` node.\n     * @returns {Token} the closing paren of parameters.\n     */\n    function getClosingParenOfParams(node) {\n      return sourceCode.getTokenAfter(node.params[0], astUtils.isClosingParenToken);\n    }\n\n    /**\n     * Determines whether the given arrow function has comments inside parens of parameters.\n     * It is assumed that the given arrow function has parens of parameters.\n     * @param {ASTNode} node `ArrowFunctionExpression` node.\n     * @param {Token} openingParen Opening paren of parameters.\n     * @returns {boolean} `true` if the function has at least one comment inside of parens of parameters.\n     */\n    function hasCommentsInParensOfParams(node, openingParen) {\n      return sourceCode.commentsExistBetween(openingParen, getClosingParenOfParams(node));\n    }\n\n    /**\n     * Determines whether the given arrow function has unexpected tokens before opening paren of parameters,\n     * in which case it will be assumed that the existing parens of parameters are necessary.\n     * Only tokens within the range of the arrow function (tokens that are part of the arrow function) are taken into account.\n     * Example: <T>(a) => b\n     * @param {ASTNode} node `ArrowFunctionExpression` node.\n     * @param {Token} openingParen Opening paren of parameters.\n     * @returns {boolean} `true` if the function has at least one unexpected token.\n     */\n    function hasUnexpectedTokensBeforeOpeningParen(node, openingParen) {\n      const expectedCount = node.async ? 1 : 0;\n      return sourceCode.getFirstToken(node, {\n        skip: expectedCount\n      }) !== openingParen;\n    }\n    return {\n      \"ArrowFunctionExpression[params.length=1]\"(node) {\n        const shouldHaveParens = !asNeeded || requireForBlockBody && hasBlockBody(node);\n        const openingParen = findOpeningParenOfParams(node);\n        const hasParens = openingParen !== null;\n        const [param] = node.params;\n        if (shouldHaveParens && !hasParens) {\n          context.report({\n            node,\n            messageId: requireForBlockBody ? \"expectedParensBlock\" : \"expectedParens\",\n            loc: param.loc,\n            *fix(fixer) {\n              yield fixer.insertTextBefore(param, \"(\");\n              yield fixer.insertTextAfter(param, \")\");\n            }\n          });\n        }\n        if (!shouldHaveParens && hasParens && param.type === \"Identifier\" && !param.typeAnnotation && !node.returnType && !hasCommentsInParensOfParams(node, openingParen) && !hasUnexpectedTokensBeforeOpeningParen(node, openingParen)) {\n          context.report({\n            node,\n            messageId: requireForBlockBody ? \"unexpectedParensInline\" : \"unexpectedParens\",\n            loc: param.loc,\n            *fix(fixer) {\n              const tokenBeforeOpeningParen = sourceCode.getTokenBefore(openingParen);\n              const closingParen = getClosingParenOfParams(node);\n              if (tokenBeforeOpeningParen && tokenBeforeOpeningParen.range[1] === openingParen.range[0] && !astUtils.canTokensBeAdjacent(tokenBeforeOpeningParen, sourceCode.getFirstToken(param))) {\n                yield fixer.insertTextBefore(openingParen, \" \");\n              }\n\n              // remove parens, whitespace inside parens, and possible trailing comma\n              yield fixer.removeRange([openingParen.range[0], param.range[0]]);\n              yield fixer.removeRange([param.range[1], closingParen.range[1]]);\n            }\n          });\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","hasBlockBody","node","body","type","module","exports","meta","docs","description","category","recommended","url","fixable","schema","enum","properties","requireForBlockBody","default","additionalProperties","messages","unexpectedParens","expectedParens","unexpectedParensInline","expectedParensBlock","create","context","asNeeded","options","sourceCode","getSourceCode","findOpeningParenOfParams","tokenBeforeParams","getTokenBefore","params","isOpeningParenToken","range","getClosingParenOfParams","getTokenAfter","isClosingParenToken","hasCommentsInParensOfParams","openingParen","commentsExistBetween","hasUnexpectedTokensBeforeOpeningParen","expectedCount","async","getFirstToken","skip","ArrowFunctionExpression[params.length=1]","shouldHaveParens","hasParens","param","report","messageId","loc","fix","fixer","insertTextBefore","insertTextAfter","typeAnnotation","returnType","tokenBeforeOpeningParen","closingParen","canTokensBeAdjacent","removeRange"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/arrow-parens.js"],"sourcesContent":["/**\n * @fileoverview Rule to require parens in arrow function arguments.\n * @author Jxck\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Determines if the given arrow function has block body.\n * @param {ASTNode} node `ArrowFunctionExpression` node.\n * @returns {boolean} `true` if the function has block body.\n */\nfunction hasBlockBody(node) {\n    return node.body.type === \"BlockStatement\";\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"require parentheses around arrow function arguments\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/arrow-parens\"\n        },\n\n        fixable: \"code\",\n\n        schema: [\n            {\n                enum: [\"always\", \"as-needed\"]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    requireForBlockBody: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            unexpectedParens: \"Unexpected parentheses around single function argument.\",\n            expectedParens: \"Expected parentheses around arrow function argument.\",\n\n            unexpectedParensInline: \"Unexpected parentheses around single function argument having a body with no curly braces.\",\n            expectedParensBlock: \"Expected parentheses around arrow function argument having a body with curly braces.\"\n        }\n    },\n\n    create(context) {\n        const asNeeded = context.options[0] === \"as-needed\";\n        const requireForBlockBody = asNeeded && context.options[1] && context.options[1].requireForBlockBody === true;\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Finds opening paren of parameters for the given arrow function, if it exists.\n         * It is assumed that the given arrow function has exactly one parameter.\n         * @param {ASTNode} node `ArrowFunctionExpression` node.\n         * @returns {Token|null} the opening paren, or `null` if the given arrow function doesn't have parens of parameters.\n         */\n        function findOpeningParenOfParams(node) {\n            const tokenBeforeParams = sourceCode.getTokenBefore(node.params[0]);\n\n            if (\n                tokenBeforeParams &&\n                astUtils.isOpeningParenToken(tokenBeforeParams) &&\n                node.range[0] <= tokenBeforeParams.range[0]\n            ) {\n                return tokenBeforeParams;\n            }\n\n            return null;\n        }\n\n        /**\n         * Finds closing paren of parameters for the given arrow function.\n         * It is assumed that the given arrow function has parens of parameters and that it has exactly one parameter.\n         * @param {ASTNode} node `ArrowFunctionExpression` node.\n         * @returns {Token} the closing paren of parameters.\n         */\n        function getClosingParenOfParams(node) {\n            return sourceCode.getTokenAfter(node.params[0], astUtils.isClosingParenToken);\n        }\n\n        /**\n         * Determines whether the given arrow function has comments inside parens of parameters.\n         * It is assumed that the given arrow function has parens of parameters.\n         * @param {ASTNode} node `ArrowFunctionExpression` node.\n         * @param {Token} openingParen Opening paren of parameters.\n         * @returns {boolean} `true` if the function has at least one comment inside of parens of parameters.\n         */\n        function hasCommentsInParensOfParams(node, openingParen) {\n            return sourceCode.commentsExistBetween(openingParen, getClosingParenOfParams(node));\n        }\n\n        /**\n         * Determines whether the given arrow function has unexpected tokens before opening paren of parameters,\n         * in which case it will be assumed that the existing parens of parameters are necessary.\n         * Only tokens within the range of the arrow function (tokens that are part of the arrow function) are taken into account.\n         * Example: <T>(a) => b\n         * @param {ASTNode} node `ArrowFunctionExpression` node.\n         * @param {Token} openingParen Opening paren of parameters.\n         * @returns {boolean} `true` if the function has at least one unexpected token.\n         */\n        function hasUnexpectedTokensBeforeOpeningParen(node, openingParen) {\n            const expectedCount = node.async ? 1 : 0;\n\n            return sourceCode.getFirstToken(node, { skip: expectedCount }) !== openingParen;\n        }\n\n        return {\n            \"ArrowFunctionExpression[params.length=1]\"(node) {\n                const shouldHaveParens = !asNeeded || requireForBlockBody && hasBlockBody(node);\n                const openingParen = findOpeningParenOfParams(node);\n                const hasParens = openingParen !== null;\n                const [param] = node.params;\n\n                if (shouldHaveParens && !hasParens) {\n                    context.report({\n                        node,\n                        messageId: requireForBlockBody ? \"expectedParensBlock\" : \"expectedParens\",\n                        loc: param.loc,\n                        *fix(fixer) {\n                            yield fixer.insertTextBefore(param, \"(\");\n                            yield fixer.insertTextAfter(param, \")\");\n                        }\n                    });\n                }\n\n                if (\n                    !shouldHaveParens &&\n                    hasParens &&\n                    param.type === \"Identifier\" &&\n                    !param.typeAnnotation &&\n                    !node.returnType &&\n                    !hasCommentsInParensOfParams(node, openingParen) &&\n                    !hasUnexpectedTokensBeforeOpeningParen(node, openingParen)\n                ) {\n                    context.report({\n                        node,\n                        messageId: requireForBlockBody ? \"unexpectedParensInline\" : \"unexpectedParens\",\n                        loc: param.loc,\n                        *fix(fixer) {\n                            const tokenBeforeOpeningParen = sourceCode.getTokenBefore(openingParen);\n                            const closingParen = getClosingParenOfParams(node);\n\n                            if (\n                                tokenBeforeOpeningParen &&\n                                tokenBeforeOpeningParen.range[1] === openingParen.range[0] &&\n                                !astUtils.canTokensBeAdjacent(tokenBeforeOpeningParen, sourceCode.getFirstToken(param))\n                            ) {\n                                yield fixer.insertTextBefore(openingParen, \" \");\n                            }\n\n                            // remove parens, whitespace inside parens, and possible trailing comma\n                            yield fixer.removeRange([openingParen.range[0], param.range[0]]);\n                            yield fixer.removeRange([param.range[1], closingParen.range[1]]);\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}