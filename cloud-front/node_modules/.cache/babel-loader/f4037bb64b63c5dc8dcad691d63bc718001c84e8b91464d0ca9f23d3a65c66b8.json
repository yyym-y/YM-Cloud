{"ast":null,"code":"/**\n * @fileoverview enforce consistent line breaks inside function parentheses\n * @author Teddy Katz\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce consistent line breaks inside function parentheses\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/function-paren-newline\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      oneOf: [{\n        enum: [\"always\", \"never\", \"consistent\", \"multiline\", \"multiline-arguments\"]\n      }, {\n        type: \"object\",\n        properties: {\n          minItems: {\n            type: \"integer\",\n            minimum: 0\n          }\n        },\n        additionalProperties: false\n      }]\n    }],\n    messages: {\n      expectedBefore: \"Expected newline before ')'.\",\n      expectedAfter: \"Expected newline after '('.\",\n      expectedBetween: \"Expected newline between arguments/params.\",\n      unexpectedBefore: \"Unexpected newline before ')'.\",\n      unexpectedAfter: \"Unexpected newline after '('.\"\n    }\n  },\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const rawOption = context.options[0] || \"multiline\";\n    const multilineOption = rawOption === \"multiline\";\n    const multilineArgumentsOption = rawOption === \"multiline-arguments\";\n    const consistentOption = rawOption === \"consistent\";\n    let minItems;\n    if (typeof rawOption === \"object\") {\n      minItems = rawOption.minItems;\n    } else if (rawOption === \"always\") {\n      minItems = 0;\n    } else if (rawOption === \"never\") {\n      minItems = Infinity;\n    } else {\n      minItems = null;\n    }\n\n    //----------------------------------------------------------------------\n    // Helpers\n    //----------------------------------------------------------------------\n\n    /**\n     * Determines whether there should be newlines inside function parens\n     * @param {ASTNode[]} elements The arguments or parameters in the list\n     * @param {boolean} hasLeftNewline `true` if the left paren has a newline in the current code.\n     * @returns {boolean} `true` if there should be newlines inside the function parens\n     */\n    function shouldHaveNewlines(elements, hasLeftNewline) {\n      if (multilineArgumentsOption && elements.length === 1) {\n        return hasLeftNewline;\n      }\n      if (multilineOption || multilineArgumentsOption) {\n        return elements.some((element, index) => index !== elements.length - 1 && element.loc.end.line !== elements[index + 1].loc.start.line);\n      }\n      if (consistentOption) {\n        return hasLeftNewline;\n      }\n      return elements.length >= minItems;\n    }\n\n    /**\n     * Validates parens\n     * @param {Object} parens An object with keys `leftParen` for the left paren token, and `rightParen` for the right paren token\n     * @param {ASTNode[]} elements The arguments or parameters in the list\n     * @returns {void}\n     */\n    function validateParens(parens, elements) {\n      const leftParen = parens.leftParen;\n      const rightParen = parens.rightParen;\n      const tokenAfterLeftParen = sourceCode.getTokenAfter(leftParen);\n      const tokenBeforeRightParen = sourceCode.getTokenBefore(rightParen);\n      const hasLeftNewline = !astUtils.isTokenOnSameLine(leftParen, tokenAfterLeftParen);\n      const hasRightNewline = !astUtils.isTokenOnSameLine(tokenBeforeRightParen, rightParen);\n      const needsNewlines = shouldHaveNewlines(elements, hasLeftNewline);\n      if (hasLeftNewline && !needsNewlines) {\n        context.report({\n          node: leftParen,\n          messageId: \"unexpectedAfter\",\n          fix(fixer) {\n            return sourceCode.getText().slice(leftParen.range[1], tokenAfterLeftParen.range[0]).trim()\n\n            // If there is a comment between the ( and the first element, don't do a fix.\n            ? null : fixer.removeRange([leftParen.range[1], tokenAfterLeftParen.range[0]]);\n          }\n        });\n      } else if (!hasLeftNewline && needsNewlines) {\n        context.report({\n          node: leftParen,\n          messageId: \"expectedAfter\",\n          fix: fixer => fixer.insertTextAfter(leftParen, \"\\n\")\n        });\n      }\n      if (hasRightNewline && !needsNewlines) {\n        context.report({\n          node: rightParen,\n          messageId: \"unexpectedBefore\",\n          fix(fixer) {\n            return sourceCode.getText().slice(tokenBeforeRightParen.range[1], rightParen.range[0]).trim()\n\n            // If there is a comment between the last element and the ), don't do a fix.\n            ? null : fixer.removeRange([tokenBeforeRightParen.range[1], rightParen.range[0]]);\n          }\n        });\n      } else if (!hasRightNewline && needsNewlines) {\n        context.report({\n          node: rightParen,\n          messageId: \"expectedBefore\",\n          fix: fixer => fixer.insertTextBefore(rightParen, \"\\n\")\n        });\n      }\n    }\n\n    /**\n     * Validates a list of arguments or parameters\n     * @param {Object} parens An object with keys `leftParen` for the left paren token, and `rightParen` for the right paren token\n     * @param {ASTNode[]} elements The arguments or parameters in the list\n     * @returns {void}\n     */\n    function validateArguments(parens, elements) {\n      const leftParen = parens.leftParen;\n      const tokenAfterLeftParen = sourceCode.getTokenAfter(leftParen);\n      const hasLeftNewline = !astUtils.isTokenOnSameLine(leftParen, tokenAfterLeftParen);\n      const needsNewlines = shouldHaveNewlines(elements, hasLeftNewline);\n      for (let i = 0; i <= elements.length - 2; i++) {\n        const currentElement = elements[i];\n        const nextElement = elements[i + 1];\n        const hasNewLine = currentElement.loc.end.line !== nextElement.loc.start.line;\n        if (!hasNewLine && needsNewlines) {\n          context.report({\n            node: currentElement,\n            messageId: \"expectedBetween\",\n            fix: fixer => fixer.insertTextBefore(nextElement, \"\\n\")\n          });\n        }\n      }\n    }\n\n    /**\n     * Gets the left paren and right paren tokens of a node.\n     * @param {ASTNode} node The node with parens\n     * @returns {Object} An object with keys `leftParen` for the left paren token, and `rightParen` for the right paren token.\n     * Can also return `null` if an expression has no parens (e.g. a NewExpression with no arguments, or an ArrowFunctionExpression\n     * with a single parameter)\n     */\n    function getParenTokens(node) {\n      switch (node.type) {\n        case \"NewExpression\":\n          if (!node.arguments.length && !(astUtils.isOpeningParenToken(sourceCode.getLastToken(node, {\n            skip: 1\n          })) && astUtils.isClosingParenToken(sourceCode.getLastToken(node)))) {\n            // If the NewExpression does not have parens (e.g. `new Foo`), return null.\n            return null;\n          }\n\n        // falls through\n\n        case \"CallExpression\":\n          return {\n            leftParen: sourceCode.getTokenAfter(node.callee, astUtils.isOpeningParenToken),\n            rightParen: sourceCode.getLastToken(node)\n          };\n        case \"FunctionDeclaration\":\n        case \"FunctionExpression\":\n          {\n            const leftParen = sourceCode.getFirstToken(node, astUtils.isOpeningParenToken);\n            const rightParen = node.params.length ? sourceCode.getTokenAfter(node.params[node.params.length - 1], astUtils.isClosingParenToken) : sourceCode.getTokenAfter(leftParen);\n            return {\n              leftParen,\n              rightParen\n            };\n          }\n        case \"ArrowFunctionExpression\":\n          {\n            const firstToken = sourceCode.getFirstToken(node, {\n              skip: node.async ? 1 : 0\n            });\n            if (!astUtils.isOpeningParenToken(firstToken)) {\n              // If the ArrowFunctionExpression has a single param without parens, return null.\n              return null;\n            }\n            return {\n              leftParen: firstToken,\n              rightParen: sourceCode.getTokenBefore(node.body, astUtils.isClosingParenToken)\n            };\n          }\n        case \"ImportExpression\":\n          {\n            const leftParen = sourceCode.getFirstToken(node, 1);\n            const rightParen = sourceCode.getLastToken(node);\n            return {\n              leftParen,\n              rightParen\n            };\n          }\n        default:\n          throw new TypeError(`unexpected node with type ${node.type}`);\n      }\n    }\n\n    //----------------------------------------------------------------------\n    // Public\n    //----------------------------------------------------------------------\n\n    return {\n      [[\"ArrowFunctionExpression\", \"CallExpression\", \"FunctionDeclaration\", \"FunctionExpression\", \"ImportExpression\", \"NewExpression\"]](node) {\n        const parens = getParenTokens(node);\n        let params;\n        if (node.type === \"ImportExpression\") {\n          params = [node.source];\n        } else if (astUtils.isFunction(node)) {\n          params = node.params;\n        } else {\n          params = node.arguments;\n        }\n        if (parens) {\n          validateParens(parens, params);\n          if (multilineArgumentsOption) {\n            validateArguments(parens, params);\n          }\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","module","exports","meta","type","docs","description","category","recommended","url","fixable","schema","oneOf","enum","properties","minItems","minimum","additionalProperties","messages","expectedBefore","expectedAfter","expectedBetween","unexpectedBefore","unexpectedAfter","create","context","sourceCode","getSourceCode","rawOption","options","multilineOption","multilineArgumentsOption","consistentOption","Infinity","shouldHaveNewlines","elements","hasLeftNewline","length","some","element","index","loc","end","line","start","validateParens","parens","leftParen","rightParen","tokenAfterLeftParen","getTokenAfter","tokenBeforeRightParen","getTokenBefore","isTokenOnSameLine","hasRightNewline","needsNewlines","report","node","messageId","fix","fixer","getText","slice","range","trim","removeRange","insertTextAfter","insertTextBefore","validateArguments","i","currentElement","nextElement","hasNewLine","getParenTokens","arguments","isOpeningParenToken","getLastToken","skip","isClosingParenToken","callee","getFirstToken","params","firstToken","async","body","TypeError","source","isFunction"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/function-paren-newline.js"],"sourcesContent":["/**\n * @fileoverview enforce consistent line breaks inside function parentheses\n * @author Teddy Katz\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce consistent line breaks inside function parentheses\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/function-paren-newline\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"always\", \"never\", \"consistent\", \"multiline\", \"multiline-arguments\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            minItems: {\n                                type: \"integer\",\n                                minimum: 0\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ],\n\n        messages: {\n            expectedBefore: \"Expected newline before ')'.\",\n            expectedAfter: \"Expected newline after '('.\",\n            expectedBetween: \"Expected newline between arguments/params.\",\n            unexpectedBefore: \"Unexpected newline before ')'.\",\n            unexpectedAfter: \"Unexpected newline after '('.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const rawOption = context.options[0] || \"multiline\";\n        const multilineOption = rawOption === \"multiline\";\n        const multilineArgumentsOption = rawOption === \"multiline-arguments\";\n        const consistentOption = rawOption === \"consistent\";\n        let minItems;\n\n        if (typeof rawOption === \"object\") {\n            minItems = rawOption.minItems;\n        } else if (rawOption === \"always\") {\n            minItems = 0;\n        } else if (rawOption === \"never\") {\n            minItems = Infinity;\n        } else {\n            minItems = null;\n        }\n\n        //----------------------------------------------------------------------\n        // Helpers\n        //----------------------------------------------------------------------\n\n        /**\n         * Determines whether there should be newlines inside function parens\n         * @param {ASTNode[]} elements The arguments or parameters in the list\n         * @param {boolean} hasLeftNewline `true` if the left paren has a newline in the current code.\n         * @returns {boolean} `true` if there should be newlines inside the function parens\n         */\n        function shouldHaveNewlines(elements, hasLeftNewline) {\n            if (multilineArgumentsOption && elements.length === 1) {\n                return hasLeftNewline;\n            }\n            if (multilineOption || multilineArgumentsOption) {\n                return elements.some((element, index) => index !== elements.length - 1 && element.loc.end.line !== elements[index + 1].loc.start.line);\n            }\n            if (consistentOption) {\n                return hasLeftNewline;\n            }\n            return elements.length >= minItems;\n        }\n\n        /**\n         * Validates parens\n         * @param {Object} parens An object with keys `leftParen` for the left paren token, and `rightParen` for the right paren token\n         * @param {ASTNode[]} elements The arguments or parameters in the list\n         * @returns {void}\n         */\n        function validateParens(parens, elements) {\n            const leftParen = parens.leftParen;\n            const rightParen = parens.rightParen;\n            const tokenAfterLeftParen = sourceCode.getTokenAfter(leftParen);\n            const tokenBeforeRightParen = sourceCode.getTokenBefore(rightParen);\n            const hasLeftNewline = !astUtils.isTokenOnSameLine(leftParen, tokenAfterLeftParen);\n            const hasRightNewline = !astUtils.isTokenOnSameLine(tokenBeforeRightParen, rightParen);\n            const needsNewlines = shouldHaveNewlines(elements, hasLeftNewline);\n\n            if (hasLeftNewline && !needsNewlines) {\n                context.report({\n                    node: leftParen,\n                    messageId: \"unexpectedAfter\",\n                    fix(fixer) {\n                        return sourceCode.getText().slice(leftParen.range[1], tokenAfterLeftParen.range[0]).trim()\n\n                            // If there is a comment between the ( and the first element, don't do a fix.\n                            ? null\n                            : fixer.removeRange([leftParen.range[1], tokenAfterLeftParen.range[0]]);\n                    }\n                });\n            } else if (!hasLeftNewline && needsNewlines) {\n                context.report({\n                    node: leftParen,\n                    messageId: \"expectedAfter\",\n                    fix: fixer => fixer.insertTextAfter(leftParen, \"\\n\")\n                });\n            }\n\n            if (hasRightNewline && !needsNewlines) {\n                context.report({\n                    node: rightParen,\n                    messageId: \"unexpectedBefore\",\n                    fix(fixer) {\n                        return sourceCode.getText().slice(tokenBeforeRightParen.range[1], rightParen.range[0]).trim()\n\n                            // If there is a comment between the last element and the ), don't do a fix.\n                            ? null\n                            : fixer.removeRange([tokenBeforeRightParen.range[1], rightParen.range[0]]);\n                    }\n                });\n            } else if (!hasRightNewline && needsNewlines) {\n                context.report({\n                    node: rightParen,\n                    messageId: \"expectedBefore\",\n                    fix: fixer => fixer.insertTextBefore(rightParen, \"\\n\")\n                });\n            }\n        }\n\n        /**\n         * Validates a list of arguments or parameters\n         * @param {Object} parens An object with keys `leftParen` for the left paren token, and `rightParen` for the right paren token\n         * @param {ASTNode[]} elements The arguments or parameters in the list\n         * @returns {void}\n         */\n        function validateArguments(parens, elements) {\n            const leftParen = parens.leftParen;\n            const tokenAfterLeftParen = sourceCode.getTokenAfter(leftParen);\n            const hasLeftNewline = !astUtils.isTokenOnSameLine(leftParen, tokenAfterLeftParen);\n            const needsNewlines = shouldHaveNewlines(elements, hasLeftNewline);\n\n            for (let i = 0; i <= elements.length - 2; i++) {\n                const currentElement = elements[i];\n                const nextElement = elements[i + 1];\n                const hasNewLine = currentElement.loc.end.line !== nextElement.loc.start.line;\n\n                if (!hasNewLine && needsNewlines) {\n                    context.report({\n                        node: currentElement,\n                        messageId: \"expectedBetween\",\n                        fix: fixer => fixer.insertTextBefore(nextElement, \"\\n\")\n                    });\n                }\n            }\n        }\n\n        /**\n         * Gets the left paren and right paren tokens of a node.\n         * @param {ASTNode} node The node with parens\n         * @returns {Object} An object with keys `leftParen` for the left paren token, and `rightParen` for the right paren token.\n         * Can also return `null` if an expression has no parens (e.g. a NewExpression with no arguments, or an ArrowFunctionExpression\n         * with a single parameter)\n         */\n        function getParenTokens(node) {\n            switch (node.type) {\n                case \"NewExpression\":\n                    if (!node.arguments.length && !(\n                        astUtils.isOpeningParenToken(sourceCode.getLastToken(node, { skip: 1 })) &&\n                        astUtils.isClosingParenToken(sourceCode.getLastToken(node))\n                    )) {\n\n                        // If the NewExpression does not have parens (e.g. `new Foo`), return null.\n                        return null;\n                    }\n\n                    // falls through\n\n                case \"CallExpression\":\n                    return {\n                        leftParen: sourceCode.getTokenAfter(node.callee, astUtils.isOpeningParenToken),\n                        rightParen: sourceCode.getLastToken(node)\n                    };\n\n                case \"FunctionDeclaration\":\n                case \"FunctionExpression\": {\n                    const leftParen = sourceCode.getFirstToken(node, astUtils.isOpeningParenToken);\n                    const rightParen = node.params.length\n                        ? sourceCode.getTokenAfter(node.params[node.params.length - 1], astUtils.isClosingParenToken)\n                        : sourceCode.getTokenAfter(leftParen);\n\n                    return { leftParen, rightParen };\n                }\n\n                case \"ArrowFunctionExpression\": {\n                    const firstToken = sourceCode.getFirstToken(node, { skip: (node.async ? 1 : 0) });\n\n                    if (!astUtils.isOpeningParenToken(firstToken)) {\n\n                        // If the ArrowFunctionExpression has a single param without parens, return null.\n                        return null;\n                    }\n\n                    return {\n                        leftParen: firstToken,\n                        rightParen: sourceCode.getTokenBefore(node.body, astUtils.isClosingParenToken)\n                    };\n                }\n\n                case \"ImportExpression\": {\n                    const leftParen = sourceCode.getFirstToken(node, 1);\n                    const rightParen = sourceCode.getLastToken(node);\n\n                    return { leftParen, rightParen };\n                }\n\n                default:\n                    throw new TypeError(`unexpected node with type ${node.type}`);\n            }\n        }\n\n        //----------------------------------------------------------------------\n        // Public\n        //----------------------------------------------------------------------\n\n        return {\n            [[\n                \"ArrowFunctionExpression\",\n                \"CallExpression\",\n                \"FunctionDeclaration\",\n                \"FunctionExpression\",\n                \"ImportExpression\",\n                \"NewExpression\"\n            ]](node) {\n                const parens = getParenTokens(node);\n                let params;\n\n                if (node.type === \"ImportExpression\") {\n                    params = [node.source];\n                } else if (astUtils.isFunction(node)) {\n                    params = node.params;\n                } else {\n                    params = node.arguments;\n                }\n\n                if (parens) {\n                    validateParens(parens, params);\n\n                    if (multilineArgumentsOption) {\n                        validateArguments(parens, params);\n                    }\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}