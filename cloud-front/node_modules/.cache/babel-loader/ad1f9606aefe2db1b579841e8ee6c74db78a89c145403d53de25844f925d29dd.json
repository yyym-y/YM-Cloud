{"ast":null,"code":"/**\n * @fileoverview disallow unnecessary concatenation of template strings\n * @author Henry Zhu\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given node is a concatenation.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node is a concatenation.\n */\nfunction isConcatenation(node) {\n  return node.type === \"BinaryExpression\" && node.operator === \"+\";\n}\n\n/**\n * Checks if the given token is a `+` token or not.\n * @param {Token} token The token to check.\n * @returns {boolean} `true` if the token is a `+` token.\n */\nfunction isConcatOperatorToken(token) {\n  return token.value === \"+\" && token.type === \"Punctuator\";\n}\n\n/**\n * Get's the right most node on the left side of a BinaryExpression with + operator.\n * @param {ASTNode} node A BinaryExpression node to check.\n * @returns {ASTNode} node\n */\nfunction getLeft(node) {\n  let left = node.left;\n  while (isConcatenation(left)) {\n    left = left.right;\n  }\n  return left;\n}\n\n/**\n * Get's the left most node on the right side of a BinaryExpression with + operator.\n * @param {ASTNode} node A BinaryExpression node to check.\n * @returns {ASTNode} node\n */\nfunction getRight(node) {\n  let right = node.right;\n  while (isConcatenation(right)) {\n    right = right.left;\n  }\n  return right;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow unnecessary concatenation of literals or template literals\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-useless-concat\"\n    },\n    schema: [],\n    messages: {\n      unexpectedConcat: \"Unexpected string concatenation of literals.\"\n    }\n  },\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    return {\n      BinaryExpression(node) {\n        // check if not concatenation\n        if (node.operator !== \"+\") {\n          return;\n        }\n\n        // account for the `foo + \"a\" + \"b\"` case\n        const left = getLeft(node);\n        const right = getRight(node);\n        if (astUtils.isStringLiteral(left) && astUtils.isStringLiteral(right) && astUtils.isTokenOnSameLine(left, right)) {\n          const operatorToken = sourceCode.getFirstTokenBetween(left, right, isConcatOperatorToken);\n          context.report({\n            node,\n            loc: operatorToken.loc,\n            messageId: \"unexpectedConcat\"\n          });\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","isConcatenation","node","type","operator","isConcatOperatorToken","token","value","getLeft","left","right","getRight","module","exports","meta","docs","description","category","recommended","url","schema","messages","unexpectedConcat","create","context","sourceCode","getSourceCode","BinaryExpression","isStringLiteral","isTokenOnSameLine","operatorToken","getFirstTokenBetween","report","loc","messageId"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/no-useless-concat.js"],"sourcesContent":["/**\n * @fileoverview disallow unnecessary concatenation of template strings\n * @author Henry Zhu\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given node is a concatenation.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node is a concatenation.\n */\nfunction isConcatenation(node) {\n    return node.type === \"BinaryExpression\" && node.operator === \"+\";\n}\n\n/**\n * Checks if the given token is a `+` token or not.\n * @param {Token} token The token to check.\n * @returns {boolean} `true` if the token is a `+` token.\n */\nfunction isConcatOperatorToken(token) {\n    return token.value === \"+\" && token.type === \"Punctuator\";\n}\n\n/**\n * Get's the right most node on the left side of a BinaryExpression with + operator.\n * @param {ASTNode} node A BinaryExpression node to check.\n * @returns {ASTNode} node\n */\nfunction getLeft(node) {\n    let left = node.left;\n\n    while (isConcatenation(left)) {\n        left = left.right;\n    }\n    return left;\n}\n\n/**\n * Get's the left most node on the right side of a BinaryExpression with + operator.\n * @param {ASTNode} node A BinaryExpression node to check.\n * @returns {ASTNode} node\n */\nfunction getRight(node) {\n    let right = node.right;\n\n    while (isConcatenation(right)) {\n        right = right.left;\n    }\n    return right;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow unnecessary concatenation of literals or template literals\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-useless-concat\"\n        },\n\n        schema: [],\n\n        messages: {\n            unexpectedConcat: \"Unexpected string concatenation of literals.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        return {\n            BinaryExpression(node) {\n\n                // check if not concatenation\n                if (node.operator !== \"+\") {\n                    return;\n                }\n\n                // account for the `foo + \"a\" + \"b\"` case\n                const left = getLeft(node);\n                const right = getRight(node);\n\n                if (astUtils.isStringLiteral(left) &&\n                    astUtils.isStringLiteral(right) &&\n                    astUtils.isTokenOnSameLine(left, right)\n                ) {\n                    const operatorToken = sourceCode.getFirstTokenBetween(left, right, isConcatOperatorToken);\n\n                    context.report({\n                        node,\n                        loc: operatorToken.loc,\n                        messageId: \"unexpectedConcat\"\n                    });\n                }\n            }\n        };\n    }\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,YAAY;;AAEZ;AACA;AACA;AAEA,MAAMA,QAAQ,GAAGC,OAAO,CAAC,mBAAmB,CAAC;;AAE7C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASC,eAAeA,CAACC,IAAI,EAAE;EAC3B,OAAOA,IAAI,CAACC,IAAI,KAAK,kBAAkB,IAAID,IAAI,CAACE,QAAQ,KAAK,GAAG;AACpE;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASC,qBAAqBA,CAACC,KAAK,EAAE;EAClC,OAAOA,KAAK,CAACC,KAAK,KAAK,GAAG,IAAID,KAAK,CAACH,IAAI,KAAK,YAAY;AAC7D;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASK,OAAOA,CAACN,IAAI,EAAE;EACnB,IAAIO,IAAI,GAAGP,IAAI,CAACO,IAAI;EAEpB,OAAOR,eAAe,CAACQ,IAAI,CAAC,EAAE;IAC1BA,IAAI,GAAGA,IAAI,CAACC,KAAK;EACrB;EACA,OAAOD,IAAI;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASE,QAAQA,CAACT,IAAI,EAAE;EACpB,IAAIQ,KAAK,GAAGR,IAAI,CAACQ,KAAK;EAEtB,OAAOT,eAAe,CAACS,KAAK,CAAC,EAAE;IAC3BA,KAAK,GAAGA,KAAK,CAACD,IAAI;EACtB;EACA,OAAOC,KAAK;AAChB;;AAEA;AACA;AACA;;AAEAE,MAAM,CAACC,OAAO,GAAG;EACbC,IAAI,EAAE;IACFX,IAAI,EAAE,YAAY;IAElBY,IAAI,EAAE;MACFC,WAAW,EAAE,qEAAqE;MAClFC,QAAQ,EAAE,gBAAgB;MAC1BC,WAAW,EAAE,KAAK;MAClBC,GAAG,EAAE;IACT,CAAC;IAEDC,MAAM,EAAE,EAAE;IAEVC,QAAQ,EAAE;MACNC,gBAAgB,EAAE;IACtB;EACJ,CAAC;EAEDC,MAAMA,CAACC,OAAO,EAAE;IACZ,MAAMC,UAAU,GAAGD,OAAO,CAACE,aAAa,CAAC,CAAC;IAE1C,OAAO;MACHC,gBAAgBA,CAACzB,IAAI,EAAE;QAEnB;QACA,IAAIA,IAAI,CAACE,QAAQ,KAAK,GAAG,EAAE;UACvB;QACJ;;QAEA;QACA,MAAMK,IAAI,GAAGD,OAAO,CAACN,IAAI,CAAC;QAC1B,MAAMQ,KAAK,GAAGC,QAAQ,CAACT,IAAI,CAAC;QAE5B,IAAIH,QAAQ,CAAC6B,eAAe,CAACnB,IAAI,CAAC,IAC9BV,QAAQ,CAAC6B,eAAe,CAAClB,KAAK,CAAC,IAC/BX,QAAQ,CAAC8B,iBAAiB,CAACpB,IAAI,EAAEC,KAAK,CAAC,EACzC;UACE,MAAMoB,aAAa,GAAGL,UAAU,CAACM,oBAAoB,CAACtB,IAAI,EAAEC,KAAK,EAAEL,qBAAqB,CAAC;UAEzFmB,OAAO,CAACQ,MAAM,CAAC;YACX9B,IAAI;YACJ+B,GAAG,EAAEH,aAAa,CAACG,GAAG;YACtBC,SAAS,EAAE;UACf,CAAC,CAAC;QACN;MACJ;IACJ,CAAC;EACL;AACJ,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}