{"ast":null,"code":"/**\n * @fileoverview Disallow Labeled Statements\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow labeled statements\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-labels\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        allowLoop: {\n          type: \"boolean\",\n          default: false\n        },\n        allowSwitch: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unexpectedLabel: \"Unexpected labeled statement.\",\n      unexpectedLabelInBreak: \"Unexpected label in break statement.\",\n      unexpectedLabelInContinue: \"Unexpected label in continue statement.\"\n    }\n  },\n  create(context) {\n    const options = context.options[0];\n    const allowLoop = options && options.allowLoop;\n    const allowSwitch = options && options.allowSwitch;\n    let scopeInfo = null;\n\n    /**\n     * Gets the kind of a given node.\n     * @param {ASTNode} node A node to get.\n     * @returns {string} The kind of the node.\n     */\n    function getBodyKind(node) {\n      if (astUtils.isLoop(node)) {\n        return \"loop\";\n      }\n      if (node.type === \"SwitchStatement\") {\n        return \"switch\";\n      }\n      return \"other\";\n    }\n\n    /**\n     * Checks whether the label of a given kind is allowed or not.\n     * @param {string} kind A kind to check.\n     * @returns {boolean} `true` if the kind is allowed.\n     */\n    function isAllowed(kind) {\n      switch (kind) {\n        case \"loop\":\n          return allowLoop;\n        case \"switch\":\n          return allowSwitch;\n        default:\n          return false;\n      }\n    }\n\n    /**\n     * Checks whether a given name is a label of a loop or not.\n     * @param {string} label A name of a label to check.\n     * @returns {boolean} `true` if the name is a label of a loop.\n     */\n    function getKind(label) {\n      let info = scopeInfo;\n      while (info) {\n        if (info.label === label) {\n          return info.kind;\n        }\n        info = info.upper;\n      }\n\n      /* istanbul ignore next: syntax error */\n      return \"other\";\n    }\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    return {\n      LabeledStatement(node) {\n        scopeInfo = {\n          label: node.label.name,\n          kind: getBodyKind(node.body),\n          upper: scopeInfo\n        };\n      },\n      \"LabeledStatement:exit\"(node) {\n        if (!isAllowed(scopeInfo.kind)) {\n          context.report({\n            node,\n            messageId: \"unexpectedLabel\"\n          });\n        }\n        scopeInfo = scopeInfo.upper;\n      },\n      BreakStatement(node) {\n        if (node.label && !isAllowed(getKind(node.label.name))) {\n          context.report({\n            node,\n            messageId: \"unexpectedLabelInBreak\"\n          });\n        }\n      },\n      ContinueStatement(node) {\n        if (node.label && !isAllowed(getKind(node.label.name))) {\n          context.report({\n            node,\n            messageId: \"unexpectedLabelInContinue\"\n          });\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","module","exports","meta","type","docs","description","category","recommended","url","schema","properties","allowLoop","default","allowSwitch","additionalProperties","messages","unexpectedLabel","unexpectedLabelInBreak","unexpectedLabelInContinue","create","context","options","scopeInfo","getBodyKind","node","isLoop","isAllowed","kind","getKind","label","info","upper","LabeledStatement","name","body","LabeledStatement:exit","report","messageId","BreakStatement","ContinueStatement"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/no-labels.js"],"sourcesContent":["/**\n * @fileoverview Disallow Labeled Statements\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow labeled statements\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-labels\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allowLoop: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    allowSwitch: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            unexpectedLabel: \"Unexpected labeled statement.\",\n            unexpectedLabelInBreak: \"Unexpected label in break statement.\",\n            unexpectedLabelInContinue: \"Unexpected label in continue statement.\"\n        }\n    },\n\n    create(context) {\n        const options = context.options[0];\n        const allowLoop = options && options.allowLoop;\n        const allowSwitch = options && options.allowSwitch;\n        let scopeInfo = null;\n\n        /**\n         * Gets the kind of a given node.\n         * @param {ASTNode} node A node to get.\n         * @returns {string} The kind of the node.\n         */\n        function getBodyKind(node) {\n            if (astUtils.isLoop(node)) {\n                return \"loop\";\n            }\n            if (node.type === \"SwitchStatement\") {\n                return \"switch\";\n            }\n            return \"other\";\n        }\n\n        /**\n         * Checks whether the label of a given kind is allowed or not.\n         * @param {string} kind A kind to check.\n         * @returns {boolean} `true` if the kind is allowed.\n         */\n        function isAllowed(kind) {\n            switch (kind) {\n                case \"loop\": return allowLoop;\n                case \"switch\": return allowSwitch;\n                default: return false;\n            }\n        }\n\n        /**\n         * Checks whether a given name is a label of a loop or not.\n         * @param {string} label A name of a label to check.\n         * @returns {boolean} `true` if the name is a label of a loop.\n         */\n        function getKind(label) {\n            let info = scopeInfo;\n\n            while (info) {\n                if (info.label === label) {\n                    return info.kind;\n                }\n                info = info.upper;\n            }\n\n            /* istanbul ignore next: syntax error */\n            return \"other\";\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            LabeledStatement(node) {\n                scopeInfo = {\n                    label: node.label.name,\n                    kind: getBodyKind(node.body),\n                    upper: scopeInfo\n                };\n            },\n\n            \"LabeledStatement:exit\"(node) {\n                if (!isAllowed(scopeInfo.kind)) {\n                    context.report({\n                        node,\n                        messageId: \"unexpectedLabel\"\n                    });\n                }\n\n                scopeInfo = scopeInfo.upper;\n            },\n\n            BreakStatement(node) {\n                if (node.label && !isAllowed(getKind(node.label.name))) {\n                    context.report({\n                        node,\n                        messageId: \"unexpectedLabelInBreak\"\n                    });\n                }\n            },\n\n            ContinueStatement(node) {\n                if (node.label && !isAllowed(getKind(node.label.name))) {\n                    context.report({\n                        node,\n                        messageId: \"unexpectedLabelInContinue\"\n                    });\n                }\n            }\n        };\n\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}