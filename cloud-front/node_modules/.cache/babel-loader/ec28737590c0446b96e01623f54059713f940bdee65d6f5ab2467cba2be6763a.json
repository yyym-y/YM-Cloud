{"ast":null,"code":"/**\n * @fileoverview Rule to check for max length on a line.\n * @author Matt DuVall <http://www.mattduvall.com>\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\nrequire(\"core-js/modules/es.array.push.js\");\nconst OPTIONS_SCHEMA = {\n  type: \"object\",\n  properties: {\n    code: {\n      type: \"integer\",\n      minimum: 0\n    },\n    comments: {\n      type: \"integer\",\n      minimum: 0\n    },\n    tabWidth: {\n      type: \"integer\",\n      minimum: 0\n    },\n    ignorePattern: {\n      type: \"string\"\n    },\n    ignoreComments: {\n      type: \"boolean\"\n    },\n    ignoreStrings: {\n      type: \"boolean\"\n    },\n    ignoreUrls: {\n      type: \"boolean\"\n    },\n    ignoreTemplateLiterals: {\n      type: \"boolean\"\n    },\n    ignoreRegExpLiterals: {\n      type: \"boolean\"\n    },\n    ignoreTrailingComments: {\n      type: \"boolean\"\n    }\n  },\n  additionalProperties: false\n};\nconst OPTIONS_OR_INTEGER_SCHEMA = {\n  anyOf: [OPTIONS_SCHEMA, {\n    type: \"integer\",\n    minimum: 0\n  }]\n};\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce a maximum line length\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/max-len\"\n    },\n    schema: [OPTIONS_OR_INTEGER_SCHEMA, OPTIONS_OR_INTEGER_SCHEMA, OPTIONS_SCHEMA],\n    messages: {\n      max: \"This line has a length of {{lineLength}}. Maximum allowed is {{maxLength}}.\",\n      maxComment: \"This line has a comment length of {{lineLength}}. Maximum allowed is {{maxCommentLength}}.\"\n    }\n  },\n  create(context) {\n    /*\n     * Inspired by http://tools.ietf.org/html/rfc3986#appendix-B, however:\n     * - They're matching an entire string that we know is a URI\n     * - We're matching part of a string where we think there *might* be a URL\n     * - We're only concerned about URLs, as picking out any URI would cause\n     *   too many false positives\n     * - We don't care about matching the entire URL, any small segment is fine\n     */\n    const URL_REGEXP = /[^:/?#]:\\/\\/[^?#]/u;\n    const sourceCode = context.getSourceCode();\n\n    /**\n     * Computes the length of a line that may contain tabs. The width of each\n     * tab will be the number of spaces to the next tab stop.\n     * @param {string} line The line.\n     * @param {int} tabWidth The width of each tab stop in spaces.\n     * @returns {int} The computed line length.\n     * @private\n     */\n    function computeLineLength(line, tabWidth) {\n      let extraCharacterCount = 0;\n      line.replace(/\\t/gu, (match, offset) => {\n        const totalOffset = offset + extraCharacterCount,\n          previousTabStopOffset = tabWidth ? totalOffset % tabWidth : 0,\n          spaceCount = tabWidth - previousTabStopOffset;\n        extraCharacterCount += spaceCount - 1; // -1 for the replaced tab\n      });\n\n      return Array.from(line).length + extraCharacterCount;\n    }\n\n    // The options object must be the last option specified…\n    const options = Object.assign({}, context.options[context.options.length - 1]);\n\n    // …but max code length…\n    if (typeof context.options[0] === \"number\") {\n      options.code = context.options[0];\n    }\n\n    // …and tabWidth can be optionally specified directly as integers.\n    if (typeof context.options[1] === \"number\") {\n      options.tabWidth = context.options[1];\n    }\n    const maxLength = typeof options.code === \"number\" ? options.code : 80,\n      tabWidth = typeof options.tabWidth === \"number\" ? options.tabWidth : 4,\n      ignoreComments = !!options.ignoreComments,\n      ignoreStrings = !!options.ignoreStrings,\n      ignoreTemplateLiterals = !!options.ignoreTemplateLiterals,\n      ignoreRegExpLiterals = !!options.ignoreRegExpLiterals,\n      ignoreTrailingComments = !!options.ignoreTrailingComments || !!options.ignoreComments,\n      ignoreUrls = !!options.ignoreUrls,\n      maxCommentLength = options.comments;\n    let ignorePattern = options.ignorePattern || null;\n    if (ignorePattern) {\n      ignorePattern = new RegExp(ignorePattern, \"u\");\n    }\n\n    //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    /**\n     * Tells if a given comment is trailing: it starts on the current line and\n     * extends to or past the end of the current line.\n     * @param {string} line The source line we want to check for a trailing comment on\n     * @param {number} lineNumber The one-indexed line number for line\n     * @param {ASTNode} comment The comment to inspect\n     * @returns {boolean} If the comment is trailing on the given line\n     */\n    function isTrailingComment(line, lineNumber, comment) {\n      return comment && comment.loc.start.line === lineNumber && lineNumber <= comment.loc.end.line && (comment.loc.end.line > lineNumber || comment.loc.end.column === line.length);\n    }\n\n    /**\n     * Tells if a comment encompasses the entire line.\n     * @param {string} line The source line with a trailing comment\n     * @param {number} lineNumber The one-indexed line number this is on\n     * @param {ASTNode} comment The comment to remove\n     * @returns {boolean} If the comment covers the entire line\n     */\n    function isFullLineComment(line, lineNumber, comment) {\n      const start = comment.loc.start,\n        end = comment.loc.end,\n        isFirstTokenOnLine = !line.slice(0, comment.loc.start.column).trim();\n      return comment && (start.line < lineNumber || start.line === lineNumber && isFirstTokenOnLine) && (end.line > lineNumber || end.line === lineNumber && end.column === line.length);\n    }\n\n    /**\n     * Check if a node is a JSXEmptyExpression contained in a single line JSXExpressionContainer.\n     * @param {ASTNode} node A node to check.\n     * @returns {boolean} True if the node is a JSXEmptyExpression contained in a single line JSXExpressionContainer.\n     */\n    function isJSXEmptyExpressionInSingleLineContainer(node) {\n      if (!node || !node.parent || node.type !== \"JSXEmptyExpression\" || node.parent.type !== \"JSXExpressionContainer\") {\n        return false;\n      }\n      const parent = node.parent;\n      return parent.loc.start.line === parent.loc.end.line;\n    }\n\n    /**\n     * Gets the line after the comment and any remaining trailing whitespace is\n     * stripped.\n     * @param {string} line The source line with a trailing comment\n     * @param {ASTNode} comment The comment to remove\n     * @returns {string} Line without comment and trailing whitespace\n     */\n    function stripTrailingComment(line, comment) {\n      // loc.column is zero-indexed\n      return line.slice(0, comment.loc.start.column).replace(/\\s+$/u, \"\");\n    }\n\n    /**\n     * Ensure that an array exists at [key] on `object`, and add `value` to it.\n     * @param {Object} object the object to mutate\n     * @param {string} key the object's key\n     * @param {*} value the value to add\n     * @returns {void}\n     * @private\n     */\n    function ensureArrayAndPush(object, key, value) {\n      if (!Array.isArray(object[key])) {\n        object[key] = [];\n      }\n      object[key].push(value);\n    }\n\n    /**\n     * Retrieves an array containing all strings (\" or ') in the source code.\n     * @returns {ASTNode[]} An array of string nodes.\n     */\n    function getAllStrings() {\n      return sourceCode.ast.tokens.filter(token => token.type === \"String\" || token.type === \"JSXText\" && sourceCode.getNodeByRangeIndex(token.range[0] - 1).type === \"JSXAttribute\");\n    }\n\n    /**\n     * Retrieves an array containing all template literals in the source code.\n     * @returns {ASTNode[]} An array of template literal nodes.\n     */\n    function getAllTemplateLiterals() {\n      return sourceCode.ast.tokens.filter(token => token.type === \"Template\");\n    }\n\n    /**\n     * Retrieves an array containing all RegExp literals in the source code.\n     * @returns {ASTNode[]} An array of RegExp literal nodes.\n     */\n    function getAllRegExpLiterals() {\n      return sourceCode.ast.tokens.filter(token => token.type === \"RegularExpression\");\n    }\n\n    /**\n     * A reducer to group an AST node by line number, both start and end.\n     * @param {Object} acc the accumulator\n     * @param {ASTNode} node the AST node in question\n     * @returns {Object} the modified accumulator\n     * @private\n     */\n    function groupByLineNumber(acc, node) {\n      for (let i = node.loc.start.line; i <= node.loc.end.line; ++i) {\n        ensureArrayAndPush(acc, i, node);\n      }\n      return acc;\n    }\n\n    /**\n     * Returns an array of all comments in the source code.\n     * If the element in the array is a JSXEmptyExpression contained with a single line JSXExpressionContainer,\n     * the element is changed with JSXExpressionContainer node.\n     * @returns {ASTNode[]} An array of comment nodes\n     */\n    function getAllComments() {\n      const comments = [];\n      sourceCode.getAllComments().forEach(commentNode => {\n        const containingNode = sourceCode.getNodeByRangeIndex(commentNode.range[0]);\n        if (isJSXEmptyExpressionInSingleLineContainer(containingNode)) {\n          // push a unique node only\n          if (comments[comments.length - 1] !== containingNode.parent) {\n            comments.push(containingNode.parent);\n          }\n        } else {\n          comments.push(commentNode);\n        }\n      });\n      return comments;\n    }\n\n    /**\n     * Check the program for max length\n     * @param {ASTNode} node Node to examine\n     * @returns {void}\n     * @private\n     */\n    function checkProgramForMaxLength(node) {\n      // split (honors line-ending)\n      const lines = sourceCode.lines,\n        // list of comments to ignore\n        comments = ignoreComments || maxCommentLength || ignoreTrailingComments ? getAllComments() : [];\n\n      // we iterate over comments in parallel with the lines\n      let commentsIndex = 0;\n      const strings = getAllStrings();\n      const stringsByLine = strings.reduce(groupByLineNumber, {});\n      const templateLiterals = getAllTemplateLiterals();\n      const templateLiteralsByLine = templateLiterals.reduce(groupByLineNumber, {});\n      const regExpLiterals = getAllRegExpLiterals();\n      const regExpLiteralsByLine = regExpLiterals.reduce(groupByLineNumber, {});\n      lines.forEach((line, i) => {\n        // i is zero-indexed, line numbers are one-indexed\n        const lineNumber = i + 1;\n\n        /*\n         * if we're checking comment length; we need to know whether this\n         * line is a comment\n         */\n        let lineIsComment = false;\n        let textToMeasure;\n\n        /*\n         * We can short-circuit the comment checks if we're already out of\n         * comments to check.\n         */\n        if (commentsIndex < comments.length) {\n          let comment = null;\n\n          // iterate over comments until we find one past the current line\n          do {\n            comment = comments[++commentsIndex];\n          } while (comment && comment.loc.start.line <= lineNumber);\n\n          // and step back by one\n          comment = comments[--commentsIndex];\n          if (isFullLineComment(line, lineNumber, comment)) {\n            lineIsComment = true;\n            textToMeasure = line;\n          } else if (ignoreTrailingComments && isTrailingComment(line, lineNumber, comment)) {\n            textToMeasure = stripTrailingComment(line, comment);\n\n            // ignore multiple trailing comments in the same line\n            let lastIndex = commentsIndex;\n            while (isTrailingComment(textToMeasure, lineNumber, comments[--lastIndex])) {\n              textToMeasure = stripTrailingComment(textToMeasure, comments[lastIndex]);\n            }\n          } else {\n            textToMeasure = line;\n          }\n        } else {\n          textToMeasure = line;\n        }\n        if (ignorePattern && ignorePattern.test(textToMeasure) || ignoreUrls && URL_REGEXP.test(textToMeasure) || ignoreStrings && stringsByLine[lineNumber] || ignoreTemplateLiterals && templateLiteralsByLine[lineNumber] || ignoreRegExpLiterals && regExpLiteralsByLine[lineNumber]) {\n          // ignore this line\n          return;\n        }\n        const lineLength = computeLineLength(textToMeasure, tabWidth);\n        const commentLengthApplies = lineIsComment && maxCommentLength;\n        if (lineIsComment && ignoreComments) {\n          return;\n        }\n        const loc = {\n          start: {\n            line: lineNumber,\n            column: 0\n          },\n          end: {\n            line: lineNumber,\n            column: textToMeasure.length\n          }\n        };\n        if (commentLengthApplies) {\n          if (lineLength > maxCommentLength) {\n            context.report({\n              node,\n              loc,\n              messageId: \"maxComment\",\n              data: {\n                lineLength,\n                maxCommentLength\n              }\n            });\n          }\n        } else if (lineLength > maxLength) {\n          context.report({\n            node,\n            loc,\n            messageId: \"max\",\n            data: {\n              lineLength,\n              maxLength\n            }\n          });\n        }\n      });\n    }\n\n    //--------------------------------------------------------------------------\n    // Public API\n    //--------------------------------------------------------------------------\n\n    return {\n      Program: checkProgramForMaxLength\n    };\n  }\n};","map":{"version":3,"names":["require","OPTIONS_SCHEMA","type","properties","code","minimum","comments","tabWidth","ignorePattern","ignoreComments","ignoreStrings","ignoreUrls","ignoreTemplateLiterals","ignoreRegExpLiterals","ignoreTrailingComments","additionalProperties","OPTIONS_OR_INTEGER_SCHEMA","anyOf","module","exports","meta","docs","description","category","recommended","url","schema","messages","max","maxComment","create","context","URL_REGEXP","sourceCode","getSourceCode","computeLineLength","line","extraCharacterCount","replace","match","offset","totalOffset","previousTabStopOffset","spaceCount","Array","from","length","options","Object","assign","maxLength","maxCommentLength","RegExp","isTrailingComment","lineNumber","comment","loc","start","end","column","isFullLineComment","isFirstTokenOnLine","slice","trim","isJSXEmptyExpressionInSingleLineContainer","node","parent","stripTrailingComment","ensureArrayAndPush","object","key","value","isArray","push","getAllStrings","ast","tokens","filter","token","getNodeByRangeIndex","range","getAllTemplateLiterals","getAllRegExpLiterals","groupByLineNumber","acc","i","getAllComments","forEach","commentNode","containingNode","checkProgramForMaxLength","lines","commentsIndex","strings","stringsByLine","reduce","templateLiterals","templateLiteralsByLine","regExpLiterals","regExpLiteralsByLine","lineIsComment","textToMeasure","lastIndex","test","lineLength","commentLengthApplies","report","messageId","data","Program"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/max-len.js"],"sourcesContent":["/**\n * @fileoverview Rule to check for max length on a line.\n * @author Matt DuVall <http://www.mattduvall.com>\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\n\nconst OPTIONS_SCHEMA = {\n    type: \"object\",\n    properties: {\n        code: {\n            type: \"integer\",\n            minimum: 0\n        },\n        comments: {\n            type: \"integer\",\n            minimum: 0\n        },\n        tabWidth: {\n            type: \"integer\",\n            minimum: 0\n        },\n        ignorePattern: {\n            type: \"string\"\n        },\n        ignoreComments: {\n            type: \"boolean\"\n        },\n        ignoreStrings: {\n            type: \"boolean\"\n        },\n        ignoreUrls: {\n            type: \"boolean\"\n        },\n        ignoreTemplateLiterals: {\n            type: \"boolean\"\n        },\n        ignoreRegExpLiterals: {\n            type: \"boolean\"\n        },\n        ignoreTrailingComments: {\n            type: \"boolean\"\n        }\n    },\n    additionalProperties: false\n};\n\nconst OPTIONS_OR_INTEGER_SCHEMA = {\n    anyOf: [\n        OPTIONS_SCHEMA,\n        {\n            type: \"integer\",\n            minimum: 0\n        }\n    ]\n};\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce a maximum line length\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/max-len\"\n        },\n\n        schema: [\n            OPTIONS_OR_INTEGER_SCHEMA,\n            OPTIONS_OR_INTEGER_SCHEMA,\n            OPTIONS_SCHEMA\n        ],\n        messages: {\n            max: \"This line has a length of {{lineLength}}. Maximum allowed is {{maxLength}}.\",\n            maxComment: \"This line has a comment length of {{lineLength}}. Maximum allowed is {{maxCommentLength}}.\"\n        }\n    },\n\n    create(context) {\n\n        /*\n         * Inspired by http://tools.ietf.org/html/rfc3986#appendix-B, however:\n         * - They're matching an entire string that we know is a URI\n         * - We're matching part of a string where we think there *might* be a URL\n         * - We're only concerned about URLs, as picking out any URI would cause\n         *   too many false positives\n         * - We don't care about matching the entire URL, any small segment is fine\n         */\n        const URL_REGEXP = /[^:/?#]:\\/\\/[^?#]/u;\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Computes the length of a line that may contain tabs. The width of each\n         * tab will be the number of spaces to the next tab stop.\n         * @param {string} line The line.\n         * @param {int} tabWidth The width of each tab stop in spaces.\n         * @returns {int} The computed line length.\n         * @private\n         */\n        function computeLineLength(line, tabWidth) {\n            let extraCharacterCount = 0;\n\n            line.replace(/\\t/gu, (match, offset) => {\n                const totalOffset = offset + extraCharacterCount,\n                    previousTabStopOffset = tabWidth ? totalOffset % tabWidth : 0,\n                    spaceCount = tabWidth - previousTabStopOffset;\n\n                extraCharacterCount += spaceCount - 1; // -1 for the replaced tab\n            });\n            return Array.from(line).length + extraCharacterCount;\n        }\n\n        // The options object must be the last option specified…\n        const options = Object.assign({}, context.options[context.options.length - 1]);\n\n        // …but max code length…\n        if (typeof context.options[0] === \"number\") {\n            options.code = context.options[0];\n        }\n\n        // …and tabWidth can be optionally specified directly as integers.\n        if (typeof context.options[1] === \"number\") {\n            options.tabWidth = context.options[1];\n        }\n\n        const maxLength = typeof options.code === \"number\" ? options.code : 80,\n            tabWidth = typeof options.tabWidth === \"number\" ? options.tabWidth : 4,\n            ignoreComments = !!options.ignoreComments,\n            ignoreStrings = !!options.ignoreStrings,\n            ignoreTemplateLiterals = !!options.ignoreTemplateLiterals,\n            ignoreRegExpLiterals = !!options.ignoreRegExpLiterals,\n            ignoreTrailingComments = !!options.ignoreTrailingComments || !!options.ignoreComments,\n            ignoreUrls = !!options.ignoreUrls,\n            maxCommentLength = options.comments;\n        let ignorePattern = options.ignorePattern || null;\n\n        if (ignorePattern) {\n            ignorePattern = new RegExp(ignorePattern, \"u\");\n        }\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Tells if a given comment is trailing: it starts on the current line and\n         * extends to or past the end of the current line.\n         * @param {string} line The source line we want to check for a trailing comment on\n         * @param {number} lineNumber The one-indexed line number for line\n         * @param {ASTNode} comment The comment to inspect\n         * @returns {boolean} If the comment is trailing on the given line\n         */\n        function isTrailingComment(line, lineNumber, comment) {\n            return comment &&\n                (comment.loc.start.line === lineNumber && lineNumber <= comment.loc.end.line) &&\n                (comment.loc.end.line > lineNumber || comment.loc.end.column === line.length);\n        }\n\n        /**\n         * Tells if a comment encompasses the entire line.\n         * @param {string} line The source line with a trailing comment\n         * @param {number} lineNumber The one-indexed line number this is on\n         * @param {ASTNode} comment The comment to remove\n         * @returns {boolean} If the comment covers the entire line\n         */\n        function isFullLineComment(line, lineNumber, comment) {\n            const start = comment.loc.start,\n                end = comment.loc.end,\n                isFirstTokenOnLine = !line.slice(0, comment.loc.start.column).trim();\n\n            return comment &&\n                (start.line < lineNumber || (start.line === lineNumber && isFirstTokenOnLine)) &&\n                (end.line > lineNumber || (end.line === lineNumber && end.column === line.length));\n        }\n\n        /**\n         * Check if a node is a JSXEmptyExpression contained in a single line JSXExpressionContainer.\n         * @param {ASTNode} node A node to check.\n         * @returns {boolean} True if the node is a JSXEmptyExpression contained in a single line JSXExpressionContainer.\n         */\n        function isJSXEmptyExpressionInSingleLineContainer(node) {\n            if (!node || !node.parent || node.type !== \"JSXEmptyExpression\" || node.parent.type !== \"JSXExpressionContainer\") {\n                return false;\n            }\n\n            const parent = node.parent;\n\n            return parent.loc.start.line === parent.loc.end.line;\n        }\n\n        /**\n         * Gets the line after the comment and any remaining trailing whitespace is\n         * stripped.\n         * @param {string} line The source line with a trailing comment\n         * @param {ASTNode} comment The comment to remove\n         * @returns {string} Line without comment and trailing whitespace\n         */\n        function stripTrailingComment(line, comment) {\n\n            // loc.column is zero-indexed\n            return line.slice(0, comment.loc.start.column).replace(/\\s+$/u, \"\");\n        }\n\n        /**\n         * Ensure that an array exists at [key] on `object`, and add `value` to it.\n         * @param {Object} object the object to mutate\n         * @param {string} key the object's key\n         * @param {*} value the value to add\n         * @returns {void}\n         * @private\n         */\n        function ensureArrayAndPush(object, key, value) {\n            if (!Array.isArray(object[key])) {\n                object[key] = [];\n            }\n            object[key].push(value);\n        }\n\n        /**\n         * Retrieves an array containing all strings (\" or ') in the source code.\n         * @returns {ASTNode[]} An array of string nodes.\n         */\n        function getAllStrings() {\n            return sourceCode.ast.tokens.filter(token => (token.type === \"String\" ||\n                (token.type === \"JSXText\" && sourceCode.getNodeByRangeIndex(token.range[0] - 1).type === \"JSXAttribute\")));\n        }\n\n        /**\n         * Retrieves an array containing all template literals in the source code.\n         * @returns {ASTNode[]} An array of template literal nodes.\n         */\n        function getAllTemplateLiterals() {\n            return sourceCode.ast.tokens.filter(token => token.type === \"Template\");\n        }\n\n\n        /**\n         * Retrieves an array containing all RegExp literals in the source code.\n         * @returns {ASTNode[]} An array of RegExp literal nodes.\n         */\n        function getAllRegExpLiterals() {\n            return sourceCode.ast.tokens.filter(token => token.type === \"RegularExpression\");\n        }\n\n\n        /**\n         * A reducer to group an AST node by line number, both start and end.\n         * @param {Object} acc the accumulator\n         * @param {ASTNode} node the AST node in question\n         * @returns {Object} the modified accumulator\n         * @private\n         */\n        function groupByLineNumber(acc, node) {\n            for (let i = node.loc.start.line; i <= node.loc.end.line; ++i) {\n                ensureArrayAndPush(acc, i, node);\n            }\n            return acc;\n        }\n\n        /**\n         * Returns an array of all comments in the source code.\n         * If the element in the array is a JSXEmptyExpression contained with a single line JSXExpressionContainer,\n         * the element is changed with JSXExpressionContainer node.\n         * @returns {ASTNode[]} An array of comment nodes\n         */\n        function getAllComments() {\n            const comments = [];\n\n            sourceCode.getAllComments()\n                .forEach(commentNode => {\n                    const containingNode = sourceCode.getNodeByRangeIndex(commentNode.range[0]);\n\n                    if (isJSXEmptyExpressionInSingleLineContainer(containingNode)) {\n\n                        // push a unique node only\n                        if (comments[comments.length - 1] !== containingNode.parent) {\n                            comments.push(containingNode.parent);\n                        }\n                    } else {\n                        comments.push(commentNode);\n                    }\n                });\n\n            return comments;\n        }\n\n        /**\n         * Check the program for max length\n         * @param {ASTNode} node Node to examine\n         * @returns {void}\n         * @private\n         */\n        function checkProgramForMaxLength(node) {\n\n            // split (honors line-ending)\n            const lines = sourceCode.lines,\n\n                // list of comments to ignore\n                comments = ignoreComments || maxCommentLength || ignoreTrailingComments ? getAllComments() : [];\n\n            // we iterate over comments in parallel with the lines\n            let commentsIndex = 0;\n\n            const strings = getAllStrings();\n            const stringsByLine = strings.reduce(groupByLineNumber, {});\n\n            const templateLiterals = getAllTemplateLiterals();\n            const templateLiteralsByLine = templateLiterals.reduce(groupByLineNumber, {});\n\n            const regExpLiterals = getAllRegExpLiterals();\n            const regExpLiteralsByLine = regExpLiterals.reduce(groupByLineNumber, {});\n\n            lines.forEach((line, i) => {\n\n                // i is zero-indexed, line numbers are one-indexed\n                const lineNumber = i + 1;\n\n                /*\n                 * if we're checking comment length; we need to know whether this\n                 * line is a comment\n                 */\n                let lineIsComment = false;\n                let textToMeasure;\n\n                /*\n                 * We can short-circuit the comment checks if we're already out of\n                 * comments to check.\n                 */\n                if (commentsIndex < comments.length) {\n                    let comment = null;\n\n                    // iterate over comments until we find one past the current line\n                    do {\n                        comment = comments[++commentsIndex];\n                    } while (comment && comment.loc.start.line <= lineNumber);\n\n                    // and step back by one\n                    comment = comments[--commentsIndex];\n\n                    if (isFullLineComment(line, lineNumber, comment)) {\n                        lineIsComment = true;\n                        textToMeasure = line;\n                    } else if (ignoreTrailingComments && isTrailingComment(line, lineNumber, comment)) {\n                        textToMeasure = stripTrailingComment(line, comment);\n\n                        // ignore multiple trailing comments in the same line\n                        let lastIndex = commentsIndex;\n\n                        while (isTrailingComment(textToMeasure, lineNumber, comments[--lastIndex])) {\n                            textToMeasure = stripTrailingComment(textToMeasure, comments[lastIndex]);\n                        }\n                    } else {\n                        textToMeasure = line;\n                    }\n                } else {\n                    textToMeasure = line;\n                }\n                if (ignorePattern && ignorePattern.test(textToMeasure) ||\n                    ignoreUrls && URL_REGEXP.test(textToMeasure) ||\n                    ignoreStrings && stringsByLine[lineNumber] ||\n                    ignoreTemplateLiterals && templateLiteralsByLine[lineNumber] ||\n                    ignoreRegExpLiterals && regExpLiteralsByLine[lineNumber]\n                ) {\n\n                    // ignore this line\n                    return;\n                }\n\n                const lineLength = computeLineLength(textToMeasure, tabWidth);\n                const commentLengthApplies = lineIsComment && maxCommentLength;\n\n                if (lineIsComment && ignoreComments) {\n                    return;\n                }\n\n                const loc = {\n                    start: {\n                        line: lineNumber,\n                        column: 0\n                    },\n                    end: {\n                        line: lineNumber,\n                        column: textToMeasure.length\n                    }\n                };\n\n                if (commentLengthApplies) {\n                    if (lineLength > maxCommentLength) {\n                        context.report({\n                            node,\n                            loc,\n                            messageId: \"maxComment\",\n                            data: {\n                                lineLength,\n                                maxCommentLength\n                            }\n                        });\n                    }\n                } else if (lineLength > maxLength) {\n                    context.report({\n                        node,\n                        loc,\n                        messageId: \"max\",\n                        data: {\n                            lineLength,\n                            maxLength\n                        }\n                    });\n                }\n            });\n        }\n\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n            Program: checkProgramForMaxLength\n        };\n\n    }\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA,YAAY;;AAEZ;AACA;AACA;AAAAA,OAAA;AAEA,MAAMC,cAAc,GAAG;EACnBC,IAAI,EAAE,QAAQ;EACdC,UAAU,EAAE;IACRC,IAAI,EAAE;MACFF,IAAI,EAAE,SAAS;MACfG,OAAO,EAAE;IACb,CAAC;IACDC,QAAQ,EAAE;MACNJ,IAAI,EAAE,SAAS;MACfG,OAAO,EAAE;IACb,CAAC;IACDE,QAAQ,EAAE;MACNL,IAAI,EAAE,SAAS;MACfG,OAAO,EAAE;IACb,CAAC;IACDG,aAAa,EAAE;MACXN,IAAI,EAAE;IACV,CAAC;IACDO,cAAc,EAAE;MACZP,IAAI,EAAE;IACV,CAAC;IACDQ,aAAa,EAAE;MACXR,IAAI,EAAE;IACV,CAAC;IACDS,UAAU,EAAE;MACRT,IAAI,EAAE;IACV,CAAC;IACDU,sBAAsB,EAAE;MACpBV,IAAI,EAAE;IACV,CAAC;IACDW,oBAAoB,EAAE;MAClBX,IAAI,EAAE;IACV,CAAC;IACDY,sBAAsB,EAAE;MACpBZ,IAAI,EAAE;IACV;EACJ,CAAC;EACDa,oBAAoB,EAAE;AAC1B,CAAC;AAED,MAAMC,yBAAyB,GAAG;EAC9BC,KAAK,EAAE,CACHhB,cAAc,EACd;IACIC,IAAI,EAAE,SAAS;IACfG,OAAO,EAAE;EACb,CAAC;AAET,CAAC;;AAED;AACA;AACA;;AAEAa,MAAM,CAACC,OAAO,GAAG;EACbC,IAAI,EAAE;IACFlB,IAAI,EAAE,QAAQ;IAEdmB,IAAI,EAAE;MACFC,WAAW,EAAE,+BAA+B;MAC5CC,QAAQ,EAAE,kBAAkB;MAC5BC,WAAW,EAAE,KAAK;MAClBC,GAAG,EAAE;IACT,CAAC;IAEDC,MAAM,EAAE,CACJV,yBAAyB,EACzBA,yBAAyB,EACzBf,cAAc,CACjB;IACD0B,QAAQ,EAAE;MACNC,GAAG,EAAE,6EAA6E;MAClFC,UAAU,EAAE;IAChB;EACJ,CAAC;EAEDC,MAAMA,CAACC,OAAO,EAAE;IAEZ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;IACQ,MAAMC,UAAU,GAAG,oBAAoB;IAEvC,MAAMC,UAAU,GAAGF,OAAO,CAACG,aAAa,CAAC,CAAC;;IAE1C;AACR;AACA;AACA;AACA;AACA;AACA;AACA;IACQ,SAASC,iBAAiBA,CAACC,IAAI,EAAE7B,QAAQ,EAAE;MACvC,IAAI8B,mBAAmB,GAAG,CAAC;MAE3BD,IAAI,CAACE,OAAO,CAAC,MAAM,EAAE,CAACC,KAAK,EAAEC,MAAM,KAAK;QACpC,MAAMC,WAAW,GAAGD,MAAM,GAAGH,mBAAmB;UAC5CK,qBAAqB,GAAGnC,QAAQ,GAAGkC,WAAW,GAAGlC,QAAQ,GAAG,CAAC;UAC7DoC,UAAU,GAAGpC,QAAQ,GAAGmC,qBAAqB;QAEjDL,mBAAmB,IAAIM,UAAU,GAAG,CAAC,CAAC,CAAC;MAC3C,CAAC,CAAC;;MACF,OAAOC,KAAK,CAACC,IAAI,CAACT,IAAI,CAAC,CAACU,MAAM,GAAGT,mBAAmB;IACxD;;IAEA;IACA,MAAMU,OAAO,GAAGC,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAElB,OAAO,CAACgB,OAAO,CAAChB,OAAO,CAACgB,OAAO,CAACD,MAAM,GAAG,CAAC,CAAC,CAAC;;IAE9E;IACA,IAAI,OAAOf,OAAO,CAACgB,OAAO,CAAC,CAAC,CAAC,KAAK,QAAQ,EAAE;MACxCA,OAAO,CAAC3C,IAAI,GAAG2B,OAAO,CAACgB,OAAO,CAAC,CAAC,CAAC;IACrC;;IAEA;IACA,IAAI,OAAOhB,OAAO,CAACgB,OAAO,CAAC,CAAC,CAAC,KAAK,QAAQ,EAAE;MACxCA,OAAO,CAACxC,QAAQ,GAAGwB,OAAO,CAACgB,OAAO,CAAC,CAAC,CAAC;IACzC;IAEA,MAAMG,SAAS,GAAG,OAAOH,OAAO,CAAC3C,IAAI,KAAK,QAAQ,GAAG2C,OAAO,CAAC3C,IAAI,GAAG,EAAE;MAClEG,QAAQ,GAAG,OAAOwC,OAAO,CAACxC,QAAQ,KAAK,QAAQ,GAAGwC,OAAO,CAACxC,QAAQ,GAAG,CAAC;MACtEE,cAAc,GAAG,CAAC,CAACsC,OAAO,CAACtC,cAAc;MACzCC,aAAa,GAAG,CAAC,CAACqC,OAAO,CAACrC,aAAa;MACvCE,sBAAsB,GAAG,CAAC,CAACmC,OAAO,CAACnC,sBAAsB;MACzDC,oBAAoB,GAAG,CAAC,CAACkC,OAAO,CAAClC,oBAAoB;MACrDC,sBAAsB,GAAG,CAAC,CAACiC,OAAO,CAACjC,sBAAsB,IAAI,CAAC,CAACiC,OAAO,CAACtC,cAAc;MACrFE,UAAU,GAAG,CAAC,CAACoC,OAAO,CAACpC,UAAU;MACjCwC,gBAAgB,GAAGJ,OAAO,CAACzC,QAAQ;IACvC,IAAIE,aAAa,GAAGuC,OAAO,CAACvC,aAAa,IAAI,IAAI;IAEjD,IAAIA,aAAa,EAAE;MACfA,aAAa,GAAG,IAAI4C,MAAM,CAAC5C,aAAa,EAAE,GAAG,CAAC;IAClD;;IAEA;IACA;IACA;;IAEA;AACR;AACA;AACA;AACA;AACA;AACA;AACA;IACQ,SAAS6C,iBAAiBA,CAACjB,IAAI,EAAEkB,UAAU,EAAEC,OAAO,EAAE;MAClD,OAAOA,OAAO,IACTA,OAAO,CAACC,GAAG,CAACC,KAAK,CAACrB,IAAI,KAAKkB,UAAU,IAAIA,UAAU,IAAIC,OAAO,CAACC,GAAG,CAACE,GAAG,CAACtB,IAAK,KAC5EmB,OAAO,CAACC,GAAG,CAACE,GAAG,CAACtB,IAAI,GAAGkB,UAAU,IAAIC,OAAO,CAACC,GAAG,CAACE,GAAG,CAACC,MAAM,KAAKvB,IAAI,CAACU,MAAM,CAAC;IACrF;;IAEA;AACR;AACA;AACA;AACA;AACA;AACA;IACQ,SAASc,iBAAiBA,CAACxB,IAAI,EAAEkB,UAAU,EAAEC,OAAO,EAAE;MAClD,MAAME,KAAK,GAAGF,OAAO,CAACC,GAAG,CAACC,KAAK;QAC3BC,GAAG,GAAGH,OAAO,CAACC,GAAG,CAACE,GAAG;QACrBG,kBAAkB,GAAG,CAACzB,IAAI,CAAC0B,KAAK,CAAC,CAAC,EAAEP,OAAO,CAACC,GAAG,CAACC,KAAK,CAACE,MAAM,CAAC,CAACI,IAAI,CAAC,CAAC;MAExE,OAAOR,OAAO,KACTE,KAAK,CAACrB,IAAI,GAAGkB,UAAU,IAAKG,KAAK,CAACrB,IAAI,KAAKkB,UAAU,IAAIO,kBAAmB,CAAC,KAC7EH,GAAG,CAACtB,IAAI,GAAGkB,UAAU,IAAKI,GAAG,CAACtB,IAAI,KAAKkB,UAAU,IAAII,GAAG,CAACC,MAAM,KAAKvB,IAAI,CAACU,MAAO,CAAC;IAC1F;;IAEA;AACR;AACA;AACA;AACA;IACQ,SAASkB,yCAAyCA,CAACC,IAAI,EAAE;MACrD,IAAI,CAACA,IAAI,IAAI,CAACA,IAAI,CAACC,MAAM,IAAID,IAAI,CAAC/D,IAAI,KAAK,oBAAoB,IAAI+D,IAAI,CAACC,MAAM,CAAChE,IAAI,KAAK,wBAAwB,EAAE;QAC9G,OAAO,KAAK;MAChB;MAEA,MAAMgE,MAAM,GAAGD,IAAI,CAACC,MAAM;MAE1B,OAAOA,MAAM,CAACV,GAAG,CAACC,KAAK,CAACrB,IAAI,KAAK8B,MAAM,CAACV,GAAG,CAACE,GAAG,CAACtB,IAAI;IACxD;;IAEA;AACR;AACA;AACA;AACA;AACA;AACA;IACQ,SAAS+B,oBAAoBA,CAAC/B,IAAI,EAAEmB,OAAO,EAAE;MAEzC;MACA,OAAOnB,IAAI,CAAC0B,KAAK,CAAC,CAAC,EAAEP,OAAO,CAACC,GAAG,CAACC,KAAK,CAACE,MAAM,CAAC,CAACrB,OAAO,CAAC,OAAO,EAAE,EAAE,CAAC;IACvE;;IAEA;AACR;AACA;AACA;AACA;AACA;AACA;AACA;IACQ,SAAS8B,kBAAkBA,CAACC,MAAM,EAAEC,GAAG,EAAEC,KAAK,EAAE;MAC5C,IAAI,CAAC3B,KAAK,CAAC4B,OAAO,CAACH,MAAM,CAACC,GAAG,CAAC,CAAC,EAAE;QAC7BD,MAAM,CAACC,GAAG,CAAC,GAAG,EAAE;MACpB;MACAD,MAAM,CAACC,GAAG,CAAC,CAACG,IAAI,CAACF,KAAK,CAAC;IAC3B;;IAEA;AACR;AACA;AACA;IACQ,SAASG,aAAaA,CAAA,EAAG;MACrB,OAAOzC,UAAU,CAAC0C,GAAG,CAACC,MAAM,CAACC,MAAM,CAACC,KAAK,IAAKA,KAAK,CAAC5E,IAAI,KAAK,QAAQ,IAChE4E,KAAK,CAAC5E,IAAI,KAAK,SAAS,IAAI+B,UAAU,CAAC8C,mBAAmB,CAACD,KAAK,CAACE,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC9E,IAAI,KAAK,cAAgB,CAAC;IAClH;;IAEA;AACR;AACA;AACA;IACQ,SAAS+E,sBAAsBA,CAAA,EAAG;MAC9B,OAAOhD,UAAU,CAAC0C,GAAG,CAACC,MAAM,CAACC,MAAM,CAACC,KAAK,IAAIA,KAAK,CAAC5E,IAAI,KAAK,UAAU,CAAC;IAC3E;;IAGA;AACR;AACA;AACA;IACQ,SAASgF,oBAAoBA,CAAA,EAAG;MAC5B,OAAOjD,UAAU,CAAC0C,GAAG,CAACC,MAAM,CAACC,MAAM,CAACC,KAAK,IAAIA,KAAK,CAAC5E,IAAI,KAAK,mBAAmB,CAAC;IACpF;;IAGA;AACR;AACA;AACA;AACA;AACA;AACA;IACQ,SAASiF,iBAAiBA,CAACC,GAAG,EAAEnB,IAAI,EAAE;MAClC,KAAK,IAAIoB,CAAC,GAAGpB,IAAI,CAACT,GAAG,CAACC,KAAK,CAACrB,IAAI,EAAEiD,CAAC,IAAIpB,IAAI,CAACT,GAAG,CAACE,GAAG,CAACtB,IAAI,EAAE,EAAEiD,CAAC,EAAE;QAC3DjB,kBAAkB,CAACgB,GAAG,EAAEC,CAAC,EAAEpB,IAAI,CAAC;MACpC;MACA,OAAOmB,GAAG;IACd;;IAEA;AACR;AACA;AACA;AACA;AACA;IACQ,SAASE,cAAcA,CAAA,EAAG;MACtB,MAAMhF,QAAQ,GAAG,EAAE;MAEnB2B,UAAU,CAACqD,cAAc,CAAC,CAAC,CACtBC,OAAO,CAACC,WAAW,IAAI;QACpB,MAAMC,cAAc,GAAGxD,UAAU,CAAC8C,mBAAmB,CAACS,WAAW,CAACR,KAAK,CAAC,CAAC,CAAC,CAAC;QAE3E,IAAIhB,yCAAyC,CAACyB,cAAc,CAAC,EAAE;UAE3D;UACA,IAAInF,QAAQ,CAACA,QAAQ,CAACwC,MAAM,GAAG,CAAC,CAAC,KAAK2C,cAAc,CAACvB,MAAM,EAAE;YACzD5D,QAAQ,CAACmE,IAAI,CAACgB,cAAc,CAACvB,MAAM,CAAC;UACxC;QACJ,CAAC,MAAM;UACH5D,QAAQ,CAACmE,IAAI,CAACe,WAAW,CAAC;QAC9B;MACJ,CAAC,CAAC;MAEN,OAAOlF,QAAQ;IACnB;;IAEA;AACR;AACA;AACA;AACA;AACA;IACQ,SAASoF,wBAAwBA,CAACzB,IAAI,EAAE;MAEpC;MACA,MAAM0B,KAAK,GAAG1D,UAAU,CAAC0D,KAAK;QAE1B;QACArF,QAAQ,GAAGG,cAAc,IAAI0C,gBAAgB,IAAIrC,sBAAsB,GAAGwE,cAAc,CAAC,CAAC,GAAG,EAAE;;MAEnG;MACA,IAAIM,aAAa,GAAG,CAAC;MAErB,MAAMC,OAAO,GAAGnB,aAAa,CAAC,CAAC;MAC/B,MAAMoB,aAAa,GAAGD,OAAO,CAACE,MAAM,CAACZ,iBAAiB,EAAE,CAAC,CAAC,CAAC;MAE3D,MAAMa,gBAAgB,GAAGf,sBAAsB,CAAC,CAAC;MACjD,MAAMgB,sBAAsB,GAAGD,gBAAgB,CAACD,MAAM,CAACZ,iBAAiB,EAAE,CAAC,CAAC,CAAC;MAE7E,MAAMe,cAAc,GAAGhB,oBAAoB,CAAC,CAAC;MAC7C,MAAMiB,oBAAoB,GAAGD,cAAc,CAACH,MAAM,CAACZ,iBAAiB,EAAE,CAAC,CAAC,CAAC;MAEzEQ,KAAK,CAACJ,OAAO,CAAC,CAACnD,IAAI,EAAEiD,CAAC,KAAK;QAEvB;QACA,MAAM/B,UAAU,GAAG+B,CAAC,GAAG,CAAC;;QAExB;AAChB;AACA;AACA;QACgB,IAAIe,aAAa,GAAG,KAAK;QACzB,IAAIC,aAAa;;QAEjB;AAChB;AACA;AACA;QACgB,IAAIT,aAAa,GAAGtF,QAAQ,CAACwC,MAAM,EAAE;UACjC,IAAIS,OAAO,GAAG,IAAI;;UAElB;UACA,GAAG;YACCA,OAAO,GAAGjD,QAAQ,CAAC,EAAEsF,aAAa,CAAC;UACvC,CAAC,QAAQrC,OAAO,IAAIA,OAAO,CAACC,GAAG,CAACC,KAAK,CAACrB,IAAI,IAAIkB,UAAU;;UAExD;UACAC,OAAO,GAAGjD,QAAQ,CAAC,EAAEsF,aAAa,CAAC;UAEnC,IAAIhC,iBAAiB,CAACxB,IAAI,EAAEkB,UAAU,EAAEC,OAAO,CAAC,EAAE;YAC9C6C,aAAa,GAAG,IAAI;YACpBC,aAAa,GAAGjE,IAAI;UACxB,CAAC,MAAM,IAAItB,sBAAsB,IAAIuC,iBAAiB,CAACjB,IAAI,EAAEkB,UAAU,EAAEC,OAAO,CAAC,EAAE;YAC/E8C,aAAa,GAAGlC,oBAAoB,CAAC/B,IAAI,EAAEmB,OAAO,CAAC;;YAEnD;YACA,IAAI+C,SAAS,GAAGV,aAAa;YAE7B,OAAOvC,iBAAiB,CAACgD,aAAa,EAAE/C,UAAU,EAAEhD,QAAQ,CAAC,EAAEgG,SAAS,CAAC,CAAC,EAAE;cACxED,aAAa,GAAGlC,oBAAoB,CAACkC,aAAa,EAAE/F,QAAQ,CAACgG,SAAS,CAAC,CAAC;YAC5E;UACJ,CAAC,MAAM;YACHD,aAAa,GAAGjE,IAAI;UACxB;QACJ,CAAC,MAAM;UACHiE,aAAa,GAAGjE,IAAI;QACxB;QACA,IAAI5B,aAAa,IAAIA,aAAa,CAAC+F,IAAI,CAACF,aAAa,CAAC,IAClD1F,UAAU,IAAIqB,UAAU,CAACuE,IAAI,CAACF,aAAa,CAAC,IAC5C3F,aAAa,IAAIoF,aAAa,CAACxC,UAAU,CAAC,IAC1C1C,sBAAsB,IAAIqF,sBAAsB,CAAC3C,UAAU,CAAC,IAC5DzC,oBAAoB,IAAIsF,oBAAoB,CAAC7C,UAAU,CAAC,EAC1D;UAEE;UACA;QACJ;QAEA,MAAMkD,UAAU,GAAGrE,iBAAiB,CAACkE,aAAa,EAAE9F,QAAQ,CAAC;QAC7D,MAAMkG,oBAAoB,GAAGL,aAAa,IAAIjD,gBAAgB;QAE9D,IAAIiD,aAAa,IAAI3F,cAAc,EAAE;UACjC;QACJ;QAEA,MAAM+C,GAAG,GAAG;UACRC,KAAK,EAAE;YACHrB,IAAI,EAAEkB,UAAU;YAChBK,MAAM,EAAE;UACZ,CAAC;UACDD,GAAG,EAAE;YACDtB,IAAI,EAAEkB,UAAU;YAChBK,MAAM,EAAE0C,aAAa,CAACvD;UAC1B;QACJ,CAAC;QAED,IAAI2D,oBAAoB,EAAE;UACtB,IAAID,UAAU,GAAGrD,gBAAgB,EAAE;YAC/BpB,OAAO,CAAC2E,MAAM,CAAC;cACXzC,IAAI;cACJT,GAAG;cACHmD,SAAS,EAAE,YAAY;cACvBC,IAAI,EAAE;gBACFJ,UAAU;gBACVrD;cACJ;YACJ,CAAC,CAAC;UACN;QACJ,CAAC,MAAM,IAAIqD,UAAU,GAAGtD,SAAS,EAAE;UAC/BnB,OAAO,CAAC2E,MAAM,CAAC;YACXzC,IAAI;YACJT,GAAG;YACHmD,SAAS,EAAE,KAAK;YAChBC,IAAI,EAAE;cACFJ,UAAU;cACVtD;YACJ;UACJ,CAAC,CAAC;QACN;MACJ,CAAC,CAAC;IACN;;IAGA;IACA;IACA;;IAEA,OAAO;MACH2D,OAAO,EAAEnB;IACb,CAAC;EAEL;AACJ,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}