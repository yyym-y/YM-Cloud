{"ast":null,"code":"/**\n * @fileoverview The event generator for AST nodes.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nrequire(\"core-js/modules/es.array.push.js\");\nconst esquery = require(\"esquery\");\n\n//------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/**\n * An object describing an AST selector\n * @typedef {Object} ASTSelector\n * @property {string} rawSelector The string that was parsed into this selector\n * @property {boolean} isExit `true` if this should be emitted when exiting the node rather than when entering\n * @property {Object} parsedSelector An object (from esquery) describing the matching behavior of the selector\n * @property {string[]|null} listenerTypes A list of node types that could possibly cause the selector to match,\n * or `null` if all node types could cause a match\n * @property {number} attributeCount The total number of classes, pseudo-classes, and attribute queries in this selector\n * @property {number} identifierCount The total number of identifier queries in this selector\n */\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Computes the union of one or more arrays\n * @param {...any[]} arrays One or more arrays to union\n * @returns {any[]} The union of the input arrays\n */\nfunction union(...arrays) {\n  // TODO(stephenwade): Replace this with arrays.flat() when we drop support for Node v10\n  return [...new Set([].concat(...arrays))];\n}\n\n/**\n * Computes the intersection of one or more arrays\n * @param {...any[]} arrays One or more arrays to intersect\n * @returns {any[]} The intersection of the input arrays\n */\nfunction intersection(...arrays) {\n  if (arrays.length === 0) {\n    return [];\n  }\n  let result = [...new Set(arrays[0])];\n  for (const array of arrays.slice(1)) {\n    result = result.filter(x => array.includes(x));\n  }\n  return result;\n}\n\n/**\n * Gets the possible types of a selector\n * @param {Object} parsedSelector An object (from esquery) describing the matching behavior of the selector\n * @returns {string[]|null} The node types that could possibly trigger this selector, or `null` if all node types could trigger it\n */\nfunction getPossibleTypes(parsedSelector) {\n  switch (parsedSelector.type) {\n    case \"identifier\":\n      return [parsedSelector.value];\n    case \"matches\":\n      {\n        const typesForComponents = parsedSelector.selectors.map(getPossibleTypes);\n        if (typesForComponents.every(Boolean)) {\n          return union(...typesForComponents);\n        }\n        return null;\n      }\n    case \"compound\":\n      {\n        const typesForComponents = parsedSelector.selectors.map(getPossibleTypes).filter(typesForComponent => typesForComponent);\n\n        // If all of the components could match any type, then the compound could also match any type.\n        if (!typesForComponents.length) {\n          return null;\n        }\n\n        /*\n         * If at least one of the components could only match a particular type, the compound could only match\n         * the intersection of those types.\n         */\n        return intersection(...typesForComponents);\n      }\n    case \"child\":\n    case \"descendant\":\n    case \"sibling\":\n    case \"adjacent\":\n      return getPossibleTypes(parsedSelector.right);\n    default:\n      return null;\n  }\n}\n\n/**\n * Counts the number of class, pseudo-class, and attribute queries in this selector\n * @param {Object} parsedSelector An object (from esquery) describing the selector's matching behavior\n * @returns {number} The number of class, pseudo-class, and attribute queries in this selector\n */\nfunction countClassAttributes(parsedSelector) {\n  switch (parsedSelector.type) {\n    case \"child\":\n    case \"descendant\":\n    case \"sibling\":\n    case \"adjacent\":\n      return countClassAttributes(parsedSelector.left) + countClassAttributes(parsedSelector.right);\n    case \"compound\":\n    case \"not\":\n    case \"matches\":\n      return parsedSelector.selectors.reduce((sum, childSelector) => sum + countClassAttributes(childSelector), 0);\n    case \"attribute\":\n    case \"field\":\n    case \"nth-child\":\n    case \"nth-last-child\":\n      return 1;\n    default:\n      return 0;\n  }\n}\n\n/**\n * Counts the number of identifier queries in this selector\n * @param {Object} parsedSelector An object (from esquery) describing the selector's matching behavior\n * @returns {number} The number of identifier queries\n */\nfunction countIdentifiers(parsedSelector) {\n  switch (parsedSelector.type) {\n    case \"child\":\n    case \"descendant\":\n    case \"sibling\":\n    case \"adjacent\":\n      return countIdentifiers(parsedSelector.left) + countIdentifiers(parsedSelector.right);\n    case \"compound\":\n    case \"not\":\n    case \"matches\":\n      return parsedSelector.selectors.reduce((sum, childSelector) => sum + countIdentifiers(childSelector), 0);\n    case \"identifier\":\n      return 1;\n    default:\n      return 0;\n  }\n}\n\n/**\n * Compares the specificity of two selector objects, with CSS-like rules.\n * @param {ASTSelector} selectorA An AST selector descriptor\n * @param {ASTSelector} selectorB Another AST selector descriptor\n * @returns {number}\n * a value less than 0 if selectorA is less specific than selectorB\n * a value greater than 0 if selectorA is more specific than selectorB\n * a value less than 0 if selectorA and selectorB have the same specificity, and selectorA <= selectorB alphabetically\n * a value greater than 0 if selectorA and selectorB have the same specificity, and selectorA > selectorB alphabetically\n */\nfunction compareSpecificity(selectorA, selectorB) {\n  return selectorA.attributeCount - selectorB.attributeCount || selectorA.identifierCount - selectorB.identifierCount || (selectorA.rawSelector <= selectorB.rawSelector ? -1 : 1);\n}\n\n/**\n * Parses a raw selector string, and throws a useful error if parsing fails.\n * @param {string} rawSelector A raw AST selector\n * @returns {Object} An object (from esquery) describing the matching behavior of this selector\n * @throws {Error} An error if the selector is invalid\n */\nfunction tryParseSelector(rawSelector) {\n  try {\n    return esquery.parse(rawSelector.replace(/:exit$/u, \"\"));\n  } catch (err) {\n    if (err.location && err.location.start && typeof err.location.start.offset === \"number\") {\n      throw new SyntaxError(`Syntax error in selector \"${rawSelector}\" at position ${err.location.start.offset}: ${err.message}`);\n    }\n    throw err;\n  }\n}\nconst selectorCache = new Map();\n\n/**\n * Parses a raw selector string, and returns the parsed selector along with specificity and type information.\n * @param {string} rawSelector A raw AST selector\n * @returns {ASTSelector} A selector descriptor\n */\nfunction parseSelector(rawSelector) {\n  if (selectorCache.has(rawSelector)) {\n    return selectorCache.get(rawSelector);\n  }\n  const parsedSelector = tryParseSelector(rawSelector);\n  const result = {\n    rawSelector,\n    isExit: rawSelector.endsWith(\":exit\"),\n    parsedSelector,\n    listenerTypes: getPossibleTypes(parsedSelector),\n    attributeCount: countClassAttributes(parsedSelector),\n    identifierCount: countIdentifiers(parsedSelector)\n  };\n  selectorCache.set(rawSelector, result);\n  return result;\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * The event generator for AST nodes.\n * This implements below interface.\n *\n * ```ts\n * interface EventGenerator {\n *     emitter: SafeEmitter;\n *     enterNode(node: ASTNode): void;\n *     leaveNode(node: ASTNode): void;\n * }\n * ```\n */\nclass NodeEventGenerator {\n  // eslint-disable-next-line jsdoc/require-description\n  /**\n   * @param {SafeEmitter} emitter\n   * An SafeEmitter which is the destination of events. This emitter must already\n   * have registered listeners for all of the events that it needs to listen for.\n   * (See lib/linter/safe-emitter.js for more details on `SafeEmitter`.)\n   * @param {ESQueryOptions} esqueryOptions `esquery` options for traversing custom nodes.\n   * @returns {NodeEventGenerator} new instance\n   */\n  constructor(emitter, esqueryOptions) {\n    this.emitter = emitter;\n    this.esqueryOptions = esqueryOptions;\n    this.currentAncestry = [];\n    this.enterSelectorsByNodeType = new Map();\n    this.exitSelectorsByNodeType = new Map();\n    this.anyTypeEnterSelectors = [];\n    this.anyTypeExitSelectors = [];\n    emitter.eventNames().forEach(rawSelector => {\n      const selector = parseSelector(rawSelector);\n      if (selector.listenerTypes) {\n        const typeMap = selector.isExit ? this.exitSelectorsByNodeType : this.enterSelectorsByNodeType;\n        selector.listenerTypes.forEach(nodeType => {\n          if (!typeMap.has(nodeType)) {\n            typeMap.set(nodeType, []);\n          }\n          typeMap.get(nodeType).push(selector);\n        });\n        return;\n      }\n      const selectors = selector.isExit ? this.anyTypeExitSelectors : this.anyTypeEnterSelectors;\n      selectors.push(selector);\n    });\n    this.anyTypeEnterSelectors.sort(compareSpecificity);\n    this.anyTypeExitSelectors.sort(compareSpecificity);\n    this.enterSelectorsByNodeType.forEach(selectorList => selectorList.sort(compareSpecificity));\n    this.exitSelectorsByNodeType.forEach(selectorList => selectorList.sort(compareSpecificity));\n  }\n\n  /**\n   * Checks a selector against a node, and emits it if it matches\n   * @param {ASTNode} node The node to check\n   * @param {ASTSelector} selector An AST selector descriptor\n   * @returns {void}\n   */\n  applySelector(node, selector) {\n    if (esquery.matches(node, selector.parsedSelector, this.currentAncestry, this.esqueryOptions)) {\n      this.emitter.emit(selector.rawSelector, node);\n    }\n  }\n\n  /**\n   * Applies all appropriate selectors to a node, in specificity order\n   * @param {ASTNode} node The node to check\n   * @param {boolean} isExit `false` if the node is currently being entered, `true` if it's currently being exited\n   * @returns {void}\n   */\n  applySelectors(node, isExit) {\n    const selectorsByNodeType = (isExit ? this.exitSelectorsByNodeType : this.enterSelectorsByNodeType).get(node.type) || [];\n    const anyTypeSelectors = isExit ? this.anyTypeExitSelectors : this.anyTypeEnterSelectors;\n\n    /*\n     * selectorsByNodeType and anyTypeSelectors were already sorted by specificity in the constructor.\n     * Iterate through each of them, applying selectors in the right order.\n     */\n    let selectorsByTypeIndex = 0;\n    let anyTypeSelectorsIndex = 0;\n    while (selectorsByTypeIndex < selectorsByNodeType.length || anyTypeSelectorsIndex < anyTypeSelectors.length) {\n      if (selectorsByTypeIndex >= selectorsByNodeType.length || anyTypeSelectorsIndex < anyTypeSelectors.length && compareSpecificity(anyTypeSelectors[anyTypeSelectorsIndex], selectorsByNodeType[selectorsByTypeIndex]) < 0) {\n        this.applySelector(node, anyTypeSelectors[anyTypeSelectorsIndex++]);\n      } else {\n        this.applySelector(node, selectorsByNodeType[selectorsByTypeIndex++]);\n      }\n    }\n  }\n\n  /**\n   * Emits an event of entering AST node.\n   * @param {ASTNode} node A node which was entered.\n   * @returns {void}\n   */\n  enterNode(node) {\n    if (node.parent) {\n      this.currentAncestry.unshift(node.parent);\n    }\n    this.applySelectors(node, false);\n  }\n\n  /**\n   * Emits an event of leaving AST node.\n   * @param {ASTNode} node A node which was left.\n   * @returns {void}\n   */\n  leaveNode(node) {\n    this.applySelectors(node, true);\n    this.currentAncestry.shift();\n  }\n}\nmodule.exports = NodeEventGenerator;","map":{"version":3,"names":["require","esquery","union","arrays","Set","concat","intersection","length","result","array","slice","filter","x","includes","getPossibleTypes","parsedSelector","type","value","typesForComponents","selectors","map","every","Boolean","typesForComponent","right","countClassAttributes","left","reduce","sum","childSelector","countIdentifiers","compareSpecificity","selectorA","selectorB","attributeCount","identifierCount","rawSelector","tryParseSelector","parse","replace","err","location","start","offset","SyntaxError","message","selectorCache","Map","parseSelector","has","get","isExit","endsWith","listenerTypes","set","NodeEventGenerator","constructor","emitter","esqueryOptions","currentAncestry","enterSelectorsByNodeType","exitSelectorsByNodeType","anyTypeEnterSelectors","anyTypeExitSelectors","eventNames","forEach","selector","typeMap","nodeType","push","sort","selectorList","applySelector","node","matches","emit","applySelectors","selectorsByNodeType","anyTypeSelectors","selectorsByTypeIndex","anyTypeSelectorsIndex","enterNode","parent","unshift","leaveNode","shift","module","exports"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/linter/node-event-generator.js"],"sourcesContent":["/**\n * @fileoverview The event generator for AST nodes.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst esquery = require(\"esquery\");\n\n//------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/**\n * An object describing an AST selector\n * @typedef {Object} ASTSelector\n * @property {string} rawSelector The string that was parsed into this selector\n * @property {boolean} isExit `true` if this should be emitted when exiting the node rather than when entering\n * @property {Object} parsedSelector An object (from esquery) describing the matching behavior of the selector\n * @property {string[]|null} listenerTypes A list of node types that could possibly cause the selector to match,\n * or `null` if all node types could cause a match\n * @property {number} attributeCount The total number of classes, pseudo-classes, and attribute queries in this selector\n * @property {number} identifierCount The total number of identifier queries in this selector\n */\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Computes the union of one or more arrays\n * @param {...any[]} arrays One or more arrays to union\n * @returns {any[]} The union of the input arrays\n */\nfunction union(...arrays) {\n\n    // TODO(stephenwade): Replace this with arrays.flat() when we drop support for Node v10\n    return [...new Set([].concat(...arrays))];\n}\n\n/**\n * Computes the intersection of one or more arrays\n * @param {...any[]} arrays One or more arrays to intersect\n * @returns {any[]} The intersection of the input arrays\n */\nfunction intersection(...arrays) {\n    if (arrays.length === 0) {\n        return [];\n    }\n\n    let result = [...new Set(arrays[0])];\n\n    for (const array of arrays.slice(1)) {\n        result = result.filter(x => array.includes(x));\n    }\n    return result;\n}\n\n/**\n * Gets the possible types of a selector\n * @param {Object} parsedSelector An object (from esquery) describing the matching behavior of the selector\n * @returns {string[]|null} The node types that could possibly trigger this selector, or `null` if all node types could trigger it\n */\nfunction getPossibleTypes(parsedSelector) {\n    switch (parsedSelector.type) {\n        case \"identifier\":\n            return [parsedSelector.value];\n\n        case \"matches\": {\n            const typesForComponents = parsedSelector.selectors.map(getPossibleTypes);\n\n            if (typesForComponents.every(Boolean)) {\n                return union(...typesForComponents);\n            }\n            return null;\n        }\n\n        case \"compound\": {\n            const typesForComponents = parsedSelector.selectors.map(getPossibleTypes).filter(typesForComponent => typesForComponent);\n\n            // If all of the components could match any type, then the compound could also match any type.\n            if (!typesForComponents.length) {\n                return null;\n            }\n\n            /*\n             * If at least one of the components could only match a particular type, the compound could only match\n             * the intersection of those types.\n             */\n            return intersection(...typesForComponents);\n        }\n\n        case \"child\":\n        case \"descendant\":\n        case \"sibling\":\n        case \"adjacent\":\n            return getPossibleTypes(parsedSelector.right);\n\n        default:\n            return null;\n\n    }\n}\n\n/**\n * Counts the number of class, pseudo-class, and attribute queries in this selector\n * @param {Object} parsedSelector An object (from esquery) describing the selector's matching behavior\n * @returns {number} The number of class, pseudo-class, and attribute queries in this selector\n */\nfunction countClassAttributes(parsedSelector) {\n    switch (parsedSelector.type) {\n        case \"child\":\n        case \"descendant\":\n        case \"sibling\":\n        case \"adjacent\":\n            return countClassAttributes(parsedSelector.left) + countClassAttributes(parsedSelector.right);\n\n        case \"compound\":\n        case \"not\":\n        case \"matches\":\n            return parsedSelector.selectors.reduce((sum, childSelector) => sum + countClassAttributes(childSelector), 0);\n\n        case \"attribute\":\n        case \"field\":\n        case \"nth-child\":\n        case \"nth-last-child\":\n            return 1;\n\n        default:\n            return 0;\n    }\n}\n\n/**\n * Counts the number of identifier queries in this selector\n * @param {Object} parsedSelector An object (from esquery) describing the selector's matching behavior\n * @returns {number} The number of identifier queries\n */\nfunction countIdentifiers(parsedSelector) {\n    switch (parsedSelector.type) {\n        case \"child\":\n        case \"descendant\":\n        case \"sibling\":\n        case \"adjacent\":\n            return countIdentifiers(parsedSelector.left) + countIdentifiers(parsedSelector.right);\n\n        case \"compound\":\n        case \"not\":\n        case \"matches\":\n            return parsedSelector.selectors.reduce((sum, childSelector) => sum + countIdentifiers(childSelector), 0);\n\n        case \"identifier\":\n            return 1;\n\n        default:\n            return 0;\n    }\n}\n\n/**\n * Compares the specificity of two selector objects, with CSS-like rules.\n * @param {ASTSelector} selectorA An AST selector descriptor\n * @param {ASTSelector} selectorB Another AST selector descriptor\n * @returns {number}\n * a value less than 0 if selectorA is less specific than selectorB\n * a value greater than 0 if selectorA is more specific than selectorB\n * a value less than 0 if selectorA and selectorB have the same specificity, and selectorA <= selectorB alphabetically\n * a value greater than 0 if selectorA and selectorB have the same specificity, and selectorA > selectorB alphabetically\n */\nfunction compareSpecificity(selectorA, selectorB) {\n    return selectorA.attributeCount - selectorB.attributeCount ||\n        selectorA.identifierCount - selectorB.identifierCount ||\n        (selectorA.rawSelector <= selectorB.rawSelector ? -1 : 1);\n}\n\n/**\n * Parses a raw selector string, and throws a useful error if parsing fails.\n * @param {string} rawSelector A raw AST selector\n * @returns {Object} An object (from esquery) describing the matching behavior of this selector\n * @throws {Error} An error if the selector is invalid\n */\nfunction tryParseSelector(rawSelector) {\n    try {\n        return esquery.parse(rawSelector.replace(/:exit$/u, \"\"));\n    } catch (err) {\n        if (err.location && err.location.start && typeof err.location.start.offset === \"number\") {\n            throw new SyntaxError(`Syntax error in selector \"${rawSelector}\" at position ${err.location.start.offset}: ${err.message}`);\n        }\n        throw err;\n    }\n}\n\nconst selectorCache = new Map();\n\n/**\n * Parses a raw selector string, and returns the parsed selector along with specificity and type information.\n * @param {string} rawSelector A raw AST selector\n * @returns {ASTSelector} A selector descriptor\n */\nfunction parseSelector(rawSelector) {\n    if (selectorCache.has(rawSelector)) {\n        return selectorCache.get(rawSelector);\n    }\n\n    const parsedSelector = tryParseSelector(rawSelector);\n\n    const result = {\n        rawSelector,\n        isExit: rawSelector.endsWith(\":exit\"),\n        parsedSelector,\n        listenerTypes: getPossibleTypes(parsedSelector),\n        attributeCount: countClassAttributes(parsedSelector),\n        identifierCount: countIdentifiers(parsedSelector)\n    };\n\n    selectorCache.set(rawSelector, result);\n    return result;\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * The event generator for AST nodes.\n * This implements below interface.\n *\n * ```ts\n * interface EventGenerator {\n *     emitter: SafeEmitter;\n *     enterNode(node: ASTNode): void;\n *     leaveNode(node: ASTNode): void;\n * }\n * ```\n */\nclass NodeEventGenerator {\n\n    // eslint-disable-next-line jsdoc/require-description\n    /**\n     * @param {SafeEmitter} emitter\n     * An SafeEmitter which is the destination of events. This emitter must already\n     * have registered listeners for all of the events that it needs to listen for.\n     * (See lib/linter/safe-emitter.js for more details on `SafeEmitter`.)\n     * @param {ESQueryOptions} esqueryOptions `esquery` options for traversing custom nodes.\n     * @returns {NodeEventGenerator} new instance\n     */\n    constructor(emitter, esqueryOptions) {\n        this.emitter = emitter;\n        this.esqueryOptions = esqueryOptions;\n        this.currentAncestry = [];\n        this.enterSelectorsByNodeType = new Map();\n        this.exitSelectorsByNodeType = new Map();\n        this.anyTypeEnterSelectors = [];\n        this.anyTypeExitSelectors = [];\n\n        emitter.eventNames().forEach(rawSelector => {\n            const selector = parseSelector(rawSelector);\n\n            if (selector.listenerTypes) {\n                const typeMap = selector.isExit ? this.exitSelectorsByNodeType : this.enterSelectorsByNodeType;\n\n                selector.listenerTypes.forEach(nodeType => {\n                    if (!typeMap.has(nodeType)) {\n                        typeMap.set(nodeType, []);\n                    }\n                    typeMap.get(nodeType).push(selector);\n                });\n                return;\n            }\n            const selectors = selector.isExit ? this.anyTypeExitSelectors : this.anyTypeEnterSelectors;\n\n            selectors.push(selector);\n        });\n\n        this.anyTypeEnterSelectors.sort(compareSpecificity);\n        this.anyTypeExitSelectors.sort(compareSpecificity);\n        this.enterSelectorsByNodeType.forEach(selectorList => selectorList.sort(compareSpecificity));\n        this.exitSelectorsByNodeType.forEach(selectorList => selectorList.sort(compareSpecificity));\n    }\n\n    /**\n     * Checks a selector against a node, and emits it if it matches\n     * @param {ASTNode} node The node to check\n     * @param {ASTSelector} selector An AST selector descriptor\n     * @returns {void}\n     */\n    applySelector(node, selector) {\n        if (esquery.matches(node, selector.parsedSelector, this.currentAncestry, this.esqueryOptions)) {\n            this.emitter.emit(selector.rawSelector, node);\n        }\n    }\n\n    /**\n     * Applies all appropriate selectors to a node, in specificity order\n     * @param {ASTNode} node The node to check\n     * @param {boolean} isExit `false` if the node is currently being entered, `true` if it's currently being exited\n     * @returns {void}\n     */\n    applySelectors(node, isExit) {\n        const selectorsByNodeType = (isExit ? this.exitSelectorsByNodeType : this.enterSelectorsByNodeType).get(node.type) || [];\n        const anyTypeSelectors = isExit ? this.anyTypeExitSelectors : this.anyTypeEnterSelectors;\n\n        /*\n         * selectorsByNodeType and anyTypeSelectors were already sorted by specificity in the constructor.\n         * Iterate through each of them, applying selectors in the right order.\n         */\n        let selectorsByTypeIndex = 0;\n        let anyTypeSelectorsIndex = 0;\n\n        while (selectorsByTypeIndex < selectorsByNodeType.length || anyTypeSelectorsIndex < anyTypeSelectors.length) {\n            if (\n                selectorsByTypeIndex >= selectorsByNodeType.length ||\n                anyTypeSelectorsIndex < anyTypeSelectors.length &&\n                compareSpecificity(anyTypeSelectors[anyTypeSelectorsIndex], selectorsByNodeType[selectorsByTypeIndex]) < 0\n            ) {\n                this.applySelector(node, anyTypeSelectors[anyTypeSelectorsIndex++]);\n            } else {\n                this.applySelector(node, selectorsByNodeType[selectorsByTypeIndex++]);\n            }\n        }\n    }\n\n    /**\n     * Emits an event of entering AST node.\n     * @param {ASTNode} node A node which was entered.\n     * @returns {void}\n     */\n    enterNode(node) {\n        if (node.parent) {\n            this.currentAncestry.unshift(node.parent);\n        }\n        this.applySelectors(node, false);\n    }\n\n    /**\n     * Emits an event of leaving AST node.\n     * @param {ASTNode} node A node which was left.\n     * @returns {void}\n     */\n    leaveNode(node) {\n        this.applySelectors(node, true);\n        this.currentAncestry.shift();\n    }\n}\n\nmodule.exports = NodeEventGenerator;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}