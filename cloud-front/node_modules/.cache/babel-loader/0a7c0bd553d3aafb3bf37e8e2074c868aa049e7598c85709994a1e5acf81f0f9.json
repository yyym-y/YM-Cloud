{"ast":null,"code":"/**\n * @fileoverview Rule to disallow mixed binary operators.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils.js\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst ARITHMETIC_OPERATORS = [\"+\", \"-\", \"*\", \"/\", \"%\", \"**\"];\nconst BITWISE_OPERATORS = [\"&\", \"|\", \"^\", \"~\", \"<<\", \">>\", \">>>\"];\nconst COMPARISON_OPERATORS = [\"==\", \"!=\", \"===\", \"!==\", \">\", \">=\", \"<\", \"<=\"];\nconst LOGICAL_OPERATORS = [\"&&\", \"||\"];\nconst RELATIONAL_OPERATORS = [\"in\", \"instanceof\"];\nconst TERNARY_OPERATOR = [\"?:\"];\nconst COALESCE_OPERATOR = [\"??\"];\nconst ALL_OPERATORS = [].concat(ARITHMETIC_OPERATORS, BITWISE_OPERATORS, COMPARISON_OPERATORS, LOGICAL_OPERATORS, RELATIONAL_OPERATORS, TERNARY_OPERATOR, COALESCE_OPERATOR);\nconst DEFAULT_GROUPS = [ARITHMETIC_OPERATORS, BITWISE_OPERATORS, COMPARISON_OPERATORS, LOGICAL_OPERATORS, RELATIONAL_OPERATORS];\nconst TARGET_NODE_TYPE = /^(?:Binary|Logical|Conditional)Expression$/u;\n\n/**\n * Normalizes options.\n * @param {Object|undefined} options A options object to normalize.\n * @returns {Object} Normalized option object.\n */\nfunction normalizeOptions(options = {}) {\n  const hasGroups = options.groups && options.groups.length > 0;\n  const groups = hasGroups ? options.groups : DEFAULT_GROUPS;\n  const allowSamePrecedence = options.allowSamePrecedence !== false;\n  return {\n    groups,\n    allowSamePrecedence\n  };\n}\n\n/**\n * Checks whether any group which includes both given operator exists or not.\n * @param {Array.<string[]>} groups A list of groups to check.\n * @param {string} left An operator.\n * @param {string} right Another operator.\n * @returns {boolean} `true` if such group existed.\n */\nfunction includesBothInAGroup(groups, left, right) {\n  return groups.some(group => group.indexOf(left) !== -1 && group.indexOf(right) !== -1);\n}\n\n/**\n * Checks whether the given node is a conditional expression and returns the test node else the left node.\n * @param {ASTNode} node A node which can be a BinaryExpression or a LogicalExpression node.\n * This parent node can be BinaryExpression, LogicalExpression\n *      , or a ConditionalExpression node\n * @returns {ASTNode} node the appropriate node(left or test).\n */\nfunction getChildNode(node) {\n  return node.type === \"ConditionalExpression\" ? node.test : node.left;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow mixed binary operators\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-mixed-operators\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        groups: {\n          type: \"array\",\n          items: {\n            type: \"array\",\n            items: {\n              enum: ALL_OPERATORS\n            },\n            minItems: 2,\n            uniqueItems: true\n          },\n          uniqueItems: true\n        },\n        allowSamePrecedence: {\n          type: \"boolean\",\n          default: true\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unexpectedMixedOperator: \"Unexpected mix of '{{leftOperator}}' and '{{rightOperator}}'. Use parentheses to clarify the intended order of operations.\"\n    }\n  },\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const options = normalizeOptions(context.options[0]);\n\n    /**\n     * Checks whether a given node should be ignored by options or not.\n     * @param {ASTNode} node A node to check. This is a BinaryExpression\n     *      node or a LogicalExpression node. This parent node is one of\n     *      them, too.\n     * @returns {boolean} `true` if the node should be ignored.\n     */\n    function shouldIgnore(node) {\n      const a = node;\n      const b = node.parent;\n      return !includesBothInAGroup(options.groups, a.operator, b.type === \"ConditionalExpression\" ? \"?:\" : b.operator) || options.allowSamePrecedence && astUtils.getPrecedence(a) === astUtils.getPrecedence(b);\n    }\n\n    /**\n     * Checks whether the operator of a given node is mixed with parent\n     * node's operator or not.\n     * @param {ASTNode} node A node to check. This is a BinaryExpression\n     *      node or a LogicalExpression node. This parent node is one of\n     *      them, too.\n     * @returns {boolean} `true` if the node was mixed.\n     */\n    function isMixedWithParent(node) {\n      return node.operator !== node.parent.operator && !astUtils.isParenthesised(sourceCode, node);\n    }\n\n    /**\n     * Gets the operator token of a given node.\n     * @param {ASTNode} node A node to check. This is a BinaryExpression\n     *      node or a LogicalExpression node.\n     * @returns {Token} The operator token of the node.\n     */\n    function getOperatorToken(node) {\n      return sourceCode.getTokenAfter(getChildNode(node), astUtils.isNotClosingParenToken);\n    }\n\n    /**\n     * Reports both the operator of a given node and the operator of the\n     * parent node.\n     * @param {ASTNode} node A node to check. This is a BinaryExpression\n     *      node or a LogicalExpression node. This parent node is one of\n     *      them, too.\n     * @returns {void}\n     */\n    function reportBothOperators(node) {\n      const parent = node.parent;\n      const left = getChildNode(parent) === node ? node : parent;\n      const right = getChildNode(parent) !== node ? node : parent;\n      const data = {\n        leftOperator: left.operator || \"?:\",\n        rightOperator: right.operator || \"?:\"\n      };\n      context.report({\n        node: left,\n        loc: getOperatorToken(left).loc,\n        messageId: \"unexpectedMixedOperator\",\n        data\n      });\n      context.report({\n        node: right,\n        loc: getOperatorToken(right).loc,\n        messageId: \"unexpectedMixedOperator\",\n        data\n      });\n    }\n\n    /**\n     * Checks between the operator of this node and the operator of the\n     * parent node.\n     * @param {ASTNode} node A node to check.\n     * @returns {void}\n     */\n    function check(node) {\n      if (TARGET_NODE_TYPE.test(node.parent.type) && isMixedWithParent(node) && !shouldIgnore(node)) {\n        reportBothOperators(node);\n      }\n    }\n    return {\n      BinaryExpression: check,\n      LogicalExpression: check\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","ARITHMETIC_OPERATORS","BITWISE_OPERATORS","COMPARISON_OPERATORS","LOGICAL_OPERATORS","RELATIONAL_OPERATORS","TERNARY_OPERATOR","COALESCE_OPERATOR","ALL_OPERATORS","concat","DEFAULT_GROUPS","TARGET_NODE_TYPE","normalizeOptions","options","hasGroups","groups","length","allowSamePrecedence","includesBothInAGroup","left","right","some","group","indexOf","getChildNode","node","type","test","module","exports","meta","docs","description","category","recommended","url","schema","properties","items","enum","minItems","uniqueItems","default","additionalProperties","messages","unexpectedMixedOperator","create","context","sourceCode","getSourceCode","shouldIgnore","a","b","parent","operator","getPrecedence","isMixedWithParent","isParenthesised","getOperatorToken","getTokenAfter","isNotClosingParenToken","reportBothOperators","data","leftOperator","rightOperator","report","loc","messageId","check","BinaryExpression","LogicalExpression"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/no-mixed-operators.js"],"sourcesContent":["/**\n * @fileoverview Rule to disallow mixed binary operators.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils.js\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst ARITHMETIC_OPERATORS = [\"+\", \"-\", \"*\", \"/\", \"%\", \"**\"];\nconst BITWISE_OPERATORS = [\"&\", \"|\", \"^\", \"~\", \"<<\", \">>\", \">>>\"];\nconst COMPARISON_OPERATORS = [\"==\", \"!=\", \"===\", \"!==\", \">\", \">=\", \"<\", \"<=\"];\nconst LOGICAL_OPERATORS = [\"&&\", \"||\"];\nconst RELATIONAL_OPERATORS = [\"in\", \"instanceof\"];\nconst TERNARY_OPERATOR = [\"?:\"];\nconst COALESCE_OPERATOR = [\"??\"];\nconst ALL_OPERATORS = [].concat(\n    ARITHMETIC_OPERATORS,\n    BITWISE_OPERATORS,\n    COMPARISON_OPERATORS,\n    LOGICAL_OPERATORS,\n    RELATIONAL_OPERATORS,\n    TERNARY_OPERATOR,\n    COALESCE_OPERATOR\n);\nconst DEFAULT_GROUPS = [\n    ARITHMETIC_OPERATORS,\n    BITWISE_OPERATORS,\n    COMPARISON_OPERATORS,\n    LOGICAL_OPERATORS,\n    RELATIONAL_OPERATORS\n];\nconst TARGET_NODE_TYPE = /^(?:Binary|Logical|Conditional)Expression$/u;\n\n/**\n * Normalizes options.\n * @param {Object|undefined} options A options object to normalize.\n * @returns {Object} Normalized option object.\n */\nfunction normalizeOptions(options = {}) {\n    const hasGroups = options.groups && options.groups.length > 0;\n    const groups = hasGroups ? options.groups : DEFAULT_GROUPS;\n    const allowSamePrecedence = options.allowSamePrecedence !== false;\n\n    return {\n        groups,\n        allowSamePrecedence\n    };\n}\n\n/**\n * Checks whether any group which includes both given operator exists or not.\n * @param {Array.<string[]>} groups A list of groups to check.\n * @param {string} left An operator.\n * @param {string} right Another operator.\n * @returns {boolean} `true` if such group existed.\n */\nfunction includesBothInAGroup(groups, left, right) {\n    return groups.some(group => group.indexOf(left) !== -1 && group.indexOf(right) !== -1);\n}\n\n/**\n * Checks whether the given node is a conditional expression and returns the test node else the left node.\n * @param {ASTNode} node A node which can be a BinaryExpression or a LogicalExpression node.\n * This parent node can be BinaryExpression, LogicalExpression\n *      , or a ConditionalExpression node\n * @returns {ASTNode} node the appropriate node(left or test).\n */\nfunction getChildNode(node) {\n    return node.type === \"ConditionalExpression\" ? node.test : node.left;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow mixed binary operators\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-mixed-operators\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    groups: {\n                        type: \"array\",\n                        items: {\n                            type: \"array\",\n                            items: { enum: ALL_OPERATORS },\n                            minItems: 2,\n                            uniqueItems: true\n                        },\n                        uniqueItems: true\n                    },\n                    allowSamePrecedence: {\n                        type: \"boolean\",\n                        default: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            unexpectedMixedOperator: \"Unexpected mix of '{{leftOperator}}' and '{{rightOperator}}'. Use parentheses to clarify the intended order of operations.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const options = normalizeOptions(context.options[0]);\n\n        /**\n         * Checks whether a given node should be ignored by options or not.\n         * @param {ASTNode} node A node to check. This is a BinaryExpression\n         *      node or a LogicalExpression node. This parent node is one of\n         *      them, too.\n         * @returns {boolean} `true` if the node should be ignored.\n         */\n        function shouldIgnore(node) {\n            const a = node;\n            const b = node.parent;\n\n            return (\n                !includesBothInAGroup(options.groups, a.operator, b.type === \"ConditionalExpression\" ? \"?:\" : b.operator) ||\n                (\n                    options.allowSamePrecedence &&\n                    astUtils.getPrecedence(a) === astUtils.getPrecedence(b)\n                )\n            );\n        }\n\n        /**\n         * Checks whether the operator of a given node is mixed with parent\n         * node's operator or not.\n         * @param {ASTNode} node A node to check. This is a BinaryExpression\n         *      node or a LogicalExpression node. This parent node is one of\n         *      them, too.\n         * @returns {boolean} `true` if the node was mixed.\n         */\n        function isMixedWithParent(node) {\n\n            return (\n                node.operator !== node.parent.operator &&\n                !astUtils.isParenthesised(sourceCode, node)\n            );\n        }\n\n        /**\n         * Gets the operator token of a given node.\n         * @param {ASTNode} node A node to check. This is a BinaryExpression\n         *      node or a LogicalExpression node.\n         * @returns {Token} The operator token of the node.\n         */\n        function getOperatorToken(node) {\n            return sourceCode.getTokenAfter(getChildNode(node), astUtils.isNotClosingParenToken);\n        }\n\n        /**\n         * Reports both the operator of a given node and the operator of the\n         * parent node.\n         * @param {ASTNode} node A node to check. This is a BinaryExpression\n         *      node or a LogicalExpression node. This parent node is one of\n         *      them, too.\n         * @returns {void}\n         */\n        function reportBothOperators(node) {\n            const parent = node.parent;\n            const left = (getChildNode(parent) === node) ? node : parent;\n            const right = (getChildNode(parent) !== node) ? node : parent;\n            const data = {\n                leftOperator: left.operator || \"?:\",\n                rightOperator: right.operator || \"?:\"\n            };\n\n            context.report({\n                node: left,\n                loc: getOperatorToken(left).loc,\n                messageId: \"unexpectedMixedOperator\",\n                data\n            });\n            context.report({\n                node: right,\n                loc: getOperatorToken(right).loc,\n                messageId: \"unexpectedMixedOperator\",\n                data\n            });\n        }\n\n        /**\n         * Checks between the operator of this node and the operator of the\n         * parent node.\n         * @param {ASTNode} node A node to check.\n         * @returns {void}\n         */\n        function check(node) {\n            if (\n                TARGET_NODE_TYPE.test(node.parent.type) &&\n                isMixedWithParent(node) &&\n                !shouldIgnore(node)\n            ) {\n                reportBothOperators(node);\n            }\n        }\n\n        return {\n            BinaryExpression: check,\n            LogicalExpression: check\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}