{"ast":null,"code":"'use strict';\n\nvar common = require('../common');\nvar Type = require('../type');\nvar YAML_FLOAT_PATTERN = new RegExp(\n// 2.5e4, 2.5 and integers\n'^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?' +\n// .2e4, .2\n// special case, seems not from spec\n'|\\\\.[0-9_]+(?:[eE][-+]?[0-9]+)?' +\n// 20:59\n'|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\\\.[0-9_]*' +\n// .inf\n'|[-+]?\\\\.(?:inf|Inf|INF)' +\n// .nan\n'|\\\\.(?:nan|NaN|NAN))$');\nfunction resolveYamlFloat(data) {\n  if (data === null) return false;\n  if (!YAML_FLOAT_PATTERN.test(data) ||\n  // Quick hack to not allow integers end with `_`\n  // Probably should update regexp & check speed\n  data[data.length - 1] === '_') {\n    return false;\n  }\n  return true;\n}\nfunction constructYamlFloat(data) {\n  var value, sign, base, digits;\n  value = data.replace(/_/g, '').toLowerCase();\n  sign = value[0] === '-' ? -1 : 1;\n  digits = [];\n  if ('+-'.indexOf(value[0]) >= 0) {\n    value = value.slice(1);\n  }\n  if (value === '.inf') {\n    return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;\n  } else if (value === '.nan') {\n    return NaN;\n  } else if (value.indexOf(':') >= 0) {\n    value.split(':').forEach(function (v) {\n      digits.unshift(parseFloat(v, 10));\n    });\n    value = 0.0;\n    base = 1;\n    digits.forEach(function (d) {\n      value += d * base;\n      base *= 60;\n    });\n    return sign * value;\n  }\n  return sign * parseFloat(value, 10);\n}\nvar SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;\nfunction representYamlFloat(object, style) {\n  var res;\n  if (isNaN(object)) {\n    switch (style) {\n      case 'lowercase':\n        return '.nan';\n      case 'uppercase':\n        return '.NAN';\n      case 'camelcase':\n        return '.NaN';\n    }\n  } else if (Number.POSITIVE_INFINITY === object) {\n    switch (style) {\n      case 'lowercase':\n        return '.inf';\n      case 'uppercase':\n        return '.INF';\n      case 'camelcase':\n        return '.Inf';\n    }\n  } else if (Number.NEGATIVE_INFINITY === object) {\n    switch (style) {\n      case 'lowercase':\n        return '-.inf';\n      case 'uppercase':\n        return '-.INF';\n      case 'camelcase':\n        return '-.Inf';\n    }\n  } else if (common.isNegativeZero(object)) {\n    return '-0.0';\n  }\n  res = object.toString(10);\n\n  // JS stringifier can build scientific format without dots: 5e-100,\n  // while YAML requres dot: 5.e-100. Fix it with simple hack\n\n  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;\n}\nfunction isFloat(object) {\n  return Object.prototype.toString.call(object) === '[object Number]' && (object % 1 !== 0 || common.isNegativeZero(object));\n}\nmodule.exports = new Type('tag:yaml.org,2002:float', {\n  kind: 'scalar',\n  resolve: resolveYamlFloat,\n  construct: constructYamlFloat,\n  predicate: isFloat,\n  represent: representYamlFloat,\n  defaultStyle: 'lowercase'\n});","map":{"version":3,"names":["common","require","Type","YAML_FLOAT_PATTERN","RegExp","resolveYamlFloat","data","test","length","constructYamlFloat","value","sign","base","digits","replace","toLowerCase","indexOf","slice","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","NaN","split","forEach","v","unshift","parseFloat","d","SCIENTIFIC_WITHOUT_DOT","representYamlFloat","object","style","res","isNaN","isNegativeZero","toString","isFloat","Object","prototype","call","module","exports","kind","resolve","construct","predicate","represent","defaultStyle"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/js-yaml/lib/js-yaml/type/float.js"],"sourcesContent":["'use strict';\n\nvar common = require('../common');\nvar Type   = require('../type');\n\nvar YAML_FLOAT_PATTERN = new RegExp(\n  // 2.5e4, 2.5 and integers\n  '^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?' +\n  // .2e4, .2\n  // special case, seems not from spec\n  '|\\\\.[0-9_]+(?:[eE][-+]?[0-9]+)?' +\n  // 20:59\n  '|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\\\.[0-9_]*' +\n  // .inf\n  '|[-+]?\\\\.(?:inf|Inf|INF)' +\n  // .nan\n  '|\\\\.(?:nan|NaN|NAN))$');\n\nfunction resolveYamlFloat(data) {\n  if (data === null) return false;\n\n  if (!YAML_FLOAT_PATTERN.test(data) ||\n      // Quick hack to not allow integers end with `_`\n      // Probably should update regexp & check speed\n      data[data.length - 1] === '_') {\n    return false;\n  }\n\n  return true;\n}\n\nfunction constructYamlFloat(data) {\n  var value, sign, base, digits;\n\n  value  = data.replace(/_/g, '').toLowerCase();\n  sign   = value[0] === '-' ? -1 : 1;\n  digits = [];\n\n  if ('+-'.indexOf(value[0]) >= 0) {\n    value = value.slice(1);\n  }\n\n  if (value === '.inf') {\n    return (sign === 1) ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;\n\n  } else if (value === '.nan') {\n    return NaN;\n\n  } else if (value.indexOf(':') >= 0) {\n    value.split(':').forEach(function (v) {\n      digits.unshift(parseFloat(v, 10));\n    });\n\n    value = 0.0;\n    base = 1;\n\n    digits.forEach(function (d) {\n      value += d * base;\n      base *= 60;\n    });\n\n    return sign * value;\n\n  }\n  return sign * parseFloat(value, 10);\n}\n\n\nvar SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;\n\nfunction representYamlFloat(object, style) {\n  var res;\n\n  if (isNaN(object)) {\n    switch (style) {\n      case 'lowercase': return '.nan';\n      case 'uppercase': return '.NAN';\n      case 'camelcase': return '.NaN';\n    }\n  } else if (Number.POSITIVE_INFINITY === object) {\n    switch (style) {\n      case 'lowercase': return '.inf';\n      case 'uppercase': return '.INF';\n      case 'camelcase': return '.Inf';\n    }\n  } else if (Number.NEGATIVE_INFINITY === object) {\n    switch (style) {\n      case 'lowercase': return '-.inf';\n      case 'uppercase': return '-.INF';\n      case 'camelcase': return '-.Inf';\n    }\n  } else if (common.isNegativeZero(object)) {\n    return '-0.0';\n  }\n\n  res = object.toString(10);\n\n  // JS stringifier can build scientific format without dots: 5e-100,\n  // while YAML requres dot: 5.e-100. Fix it with simple hack\n\n  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;\n}\n\nfunction isFloat(object) {\n  return (Object.prototype.toString.call(object) === '[object Number]') &&\n         (object % 1 !== 0 || common.isNegativeZero(object));\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:float', {\n  kind: 'scalar',\n  resolve: resolveYamlFloat,\n  construct: constructYamlFloat,\n  predicate: isFloat,\n  represent: representYamlFloat,\n  defaultStyle: 'lowercase'\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}