{"ast":null,"code":"/**\n * @fileoverview Disallows multiple blank lines.\n * implementation adapted from the no-trailing-spaces rule.\n * @author Greg Cochard\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\nrequire(\"core-js/modules/es.array.push.js\");\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"disallow multiple empty lines\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-multiple-empty-lines\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      type: \"object\",\n      properties: {\n        max: {\n          type: \"integer\",\n          minimum: 0\n        },\n        maxEOF: {\n          type: \"integer\",\n          minimum: 0\n        },\n        maxBOF: {\n          type: \"integer\",\n          minimum: 0\n        }\n      },\n      required: [\"max\"],\n      additionalProperties: false\n    }],\n    messages: {\n      blankBeginningOfFile: \"Too many blank lines at the beginning of file. Max of {{max}} allowed.\",\n      blankEndOfFile: \"Too many blank lines at the end of file. Max of {{max}} allowed.\",\n      consecutiveBlank: \"More than {{max}} blank {{pluralizedLines}} not allowed.\"\n    }\n  },\n  create(context) {\n    // Use options.max or 2 as default\n    let max = 2,\n      maxEOF = max,\n      maxBOF = max;\n    if (context.options.length) {\n      max = context.options[0].max;\n      maxEOF = typeof context.options[0].maxEOF !== \"undefined\" ? context.options[0].maxEOF : max;\n      maxBOF = typeof context.options[0].maxBOF !== \"undefined\" ? context.options[0].maxBOF : max;\n    }\n    const sourceCode = context.getSourceCode();\n\n    // Swallow the final newline, as some editors add it automatically and we don't want it to cause an issue\n    const allLines = sourceCode.lines[sourceCode.lines.length - 1] === \"\" ? sourceCode.lines.slice(0, -1) : sourceCode.lines;\n    const templateLiteralLines = new Set();\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    return {\n      TemplateLiteral(node) {\n        node.quasis.forEach(literalPart => {\n          // Empty lines have a semantic meaning if they're inside template literals. Don't count these as empty lines.\n          for (let ignoredLine = literalPart.loc.start.line; ignoredLine < literalPart.loc.end.line; ignoredLine++) {\n            templateLiteralLines.add(ignoredLine);\n          }\n        });\n      },\n      \"Program:exit\"(node) {\n        return allLines\n\n        // Given a list of lines, first get a list of line numbers that are non-empty.\n        .reduce((nonEmptyLineNumbers, line, index) => {\n          if (line.trim() || templateLiteralLines.has(index + 1)) {\n            nonEmptyLineNumbers.push(index + 1);\n          }\n          return nonEmptyLineNumbers;\n        }, [])\n\n        // Add a value at the end to allow trailing empty lines to be checked.\n        .concat(allLines.length + 1)\n\n        // Given two line numbers of non-empty lines, report the lines between if the difference is too large.\n        .reduce((lastLineNumber, lineNumber) => {\n          let messageId, maxAllowed;\n          if (lastLineNumber === 0) {\n            messageId = \"blankBeginningOfFile\";\n            maxAllowed = maxBOF;\n          } else if (lineNumber === allLines.length + 1) {\n            messageId = \"blankEndOfFile\";\n            maxAllowed = maxEOF;\n          } else {\n            messageId = \"consecutiveBlank\";\n            maxAllowed = max;\n          }\n          if (lineNumber - lastLineNumber - 1 > maxAllowed) {\n            context.report({\n              node,\n              loc: {\n                start: {\n                  line: lastLineNumber + maxAllowed + 1,\n                  column: 0\n                },\n                end: {\n                  line: lineNumber,\n                  column: 0\n                }\n              },\n              messageId,\n              data: {\n                max: maxAllowed,\n                pluralizedLines: maxAllowed === 1 ? \"line\" : \"lines\"\n              },\n              fix(fixer) {\n                const rangeStart = sourceCode.getIndexFromLoc({\n                  line: lastLineNumber + 1,\n                  column: 0\n                });\n\n                /*\n                 * The end of the removal range is usually the start index of the next line.\n                 * However, at the end of the file there is no next line, so the end of the\n                 * range is just the length of the text.\n                 */\n                const lineNumberAfterRemovedLines = lineNumber - maxAllowed;\n                const rangeEnd = lineNumberAfterRemovedLines <= allLines.length ? sourceCode.getIndexFromLoc({\n                  line: lineNumberAfterRemovedLines,\n                  column: 0\n                }) : sourceCode.text.length;\n                return fixer.removeRange([rangeStart, rangeEnd]);\n              }\n            });\n          }\n          return lineNumber;\n        }, 0);\n      }\n    };\n  }\n};","map":{"version":3,"names":["require","module","exports","meta","type","docs","description","category","recommended","url","fixable","schema","properties","max","minimum","maxEOF","maxBOF","required","additionalProperties","messages","blankBeginningOfFile","blankEndOfFile","consecutiveBlank","create","context","options","length","sourceCode","getSourceCode","allLines","lines","slice","templateLiteralLines","Set","TemplateLiteral","node","quasis","forEach","literalPart","ignoredLine","loc","start","line","end","add","Program:exit","reduce","nonEmptyLineNumbers","index","trim","has","push","concat","lastLineNumber","lineNumber","messageId","maxAllowed","report","column","data","pluralizedLines","fix","fixer","rangeStart","getIndexFromLoc","lineNumberAfterRemovedLines","rangeEnd","text","removeRange"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/no-multiple-empty-lines.js"],"sourcesContent":["/**\n * @fileoverview Disallows multiple blank lines.\n * implementation adapted from the no-trailing-spaces rule.\n * @author Greg Cochard\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"disallow multiple empty lines\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-multiple-empty-lines\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    max: {\n                        type: \"integer\",\n                        minimum: 0\n                    },\n                    maxEOF: {\n                        type: \"integer\",\n                        minimum: 0\n                    },\n                    maxBOF: {\n                        type: \"integer\",\n                        minimum: 0\n                    }\n                },\n                required: [\"max\"],\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            blankBeginningOfFile: \"Too many blank lines at the beginning of file. Max of {{max}} allowed.\",\n            blankEndOfFile: \"Too many blank lines at the end of file. Max of {{max}} allowed.\",\n            consecutiveBlank: \"More than {{max}} blank {{pluralizedLines}} not allowed.\"\n        }\n    },\n\n    create(context) {\n\n        // Use options.max or 2 as default\n        let max = 2,\n            maxEOF = max,\n            maxBOF = max;\n\n        if (context.options.length) {\n            max = context.options[0].max;\n            maxEOF = typeof context.options[0].maxEOF !== \"undefined\" ? context.options[0].maxEOF : max;\n            maxBOF = typeof context.options[0].maxBOF !== \"undefined\" ? context.options[0].maxBOF : max;\n        }\n\n        const sourceCode = context.getSourceCode();\n\n        // Swallow the final newline, as some editors add it automatically and we don't want it to cause an issue\n        const allLines = sourceCode.lines[sourceCode.lines.length - 1] === \"\" ? sourceCode.lines.slice(0, -1) : sourceCode.lines;\n        const templateLiteralLines = new Set();\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            TemplateLiteral(node) {\n                node.quasis.forEach(literalPart => {\n\n                    // Empty lines have a semantic meaning if they're inside template literals. Don't count these as empty lines.\n                    for (let ignoredLine = literalPart.loc.start.line; ignoredLine < literalPart.loc.end.line; ignoredLine++) {\n                        templateLiteralLines.add(ignoredLine);\n                    }\n                });\n            },\n            \"Program:exit\"(node) {\n                return allLines\n\n                    // Given a list of lines, first get a list of line numbers that are non-empty.\n                    .reduce((nonEmptyLineNumbers, line, index) => {\n                        if (line.trim() || templateLiteralLines.has(index + 1)) {\n                            nonEmptyLineNumbers.push(index + 1);\n                        }\n                        return nonEmptyLineNumbers;\n                    }, [])\n\n                    // Add a value at the end to allow trailing empty lines to be checked.\n                    .concat(allLines.length + 1)\n\n                    // Given two line numbers of non-empty lines, report the lines between if the difference is too large.\n                    .reduce((lastLineNumber, lineNumber) => {\n                        let messageId, maxAllowed;\n\n                        if (lastLineNumber === 0) {\n                            messageId = \"blankBeginningOfFile\";\n                            maxAllowed = maxBOF;\n                        } else if (lineNumber === allLines.length + 1) {\n                            messageId = \"blankEndOfFile\";\n                            maxAllowed = maxEOF;\n                        } else {\n                            messageId = \"consecutiveBlank\";\n                            maxAllowed = max;\n                        }\n\n                        if (lineNumber - lastLineNumber - 1 > maxAllowed) {\n                            context.report({\n                                node,\n                                loc: {\n                                    start: { line: lastLineNumber + maxAllowed + 1, column: 0 },\n                                    end: { line: lineNumber, column: 0 }\n                                },\n                                messageId,\n                                data: {\n                                    max: maxAllowed,\n                                    pluralizedLines: maxAllowed === 1 ? \"line\" : \"lines\"\n                                },\n                                fix(fixer) {\n                                    const rangeStart = sourceCode.getIndexFromLoc({ line: lastLineNumber + 1, column: 0 });\n\n                                    /*\n                                     * The end of the removal range is usually the start index of the next line.\n                                     * However, at the end of the file there is no next line, so the end of the\n                                     * range is just the length of the text.\n                                     */\n                                    const lineNumberAfterRemovedLines = lineNumber - maxAllowed;\n                                    const rangeEnd = lineNumberAfterRemovedLines <= allLines.length\n                                        ? sourceCode.getIndexFromLoc({ line: lineNumberAfterRemovedLines, column: 0 })\n                                        : sourceCode.text.length;\n\n                                    return fixer.removeRange([rangeStart, rangeEnd]);\n                                }\n                            });\n                        }\n\n                        return lineNumber;\n                    }, 0);\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}