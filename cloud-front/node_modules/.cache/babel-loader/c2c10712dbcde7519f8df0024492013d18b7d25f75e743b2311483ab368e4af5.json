{"ast":null,"code":"/**\n * @fileoverview Main CLI object.\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n/*\n * The CLI object should *not* call process.exit() directly. It should only return\n * exit codes. This allows other programs to use the CLI object and still control\n * when the program exits.\n */\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nrequire(\"core-js/modules/es.array.push.js\");\nconst fs = require(\"fs\");\nconst path = require(\"path\");\nconst defaultOptions = require(\"../../conf/default-cli-options\");\nconst pkg = require(\"../../package.json\");\nconst {\n  Legacy: {\n    ConfigOps,\n    naming,\n    CascadingConfigArrayFactory,\n    IgnorePattern,\n    getUsedExtractedConfigs,\n    ModuleResolver\n  }\n} = require(\"@eslint/eslintrc\");\nconst {\n  FileEnumerator\n} = require(\"./file-enumerator\");\nconst {\n  Linter\n} = require(\"../linter\");\nconst builtInRules = require(\"../rules\");\nconst loadRules = require(\"./load-rules\");\nconst hash = require(\"./hash\");\nconst LintResultCache = require(\"./lint-result-cache\");\nconst debug = require(\"debug\")(\"eslint:cli-engine\");\nconst validFixTypes = new Set([\"problem\", \"suggestion\", \"layout\"]);\n\n//------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n// For VSCode IntelliSense\n/** @typedef {import(\"../shared/types\").ConfigData} ConfigData */\n/** @typedef {import(\"../shared/types\").DeprecatedRuleInfo} DeprecatedRuleInfo */\n/** @typedef {import(\"../shared/types\").LintMessage} LintMessage */\n/** @typedef {import(\"../shared/types\").ParserOptions} ParserOptions */\n/** @typedef {import(\"../shared/types\").Plugin} Plugin */\n/** @typedef {import(\"../shared/types\").RuleConf} RuleConf */\n/** @typedef {import(\"../shared/types\").Rule} Rule */\n/** @typedef {ReturnType<CascadingConfigArrayFactory[\"getConfigArrayForFile\"]>} ConfigArray */\n/** @typedef {ReturnType<ConfigArray[\"extractConfig\"]>} ExtractedConfig */\n\n/**\n * The options to configure a CLI engine with.\n * @typedef {Object} CLIEngineOptions\n * @property {boolean} [allowInlineConfig] Enable or disable inline configuration comments.\n * @property {ConfigData} [baseConfig] Base config object, extended by all configs used with this CLIEngine instance\n * @property {boolean} [cache] Enable result caching.\n * @property {string} [cacheLocation] The cache file to use instead of .eslintcache.\n * @property {string} [configFile] The configuration file to use.\n * @property {string} [cwd] The value to use for the current working directory.\n * @property {string[]} [envs] An array of environments to load.\n * @property {string[]|null} [extensions] An array of file extensions to check.\n * @property {boolean|Function} [fix] Execute in autofix mode. If a function, should return a boolean.\n * @property {string[]} [fixTypes] Array of rule types to apply fixes for.\n * @property {string[]} [globals] An array of global variables to declare.\n * @property {boolean} [ignore] False disables use of .eslintignore.\n * @property {string} [ignorePath] The ignore file to use instead of .eslintignore.\n * @property {string|string[]} [ignorePattern] One or more glob patterns to ignore.\n * @property {boolean} [useEslintrc] False disables looking for .eslintrc\n * @property {string} [parser] The name of the parser to use.\n * @property {ParserOptions} [parserOptions] An object of parserOption settings to use.\n * @property {string[]} [plugins] An array of plugins to load.\n * @property {Record<string,RuleConf>} [rules] An object of rules to use.\n * @property {string[]} [rulePaths] An array of directories to load custom rules from.\n * @property {boolean} [reportUnusedDisableDirectives] `true` adds reports for unused eslint-disable directives\n * @property {boolean} [globInputPaths] Set to false to skip glob resolution of input file paths to lint (default: true). If false, each input file paths is assumed to be a non-glob path to an existing file.\n * @property {string} [resolvePluginsRelativeTo] The folder where plugins should be resolved from, defaulting to the CWD\n */\n\n/**\n * A linting result.\n * @typedef {Object} LintResult\n * @property {string} filePath The path to the file that was linted.\n * @property {LintMessage[]} messages All of the messages for the result.\n * @property {number} errorCount Number of errors for the result.\n * @property {number} warningCount Number of warnings for the result.\n * @property {number} fixableErrorCount Number of fixable errors for the result.\n * @property {number} fixableWarningCount Number of fixable warnings for the result.\n * @property {string} [source] The source code of the file that was linted.\n * @property {string} [output] The source code of the file that was linted, with as many fixes applied as possible.\n */\n\n/**\n * Linting results.\n * @typedef {Object} LintReport\n * @property {LintResult[]} results All of the result.\n * @property {number} errorCount Number of errors for the result.\n * @property {number} warningCount Number of warnings for the result.\n * @property {number} fixableErrorCount Number of fixable errors for the result.\n * @property {number} fixableWarningCount Number of fixable warnings for the result.\n * @property {DeprecatedRuleInfo[]} usedDeprecatedRules The list of used deprecated rules.\n */\n\n/**\n * Private data for CLIEngine.\n * @typedef {Object} CLIEngineInternalSlots\n * @property {Map<string, Plugin>} additionalPluginPool The map for additional plugins.\n * @property {string} cacheFilePath The path to the cache of lint results.\n * @property {CascadingConfigArrayFactory} configArrayFactory The factory of configs.\n * @property {(filePath: string) => boolean} defaultIgnores The default predicate function to check if a file ignored or not.\n * @property {FileEnumerator} fileEnumerator The file enumerator.\n * @property {ConfigArray[]} lastConfigArrays The list of config arrays that the last `executeOnFiles` or `executeOnText` used.\n * @property {LintResultCache|null} lintResultCache The cache of lint results.\n * @property {Linter} linter The linter instance which has loaded rules.\n * @property {CLIEngineOptions} options The normalized options of this instance.\n */\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/** @type {WeakMap<CLIEngine, CLIEngineInternalSlots>} */\nconst internalSlotsMap = new WeakMap();\n\n/**\n * Determines if each fix type in an array is supported by ESLint and throws\n * an error if not.\n * @param {string[]} fixTypes An array of fix types to check.\n * @returns {void}\n * @throws {Error} If an invalid fix type is found.\n */\nfunction validateFixTypes(fixTypes) {\n  for (const fixType of fixTypes) {\n    if (!validFixTypes.has(fixType)) {\n      throw new Error(`Invalid fix type \"${fixType}\" found.`);\n    }\n  }\n}\n\n/**\n * It will calculate the error and warning count for collection of messages per file\n * @param {LintMessage[]} messages Collection of messages\n * @returns {Object} Contains the stats\n * @private\n */\nfunction calculateStatsPerFile(messages) {\n  return messages.reduce((stat, message) => {\n    if (message.fatal || message.severity === 2) {\n      stat.errorCount++;\n      if (message.fatal) {\n        stat.fatalErrorCount++;\n      }\n      if (message.fix) {\n        stat.fixableErrorCount++;\n      }\n    } else {\n      stat.warningCount++;\n      if (message.fix) {\n        stat.fixableWarningCount++;\n      }\n    }\n    return stat;\n  }, {\n    errorCount: 0,\n    fatalErrorCount: 0,\n    warningCount: 0,\n    fixableErrorCount: 0,\n    fixableWarningCount: 0\n  });\n}\n\n/**\n * It will calculate the error and warning count for collection of results from all files\n * @param {LintResult[]} results Collection of messages from all the files\n * @returns {Object} Contains the stats\n * @private\n */\nfunction calculateStatsPerRun(results) {\n  return results.reduce((stat, result) => {\n    stat.errorCount += result.errorCount;\n    stat.fatalErrorCount += result.fatalErrorCount;\n    stat.warningCount += result.warningCount;\n    stat.fixableErrorCount += result.fixableErrorCount;\n    stat.fixableWarningCount += result.fixableWarningCount;\n    return stat;\n  }, {\n    errorCount: 0,\n    fatalErrorCount: 0,\n    warningCount: 0,\n    fixableErrorCount: 0,\n    fixableWarningCount: 0\n  });\n}\n\n/**\n * Processes an source code using ESLint.\n * @param {Object} config The config object.\n * @param {string} config.text The source code to verify.\n * @param {string} config.cwd The path to the current working directory.\n * @param {string|undefined} config.filePath The path to the file of `text`. If this is undefined, it uses `<text>`.\n * @param {ConfigArray} config.config The config.\n * @param {boolean} config.fix If `true` then it does fix.\n * @param {boolean} config.allowInlineConfig If `true` then it uses directive comments.\n * @param {boolean} config.reportUnusedDisableDirectives If `true` then it reports unused `eslint-disable` comments.\n * @param {FileEnumerator} config.fileEnumerator The file enumerator to check if a path is a target or not.\n * @param {Linter} config.linter The linter instance to verify.\n * @returns {LintResult} The result of linting.\n * @private\n */\nfunction verifyText({\n  text,\n  cwd,\n  filePath: providedFilePath,\n  config,\n  fix,\n  allowInlineConfig,\n  reportUnusedDisableDirectives,\n  fileEnumerator,\n  linter\n}) {\n  const filePath = providedFilePath || \"<text>\";\n  debug(`Lint ${filePath}`);\n\n  /*\n   * Verify.\n   * `config.extractConfig(filePath)` requires an absolute path, but `linter`\n   * doesn't know CWD, so it gives `linter` an absolute path always.\n   */\n  const filePathToVerify = filePath === \"<text>\" ? path.join(cwd, filePath) : filePath;\n  const {\n    fixed,\n    messages,\n    output\n  } = linter.verifyAndFix(text, config, {\n    allowInlineConfig,\n    filename: filePathToVerify,\n    fix,\n    reportUnusedDisableDirectives,\n    /**\n     * Check if the linter should adopt a given code block or not.\n     * @param {string} blockFilename The virtual filename of a code block.\n     * @returns {boolean} `true` if the linter should adopt the code block.\n     */\n    filterCodeBlock(blockFilename) {\n      return fileEnumerator.isTargetPath(blockFilename);\n    }\n  });\n\n  // Tweak and return.\n  const result = {\n    filePath,\n    messages,\n    ...calculateStatsPerFile(messages)\n  };\n  if (fixed) {\n    result.output = output;\n  }\n  if (result.errorCount + result.warningCount > 0 && typeof result.output === \"undefined\") {\n    result.source = text;\n  }\n  return result;\n}\n\n/**\n * Returns result with warning by ignore settings\n * @param {string} filePath File path of checked code\n * @param {string} baseDir  Absolute path of base directory\n * @returns {LintResult} Result with single warning\n * @private\n */\nfunction createIgnoreResult(filePath, baseDir) {\n  let message;\n  const isHidden = filePath.split(path.sep).find(segment => /^\\./u.test(segment));\n  const isInNodeModules = baseDir && path.relative(baseDir, filePath).startsWith(\"node_modules\");\n  if (isHidden) {\n    message = \"File ignored by default.  Use a negated ignore pattern (like \\\"--ignore-pattern '!<relative/path/to/filename>'\\\") to override.\";\n  } else if (isInNodeModules) {\n    message = \"File ignored by default. Use \\\"--ignore-pattern '!node_modules/*'\\\" to override.\";\n  } else {\n    message = \"File ignored because of a matching ignore pattern. Use \\\"--no-ignore\\\" to override.\";\n  }\n  return {\n    filePath: path.resolve(filePath),\n    messages: [{\n      fatal: false,\n      severity: 1,\n      message\n    }],\n    errorCount: 0,\n    warningCount: 1,\n    fixableErrorCount: 0,\n    fixableWarningCount: 0\n  };\n}\n\n/**\n * Get a rule.\n * @param {string} ruleId The rule ID to get.\n * @param {ConfigArray[]} configArrays The config arrays that have plugin rules.\n * @returns {Rule|null} The rule or null.\n */\nfunction getRule(ruleId, configArrays) {\n  for (const configArray of configArrays) {\n    const rule = configArray.pluginRules.get(ruleId);\n    if (rule) {\n      return rule;\n    }\n  }\n  return builtInRules.get(ruleId) || null;\n}\n\n/**\n * Collect used deprecated rules.\n * @param {ConfigArray[]} usedConfigArrays The config arrays which were used.\n * @returns {IterableIterator<DeprecatedRuleInfo>} Used deprecated rules.\n */\nfunction* iterateRuleDeprecationWarnings(usedConfigArrays) {\n  const processedRuleIds = new Set();\n\n  // Flatten used configs.\n  /** @type {ExtractedConfig[]} */\n  const configs = [].concat(...usedConfigArrays.map(getUsedExtractedConfigs));\n\n  // Traverse rule configs.\n  for (const config of configs) {\n    for (const [ruleId, ruleConfig] of Object.entries(config.rules)) {\n      // Skip if it was processed.\n      if (processedRuleIds.has(ruleId)) {\n        continue;\n      }\n      processedRuleIds.add(ruleId);\n\n      // Skip if it's not used.\n      if (!ConfigOps.getRuleSeverity(ruleConfig)) {\n        continue;\n      }\n      const rule = getRule(ruleId, usedConfigArrays);\n\n      // Skip if it's not deprecated.\n      if (!(rule && rule.meta && rule.meta.deprecated)) {\n        continue;\n      }\n\n      // This rule was used and deprecated.\n      yield {\n        ruleId,\n        replacedBy: rule.meta.replacedBy || []\n      };\n    }\n  }\n}\n\n/**\n * Checks if the given message is an error message.\n * @param {LintMessage} message The message to check.\n * @returns {boolean} Whether or not the message is an error message.\n * @private\n */\nfunction isErrorMessage(message) {\n  return message.severity === 2;\n}\n\n/**\n * return the cacheFile to be used by eslint, based on whether the provided parameter is\n * a directory or looks like a directory (ends in `path.sep`), in which case the file\n * name will be the `cacheFile/.cache_hashOfCWD`\n *\n * if cacheFile points to a file or looks like a file then in will just use that file\n * @param {string} cacheFile The name of file to be used to store the cache\n * @param {string} cwd Current working directory\n * @returns {string} the resolved path to the cache file\n */\nfunction getCacheFile(cacheFile, cwd) {\n  /*\n   * make sure the path separators are normalized for the environment/os\n   * keeping the trailing path separator if present\n   */\n  const normalizedCacheFile = path.normalize(cacheFile);\n  const resolvedCacheFile = path.resolve(cwd, normalizedCacheFile);\n  const looksLikeADirectory = normalizedCacheFile.slice(-1) === path.sep;\n\n  /**\n   * return the name for the cache file in case the provided parameter is a directory\n   * @returns {string} the resolved path to the cacheFile\n   */\n  function getCacheFileForDirectory() {\n    return path.join(resolvedCacheFile, `.cache_${hash(cwd)}`);\n  }\n  let fileStats;\n  try {\n    fileStats = fs.lstatSync(resolvedCacheFile);\n  } catch {\n    fileStats = null;\n  }\n\n  /*\n   * in case the file exists we need to verify if the provided path\n   * is a directory or a file. If it is a directory we want to create a file\n   * inside that directory\n   */\n  if (fileStats) {\n    /*\n     * is a directory or is a file, but the original file the user provided\n     * looks like a directory but `path.resolve` removed the `last path.sep`\n     * so we need to still treat this like a directory\n     */\n    if (fileStats.isDirectory() || looksLikeADirectory) {\n      return getCacheFileForDirectory();\n    }\n\n    // is file so just use that file\n    return resolvedCacheFile;\n  }\n\n  /*\n   * here we known the file or directory doesn't exist,\n   * so we will try to infer if its a directory if it looks like a directory\n   * for the current operating system.\n   */\n\n  // if the last character passed is a path separator we assume is a directory\n  if (looksLikeADirectory) {\n    return getCacheFileForDirectory();\n  }\n  return resolvedCacheFile;\n}\n\n/**\n * Convert a string array to a boolean map.\n * @param {string[]|null} keys The keys to assign true.\n * @param {boolean} defaultValue The default value for each property.\n * @param {string} displayName The property name which is used in error message.\n * @returns {Record<string,boolean>} The boolean map.\n */\nfunction toBooleanMap(keys, defaultValue, displayName) {\n  if (keys && !Array.isArray(keys)) {\n    throw new Error(`${displayName} must be an array.`);\n  }\n  if (keys && keys.length > 0) {\n    return keys.reduce((map, def) => {\n      const [key, value] = def.split(\":\");\n      if (key !== \"__proto__\") {\n        map[key] = value === void 0 ? defaultValue : value === \"true\";\n      }\n      return map;\n    }, {});\n  }\n  return void 0;\n}\n\n/**\n * Create a config data from CLI options.\n * @param {CLIEngineOptions} options The options\n * @returns {ConfigData|null} The created config data.\n */\nfunction createConfigDataFromOptions(options) {\n  const {\n    ignorePattern,\n    parser,\n    parserOptions,\n    plugins,\n    rules\n  } = options;\n  const env = toBooleanMap(options.envs, true, \"envs\");\n  const globals = toBooleanMap(options.globals, false, \"globals\");\n  if (env === void 0 && globals === void 0 && (ignorePattern === void 0 || ignorePattern.length === 0) && parser === void 0 && parserOptions === void 0 && plugins === void 0 && rules === void 0) {\n    return null;\n  }\n  return {\n    env,\n    globals,\n    ignorePatterns: ignorePattern,\n    parser,\n    parserOptions,\n    plugins,\n    rules\n  };\n}\n\n/**\n * Checks whether a directory exists at the given location\n * @param {string} resolvedPath A path from the CWD\n * @returns {boolean} `true` if a directory exists\n */\nfunction directoryExists(resolvedPath) {\n  try {\n    return fs.statSync(resolvedPath).isDirectory();\n  } catch (error) {\n    if (error && (error.code === \"ENOENT\" || error.code === \"ENOTDIR\")) {\n      return false;\n    }\n    throw error;\n  }\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nclass CLIEngine {\n  /**\n   * Creates a new instance of the core CLI engine.\n   * @param {CLIEngineOptions} providedOptions The options for this instance.\n   */\n  constructor(providedOptions) {\n    const options = Object.assign(Object.create(null), defaultOptions, {\n      cwd: process.cwd()\n    }, providedOptions);\n    if (options.fix === void 0) {\n      options.fix = false;\n    }\n    const additionalPluginPool = new Map();\n    const cacheFilePath = getCacheFile(options.cacheLocation || options.cacheFile, options.cwd);\n    const configArrayFactory = new CascadingConfigArrayFactory({\n      additionalPluginPool,\n      baseConfig: options.baseConfig || null,\n      cliConfig: createConfigDataFromOptions(options),\n      cwd: options.cwd,\n      ignorePath: options.ignorePath,\n      resolvePluginsRelativeTo: options.resolvePluginsRelativeTo,\n      rulePaths: options.rulePaths,\n      specificConfigPath: options.configFile,\n      useEslintrc: options.useEslintrc,\n      builtInRules,\n      loadRules,\n      eslintRecommendedPath: path.resolve(__dirname, \"../../conf/eslint-recommended.js\"),\n      eslintAllPath: path.resolve(__dirname, \"../../conf/eslint-all.js\")\n    });\n    const fileEnumerator = new FileEnumerator({\n      configArrayFactory,\n      cwd: options.cwd,\n      extensions: options.extensions,\n      globInputPaths: options.globInputPaths,\n      errorOnUnmatchedPattern: options.errorOnUnmatchedPattern,\n      ignore: options.ignore\n    });\n    const lintResultCache = options.cache ? new LintResultCache(cacheFilePath, options.cacheStrategy) : null;\n    const linter = new Linter({\n      cwd: options.cwd\n    });\n\n    /** @type {ConfigArray[]} */\n    const lastConfigArrays = [configArrayFactory.getConfigArrayForFile()];\n\n    // Store private data.\n    internalSlotsMap.set(this, {\n      additionalPluginPool,\n      cacheFilePath,\n      configArrayFactory,\n      defaultIgnores: IgnorePattern.createDefaultIgnore(options.cwd),\n      fileEnumerator,\n      lastConfigArrays,\n      lintResultCache,\n      linter,\n      options\n    });\n\n    // setup special filter for fixes\n    if (options.fix && options.fixTypes && options.fixTypes.length > 0) {\n      debug(`Using fix types ${options.fixTypes}`);\n\n      // throw an error if any invalid fix types are found\n      validateFixTypes(options.fixTypes);\n\n      // convert to Set for faster lookup\n      const fixTypes = new Set(options.fixTypes);\n\n      // save original value of options.fix in case it's a function\n      const originalFix = typeof options.fix === \"function\" ? options.fix : () => true;\n      options.fix = message => {\n        const rule = message.ruleId && getRule(message.ruleId, lastConfigArrays);\n        const matches = rule && rule.meta && fixTypes.has(rule.meta.type);\n        return matches && originalFix(message);\n      };\n    }\n  }\n  getRules() {\n    const {\n      lastConfigArrays\n    } = internalSlotsMap.get(this);\n    return new Map(function* () {\n      yield* builtInRules;\n      for (const configArray of lastConfigArrays) {\n        yield* configArray.pluginRules;\n      }\n    }());\n  }\n\n  /**\n   * Returns results that only contains errors.\n   * @param {LintResult[]} results The results to filter.\n   * @returns {LintResult[]} The filtered results.\n   */\n  static getErrorResults(results) {\n    const filtered = [];\n    results.forEach(result => {\n      const filteredMessages = result.messages.filter(isErrorMessage);\n      if (filteredMessages.length > 0) {\n        filtered.push({\n          ...result,\n          messages: filteredMessages,\n          errorCount: filteredMessages.length,\n          warningCount: 0,\n          fixableErrorCount: result.fixableErrorCount,\n          fixableWarningCount: 0\n        });\n      }\n    });\n    return filtered;\n  }\n\n  /**\n   * Outputs fixes from the given results to files.\n   * @param {LintReport} report The report object created by CLIEngine.\n   * @returns {void}\n   */\n  static outputFixes(report) {\n    report.results.filter(result => Object.prototype.hasOwnProperty.call(result, \"output\")).forEach(result => {\n      fs.writeFileSync(result.filePath, result.output);\n    });\n  }\n\n  /**\n   * Add a plugin by passing its configuration\n   * @param {string} name Name of the plugin.\n   * @param {Plugin} pluginObject Plugin configuration object.\n   * @returns {void}\n   */\n  addPlugin(name, pluginObject) {\n    const {\n      additionalPluginPool,\n      configArrayFactory,\n      lastConfigArrays\n    } = internalSlotsMap.get(this);\n    additionalPluginPool.set(name, pluginObject);\n    configArrayFactory.clearCache();\n    lastConfigArrays.length = 1;\n    lastConfigArrays[0] = configArrayFactory.getConfigArrayForFile();\n  }\n\n  /**\n   * Resolves the patterns passed into executeOnFiles() into glob-based patterns\n   * for easier handling.\n   * @param {string[]} patterns The file patterns passed on the command line.\n   * @returns {string[]} The equivalent glob patterns.\n   */\n  resolveFileGlobPatterns(patterns) {\n    const {\n      options\n    } = internalSlotsMap.get(this);\n    if (options.globInputPaths === false) {\n      return patterns.filter(Boolean);\n    }\n    const extensions = (options.extensions || [\".js\"]).map(ext => ext.replace(/^\\./u, \"\"));\n    const dirSuffix = `/**/*.{${extensions.join(\",\")}}`;\n    return patterns.filter(Boolean).map(pathname => {\n      const resolvedPath = path.resolve(options.cwd, pathname);\n      const newPath = directoryExists(resolvedPath) ? pathname.replace(/[/\\\\]$/u, \"\") + dirSuffix : pathname;\n      return path.normalize(newPath).replace(/\\\\/gu, \"/\");\n    });\n  }\n\n  /**\n   * Executes the current configuration on an array of file and directory names.\n   * @param {string[]} patterns An array of file and directory names.\n   * @returns {LintReport} The results for all files that were linted.\n   */\n  executeOnFiles(patterns) {\n    const {\n      cacheFilePath,\n      fileEnumerator,\n      lastConfigArrays,\n      lintResultCache,\n      linter,\n      options: {\n        allowInlineConfig,\n        cache,\n        cwd,\n        fix,\n        reportUnusedDisableDirectives\n      }\n    } = internalSlotsMap.get(this);\n    const results = [];\n    const startTime = Date.now();\n\n    // Clear the last used config arrays.\n    lastConfigArrays.length = 0;\n\n    // Delete cache file; should this do here?\n    if (!cache) {\n      try {\n        fs.unlinkSync(cacheFilePath);\n      } catch (error) {\n        const errorCode = error && error.code;\n\n        // Ignore errors when no such file exists or file system is read only (and cache file does not exist)\n        if (errorCode !== \"ENOENT\" && !(errorCode === \"EROFS\" && !fs.existsSync(cacheFilePath))) {\n          throw error;\n        }\n      }\n    }\n\n    // Iterate source code files.\n    for (const {\n      config,\n      filePath,\n      ignored\n    } of fileEnumerator.iterateFiles(patterns)) {\n      if (ignored) {\n        results.push(createIgnoreResult(filePath, cwd));\n        continue;\n      }\n\n      /*\n       * Store used configs for:\n       * - this method uses to collect used deprecated rules.\n       * - `getRules()` method uses to collect all loaded rules.\n       * - `--fix-type` option uses to get the loaded rule's meta data.\n       */\n      if (!lastConfigArrays.includes(config)) {\n        lastConfigArrays.push(config);\n      }\n\n      // Skip if there is cached result.\n      if (lintResultCache) {\n        const cachedResult = lintResultCache.getCachedLintResults(filePath, config);\n        if (cachedResult) {\n          const hadMessages = cachedResult.messages && cachedResult.messages.length > 0;\n          if (hadMessages && fix) {\n            debug(`Reprocessing cached file to allow autofix: ${filePath}`);\n          } else {\n            debug(`Skipping file since it hasn't changed: ${filePath}`);\n            results.push(cachedResult);\n            continue;\n          }\n        }\n      }\n\n      // Do lint.\n      const result = verifyText({\n        text: fs.readFileSync(filePath, \"utf8\"),\n        filePath,\n        config,\n        cwd,\n        fix,\n        allowInlineConfig,\n        reportUnusedDisableDirectives,\n        fileEnumerator,\n        linter\n      });\n      results.push(result);\n\n      /*\n       * Store the lint result in the LintResultCache.\n       * NOTE: The LintResultCache will remove the file source and any\n       * other properties that are difficult to serialize, and will\n       * hydrate those properties back in on future lint runs.\n       */\n      if (lintResultCache) {\n        lintResultCache.setCachedLintResults(filePath, config, result);\n      }\n    }\n\n    // Persist the cache to disk.\n    if (lintResultCache) {\n      lintResultCache.reconcile();\n    }\n    debug(`Linting complete in: ${Date.now() - startTime}ms`);\n    let usedDeprecatedRules;\n    return {\n      results,\n      ...calculateStatsPerRun(results),\n      // Initialize it lazily because CLI and `ESLint` API don't use it.\n      get usedDeprecatedRules() {\n        if (!usedDeprecatedRules) {\n          usedDeprecatedRules = Array.from(iterateRuleDeprecationWarnings(lastConfigArrays));\n        }\n        return usedDeprecatedRules;\n      }\n    };\n  }\n\n  /**\n   * Executes the current configuration on text.\n   * @param {string} text A string of JavaScript code to lint.\n   * @param {string} [filename] An optional string representing the texts filename.\n   * @param {boolean} [warnIgnored] Always warn when a file is ignored\n   * @returns {LintReport} The results for the linting.\n   */\n  executeOnText(text, filename, warnIgnored) {\n    const {\n      configArrayFactory,\n      fileEnumerator,\n      lastConfigArrays,\n      linter,\n      options: {\n        allowInlineConfig,\n        cwd,\n        fix,\n        reportUnusedDisableDirectives\n      }\n    } = internalSlotsMap.get(this);\n    const results = [];\n    const startTime = Date.now();\n    const resolvedFilename = filename && path.resolve(cwd, filename);\n\n    // Clear the last used config arrays.\n    lastConfigArrays.length = 0;\n    if (resolvedFilename && this.isPathIgnored(resolvedFilename)) {\n      if (warnIgnored) {\n        results.push(createIgnoreResult(resolvedFilename, cwd));\n      }\n    } else {\n      const config = configArrayFactory.getConfigArrayForFile(resolvedFilename || \"__placeholder__.js\");\n\n      /*\n       * Store used configs for:\n       * - this method uses to collect used deprecated rules.\n       * - `getRules()` method uses to collect all loaded rules.\n       * - `--fix-type` option uses to get the loaded rule's meta data.\n       */\n      lastConfigArrays.push(config);\n\n      // Do lint.\n      results.push(verifyText({\n        text,\n        filePath: resolvedFilename,\n        config,\n        cwd,\n        fix,\n        allowInlineConfig,\n        reportUnusedDisableDirectives,\n        fileEnumerator,\n        linter\n      }));\n    }\n    debug(`Linting complete in: ${Date.now() - startTime}ms`);\n    let usedDeprecatedRules;\n    return {\n      results,\n      ...calculateStatsPerRun(results),\n      // Initialize it lazily because CLI and `ESLint` API don't use it.\n      get usedDeprecatedRules() {\n        if (!usedDeprecatedRules) {\n          usedDeprecatedRules = Array.from(iterateRuleDeprecationWarnings(lastConfigArrays));\n        }\n        return usedDeprecatedRules;\n      }\n    };\n  }\n\n  /**\n   * Returns a configuration object for the given file based on the CLI options.\n   * This is the same logic used by the ESLint CLI executable to determine\n   * configuration for each file it processes.\n   * @param {string} filePath The path of the file to retrieve a config object for.\n   * @returns {ConfigData} A configuration object for the file.\n   */\n  getConfigForFile(filePath) {\n    const {\n      configArrayFactory,\n      options\n    } = internalSlotsMap.get(this);\n    const absolutePath = path.resolve(options.cwd, filePath);\n    if (directoryExists(absolutePath)) {\n      throw Object.assign(new Error(\"'filePath' should not be a directory path.\"), {\n        messageTemplate: \"print-config-with-directory-path\"\n      });\n    }\n    return configArrayFactory.getConfigArrayForFile(absolutePath).extractConfig(absolutePath).toCompatibleObjectAsConfigFileContent();\n  }\n\n  /**\n   * Checks if a given path is ignored by ESLint.\n   * @param {string} filePath The path of the file to check.\n   * @returns {boolean} Whether or not the given path is ignored.\n   */\n  isPathIgnored(filePath) {\n    const {\n      configArrayFactory,\n      defaultIgnores,\n      options: {\n        cwd,\n        ignore\n      }\n    } = internalSlotsMap.get(this);\n    const absolutePath = path.resolve(cwd, filePath);\n    if (ignore) {\n      const config = configArrayFactory.getConfigArrayForFile(absolutePath).extractConfig(absolutePath);\n      const ignores = config.ignores || defaultIgnores;\n      return ignores(absolutePath);\n    }\n    return defaultIgnores(absolutePath);\n  }\n\n  /**\n   * Returns the formatter representing the given format or null if the `format` is not a string.\n   * @param {string} [format] The name of the format to load or the path to a\n   *      custom formatter.\n   * @returns {(Function|null)} The formatter function or null if the `format` is not a string.\n   */\n  getFormatter(format) {\n    // default is stylish\n    const resolvedFormatName = format || \"stylish\";\n\n    // only strings are valid formatters\n    if (typeof resolvedFormatName === \"string\") {\n      // replace \\ with / for Windows compatibility\n      const normalizedFormatName = resolvedFormatName.replace(/\\\\/gu, \"/\");\n      const slots = internalSlotsMap.get(this);\n      const cwd = slots ? slots.options.cwd : process.cwd();\n      const namespace = naming.getNamespaceFromTerm(normalizedFormatName);\n      let formatterPath;\n\n      // if there's a slash, then it's a file (TODO: this check seems dubious for scoped npm packages)\n      if (!namespace && normalizedFormatName.indexOf(\"/\") > -1) {\n        formatterPath = path.resolve(cwd, normalizedFormatName);\n      } else {\n        try {\n          const npmFormat = naming.normalizePackageName(normalizedFormatName, \"eslint-formatter\");\n          formatterPath = ModuleResolver.resolve(npmFormat, path.join(cwd, \"__placeholder__.js\"));\n        } catch {\n          formatterPath = path.resolve(__dirname, \"formatters\", normalizedFormatName);\n        }\n      }\n      try {\n        return require(formatterPath);\n      } catch (ex) {\n        ex.message = `There was a problem loading formatter: ${formatterPath}\\nError: ${ex.message}`;\n        throw ex;\n      }\n    } else {\n      return null;\n    }\n  }\n}\nCLIEngine.version = pkg.version;\nCLIEngine.getFormatter = CLIEngine.prototype.getFormatter;\nmodule.exports = {\n  CLIEngine,\n  /**\n   * Get the internal slots of a given CLIEngine instance for tests.\n   * @param {CLIEngine} instance The CLIEngine instance to get.\n   * @returns {CLIEngineInternalSlots} The internal slots.\n   */\n  getCLIEngineInternalSlots(instance) {\n    return internalSlotsMap.get(instance);\n  }\n};","map":{"version":3,"names":["require","fs","path","defaultOptions","pkg","Legacy","ConfigOps","naming","CascadingConfigArrayFactory","IgnorePattern","getUsedExtractedConfigs","ModuleResolver","FileEnumerator","Linter","builtInRules","loadRules","hash","LintResultCache","debug","validFixTypes","Set","internalSlotsMap","WeakMap","validateFixTypes","fixTypes","fixType","has","Error","calculateStatsPerFile","messages","reduce","stat","message","fatal","severity","errorCount","fatalErrorCount","fix","fixableErrorCount","warningCount","fixableWarningCount","calculateStatsPerRun","results","result","verifyText","text","cwd","filePath","providedFilePath","config","allowInlineConfig","reportUnusedDisableDirectives","fileEnumerator","linter","filePathToVerify","join","fixed","output","verifyAndFix","filename","filterCodeBlock","blockFilename","isTargetPath","source","createIgnoreResult","baseDir","isHidden","split","sep","find","segment","test","isInNodeModules","relative","startsWith","resolve","getRule","ruleId","configArrays","configArray","rule","pluginRules","get","iterateRuleDeprecationWarnings","usedConfigArrays","processedRuleIds","configs","concat","map","ruleConfig","Object","entries","rules","add","getRuleSeverity","meta","deprecated","replacedBy","isErrorMessage","getCacheFile","cacheFile","normalizedCacheFile","normalize","resolvedCacheFile","looksLikeADirectory","slice","getCacheFileForDirectory","fileStats","lstatSync","isDirectory","toBooleanMap","keys","defaultValue","displayName","Array","isArray","length","def","key","value","createConfigDataFromOptions","options","ignorePattern","parser","parserOptions","plugins","env","envs","globals","ignorePatterns","directoryExists","resolvedPath","statSync","error","code","CLIEngine","constructor","providedOptions","assign","create","process","additionalPluginPool","Map","cacheFilePath","cacheLocation","configArrayFactory","baseConfig","cliConfig","ignorePath","resolvePluginsRelativeTo","rulePaths","specificConfigPath","configFile","useEslintrc","eslintRecommendedPath","__dirname","eslintAllPath","extensions","globInputPaths","errorOnUnmatchedPattern","ignore","lintResultCache","cache","cacheStrategy","lastConfigArrays","getConfigArrayForFile","set","defaultIgnores","createDefaultIgnore","originalFix","matches","type","getRules","getErrorResults","filtered","forEach","filteredMessages","filter","push","outputFixes","report","prototype","hasOwnProperty","call","writeFileSync","addPlugin","name","pluginObject","clearCache","resolveFileGlobPatterns","patterns","Boolean","ext","replace","dirSuffix","pathname","newPath","executeOnFiles","startTime","Date","now","unlinkSync","errorCode","existsSync","ignored","iterateFiles","includes","cachedResult","getCachedLintResults","hadMessages","readFileSync","setCachedLintResults","reconcile","usedDeprecatedRules","from","executeOnText","warnIgnored","resolvedFilename","isPathIgnored","getConfigForFile","absolutePath","messageTemplate","extractConfig","toCompatibleObjectAsConfigFileContent","ignores","getFormatter","format","resolvedFormatName","normalizedFormatName","slots","namespace","getNamespaceFromTerm","formatterPath","indexOf","npmFormat","normalizePackageName","ex","version","module","exports","getCLIEngineInternalSlots","instance"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/cli-engine/cli-engine.js"],"sourcesContent":["/**\n * @fileoverview Main CLI object.\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n/*\n * The CLI object should *not* call process.exit() directly. It should only return\n * exit codes. This allows other programs to use the CLI object and still control\n * when the program exits.\n */\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst fs = require(\"fs\");\nconst path = require(\"path\");\nconst defaultOptions = require(\"../../conf/default-cli-options\");\nconst pkg = require(\"../../package.json\");\n\n\nconst {\n    Legacy: {\n        ConfigOps,\n        naming,\n        CascadingConfigArrayFactory,\n        IgnorePattern,\n        getUsedExtractedConfigs,\n        ModuleResolver\n    }\n} = require(\"@eslint/eslintrc\");\n\nconst { FileEnumerator } = require(\"./file-enumerator\");\n\nconst { Linter } = require(\"../linter\");\nconst builtInRules = require(\"../rules\");\nconst loadRules = require(\"./load-rules\");\nconst hash = require(\"./hash\");\nconst LintResultCache = require(\"./lint-result-cache\");\n\nconst debug = require(\"debug\")(\"eslint:cli-engine\");\nconst validFixTypes = new Set([\"problem\", \"suggestion\", \"layout\"]);\n\n//------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n// For VSCode IntelliSense\n/** @typedef {import(\"../shared/types\").ConfigData} ConfigData */\n/** @typedef {import(\"../shared/types\").DeprecatedRuleInfo} DeprecatedRuleInfo */\n/** @typedef {import(\"../shared/types\").LintMessage} LintMessage */\n/** @typedef {import(\"../shared/types\").ParserOptions} ParserOptions */\n/** @typedef {import(\"../shared/types\").Plugin} Plugin */\n/** @typedef {import(\"../shared/types\").RuleConf} RuleConf */\n/** @typedef {import(\"../shared/types\").Rule} Rule */\n/** @typedef {ReturnType<CascadingConfigArrayFactory[\"getConfigArrayForFile\"]>} ConfigArray */\n/** @typedef {ReturnType<ConfigArray[\"extractConfig\"]>} ExtractedConfig */\n\n/**\n * The options to configure a CLI engine with.\n * @typedef {Object} CLIEngineOptions\n * @property {boolean} [allowInlineConfig] Enable or disable inline configuration comments.\n * @property {ConfigData} [baseConfig] Base config object, extended by all configs used with this CLIEngine instance\n * @property {boolean} [cache] Enable result caching.\n * @property {string} [cacheLocation] The cache file to use instead of .eslintcache.\n * @property {string} [configFile] The configuration file to use.\n * @property {string} [cwd] The value to use for the current working directory.\n * @property {string[]} [envs] An array of environments to load.\n * @property {string[]|null} [extensions] An array of file extensions to check.\n * @property {boolean|Function} [fix] Execute in autofix mode. If a function, should return a boolean.\n * @property {string[]} [fixTypes] Array of rule types to apply fixes for.\n * @property {string[]} [globals] An array of global variables to declare.\n * @property {boolean} [ignore] False disables use of .eslintignore.\n * @property {string} [ignorePath] The ignore file to use instead of .eslintignore.\n * @property {string|string[]} [ignorePattern] One or more glob patterns to ignore.\n * @property {boolean} [useEslintrc] False disables looking for .eslintrc\n * @property {string} [parser] The name of the parser to use.\n * @property {ParserOptions} [parserOptions] An object of parserOption settings to use.\n * @property {string[]} [plugins] An array of plugins to load.\n * @property {Record<string,RuleConf>} [rules] An object of rules to use.\n * @property {string[]} [rulePaths] An array of directories to load custom rules from.\n * @property {boolean} [reportUnusedDisableDirectives] `true` adds reports for unused eslint-disable directives\n * @property {boolean} [globInputPaths] Set to false to skip glob resolution of input file paths to lint (default: true). If false, each input file paths is assumed to be a non-glob path to an existing file.\n * @property {string} [resolvePluginsRelativeTo] The folder where plugins should be resolved from, defaulting to the CWD\n */\n\n/**\n * A linting result.\n * @typedef {Object} LintResult\n * @property {string} filePath The path to the file that was linted.\n * @property {LintMessage[]} messages All of the messages for the result.\n * @property {number} errorCount Number of errors for the result.\n * @property {number} warningCount Number of warnings for the result.\n * @property {number} fixableErrorCount Number of fixable errors for the result.\n * @property {number} fixableWarningCount Number of fixable warnings for the result.\n * @property {string} [source] The source code of the file that was linted.\n * @property {string} [output] The source code of the file that was linted, with as many fixes applied as possible.\n */\n\n/**\n * Linting results.\n * @typedef {Object} LintReport\n * @property {LintResult[]} results All of the result.\n * @property {number} errorCount Number of errors for the result.\n * @property {number} warningCount Number of warnings for the result.\n * @property {number} fixableErrorCount Number of fixable errors for the result.\n * @property {number} fixableWarningCount Number of fixable warnings for the result.\n * @property {DeprecatedRuleInfo[]} usedDeprecatedRules The list of used deprecated rules.\n */\n\n/**\n * Private data for CLIEngine.\n * @typedef {Object} CLIEngineInternalSlots\n * @property {Map<string, Plugin>} additionalPluginPool The map for additional plugins.\n * @property {string} cacheFilePath The path to the cache of lint results.\n * @property {CascadingConfigArrayFactory} configArrayFactory The factory of configs.\n * @property {(filePath: string) => boolean} defaultIgnores The default predicate function to check if a file ignored or not.\n * @property {FileEnumerator} fileEnumerator The file enumerator.\n * @property {ConfigArray[]} lastConfigArrays The list of config arrays that the last `executeOnFiles` or `executeOnText` used.\n * @property {LintResultCache|null} lintResultCache The cache of lint results.\n * @property {Linter} linter The linter instance which has loaded rules.\n * @property {CLIEngineOptions} options The normalized options of this instance.\n */\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/** @type {WeakMap<CLIEngine, CLIEngineInternalSlots>} */\nconst internalSlotsMap = new WeakMap();\n\n/**\n * Determines if each fix type in an array is supported by ESLint and throws\n * an error if not.\n * @param {string[]} fixTypes An array of fix types to check.\n * @returns {void}\n * @throws {Error} If an invalid fix type is found.\n */\nfunction validateFixTypes(fixTypes) {\n    for (const fixType of fixTypes) {\n        if (!validFixTypes.has(fixType)) {\n            throw new Error(`Invalid fix type \"${fixType}\" found.`);\n        }\n    }\n}\n\n/**\n * It will calculate the error and warning count for collection of messages per file\n * @param {LintMessage[]} messages Collection of messages\n * @returns {Object} Contains the stats\n * @private\n */\nfunction calculateStatsPerFile(messages) {\n    return messages.reduce((stat, message) => {\n        if (message.fatal || message.severity === 2) {\n            stat.errorCount++;\n            if (message.fatal) {\n                stat.fatalErrorCount++;\n            }\n            if (message.fix) {\n                stat.fixableErrorCount++;\n            }\n        } else {\n            stat.warningCount++;\n            if (message.fix) {\n                stat.fixableWarningCount++;\n            }\n        }\n        return stat;\n    }, {\n        errorCount: 0,\n        fatalErrorCount: 0,\n        warningCount: 0,\n        fixableErrorCount: 0,\n        fixableWarningCount: 0\n    });\n}\n\n/**\n * It will calculate the error and warning count for collection of results from all files\n * @param {LintResult[]} results Collection of messages from all the files\n * @returns {Object} Contains the stats\n * @private\n */\nfunction calculateStatsPerRun(results) {\n    return results.reduce((stat, result) => {\n        stat.errorCount += result.errorCount;\n        stat.fatalErrorCount += result.fatalErrorCount;\n        stat.warningCount += result.warningCount;\n        stat.fixableErrorCount += result.fixableErrorCount;\n        stat.fixableWarningCount += result.fixableWarningCount;\n        return stat;\n    }, {\n        errorCount: 0,\n        fatalErrorCount: 0,\n        warningCount: 0,\n        fixableErrorCount: 0,\n        fixableWarningCount: 0\n    });\n}\n\n/**\n * Processes an source code using ESLint.\n * @param {Object} config The config object.\n * @param {string} config.text The source code to verify.\n * @param {string} config.cwd The path to the current working directory.\n * @param {string|undefined} config.filePath The path to the file of `text`. If this is undefined, it uses `<text>`.\n * @param {ConfigArray} config.config The config.\n * @param {boolean} config.fix If `true` then it does fix.\n * @param {boolean} config.allowInlineConfig If `true` then it uses directive comments.\n * @param {boolean} config.reportUnusedDisableDirectives If `true` then it reports unused `eslint-disable` comments.\n * @param {FileEnumerator} config.fileEnumerator The file enumerator to check if a path is a target or not.\n * @param {Linter} config.linter The linter instance to verify.\n * @returns {LintResult} The result of linting.\n * @private\n */\nfunction verifyText({\n    text,\n    cwd,\n    filePath: providedFilePath,\n    config,\n    fix,\n    allowInlineConfig,\n    reportUnusedDisableDirectives,\n    fileEnumerator,\n    linter\n}) {\n    const filePath = providedFilePath || \"<text>\";\n\n    debug(`Lint ${filePath}`);\n\n    /*\n     * Verify.\n     * `config.extractConfig(filePath)` requires an absolute path, but `linter`\n     * doesn't know CWD, so it gives `linter` an absolute path always.\n     */\n    const filePathToVerify = filePath === \"<text>\" ? path.join(cwd, filePath) : filePath;\n    const { fixed, messages, output } = linter.verifyAndFix(\n        text,\n        config,\n        {\n            allowInlineConfig,\n            filename: filePathToVerify,\n            fix,\n            reportUnusedDisableDirectives,\n\n            /**\n             * Check if the linter should adopt a given code block or not.\n             * @param {string} blockFilename The virtual filename of a code block.\n             * @returns {boolean} `true` if the linter should adopt the code block.\n             */\n            filterCodeBlock(blockFilename) {\n                return fileEnumerator.isTargetPath(blockFilename);\n            }\n        }\n    );\n\n    // Tweak and return.\n    const result = {\n        filePath,\n        messages,\n        ...calculateStatsPerFile(messages)\n    };\n\n    if (fixed) {\n        result.output = output;\n    }\n    if (\n        result.errorCount + result.warningCount > 0 &&\n        typeof result.output === \"undefined\"\n    ) {\n        result.source = text;\n    }\n\n    return result;\n}\n\n/**\n * Returns result with warning by ignore settings\n * @param {string} filePath File path of checked code\n * @param {string} baseDir  Absolute path of base directory\n * @returns {LintResult} Result with single warning\n * @private\n */\nfunction createIgnoreResult(filePath, baseDir) {\n    let message;\n    const isHidden = filePath.split(path.sep)\n        .find(segment => /^\\./u.test(segment));\n    const isInNodeModules = baseDir && path.relative(baseDir, filePath).startsWith(\"node_modules\");\n\n    if (isHidden) {\n        message = \"File ignored by default.  Use a negated ignore pattern (like \\\"--ignore-pattern '!<relative/path/to/filename>'\\\") to override.\";\n    } else if (isInNodeModules) {\n        message = \"File ignored by default. Use \\\"--ignore-pattern '!node_modules/*'\\\" to override.\";\n    } else {\n        message = \"File ignored because of a matching ignore pattern. Use \\\"--no-ignore\\\" to override.\";\n    }\n\n    return {\n        filePath: path.resolve(filePath),\n        messages: [\n            {\n                fatal: false,\n                severity: 1,\n                message\n            }\n        ],\n        errorCount: 0,\n        warningCount: 1,\n        fixableErrorCount: 0,\n        fixableWarningCount: 0\n    };\n}\n\n/**\n * Get a rule.\n * @param {string} ruleId The rule ID to get.\n * @param {ConfigArray[]} configArrays The config arrays that have plugin rules.\n * @returns {Rule|null} The rule or null.\n */\nfunction getRule(ruleId, configArrays) {\n    for (const configArray of configArrays) {\n        const rule = configArray.pluginRules.get(ruleId);\n\n        if (rule) {\n            return rule;\n        }\n    }\n    return builtInRules.get(ruleId) || null;\n}\n\n/**\n * Collect used deprecated rules.\n * @param {ConfigArray[]} usedConfigArrays The config arrays which were used.\n * @returns {IterableIterator<DeprecatedRuleInfo>} Used deprecated rules.\n */\nfunction *iterateRuleDeprecationWarnings(usedConfigArrays) {\n    const processedRuleIds = new Set();\n\n    // Flatten used configs.\n    /** @type {ExtractedConfig[]} */\n    const configs = [].concat(\n        ...usedConfigArrays.map(getUsedExtractedConfigs)\n    );\n\n    // Traverse rule configs.\n    for (const config of configs) {\n        for (const [ruleId, ruleConfig] of Object.entries(config.rules)) {\n\n            // Skip if it was processed.\n            if (processedRuleIds.has(ruleId)) {\n                continue;\n            }\n            processedRuleIds.add(ruleId);\n\n            // Skip if it's not used.\n            if (!ConfigOps.getRuleSeverity(ruleConfig)) {\n                continue;\n            }\n            const rule = getRule(ruleId, usedConfigArrays);\n\n            // Skip if it's not deprecated.\n            if (!(rule && rule.meta && rule.meta.deprecated)) {\n                continue;\n            }\n\n            // This rule was used and deprecated.\n            yield {\n                ruleId,\n                replacedBy: rule.meta.replacedBy || []\n            };\n        }\n    }\n}\n\n/**\n * Checks if the given message is an error message.\n * @param {LintMessage} message The message to check.\n * @returns {boolean} Whether or not the message is an error message.\n * @private\n */\nfunction isErrorMessage(message) {\n    return message.severity === 2;\n}\n\n\n/**\n * return the cacheFile to be used by eslint, based on whether the provided parameter is\n * a directory or looks like a directory (ends in `path.sep`), in which case the file\n * name will be the `cacheFile/.cache_hashOfCWD`\n *\n * if cacheFile points to a file or looks like a file then in will just use that file\n * @param {string} cacheFile The name of file to be used to store the cache\n * @param {string} cwd Current working directory\n * @returns {string} the resolved path to the cache file\n */\nfunction getCacheFile(cacheFile, cwd) {\n\n    /*\n     * make sure the path separators are normalized for the environment/os\n     * keeping the trailing path separator if present\n     */\n    const normalizedCacheFile = path.normalize(cacheFile);\n\n    const resolvedCacheFile = path.resolve(cwd, normalizedCacheFile);\n    const looksLikeADirectory = normalizedCacheFile.slice(-1) === path.sep;\n\n    /**\n     * return the name for the cache file in case the provided parameter is a directory\n     * @returns {string} the resolved path to the cacheFile\n     */\n    function getCacheFileForDirectory() {\n        return path.join(resolvedCacheFile, `.cache_${hash(cwd)}`);\n    }\n\n    let fileStats;\n\n    try {\n        fileStats = fs.lstatSync(resolvedCacheFile);\n    } catch {\n        fileStats = null;\n    }\n\n\n    /*\n     * in case the file exists we need to verify if the provided path\n     * is a directory or a file. If it is a directory we want to create a file\n     * inside that directory\n     */\n    if (fileStats) {\n\n        /*\n         * is a directory or is a file, but the original file the user provided\n         * looks like a directory but `path.resolve` removed the `last path.sep`\n         * so we need to still treat this like a directory\n         */\n        if (fileStats.isDirectory() || looksLikeADirectory) {\n            return getCacheFileForDirectory();\n        }\n\n        // is file so just use that file\n        return resolvedCacheFile;\n    }\n\n    /*\n     * here we known the file or directory doesn't exist,\n     * so we will try to infer if its a directory if it looks like a directory\n     * for the current operating system.\n     */\n\n    // if the last character passed is a path separator we assume is a directory\n    if (looksLikeADirectory) {\n        return getCacheFileForDirectory();\n    }\n\n    return resolvedCacheFile;\n}\n\n/**\n * Convert a string array to a boolean map.\n * @param {string[]|null} keys The keys to assign true.\n * @param {boolean} defaultValue The default value for each property.\n * @param {string} displayName The property name which is used in error message.\n * @returns {Record<string,boolean>} The boolean map.\n */\nfunction toBooleanMap(keys, defaultValue, displayName) {\n    if (keys && !Array.isArray(keys)) {\n        throw new Error(`${displayName} must be an array.`);\n    }\n    if (keys && keys.length > 0) {\n        return keys.reduce((map, def) => {\n            const [key, value] = def.split(\":\");\n\n            if (key !== \"__proto__\") {\n                map[key] = value === void 0\n                    ? defaultValue\n                    : value === \"true\";\n            }\n\n            return map;\n        }, {});\n    }\n    return void 0;\n}\n\n/**\n * Create a config data from CLI options.\n * @param {CLIEngineOptions} options The options\n * @returns {ConfigData|null} The created config data.\n */\nfunction createConfigDataFromOptions(options) {\n    const {\n        ignorePattern,\n        parser,\n        parserOptions,\n        plugins,\n        rules\n    } = options;\n    const env = toBooleanMap(options.envs, true, \"envs\");\n    const globals = toBooleanMap(options.globals, false, \"globals\");\n\n    if (\n        env === void 0 &&\n        globals === void 0 &&\n        (ignorePattern === void 0 || ignorePattern.length === 0) &&\n        parser === void 0 &&\n        parserOptions === void 0 &&\n        plugins === void 0 &&\n        rules === void 0\n    ) {\n        return null;\n    }\n    return {\n        env,\n        globals,\n        ignorePatterns: ignorePattern,\n        parser,\n        parserOptions,\n        plugins,\n        rules\n    };\n}\n\n/**\n * Checks whether a directory exists at the given location\n * @param {string} resolvedPath A path from the CWD\n * @returns {boolean} `true` if a directory exists\n */\nfunction directoryExists(resolvedPath) {\n    try {\n        return fs.statSync(resolvedPath).isDirectory();\n    } catch (error) {\n        if (error && (error.code === \"ENOENT\" || error.code === \"ENOTDIR\")) {\n            return false;\n        }\n        throw error;\n    }\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nclass CLIEngine {\n\n    /**\n     * Creates a new instance of the core CLI engine.\n     * @param {CLIEngineOptions} providedOptions The options for this instance.\n     */\n    constructor(providedOptions) {\n        const options = Object.assign(\n            Object.create(null),\n            defaultOptions,\n            { cwd: process.cwd() },\n            providedOptions\n        );\n\n        if (options.fix === void 0) {\n            options.fix = false;\n        }\n\n        const additionalPluginPool = new Map();\n        const cacheFilePath = getCacheFile(\n            options.cacheLocation || options.cacheFile,\n            options.cwd\n        );\n        const configArrayFactory = new CascadingConfigArrayFactory({\n            additionalPluginPool,\n            baseConfig: options.baseConfig || null,\n            cliConfig: createConfigDataFromOptions(options),\n            cwd: options.cwd,\n            ignorePath: options.ignorePath,\n            resolvePluginsRelativeTo: options.resolvePluginsRelativeTo,\n            rulePaths: options.rulePaths,\n            specificConfigPath: options.configFile,\n            useEslintrc: options.useEslintrc,\n            builtInRules,\n            loadRules,\n            eslintRecommendedPath: path.resolve(__dirname, \"../../conf/eslint-recommended.js\"),\n            eslintAllPath: path.resolve(__dirname, \"../../conf/eslint-all.js\")\n        });\n        const fileEnumerator = new FileEnumerator({\n            configArrayFactory,\n            cwd: options.cwd,\n            extensions: options.extensions,\n            globInputPaths: options.globInputPaths,\n            errorOnUnmatchedPattern: options.errorOnUnmatchedPattern,\n            ignore: options.ignore\n        });\n        const lintResultCache =\n            options.cache ? new LintResultCache(cacheFilePath, options.cacheStrategy) : null;\n        const linter = new Linter({ cwd: options.cwd });\n\n        /** @type {ConfigArray[]} */\n        const lastConfigArrays = [configArrayFactory.getConfigArrayForFile()];\n\n        // Store private data.\n        internalSlotsMap.set(this, {\n            additionalPluginPool,\n            cacheFilePath,\n            configArrayFactory,\n            defaultIgnores: IgnorePattern.createDefaultIgnore(options.cwd),\n            fileEnumerator,\n            lastConfigArrays,\n            lintResultCache,\n            linter,\n            options\n        });\n\n        // setup special filter for fixes\n        if (options.fix && options.fixTypes && options.fixTypes.length > 0) {\n            debug(`Using fix types ${options.fixTypes}`);\n\n            // throw an error if any invalid fix types are found\n            validateFixTypes(options.fixTypes);\n\n            // convert to Set for faster lookup\n            const fixTypes = new Set(options.fixTypes);\n\n            // save original value of options.fix in case it's a function\n            const originalFix = (typeof options.fix === \"function\")\n                ? options.fix : () => true;\n\n            options.fix = message => {\n                const rule = message.ruleId && getRule(message.ruleId, lastConfigArrays);\n                const matches = rule && rule.meta && fixTypes.has(rule.meta.type);\n\n                return matches && originalFix(message);\n            };\n        }\n    }\n\n    getRules() {\n        const { lastConfigArrays } = internalSlotsMap.get(this);\n\n        return new Map(function *() {\n            yield* builtInRules;\n\n            for (const configArray of lastConfigArrays) {\n                yield* configArray.pluginRules;\n            }\n        }());\n    }\n\n    /**\n     * Returns results that only contains errors.\n     * @param {LintResult[]} results The results to filter.\n     * @returns {LintResult[]} The filtered results.\n     */\n    static getErrorResults(results) {\n        const filtered = [];\n\n        results.forEach(result => {\n            const filteredMessages = result.messages.filter(isErrorMessage);\n\n            if (filteredMessages.length > 0) {\n                filtered.push({\n                    ...result,\n                    messages: filteredMessages,\n                    errorCount: filteredMessages.length,\n                    warningCount: 0,\n                    fixableErrorCount: result.fixableErrorCount,\n                    fixableWarningCount: 0\n                });\n            }\n        });\n\n        return filtered;\n    }\n\n    /**\n     * Outputs fixes from the given results to files.\n     * @param {LintReport} report The report object created by CLIEngine.\n     * @returns {void}\n     */\n    static outputFixes(report) {\n        report.results.filter(result => Object.prototype.hasOwnProperty.call(result, \"output\")).forEach(result => {\n            fs.writeFileSync(result.filePath, result.output);\n        });\n    }\n\n\n    /**\n     * Add a plugin by passing its configuration\n     * @param {string} name Name of the plugin.\n     * @param {Plugin} pluginObject Plugin configuration object.\n     * @returns {void}\n     */\n    addPlugin(name, pluginObject) {\n        const {\n            additionalPluginPool,\n            configArrayFactory,\n            lastConfigArrays\n        } = internalSlotsMap.get(this);\n\n        additionalPluginPool.set(name, pluginObject);\n        configArrayFactory.clearCache();\n        lastConfigArrays.length = 1;\n        lastConfigArrays[0] = configArrayFactory.getConfigArrayForFile();\n    }\n\n    /**\n     * Resolves the patterns passed into executeOnFiles() into glob-based patterns\n     * for easier handling.\n     * @param {string[]} patterns The file patterns passed on the command line.\n     * @returns {string[]} The equivalent glob patterns.\n     */\n    resolveFileGlobPatterns(patterns) {\n        const { options } = internalSlotsMap.get(this);\n\n        if (options.globInputPaths === false) {\n            return patterns.filter(Boolean);\n        }\n\n        const extensions = (options.extensions || [\".js\"]).map(ext => ext.replace(/^\\./u, \"\"));\n        const dirSuffix = `/**/*.{${extensions.join(\",\")}}`;\n\n        return patterns.filter(Boolean).map(pathname => {\n            const resolvedPath = path.resolve(options.cwd, pathname);\n            const newPath = directoryExists(resolvedPath)\n                ? pathname.replace(/[/\\\\]$/u, \"\") + dirSuffix\n                : pathname;\n\n            return path.normalize(newPath).replace(/\\\\/gu, \"/\");\n        });\n    }\n\n    /**\n     * Executes the current configuration on an array of file and directory names.\n     * @param {string[]} patterns An array of file and directory names.\n     * @returns {LintReport} The results for all files that were linted.\n     */\n    executeOnFiles(patterns) {\n        const {\n            cacheFilePath,\n            fileEnumerator,\n            lastConfigArrays,\n            lintResultCache,\n            linter,\n            options: {\n                allowInlineConfig,\n                cache,\n                cwd,\n                fix,\n                reportUnusedDisableDirectives\n            }\n        } = internalSlotsMap.get(this);\n        const results = [];\n        const startTime = Date.now();\n\n        // Clear the last used config arrays.\n        lastConfigArrays.length = 0;\n\n        // Delete cache file; should this do here?\n        if (!cache) {\n            try {\n                fs.unlinkSync(cacheFilePath);\n            } catch (error) {\n                const errorCode = error && error.code;\n\n                // Ignore errors when no such file exists or file system is read only (and cache file does not exist)\n                if (errorCode !== \"ENOENT\" && !(errorCode === \"EROFS\" && !fs.existsSync(cacheFilePath))) {\n                    throw error;\n                }\n            }\n        }\n\n        // Iterate source code files.\n        for (const { config, filePath, ignored } of fileEnumerator.iterateFiles(patterns)) {\n            if (ignored) {\n                results.push(createIgnoreResult(filePath, cwd));\n                continue;\n            }\n\n            /*\n             * Store used configs for:\n             * - this method uses to collect used deprecated rules.\n             * - `getRules()` method uses to collect all loaded rules.\n             * - `--fix-type` option uses to get the loaded rule's meta data.\n             */\n            if (!lastConfigArrays.includes(config)) {\n                lastConfigArrays.push(config);\n            }\n\n            // Skip if there is cached result.\n            if (lintResultCache) {\n                const cachedResult =\n                    lintResultCache.getCachedLintResults(filePath, config);\n\n                if (cachedResult) {\n                    const hadMessages =\n                        cachedResult.messages &&\n                        cachedResult.messages.length > 0;\n\n                    if (hadMessages && fix) {\n                        debug(`Reprocessing cached file to allow autofix: ${filePath}`);\n                    } else {\n                        debug(`Skipping file since it hasn't changed: ${filePath}`);\n                        results.push(cachedResult);\n                        continue;\n                    }\n                }\n            }\n\n            // Do lint.\n            const result = verifyText({\n                text: fs.readFileSync(filePath, \"utf8\"),\n                filePath,\n                config,\n                cwd,\n                fix,\n                allowInlineConfig,\n                reportUnusedDisableDirectives,\n                fileEnumerator,\n                linter\n            });\n\n            results.push(result);\n\n            /*\n             * Store the lint result in the LintResultCache.\n             * NOTE: The LintResultCache will remove the file source and any\n             * other properties that are difficult to serialize, and will\n             * hydrate those properties back in on future lint runs.\n             */\n            if (lintResultCache) {\n                lintResultCache.setCachedLintResults(filePath, config, result);\n            }\n        }\n\n        // Persist the cache to disk.\n        if (lintResultCache) {\n            lintResultCache.reconcile();\n        }\n\n        debug(`Linting complete in: ${Date.now() - startTime}ms`);\n        let usedDeprecatedRules;\n\n        return {\n            results,\n            ...calculateStatsPerRun(results),\n\n            // Initialize it lazily because CLI and `ESLint` API don't use it.\n            get usedDeprecatedRules() {\n                if (!usedDeprecatedRules) {\n                    usedDeprecatedRules = Array.from(\n                        iterateRuleDeprecationWarnings(lastConfigArrays)\n                    );\n                }\n                return usedDeprecatedRules;\n            }\n        };\n    }\n\n    /**\n     * Executes the current configuration on text.\n     * @param {string} text A string of JavaScript code to lint.\n     * @param {string} [filename] An optional string representing the texts filename.\n     * @param {boolean} [warnIgnored] Always warn when a file is ignored\n     * @returns {LintReport} The results for the linting.\n     */\n    executeOnText(text, filename, warnIgnored) {\n        const {\n            configArrayFactory,\n            fileEnumerator,\n            lastConfigArrays,\n            linter,\n            options: {\n                allowInlineConfig,\n                cwd,\n                fix,\n                reportUnusedDisableDirectives\n            }\n        } = internalSlotsMap.get(this);\n        const results = [];\n        const startTime = Date.now();\n        const resolvedFilename = filename && path.resolve(cwd, filename);\n\n\n        // Clear the last used config arrays.\n        lastConfigArrays.length = 0;\n        if (resolvedFilename && this.isPathIgnored(resolvedFilename)) {\n            if (warnIgnored) {\n                results.push(createIgnoreResult(resolvedFilename, cwd));\n            }\n        } else {\n            const config = configArrayFactory.getConfigArrayForFile(\n                resolvedFilename || \"__placeholder__.js\"\n            );\n\n            /*\n             * Store used configs for:\n             * - this method uses to collect used deprecated rules.\n             * - `getRules()` method uses to collect all loaded rules.\n             * - `--fix-type` option uses to get the loaded rule's meta data.\n             */\n            lastConfigArrays.push(config);\n\n            // Do lint.\n            results.push(verifyText({\n                text,\n                filePath: resolvedFilename,\n                config,\n                cwd,\n                fix,\n                allowInlineConfig,\n                reportUnusedDisableDirectives,\n                fileEnumerator,\n                linter\n            }));\n        }\n\n        debug(`Linting complete in: ${Date.now() - startTime}ms`);\n        let usedDeprecatedRules;\n\n        return {\n            results,\n            ...calculateStatsPerRun(results),\n\n            // Initialize it lazily because CLI and `ESLint` API don't use it.\n            get usedDeprecatedRules() {\n                if (!usedDeprecatedRules) {\n                    usedDeprecatedRules = Array.from(\n                        iterateRuleDeprecationWarnings(lastConfigArrays)\n                    );\n                }\n                return usedDeprecatedRules;\n            }\n        };\n    }\n\n    /**\n     * Returns a configuration object for the given file based on the CLI options.\n     * This is the same logic used by the ESLint CLI executable to determine\n     * configuration for each file it processes.\n     * @param {string} filePath The path of the file to retrieve a config object for.\n     * @returns {ConfigData} A configuration object for the file.\n     */\n    getConfigForFile(filePath) {\n        const { configArrayFactory, options } = internalSlotsMap.get(this);\n        const absolutePath = path.resolve(options.cwd, filePath);\n\n        if (directoryExists(absolutePath)) {\n            throw Object.assign(\n                new Error(\"'filePath' should not be a directory path.\"),\n                { messageTemplate: \"print-config-with-directory-path\" }\n            );\n        }\n\n        return configArrayFactory\n            .getConfigArrayForFile(absolutePath)\n            .extractConfig(absolutePath)\n            .toCompatibleObjectAsConfigFileContent();\n    }\n\n    /**\n     * Checks if a given path is ignored by ESLint.\n     * @param {string} filePath The path of the file to check.\n     * @returns {boolean} Whether or not the given path is ignored.\n     */\n    isPathIgnored(filePath) {\n        const {\n            configArrayFactory,\n            defaultIgnores,\n            options: { cwd, ignore }\n        } = internalSlotsMap.get(this);\n        const absolutePath = path.resolve(cwd, filePath);\n\n        if (ignore) {\n            const config = configArrayFactory\n                .getConfigArrayForFile(absolutePath)\n                .extractConfig(absolutePath);\n            const ignores = config.ignores || defaultIgnores;\n\n            return ignores(absolutePath);\n        }\n\n        return defaultIgnores(absolutePath);\n    }\n\n    /**\n     * Returns the formatter representing the given format or null if the `format` is not a string.\n     * @param {string} [format] The name of the format to load or the path to a\n     *      custom formatter.\n     * @returns {(Function|null)} The formatter function or null if the `format` is not a string.\n     */\n    getFormatter(format) {\n\n        // default is stylish\n        const resolvedFormatName = format || \"stylish\";\n\n        // only strings are valid formatters\n        if (typeof resolvedFormatName === \"string\") {\n\n            // replace \\ with / for Windows compatibility\n            const normalizedFormatName = resolvedFormatName.replace(/\\\\/gu, \"/\");\n\n            const slots = internalSlotsMap.get(this);\n            const cwd = slots ? slots.options.cwd : process.cwd();\n            const namespace = naming.getNamespaceFromTerm(normalizedFormatName);\n\n            let formatterPath;\n\n            // if there's a slash, then it's a file (TODO: this check seems dubious for scoped npm packages)\n            if (!namespace && normalizedFormatName.indexOf(\"/\") > -1) {\n                formatterPath = path.resolve(cwd, normalizedFormatName);\n            } else {\n                try {\n                    const npmFormat = naming.normalizePackageName(normalizedFormatName, \"eslint-formatter\");\n\n                    formatterPath = ModuleResolver.resolve(npmFormat, path.join(cwd, \"__placeholder__.js\"));\n                } catch {\n                    formatterPath = path.resolve(__dirname, \"formatters\", normalizedFormatName);\n                }\n            }\n\n            try {\n                return require(formatterPath);\n            } catch (ex) {\n                ex.message = `There was a problem loading formatter: ${formatterPath}\\nError: ${ex.message}`;\n                throw ex;\n            }\n\n        } else {\n            return null;\n        }\n    }\n}\n\nCLIEngine.version = pkg.version;\nCLIEngine.getFormatter = CLIEngine.prototype.getFormatter;\n\nmodule.exports = {\n    CLIEngine,\n\n    /**\n     * Get the internal slots of a given CLIEngine instance for tests.\n     * @param {CLIEngine} instance The CLIEngine instance to get.\n     * @returns {CLIEngineInternalSlots} The internal slots.\n     */\n    getCLIEngineInternalSlots(instance) {\n        return internalSlotsMap.get(instance);\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}