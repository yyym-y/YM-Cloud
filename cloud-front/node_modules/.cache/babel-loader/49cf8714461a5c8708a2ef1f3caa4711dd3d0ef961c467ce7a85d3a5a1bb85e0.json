{"ast":null,"code":"/**\n * @fileoverview Rule to disallow negating the left operand of relational operators\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether the given operator is `in` or `instanceof`\n * @param {string} op The operator type to check.\n * @returns {boolean} `true` if the operator is `in` or `instanceof`\n */\nfunction isInOrInstanceOfOperator(op) {\n  return op === \"in\" || op === \"instanceof\";\n}\n\n/**\n * Checks whether the given operator is an ordering relational operator or not.\n * @param {string} op The operator type to check.\n * @returns {boolean} `true` if the operator is an ordering relational operator.\n */\nfunction isOrderingRelationalOperator(op) {\n  return op === \"<\" || op === \">\" || op === \">=\" || op === \"<=\";\n}\n\n/**\n * Checks whether the given node is a logical negation expression or not.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} `true` if the node is a logical negation expression.\n */\nfunction isNegation(node) {\n  return node.type === \"UnaryExpression\" && node.operator === \"!\";\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow negating the left operand of relational operators\",\n      category: \"Possible Errors\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-unsafe-negation\",\n      suggestion: true\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        enforceForOrderingRelations: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    fixable: null,\n    messages: {\n      unexpected: \"Unexpected negating the left operand of '{{operator}}' operator.\",\n      suggestNegatedExpression: \"Negate '{{operator}}' expression instead of its left operand. This changes the current behavior.\",\n      suggestParenthesisedNegation: \"Wrap negation in '()' to make the intention explicit. This preserves the current behavior.\"\n    }\n  },\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const options = context.options[0] || {};\n    const enforceForOrderingRelations = options.enforceForOrderingRelations === true;\n    return {\n      BinaryExpression(node) {\n        const operator = node.operator;\n        const orderingRelationRuleApplies = enforceForOrderingRelations && isOrderingRelationalOperator(operator);\n        if ((isInOrInstanceOfOperator(operator) || orderingRelationRuleApplies) && isNegation(node.left) && !astUtils.isParenthesised(sourceCode, node.left)) {\n          context.report({\n            node,\n            loc: node.left.loc,\n            messageId: \"unexpected\",\n            data: {\n              operator\n            },\n            suggest: [{\n              messageId: \"suggestNegatedExpression\",\n              data: {\n                operator\n              },\n              fix(fixer) {\n                const negationToken = sourceCode.getFirstToken(node.left);\n                const fixRange = [negationToken.range[1], node.range[1]];\n                const text = sourceCode.text.slice(fixRange[0], fixRange[1]);\n                return fixer.replaceTextRange(fixRange, `(${text})`);\n              }\n            }, {\n              messageId: \"suggestParenthesisedNegation\",\n              fix(fixer) {\n                return fixer.replaceText(node.left, `(${sourceCode.getText(node.left)})`);\n              }\n            }]\n          });\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","isInOrInstanceOfOperator","op","isOrderingRelationalOperator","isNegation","node","type","operator","module","exports","meta","docs","description","category","recommended","url","suggestion","schema","properties","enforceForOrderingRelations","default","additionalProperties","fixable","messages","unexpected","suggestNegatedExpression","suggestParenthesisedNegation","create","context","sourceCode","getSourceCode","options","BinaryExpression","orderingRelationRuleApplies","left","isParenthesised","report","loc","messageId","data","suggest","fix","fixer","negationToken","getFirstToken","fixRange","range","text","slice","replaceTextRange","replaceText","getText"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/no-unsafe-negation.js"],"sourcesContent":["/**\n * @fileoverview Rule to disallow negating the left operand of relational operators\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether the given operator is `in` or `instanceof`\n * @param {string} op The operator type to check.\n * @returns {boolean} `true` if the operator is `in` or `instanceof`\n */\nfunction isInOrInstanceOfOperator(op) {\n    return op === \"in\" || op === \"instanceof\";\n}\n\n/**\n * Checks whether the given operator is an ordering relational operator or not.\n * @param {string} op The operator type to check.\n * @returns {boolean} `true` if the operator is an ordering relational operator.\n */\nfunction isOrderingRelationalOperator(op) {\n    return op === \"<\" || op === \">\" || op === \">=\" || op === \"<=\";\n}\n\n/**\n * Checks whether the given node is a logical negation expression or not.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} `true` if the node is a logical negation expression.\n */\nfunction isNegation(node) {\n    return node.type === \"UnaryExpression\" && node.operator === \"!\";\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow negating the left operand of relational operators\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-unsafe-negation\",\n            suggestion: true\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    enforceForOrderingRelations: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: null,\n\n        messages: {\n            unexpected: \"Unexpected negating the left operand of '{{operator}}' operator.\",\n            suggestNegatedExpression: \"Negate '{{operator}}' expression instead of its left operand. This changes the current behavior.\",\n            suggestParenthesisedNegation: \"Wrap negation in '()' to make the intention explicit. This preserves the current behavior.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const options = context.options[0] || {};\n        const enforceForOrderingRelations = options.enforceForOrderingRelations === true;\n\n        return {\n            BinaryExpression(node) {\n                const operator = node.operator;\n                const orderingRelationRuleApplies = enforceForOrderingRelations && isOrderingRelationalOperator(operator);\n\n                if (\n                    (isInOrInstanceOfOperator(operator) || orderingRelationRuleApplies) &&\n                    isNegation(node.left) &&\n                    !astUtils.isParenthesised(sourceCode, node.left)\n                ) {\n                    context.report({\n                        node,\n                        loc: node.left.loc,\n                        messageId: \"unexpected\",\n                        data: { operator },\n                        suggest: [\n                            {\n                                messageId: \"suggestNegatedExpression\",\n                                data: { operator },\n                                fix(fixer) {\n                                    const negationToken = sourceCode.getFirstToken(node.left);\n                                    const fixRange = [negationToken.range[1], node.range[1]];\n                                    const text = sourceCode.text.slice(fixRange[0], fixRange[1]);\n\n                                    return fixer.replaceTextRange(fixRange, `(${text})`);\n                                }\n                            },\n                            {\n                                messageId: \"suggestParenthesisedNegation\",\n                                fix(fixer) {\n                                    return fixer.replaceText(node.left, `(${sourceCode.getText(node.left)})`);\n                                }\n                            }\n                        ]\n                    });\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}