{"ast":null,"code":"require(\"core-js/modules/es.array.push.js\");\n// Generated by LiveScript 1.6.0\n(function () {\n  var reject, special, tokenRegex;\n  reject = require('prelude-ls').reject;\n  function consumeOp(tokens, op) {\n    if (tokens[0] === op) {\n      return tokens.shift();\n    } else {\n      throw new Error(\"Expected '\" + op + \"', but got '\" + tokens[0] + \"' instead in \" + JSON.stringify(tokens) + \".\");\n    }\n  }\n  function maybeConsumeOp(tokens, op) {\n    if (tokens[0] === op) {\n      return tokens.shift();\n    }\n  }\n  function consumeList(tokens, arg$, hasDelimiters) {\n    var open, close, result, untilTest;\n    open = arg$[0], close = arg$[1];\n    if (hasDelimiters) {\n      consumeOp(tokens, open);\n    }\n    result = [];\n    untilTest = \",\" + (hasDelimiters ? close : '');\n    while (tokens.length && hasDelimiters && tokens[0] !== close) {\n      result.push(consumeElement(tokens, untilTest));\n      maybeConsumeOp(tokens, ',');\n    }\n    if (hasDelimiters) {\n      consumeOp(tokens, close);\n    }\n    return result;\n  }\n  function consumeArray(tokens, hasDelimiters) {\n    return consumeList(tokens, ['[', ']'], hasDelimiters);\n  }\n  function consumeTuple(tokens, hasDelimiters) {\n    return consumeList(tokens, ['(', ')'], hasDelimiters);\n  }\n  function consumeFields(tokens, hasDelimiters) {\n    var result, untilTest, key;\n    if (hasDelimiters) {\n      consumeOp(tokens, '{');\n    }\n    result = {};\n    untilTest = \",\" + (hasDelimiters ? '}' : '');\n    while (tokens.length && (!hasDelimiters || tokens[0] !== '}')) {\n      key = consumeValue(tokens, ':');\n      consumeOp(tokens, ':');\n      result[key] = consumeElement(tokens, untilTest);\n      maybeConsumeOp(tokens, ',');\n    }\n    if (hasDelimiters) {\n      consumeOp(tokens, '}');\n    }\n    return result;\n  }\n  function consumeValue(tokens, untilTest) {\n    var out;\n    untilTest == null && (untilTest = '');\n    out = '';\n    while (tokens.length && -1 === untilTest.indexOf(tokens[0])) {\n      out += tokens.shift();\n    }\n    return out;\n  }\n  function consumeElement(tokens, untilTest) {\n    switch (tokens[0]) {\n      case '[':\n        return consumeArray(tokens, true);\n      case '(':\n        return consumeTuple(tokens, true);\n      case '{':\n        return consumeFields(tokens, true);\n      default:\n        return consumeValue(tokens, untilTest);\n    }\n  }\n  function consumeTopLevel(tokens, types, options) {\n    var ref$, type, structure, origTokens, result, finalResult, x$, y$;\n    ref$ = types[0], type = ref$.type, structure = ref$.structure;\n    origTokens = tokens.concat();\n    if (!options.explicit && types.length === 1 && (!type && structure || type === 'Array' || type === 'Object')) {\n      result = structure === 'array' || type === 'Array' ? consumeArray(tokens, tokens[0] === '[') : structure === 'tuple' ? consumeTuple(tokens, tokens[0] === '(') : consumeFields(tokens, tokens[0] === '{');\n      finalResult = tokens.length ? consumeElement(structure === 'array' || type === 'Array' ? (x$ = origTokens, x$.unshift('['), x$.push(']'), x$) : (y$ = origTokens, y$.unshift('('), y$.push(')'), y$)) : result;\n    } else {\n      finalResult = consumeElement(tokens);\n    }\n    return finalResult;\n  }\n  special = /\\[\\]\\(\\)}{:,/.source;\n  tokenRegex = RegExp('(\"(?:\\\\\\\\\"|[^\"])*\")|(\\'(?:\\\\\\\\\\'|[^\\'])*\\')|(/(?:\\\\\\\\/|[^/])*/[a-zA-Z]*)|(#.*#)|([' + special + '])|([^\\\\s' + special + '](?:\\\\s*[^\\\\s' + special + ']+)*)|\\\\s*');\n  module.exports = function (types, string, options) {\n    var tokens, node;\n    options == null && (options = {});\n    if (!options.explicit && types.length === 1 && types[0].type === 'String') {\n      return string;\n    }\n    tokens = reject(not$, string.split(tokenRegex));\n    node = consumeTopLevel(tokens, types, options);\n    if (!node) {\n      throw new Error(\"Error parsing '\" + string + \"'.\");\n    }\n    return node;\n  };\n  function not$(x) {\n    return !x;\n  }\n}).call(this);","map":{"version":3,"names":["reject","special","tokenRegex","require","consumeOp","tokens","op","shift","Error","JSON","stringify","maybeConsumeOp","consumeList","arg$","hasDelimiters","open","close","result","untilTest","length","push","consumeElement","consumeArray","consumeTuple","consumeFields","key","consumeValue","out","indexOf","consumeTopLevel","types","options","ref$","type","structure","origTokens","finalResult","x$","y$","concat","explicit","unshift","source","RegExp","module","exports","string","node","not$","split","x","call"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/levn/lib/parse-string.js"],"sourcesContent":["// Generated by LiveScript 1.6.0\n(function(){\n  var reject, special, tokenRegex;\n  reject = require('prelude-ls').reject;\n  function consumeOp(tokens, op){\n    if (tokens[0] === op) {\n      return tokens.shift();\n    } else {\n      throw new Error(\"Expected '\" + op + \"', but got '\" + tokens[0] + \"' instead in \" + JSON.stringify(tokens) + \".\");\n    }\n  }\n  function maybeConsumeOp(tokens, op){\n    if (tokens[0] === op) {\n      return tokens.shift();\n    }\n  }\n  function consumeList(tokens, arg$, hasDelimiters){\n    var open, close, result, untilTest;\n    open = arg$[0], close = arg$[1];\n    if (hasDelimiters) {\n      consumeOp(tokens, open);\n    }\n    result = [];\n    untilTest = \",\" + (hasDelimiters ? close : '');\n    while (tokens.length && (hasDelimiters && tokens[0] !== close)) {\n      result.push(consumeElement(tokens, untilTest));\n      maybeConsumeOp(tokens, ',');\n    }\n    if (hasDelimiters) {\n      consumeOp(tokens, close);\n    }\n    return result;\n  }\n  function consumeArray(tokens, hasDelimiters){\n    return consumeList(tokens, ['[', ']'], hasDelimiters);\n  }\n  function consumeTuple(tokens, hasDelimiters){\n    return consumeList(tokens, ['(', ')'], hasDelimiters);\n  }\n  function consumeFields(tokens, hasDelimiters){\n    var result, untilTest, key;\n    if (hasDelimiters) {\n      consumeOp(tokens, '{');\n    }\n    result = {};\n    untilTest = \",\" + (hasDelimiters ? '}' : '');\n    while (tokens.length && (!hasDelimiters || tokens[0] !== '}')) {\n      key = consumeValue(tokens, ':');\n      consumeOp(tokens, ':');\n      result[key] = consumeElement(tokens, untilTest);\n      maybeConsumeOp(tokens, ',');\n    }\n    if (hasDelimiters) {\n      consumeOp(tokens, '}');\n    }\n    return result;\n  }\n  function consumeValue(tokens, untilTest){\n    var out;\n    untilTest == null && (untilTest = '');\n    out = '';\n    while (tokens.length && -1 === untilTest.indexOf(tokens[0])) {\n      out += tokens.shift();\n    }\n    return out;\n  }\n  function consumeElement(tokens, untilTest){\n    switch (tokens[0]) {\n    case '[':\n      return consumeArray(tokens, true);\n    case '(':\n      return consumeTuple(tokens, true);\n    case '{':\n      return consumeFields(tokens, true);\n    default:\n      return consumeValue(tokens, untilTest);\n    }\n  }\n  function consumeTopLevel(tokens, types, options){\n    var ref$, type, structure, origTokens, result, finalResult, x$, y$;\n    ref$ = types[0], type = ref$.type, structure = ref$.structure;\n    origTokens = tokens.concat();\n    if (!options.explicit && types.length === 1 && ((!type && structure) || (type === 'Array' || type === 'Object'))) {\n      result = structure === 'array' || type === 'Array'\n        ? consumeArray(tokens, tokens[0] === '[')\n        : structure === 'tuple'\n          ? consumeTuple(tokens, tokens[0] === '(')\n          : consumeFields(tokens, tokens[0] === '{');\n      finalResult = tokens.length ? consumeElement(structure === 'array' || type === 'Array'\n        ? (x$ = origTokens, x$.unshift('['), x$.push(']'), x$)\n        : (y$ = origTokens, y$.unshift('('), y$.push(')'), y$)) : result;\n    } else {\n      finalResult = consumeElement(tokens);\n    }\n    return finalResult;\n  }\n  special = /\\[\\]\\(\\)}{:,/.source;\n  tokenRegex = RegExp('(\"(?:\\\\\\\\\"|[^\"])*\")|(\\'(?:\\\\\\\\\\'|[^\\'])*\\')|(/(?:\\\\\\\\/|[^/])*/[a-zA-Z]*)|(#.*#)|([' + special + '])|([^\\\\s' + special + '](?:\\\\s*[^\\\\s' + special + ']+)*)|\\\\s*');\n  module.exports = function(types, string, options){\n    var tokens, node;\n    options == null && (options = {});\n    if (!options.explicit && types.length === 1 && types[0].type === 'String') {\n      return string;\n    }\n    tokens = reject(not$, string.split(tokenRegex));\n    node = consumeTopLevel(tokens, types, options);\n    if (!node) {\n      throw new Error(\"Error parsing '\" + string + \"'.\");\n    }\n    return node;\n  };\n  function not$(x){ return !x; }\n}).call(this);\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}