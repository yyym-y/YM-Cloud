{"ast":null,"code":"/**\n * @fileoverview Restrict usage of specified node modules.\n * @author Christian Schulz\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\nconst ignore = require(\"ignore\");\nconst arrayOfStrings = {\n  type: \"array\",\n  items: {\n    type: \"string\"\n  },\n  uniqueItems: true\n};\nconst arrayOfStringsOrObjects = {\n  type: \"array\",\n  items: {\n    anyOf: [{\n      type: \"string\"\n    }, {\n      type: \"object\",\n      properties: {\n        name: {\n          type: \"string\"\n        },\n        message: {\n          type: \"string\",\n          minLength: 1\n        }\n      },\n      additionalProperties: false,\n      required: [\"name\"]\n    }]\n  },\n  uniqueItems: true\n};\nmodule.exports = {\n  meta: {\n    deprecated: true,\n    replacedBy: [],\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow specified modules when loaded by `require`\",\n      category: \"Node.js and CommonJS\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-restricted-modules\"\n    },\n    schema: {\n      anyOf: [arrayOfStringsOrObjects, {\n        type: \"array\",\n        items: {\n          type: \"object\",\n          properties: {\n            paths: arrayOfStringsOrObjects,\n            patterns: arrayOfStrings\n          },\n          additionalProperties: false\n        },\n        additionalItems: false\n      }]\n    },\n    messages: {\n      defaultMessage: \"'{{name}}' module is restricted from being used.\",\n      // eslint-disable-next-line eslint-plugin/report-message-format\n      customMessage: \"'{{name}}' module is restricted from being used. {{customMessage}}\",\n      patternMessage: \"'{{name}}' module is restricted from being used by a pattern.\"\n    }\n  },\n  create(context) {\n    const options = Array.isArray(context.options) ? context.options : [];\n    const isPathAndPatternsObject = typeof options[0] === \"object\" && (Object.prototype.hasOwnProperty.call(options[0], \"paths\") || Object.prototype.hasOwnProperty.call(options[0], \"patterns\"));\n    const restrictedPaths = (isPathAndPatternsObject ? options[0].paths : context.options) || [];\n    const restrictedPatterns = (isPathAndPatternsObject ? options[0].patterns : []) || [];\n    const restrictedPathMessages = restrictedPaths.reduce((memo, importName) => {\n      if (typeof importName === \"string\") {\n        memo[importName] = null;\n      } else {\n        memo[importName.name] = importName.message;\n      }\n      return memo;\n    }, {});\n\n    // if no imports are restricted we don\"t need to check\n    if (Object.keys(restrictedPaths).length === 0 && restrictedPatterns.length === 0) {\n      return {};\n    }\n    const ig = ignore().add(restrictedPatterns);\n\n    /**\n     * Function to check if a node is a string literal.\n     * @param {ASTNode} node The node to check.\n     * @returns {boolean} If the node is a string literal.\n     */\n    function isStringLiteral(node) {\n      return node && node.type === \"Literal\" && typeof node.value === \"string\";\n    }\n\n    /**\n     * Function to check if a node is a static string template literal.\n     * @param {ASTNode} node The node to check.\n     * @returns {boolean} If the node is a string template literal.\n     */\n    function isStaticTemplateLiteral(node) {\n      return node && node.type === \"TemplateLiteral\" && node.expressions.length === 0;\n    }\n\n    /**\n     * Function to check if a node is a require call.\n     * @param {ASTNode} node The node to check.\n     * @returns {boolean} If the node is a require call.\n     */\n    function isRequireCall(node) {\n      return node.callee.type === \"Identifier\" && node.callee.name === \"require\";\n    }\n\n    /**\n     * Extract string from Literal or TemplateLiteral node\n     * @param {ASTNode} node The node to extract from\n     * @returns {string|null} Extracted string or null if node doesn't represent a string\n     */\n    function getFirstArgumentString(node) {\n      if (isStringLiteral(node)) {\n        return node.value.trim();\n      }\n      if (isStaticTemplateLiteral(node)) {\n        return node.quasis[0].value.cooked.trim();\n      }\n      return null;\n    }\n\n    /**\n     * Report a restricted path.\n     * @param {node} node representing the restricted path reference\n     * @param {string} name restricted path\n     * @returns {void}\n     * @private\n     */\n    function reportPath(node, name) {\n      const customMessage = restrictedPathMessages[name];\n      const messageId = customMessage ? \"customMessage\" : \"defaultMessage\";\n      context.report({\n        node,\n        messageId,\n        data: {\n          name,\n          customMessage\n        }\n      });\n    }\n\n    /**\n     * Check if the given name is a restricted path name\n     * @param {string} name name of a variable\n     * @returns {boolean} whether the variable is a restricted path or not\n     * @private\n     */\n    function isRestrictedPath(name) {\n      return Object.prototype.hasOwnProperty.call(restrictedPathMessages, name);\n    }\n    return {\n      CallExpression(node) {\n        if (isRequireCall(node)) {\n          // node has arguments\n          if (node.arguments.length) {\n            const name = getFirstArgumentString(node.arguments[0]);\n\n            // if first argument is a string literal or a static string template literal\n            if (name) {\n              // check if argument value is in restricted modules array\n              if (isRestrictedPath(name)) {\n                reportPath(node, name);\n              }\n              if (restrictedPatterns.length > 0 && ig.ignores(name)) {\n                context.report({\n                  node,\n                  messageId: \"patternMessage\",\n                  data: {\n                    name\n                  }\n                });\n              }\n            }\n          }\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["ignore","require","arrayOfStrings","type","items","uniqueItems","arrayOfStringsOrObjects","anyOf","properties","name","message","minLength","additionalProperties","required","module","exports","meta","deprecated","replacedBy","docs","description","category","recommended","url","schema","paths","patterns","additionalItems","messages","defaultMessage","customMessage","patternMessage","create","context","options","Array","isArray","isPathAndPatternsObject","Object","prototype","hasOwnProperty","call","restrictedPaths","restrictedPatterns","restrictedPathMessages","reduce","memo","importName","keys","length","ig","add","isStringLiteral","node","value","isStaticTemplateLiteral","expressions","isRequireCall","callee","getFirstArgumentString","trim","quasis","cooked","reportPath","messageId","report","data","isRestrictedPath","CallExpression","arguments","ignores"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/no-restricted-modules.js"],"sourcesContent":["/**\n * @fileoverview Restrict usage of specified node modules.\n * @author Christian Schulz\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst ignore = require(\"ignore\");\n\nconst arrayOfStrings = {\n    type: \"array\",\n    items: { type: \"string\" },\n    uniqueItems: true\n};\n\nconst arrayOfStringsOrObjects = {\n    type: \"array\",\n    items: {\n        anyOf: [\n            { type: \"string\" },\n            {\n                type: \"object\",\n                properties: {\n                    name: { type: \"string\" },\n                    message: {\n                        type: \"string\",\n                        minLength: 1\n                    }\n                },\n                additionalProperties: false,\n                required: [\"name\"]\n            }\n        ]\n    },\n    uniqueItems: true\n};\n\nmodule.exports = {\n    meta: {\n        deprecated: true,\n\n        replacedBy: [],\n\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow specified modules when loaded by `require`\",\n            category: \"Node.js and CommonJS\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-restricted-modules\"\n        },\n\n        schema: {\n            anyOf: [\n                arrayOfStringsOrObjects,\n                {\n                    type: \"array\",\n                    items: {\n                        type: \"object\",\n                        properties: {\n                            paths: arrayOfStringsOrObjects,\n                            patterns: arrayOfStrings\n                        },\n                        additionalProperties: false\n                    },\n                    additionalItems: false\n                }\n            ]\n        },\n\n        messages: {\n            defaultMessage: \"'{{name}}' module is restricted from being used.\",\n            // eslint-disable-next-line eslint-plugin/report-message-format\n            customMessage: \"'{{name}}' module is restricted from being used. {{customMessage}}\",\n            patternMessage: \"'{{name}}' module is restricted from being used by a pattern.\"\n        }\n    },\n\n    create(context) {\n        const options = Array.isArray(context.options) ? context.options : [];\n        const isPathAndPatternsObject =\n            typeof options[0] === \"object\" &&\n            (Object.prototype.hasOwnProperty.call(options[0], \"paths\") || Object.prototype.hasOwnProperty.call(options[0], \"patterns\"));\n\n        const restrictedPaths = (isPathAndPatternsObject ? options[0].paths : context.options) || [];\n        const restrictedPatterns = (isPathAndPatternsObject ? options[0].patterns : []) || [];\n\n        const restrictedPathMessages = restrictedPaths.reduce((memo, importName) => {\n            if (typeof importName === \"string\") {\n                memo[importName] = null;\n            } else {\n                memo[importName.name] = importName.message;\n            }\n            return memo;\n        }, {});\n\n        // if no imports are restricted we don\"t need to check\n        if (Object.keys(restrictedPaths).length === 0 && restrictedPatterns.length === 0) {\n            return {};\n        }\n\n        const ig = ignore().add(restrictedPatterns);\n\n\n        /**\n         * Function to check if a node is a string literal.\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} If the node is a string literal.\n         */\n        function isStringLiteral(node) {\n            return node && node.type === \"Literal\" && typeof node.value === \"string\";\n        }\n\n        /**\n         * Function to check if a node is a static string template literal.\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} If the node is a string template literal.\n         */\n        function isStaticTemplateLiteral(node) {\n            return node && node.type === \"TemplateLiteral\" && node.expressions.length === 0;\n        }\n\n        /**\n         * Function to check if a node is a require call.\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} If the node is a require call.\n         */\n        function isRequireCall(node) {\n            return node.callee.type === \"Identifier\" && node.callee.name === \"require\";\n        }\n\n        /**\n         * Extract string from Literal or TemplateLiteral node\n         * @param {ASTNode} node The node to extract from\n         * @returns {string|null} Extracted string or null if node doesn't represent a string\n         */\n        function getFirstArgumentString(node) {\n            if (isStringLiteral(node)) {\n                return node.value.trim();\n            }\n\n            if (isStaticTemplateLiteral(node)) {\n                return node.quasis[0].value.cooked.trim();\n            }\n\n            return null;\n        }\n\n        /**\n         * Report a restricted path.\n         * @param {node} node representing the restricted path reference\n         * @param {string} name restricted path\n         * @returns {void}\n         * @private\n         */\n        function reportPath(node, name) {\n            const customMessage = restrictedPathMessages[name];\n            const messageId = customMessage\n                ? \"customMessage\"\n                : \"defaultMessage\";\n\n            context.report({\n                node,\n                messageId,\n                data: {\n                    name,\n                    customMessage\n                }\n            });\n        }\n\n        /**\n         * Check if the given name is a restricted path name\n         * @param {string} name name of a variable\n         * @returns {boolean} whether the variable is a restricted path or not\n         * @private\n         */\n        function isRestrictedPath(name) {\n            return Object.prototype.hasOwnProperty.call(restrictedPathMessages, name);\n        }\n\n        return {\n            CallExpression(node) {\n                if (isRequireCall(node)) {\n\n                    // node has arguments\n                    if (node.arguments.length) {\n                        const name = getFirstArgumentString(node.arguments[0]);\n\n                        // if first argument is a string literal or a static string template literal\n                        if (name) {\n\n                            // check if argument value is in restricted modules array\n                            if (isRestrictedPath(name)) {\n                                reportPath(node, name);\n                            }\n\n                            if (restrictedPatterns.length > 0 && ig.ignores(name)) {\n                                context.report({\n                                    node,\n                                    messageId: \"patternMessage\",\n                                    data: { name }\n                                });\n                            }\n                        }\n                    }\n                }\n            }\n        };\n    }\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,YAAY;;AAEZ;AACA;AACA;AAEA,MAAMA,MAAM,GAAGC,OAAO,CAAC,QAAQ,CAAC;AAEhC,MAAMC,cAAc,GAAG;EACnBC,IAAI,EAAE,OAAO;EACbC,KAAK,EAAE;IAAED,IAAI,EAAE;EAAS,CAAC;EACzBE,WAAW,EAAE;AACjB,CAAC;AAED,MAAMC,uBAAuB,GAAG;EAC5BH,IAAI,EAAE,OAAO;EACbC,KAAK,EAAE;IACHG,KAAK,EAAE,CACH;MAAEJ,IAAI,EAAE;IAAS,CAAC,EAClB;MACIA,IAAI,EAAE,QAAQ;MACdK,UAAU,EAAE;QACRC,IAAI,EAAE;UAAEN,IAAI,EAAE;QAAS,CAAC;QACxBO,OAAO,EAAE;UACLP,IAAI,EAAE,QAAQ;UACdQ,SAAS,EAAE;QACf;MACJ,CAAC;MACDC,oBAAoB,EAAE,KAAK;MAC3BC,QAAQ,EAAE,CAAC,MAAM;IACrB,CAAC;EAET,CAAC;EACDR,WAAW,EAAE;AACjB,CAAC;AAEDS,MAAM,CAACC,OAAO,GAAG;EACbC,IAAI,EAAE;IACFC,UAAU,EAAE,IAAI;IAEhBC,UAAU,EAAE,EAAE;IAEdf,IAAI,EAAE,YAAY;IAElBgB,IAAI,EAAE;MACFC,WAAW,EAAE,qDAAqD;MAClEC,QAAQ,EAAE,sBAAsB;MAChCC,WAAW,EAAE,KAAK;MAClBC,GAAG,EAAE;IACT,CAAC;IAEDC,MAAM,EAAE;MACJjB,KAAK,EAAE,CACHD,uBAAuB,EACvB;QACIH,IAAI,EAAE,OAAO;QACbC,KAAK,EAAE;UACHD,IAAI,EAAE,QAAQ;UACdK,UAAU,EAAE;YACRiB,KAAK,EAAEnB,uBAAuB;YAC9BoB,QAAQ,EAAExB;UACd,CAAC;UACDU,oBAAoB,EAAE;QAC1B,CAAC;QACDe,eAAe,EAAE;MACrB,CAAC;IAET,CAAC;IAEDC,QAAQ,EAAE;MACNC,cAAc,EAAE,kDAAkD;MAClE;MACAC,aAAa,EAAE,oEAAoE;MACnFC,cAAc,EAAE;IACpB;EACJ,CAAC;EAEDC,MAAMA,CAACC,OAAO,EAAE;IACZ,MAAMC,OAAO,GAAGC,KAAK,CAACC,OAAO,CAACH,OAAO,CAACC,OAAO,CAAC,GAAGD,OAAO,CAACC,OAAO,GAAG,EAAE;IACrE,MAAMG,uBAAuB,GACzB,OAAOH,OAAO,CAAC,CAAC,CAAC,KAAK,QAAQ,KAC7BI,MAAM,CAACC,SAAS,CAACC,cAAc,CAACC,IAAI,CAACP,OAAO,CAAC,CAAC,CAAC,EAAE,OAAO,CAAC,IAAII,MAAM,CAACC,SAAS,CAACC,cAAc,CAACC,IAAI,CAACP,OAAO,CAAC,CAAC,CAAC,EAAE,UAAU,CAAC,CAAC;IAE/H,MAAMQ,eAAe,GAAG,CAACL,uBAAuB,GAAGH,OAAO,CAAC,CAAC,CAAC,CAACT,KAAK,GAAGQ,OAAO,CAACC,OAAO,KAAK,EAAE;IAC5F,MAAMS,kBAAkB,GAAG,CAACN,uBAAuB,GAAGH,OAAO,CAAC,CAAC,CAAC,CAACR,QAAQ,GAAG,EAAE,KAAK,EAAE;IAErF,MAAMkB,sBAAsB,GAAGF,eAAe,CAACG,MAAM,CAAC,CAACC,IAAI,EAAEC,UAAU,KAAK;MACxE,IAAI,OAAOA,UAAU,KAAK,QAAQ,EAAE;QAChCD,IAAI,CAACC,UAAU,CAAC,GAAG,IAAI;MAC3B,CAAC,MAAM;QACHD,IAAI,CAACC,UAAU,CAACtC,IAAI,CAAC,GAAGsC,UAAU,CAACrC,OAAO;MAC9C;MACA,OAAOoC,IAAI;IACf,CAAC,EAAE,CAAC,CAAC,CAAC;;IAEN;IACA,IAAIR,MAAM,CAACU,IAAI,CAACN,eAAe,CAAC,CAACO,MAAM,KAAK,CAAC,IAAIN,kBAAkB,CAACM,MAAM,KAAK,CAAC,EAAE;MAC9E,OAAO,CAAC,CAAC;IACb;IAEA,MAAMC,EAAE,GAAGlD,MAAM,CAAC,CAAC,CAACmD,GAAG,CAACR,kBAAkB,CAAC;;IAG3C;AACR;AACA;AACA;AACA;IACQ,SAASS,eAAeA,CAACC,IAAI,EAAE;MAC3B,OAAOA,IAAI,IAAIA,IAAI,CAAClD,IAAI,KAAK,SAAS,IAAI,OAAOkD,IAAI,CAACC,KAAK,KAAK,QAAQ;IAC5E;;IAEA;AACR;AACA;AACA;AACA;IACQ,SAASC,uBAAuBA,CAACF,IAAI,EAAE;MACnC,OAAOA,IAAI,IAAIA,IAAI,CAAClD,IAAI,KAAK,iBAAiB,IAAIkD,IAAI,CAACG,WAAW,CAACP,MAAM,KAAK,CAAC;IACnF;;IAEA;AACR;AACA;AACA;AACA;IACQ,SAASQ,aAAaA,CAACJ,IAAI,EAAE;MACzB,OAAOA,IAAI,CAACK,MAAM,CAACvD,IAAI,KAAK,YAAY,IAAIkD,IAAI,CAACK,MAAM,CAACjD,IAAI,KAAK,SAAS;IAC9E;;IAEA;AACR;AACA;AACA;AACA;IACQ,SAASkD,sBAAsBA,CAACN,IAAI,EAAE;MAClC,IAAID,eAAe,CAACC,IAAI,CAAC,EAAE;QACvB,OAAOA,IAAI,CAACC,KAAK,CAACM,IAAI,CAAC,CAAC;MAC5B;MAEA,IAAIL,uBAAuB,CAACF,IAAI,CAAC,EAAE;QAC/B,OAAOA,IAAI,CAACQ,MAAM,CAAC,CAAC,CAAC,CAACP,KAAK,CAACQ,MAAM,CAACF,IAAI,CAAC,CAAC;MAC7C;MAEA,OAAO,IAAI;IACf;;IAEA;AACR;AACA;AACA;AACA;AACA;AACA;IACQ,SAASG,UAAUA,CAACV,IAAI,EAAE5C,IAAI,EAAE;MAC5B,MAAMqB,aAAa,GAAGc,sBAAsB,CAACnC,IAAI,CAAC;MAClD,MAAMuD,SAAS,GAAGlC,aAAa,GACzB,eAAe,GACf,gBAAgB;MAEtBG,OAAO,CAACgC,MAAM,CAAC;QACXZ,IAAI;QACJW,SAAS;QACTE,IAAI,EAAE;UACFzD,IAAI;UACJqB;QACJ;MACJ,CAAC,CAAC;IACN;;IAEA;AACR;AACA;AACA;AACA;AACA;IACQ,SAASqC,gBAAgBA,CAAC1D,IAAI,EAAE;MAC5B,OAAO6B,MAAM,CAACC,SAAS,CAACC,cAAc,CAACC,IAAI,CAACG,sBAAsB,EAAEnC,IAAI,CAAC;IAC7E;IAEA,OAAO;MACH2D,cAAcA,CAACf,IAAI,EAAE;QACjB,IAAII,aAAa,CAACJ,IAAI,CAAC,EAAE;UAErB;UACA,IAAIA,IAAI,CAACgB,SAAS,CAACpB,MAAM,EAAE;YACvB,MAAMxC,IAAI,GAAGkD,sBAAsB,CAACN,IAAI,CAACgB,SAAS,CAAC,CAAC,CAAC,CAAC;;YAEtD;YACA,IAAI5D,IAAI,EAAE;cAEN;cACA,IAAI0D,gBAAgB,CAAC1D,IAAI,CAAC,EAAE;gBACxBsD,UAAU,CAACV,IAAI,EAAE5C,IAAI,CAAC;cAC1B;cAEA,IAAIkC,kBAAkB,CAACM,MAAM,GAAG,CAAC,IAAIC,EAAE,CAACoB,OAAO,CAAC7D,IAAI,CAAC,EAAE;gBACnDwB,OAAO,CAACgC,MAAM,CAAC;kBACXZ,IAAI;kBACJW,SAAS,EAAE,gBAAgB;kBAC3BE,IAAI,EAAE;oBAAEzD;kBAAK;gBACjB,CAAC,CAAC;cACN;YACJ;UACJ;QACJ;MACJ;IACJ,CAAC;EACL;AACJ,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}