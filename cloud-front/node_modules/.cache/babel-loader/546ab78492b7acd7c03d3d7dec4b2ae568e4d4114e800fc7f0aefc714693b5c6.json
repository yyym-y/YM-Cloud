{"ast":null,"code":"/**\n * @fileoverview Rule to enforce return statements in callbacks of array's methods\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst TARGET_NODE_TYPE = /^(?:Arrow)?FunctionExpression$/u;\nconst TARGET_METHODS = /^(?:every|filter|find(?:Index)?|flatMap|forEach|map|reduce(?:Right)?|some|sort)$/u;\n\n/**\n * Checks a given code path segment is reachable.\n * @param {CodePathSegment} segment A segment to check.\n * @returns {boolean} `true` if the segment is reachable.\n */\nfunction isReachable(segment) {\n  return segment.reachable;\n}\n\n/**\n * Checks a given node is a member access which has the specified name's\n * property.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node is a member access which has\n *      the specified name's property. The node may be a `(Chain|Member)Expression` node.\n */\nfunction isTargetMethod(node) {\n  return astUtils.isSpecificMemberAccess(node, null, TARGET_METHODS);\n}\n\n/**\n * Returns a human-legible description of an array method\n * @param {string} arrayMethodName A method name to fully qualify\n * @returns {string} the method name prefixed with `Array.` if it is a class method,\n *      or else `Array.prototype.` if it is an instance method.\n */\nfunction fullMethodName(arrayMethodName) {\n  if ([\"from\", \"of\", \"isArray\"].includes(arrayMethodName)) {\n    return \"Array.\".concat(arrayMethodName);\n  }\n  return \"Array.prototype.\".concat(arrayMethodName);\n}\n\n/**\n * Checks whether or not a given node is a function expression which is the\n * callback of an array method, returning the method name.\n * @param {ASTNode} node A node to check. This is one of\n *      FunctionExpression or ArrowFunctionExpression.\n * @returns {string} The method name if the node is a callback method,\n *      null otherwise.\n */\nfunction getArrayMethodName(node) {\n  let currentNode = node;\n  while (currentNode) {\n    const parent = currentNode.parent;\n    switch (parent.type) {\n      /*\n       * Looks up the destination. e.g.,\n       * foo.every(nativeFoo || function foo() { ... });\n       */\n      case \"LogicalExpression\":\n      case \"ConditionalExpression\":\n      case \"ChainExpression\":\n        currentNode = parent;\n        break;\n\n      /*\n       * If the upper function is IIFE, checks the destination of the return value.\n       * e.g.\n       *   foo.every((function() {\n       *     // setup...\n       *     return function callback() { ... };\n       *   })());\n       */\n      case \"ReturnStatement\":\n        {\n          const func = astUtils.getUpperFunction(parent);\n          if (func === null || !astUtils.isCallee(func)) {\n            return null;\n          }\n          currentNode = func.parent;\n          break;\n        }\n\n      /*\n       * e.g.\n       *   Array.from([], function() {});\n       *   list.every(function() {});\n       */\n      case \"CallExpression\":\n        if (astUtils.isArrayFromMethod(parent.callee)) {\n          if (parent.arguments.length >= 2 && parent.arguments[1] === currentNode) {\n            return \"from\";\n          }\n        }\n        if (isTargetMethod(parent.callee)) {\n          if (parent.arguments.length >= 1 && parent.arguments[0] === currentNode) {\n            return astUtils.getStaticPropertyName(parent.callee);\n          }\n        }\n        return null;\n\n      // Otherwise this node is not target.\n      default:\n        return null;\n    }\n  }\n\n  /* istanbul ignore next: unreachable */\n  return null;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"enforce `return` statements in callbacks of array methods\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/array-callback-return\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        allowImplicit: {\n          type: \"boolean\",\n          default: false\n        },\n        checkForEach: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      expectedAtEnd: \"{{arrayMethodName}}() expects a value to be returned at the end of {{name}}.\",\n      expectedInside: \"{{arrayMethodName}}() expects a return value from {{name}}.\",\n      expectedReturnValue: \"{{arrayMethodName}}() expects a return value from {{name}}.\",\n      expectedNoReturnValue: \"{{arrayMethodName}}() expects no useless return value from {{name}}.\"\n    }\n  },\n  create(context) {\n    const options = context.options[0] || {\n      allowImplicit: false,\n      checkForEach: false\n    };\n    const sourceCode = context.getSourceCode();\n    let funcInfo = {\n      arrayMethodName: null,\n      upper: null,\n      codePath: null,\n      hasReturn: false,\n      shouldCheck: false,\n      node: null\n    };\n\n    /**\n     * Checks whether or not the last code path segment is reachable.\n     * Then reports this function if the segment is reachable.\n     *\n     * If the last code path segment is reachable, there are paths which are not\n     * returned or thrown.\n     * @param {ASTNode} node A node to check.\n     * @returns {void}\n     */\n    function checkLastSegment(node) {\n      if (!funcInfo.shouldCheck) {\n        return;\n      }\n      let messageId = null;\n      if (funcInfo.arrayMethodName === \"forEach\") {\n        if (options.checkForEach && node.type === \"ArrowFunctionExpression\" && node.expression) {\n          messageId = \"expectedNoReturnValue\";\n        }\n      } else {\n        if (node.body.type === \"BlockStatement\" && funcInfo.codePath.currentSegments.some(isReachable)) {\n          messageId = funcInfo.hasReturn ? \"expectedAtEnd\" : \"expectedInside\";\n        }\n      }\n      if (messageId) {\n        const name = astUtils.getFunctionNameWithKind(node);\n        context.report({\n          node,\n          loc: astUtils.getFunctionHeadLoc(node, sourceCode),\n          messageId,\n          data: {\n            name,\n            arrayMethodName: fullMethodName(funcInfo.arrayMethodName)\n          }\n        });\n      }\n    }\n    return {\n      // Stacks this function's information.\n      onCodePathStart(codePath, node) {\n        let methodName = null;\n        if (TARGET_NODE_TYPE.test(node.type)) {\n          methodName = getArrayMethodName(node);\n        }\n        funcInfo = {\n          arrayMethodName: methodName,\n          upper: funcInfo,\n          codePath,\n          hasReturn: false,\n          shouldCheck: methodName && !node.async && !node.generator,\n          node\n        };\n      },\n      // Pops this function's information.\n      onCodePathEnd() {\n        funcInfo = funcInfo.upper;\n      },\n      // Checks the return statement is valid.\n      ReturnStatement(node) {\n        if (!funcInfo.shouldCheck) {\n          return;\n        }\n        funcInfo.hasReturn = true;\n        let messageId = null;\n        if (funcInfo.arrayMethodName === \"forEach\") {\n          // if checkForEach: true, returning a value at any path inside a forEach is not allowed\n          if (options.checkForEach && node.argument) {\n            messageId = \"expectedNoReturnValue\";\n          }\n        } else {\n          // if allowImplicit: false, should also check node.argument\n          if (!options.allowImplicit && !node.argument) {\n            messageId = \"expectedReturnValue\";\n          }\n        }\n        if (messageId) {\n          context.report({\n            node,\n            messageId,\n            data: {\n              name: astUtils.getFunctionNameWithKind(funcInfo.node),\n              arrayMethodName: fullMethodName(funcInfo.arrayMethodName)\n            }\n          });\n        }\n      },\n      // Reports a given function if the last path is reachable.\n      \"FunctionExpression:exit\": checkLastSegment,\n      \"ArrowFunctionExpression:exit\": checkLastSegment\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","TARGET_NODE_TYPE","TARGET_METHODS","isReachable","segment","reachable","isTargetMethod","node","isSpecificMemberAccess","fullMethodName","arrayMethodName","includes","concat","getArrayMethodName","currentNode","parent","type","func","getUpperFunction","isCallee","isArrayFromMethod","callee","arguments","length","getStaticPropertyName","module","exports","meta","docs","description","category","recommended","url","schema","properties","allowImplicit","default","checkForEach","additionalProperties","messages","expectedAtEnd","expectedInside","expectedReturnValue","expectedNoReturnValue","create","context","options","sourceCode","getSourceCode","funcInfo","upper","codePath","hasReturn","shouldCheck","checkLastSegment","messageId","expression","body","currentSegments","some","name","getFunctionNameWithKind","report","loc","getFunctionHeadLoc","data","onCodePathStart","methodName","test","async","generator","onCodePathEnd","ReturnStatement","argument"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/array-callback-return.js"],"sourcesContent":["/**\n * @fileoverview Rule to enforce return statements in callbacks of array's methods\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst TARGET_NODE_TYPE = /^(?:Arrow)?FunctionExpression$/u;\nconst TARGET_METHODS = /^(?:every|filter|find(?:Index)?|flatMap|forEach|map|reduce(?:Right)?|some|sort)$/u;\n\n/**\n * Checks a given code path segment is reachable.\n * @param {CodePathSegment} segment A segment to check.\n * @returns {boolean} `true` if the segment is reachable.\n */\nfunction isReachable(segment) {\n    return segment.reachable;\n}\n\n/**\n * Checks a given node is a member access which has the specified name's\n * property.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node is a member access which has\n *      the specified name's property. The node may be a `(Chain|Member)Expression` node.\n */\nfunction isTargetMethod(node) {\n    return astUtils.isSpecificMemberAccess(node, null, TARGET_METHODS);\n}\n\n/**\n * Returns a human-legible description of an array method\n * @param {string} arrayMethodName A method name to fully qualify\n * @returns {string} the method name prefixed with `Array.` if it is a class method,\n *      or else `Array.prototype.` if it is an instance method.\n */\nfunction fullMethodName(arrayMethodName) {\n    if ([\"from\", \"of\", \"isArray\"].includes(arrayMethodName)) {\n        return \"Array.\".concat(arrayMethodName);\n    }\n    return \"Array.prototype.\".concat(arrayMethodName);\n}\n\n/**\n * Checks whether or not a given node is a function expression which is the\n * callback of an array method, returning the method name.\n * @param {ASTNode} node A node to check. This is one of\n *      FunctionExpression or ArrowFunctionExpression.\n * @returns {string} The method name if the node is a callback method,\n *      null otherwise.\n */\nfunction getArrayMethodName(node) {\n    let currentNode = node;\n\n    while (currentNode) {\n        const parent = currentNode.parent;\n\n        switch (parent.type) {\n\n            /*\n             * Looks up the destination. e.g.,\n             * foo.every(nativeFoo || function foo() { ... });\n             */\n            case \"LogicalExpression\":\n            case \"ConditionalExpression\":\n            case \"ChainExpression\":\n                currentNode = parent;\n                break;\n\n            /*\n             * If the upper function is IIFE, checks the destination of the return value.\n             * e.g.\n             *   foo.every((function() {\n             *     // setup...\n             *     return function callback() { ... };\n             *   })());\n             */\n            case \"ReturnStatement\": {\n                const func = astUtils.getUpperFunction(parent);\n\n                if (func === null || !astUtils.isCallee(func)) {\n                    return null;\n                }\n                currentNode = func.parent;\n                break;\n            }\n\n            /*\n             * e.g.\n             *   Array.from([], function() {});\n             *   list.every(function() {});\n             */\n            case \"CallExpression\":\n                if (astUtils.isArrayFromMethod(parent.callee)) {\n                    if (\n                        parent.arguments.length >= 2 &&\n                        parent.arguments[1] === currentNode\n                    ) {\n                        return \"from\";\n                    }\n                }\n                if (isTargetMethod(parent.callee)) {\n                    if (\n                        parent.arguments.length >= 1 &&\n                        parent.arguments[0] === currentNode\n                    ) {\n                        return astUtils.getStaticPropertyName(parent.callee);\n                    }\n                }\n                return null;\n\n            // Otherwise this node is not target.\n            default:\n                return null;\n        }\n    }\n\n    /* istanbul ignore next: unreachable */\n    return null;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"enforce `return` statements in callbacks of array methods\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/array-callback-return\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allowImplicit: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    checkForEach: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            expectedAtEnd: \"{{arrayMethodName}}() expects a value to be returned at the end of {{name}}.\",\n            expectedInside: \"{{arrayMethodName}}() expects a return value from {{name}}.\",\n            expectedReturnValue: \"{{arrayMethodName}}() expects a return value from {{name}}.\",\n            expectedNoReturnValue: \"{{arrayMethodName}}() expects no useless return value from {{name}}.\"\n        }\n    },\n\n    create(context) {\n\n        const options = context.options[0] || { allowImplicit: false, checkForEach: false };\n        const sourceCode = context.getSourceCode();\n\n        let funcInfo = {\n            arrayMethodName: null,\n            upper: null,\n            codePath: null,\n            hasReturn: false,\n            shouldCheck: false,\n            node: null\n        };\n\n        /**\n         * Checks whether or not the last code path segment is reachable.\n         * Then reports this function if the segment is reachable.\n         *\n         * If the last code path segment is reachable, there are paths which are not\n         * returned or thrown.\n         * @param {ASTNode} node A node to check.\n         * @returns {void}\n         */\n        function checkLastSegment(node) {\n\n            if (!funcInfo.shouldCheck) {\n                return;\n            }\n\n            let messageId = null;\n\n            if (funcInfo.arrayMethodName === \"forEach\") {\n                if (options.checkForEach && node.type === \"ArrowFunctionExpression\" && node.expression) {\n                    messageId = \"expectedNoReturnValue\";\n                }\n            } else {\n                if (node.body.type === \"BlockStatement\" && funcInfo.codePath.currentSegments.some(isReachable)) {\n                    messageId = funcInfo.hasReturn ? \"expectedAtEnd\" : \"expectedInside\";\n                }\n            }\n\n            if (messageId) {\n                const name = astUtils.getFunctionNameWithKind(node);\n\n                context.report({\n                    node,\n                    loc: astUtils.getFunctionHeadLoc(node, sourceCode),\n                    messageId,\n                    data: { name, arrayMethodName: fullMethodName(funcInfo.arrayMethodName) }\n                });\n            }\n        }\n\n        return {\n\n            // Stacks this function's information.\n            onCodePathStart(codePath, node) {\n\n                let methodName = null;\n\n                if (TARGET_NODE_TYPE.test(node.type)) {\n                    methodName = getArrayMethodName(node);\n                }\n\n                funcInfo = {\n                    arrayMethodName: methodName,\n                    upper: funcInfo,\n                    codePath,\n                    hasReturn: false,\n                    shouldCheck:\n                        methodName &&\n                        !node.async &&\n                        !node.generator,\n                    node\n                };\n            },\n\n            // Pops this function's information.\n            onCodePathEnd() {\n                funcInfo = funcInfo.upper;\n            },\n\n            // Checks the return statement is valid.\n            ReturnStatement(node) {\n\n                if (!funcInfo.shouldCheck) {\n                    return;\n                }\n\n                funcInfo.hasReturn = true;\n\n                let messageId = null;\n\n                if (funcInfo.arrayMethodName === \"forEach\") {\n\n                    // if checkForEach: true, returning a value at any path inside a forEach is not allowed\n                    if (options.checkForEach && node.argument) {\n                        messageId = \"expectedNoReturnValue\";\n                    }\n                } else {\n\n                    // if allowImplicit: false, should also check node.argument\n                    if (!options.allowImplicit && !node.argument) {\n                        messageId = \"expectedReturnValue\";\n                    }\n                }\n\n                if (messageId) {\n                    context.report({\n                        node,\n                        messageId,\n                        data: {\n                            name: astUtils.getFunctionNameWithKind(funcInfo.node),\n                            arrayMethodName: fullMethodName(funcInfo.arrayMethodName)\n                        }\n                    });\n                }\n            },\n\n            // Reports a given function if the last path is reachable.\n            \"FunctionExpression:exit\": checkLastSegment,\n            \"ArrowFunctionExpression:exit\": checkLastSegment\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}