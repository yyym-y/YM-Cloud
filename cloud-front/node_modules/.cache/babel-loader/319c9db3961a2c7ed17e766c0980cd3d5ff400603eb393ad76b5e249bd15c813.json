{"ast":null,"code":"require(\"core-js/modules/es.array.push.js\");\nvar path = require('path');\nvar crypto = require('crypto');\nmodule.exports = {\n  createFromFile: function (filePath, useChecksum) {\n    var fname = path.basename(filePath);\n    var dir = path.dirname(filePath);\n    return this.create(fname, dir, useChecksum);\n  },\n  create: function (cacheId, _path, useChecksum) {\n    var fs = require('fs');\n    var flatCache = require('flat-cache');\n    var cache = flatCache.load(cacheId, _path);\n    var normalizedEntries = {};\n    var removeNotFoundFiles = function removeNotFoundFiles() {\n      const cachedEntries = cache.keys();\n      // remove not found entries\n      cachedEntries.forEach(function remover(fPath) {\n        try {\n          fs.statSync(fPath);\n        } catch (err) {\n          if (err.code === 'ENOENT') {\n            cache.removeKey(fPath);\n          }\n        }\n      });\n    };\n    removeNotFoundFiles();\n    return {\n      /**\n       * the flat cache storage used to persist the metadata of the `files\n       * @type {Object}\n       */\n      cache: cache,\n      /**\n       * Given a buffer, calculate md5 hash of its content.\n       * @method getHash\n       * @param  {Buffer} buffer   buffer to calculate hash on\n       * @return {String}          content hash digest\n       */\n      getHash: function (buffer) {\n        return crypto.createHash('md5').update(buffer).digest('hex');\n      },\n      /**\n       * Return whether or not a file has changed since last time reconcile was called.\n       * @method hasFileChanged\n       * @param  {String}  file  the filepath to check\n       * @return {Boolean}       wheter or not the file has changed\n       */\n      hasFileChanged: function (file) {\n        return this.getFileDescriptor(file).changed;\n      },\n      /**\n       * given an array of file paths it return and object with three arrays:\n       *  - changedFiles: Files that changed since previous run\n       *  - notChangedFiles: Files that haven't change\n       *  - notFoundFiles: Files that were not found, probably deleted\n       *\n       * @param  {Array} files the files to analyze and compare to the previous seen files\n       * @return {[type]}       [description]\n       */\n      analyzeFiles: function (files) {\n        var me = this;\n        files = files || [];\n        var res = {\n          changedFiles: [],\n          notFoundFiles: [],\n          notChangedFiles: []\n        };\n        me.normalizeEntries(files).forEach(function (entry) {\n          if (entry.changed) {\n            res.changedFiles.push(entry.key);\n            return;\n          }\n          if (entry.notFound) {\n            res.notFoundFiles.push(entry.key);\n            return;\n          }\n          res.notChangedFiles.push(entry.key);\n        });\n        return res;\n      },\n      getFileDescriptor: function (file) {\n        var fstat;\n        try {\n          fstat = fs.statSync(file);\n        } catch (ex) {\n          this.removeEntry(file);\n          return {\n            key: file,\n            notFound: true,\n            err: ex\n          };\n        }\n        if (useChecksum) {\n          return this._getFileDescriptorUsingChecksum(file);\n        }\n        return this._getFileDescriptorUsingMtimeAndSize(file, fstat);\n      },\n      _getFileDescriptorUsingMtimeAndSize: function (file, fstat) {\n        var meta = cache.getKey(file);\n        var cacheExists = !!meta;\n        var cSize = fstat.size;\n        var cTime = fstat.mtime.getTime();\n        var isDifferentDate;\n        var isDifferentSize;\n        if (!meta) {\n          meta = {\n            size: cSize,\n            mtime: cTime\n          };\n        } else {\n          isDifferentDate = cTime !== meta.mtime;\n          isDifferentSize = cSize !== meta.size;\n        }\n        var nEntry = normalizedEntries[file] = {\n          key: file,\n          changed: !cacheExists || isDifferentDate || isDifferentSize,\n          meta: meta\n        };\n        return nEntry;\n      },\n      _getFileDescriptorUsingChecksum: function (file) {\n        var meta = cache.getKey(file);\n        var cacheExists = !!meta;\n        var contentBuffer;\n        try {\n          contentBuffer = fs.readFileSync(file);\n        } catch (ex) {\n          contentBuffer = '';\n        }\n        var isDifferent = true;\n        var hash = this.getHash(contentBuffer);\n        if (!meta) {\n          meta = {\n            hash: hash\n          };\n        } else {\n          isDifferent = hash !== meta.hash;\n        }\n        var nEntry = normalizedEntries[file] = {\n          key: file,\n          changed: !cacheExists || isDifferent,\n          meta: meta\n        };\n        return nEntry;\n      },\n      /**\n       * Return the list o the files that changed compared\n       * against the ones stored in the cache\n       *\n       * @method getUpdated\n       * @param files {Array} the array of files to compare against the ones in the cache\n       * @returns {Array}\n       */\n      getUpdatedFiles: function (files) {\n        var me = this;\n        files = files || [];\n        return me.normalizeEntries(files).filter(function (entry) {\n          return entry.changed;\n        }).map(function (entry) {\n          return entry.key;\n        });\n      },\n      /**\n       * return the list of files\n       * @method normalizeEntries\n       * @param files\n       * @returns {*}\n       */\n      normalizeEntries: function (files) {\n        files = files || [];\n        var me = this;\n        var nEntries = files.map(function (file) {\n          return me.getFileDescriptor(file);\n        });\n\n        //normalizeEntries = nEntries;\n        return nEntries;\n      },\n      /**\n       * Remove an entry from the file-entry-cache. Useful to force the file to still be considered\n       * modified the next time the process is run\n       *\n       * @method removeEntry\n       * @param entryName\n       */\n      removeEntry: function (entryName) {\n        delete normalizedEntries[entryName];\n        cache.removeKey(entryName);\n      },\n      /**\n       * Delete the cache file from the disk\n       * @method deleteCacheFile\n       */\n      deleteCacheFile: function () {\n        cache.removeCacheFile();\n      },\n      /**\n       * remove the cache from the file and clear the memory cache\n       */\n      destroy: function () {\n        normalizedEntries = {};\n        cache.destroy();\n      },\n      _getMetaForFileUsingCheckSum: function (cacheEntry) {\n        var contentBuffer = fs.readFileSync(cacheEntry.key);\n        var hash = this.getHash(contentBuffer);\n        var meta = Object.assign(cacheEntry.meta, {\n          hash: hash\n        });\n        delete meta.size;\n        delete meta.mtime;\n        return meta;\n      },\n      _getMetaForFileUsingMtimeAndSize: function (cacheEntry) {\n        var stat = fs.statSync(cacheEntry.key);\n        var meta = Object.assign(cacheEntry.meta, {\n          size: stat.size,\n          mtime: stat.mtime.getTime()\n        });\n        delete meta.hash;\n        return meta;\n      },\n      /**\n       * Sync the files and persist them to the cache\n       * @method reconcile\n       */\n      reconcile: function (noPrune) {\n        removeNotFoundFiles();\n        noPrune = typeof noPrune === 'undefined' ? true : noPrune;\n        var entries = normalizedEntries;\n        var keys = Object.keys(entries);\n        if (keys.length === 0) {\n          return;\n        }\n        var me = this;\n        keys.forEach(function (entryName) {\n          var cacheEntry = entries[entryName];\n          try {\n            var meta = useChecksum ? me._getMetaForFileUsingCheckSum(cacheEntry) : me._getMetaForFileUsingMtimeAndSize(cacheEntry);\n            cache.setKey(entryName, meta);\n          } catch (err) {\n            // if the file does not exists we don't save it\n            // other errors are just thrown\n            if (err.code !== 'ENOENT') {\n              throw err;\n            }\n          }\n        });\n        cache.save(noPrune);\n      }\n    };\n  }\n};","map":{"version":3,"names":["path","require","crypto","module","exports","createFromFile","filePath","useChecksum","fname","basename","dir","dirname","create","cacheId","_path","fs","flatCache","cache","load","normalizedEntries","removeNotFoundFiles","cachedEntries","keys","forEach","remover","fPath","statSync","err","code","removeKey","getHash","buffer","createHash","update","digest","hasFileChanged","file","getFileDescriptor","changed","analyzeFiles","files","me","res","changedFiles","notFoundFiles","notChangedFiles","normalizeEntries","entry","push","key","notFound","fstat","ex","removeEntry","_getFileDescriptorUsingChecksum","_getFileDescriptorUsingMtimeAndSize","meta","getKey","cacheExists","cSize","size","cTime","mtime","getTime","isDifferentDate","isDifferentSize","nEntry","contentBuffer","readFileSync","isDifferent","hash","getUpdatedFiles","filter","map","nEntries","entryName","deleteCacheFile","removeCacheFile","destroy","_getMetaForFileUsingCheckSum","cacheEntry","Object","assign","_getMetaForFileUsingMtimeAndSize","stat","reconcile","noPrune","entries","length","setKey","save"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/file-entry-cache/cache.js"],"sourcesContent":["var path = require('path');\nvar crypto = require('crypto');\n\nmodule.exports = {\n  createFromFile: function (filePath, useChecksum) {\n    var fname = path.basename(filePath);\n    var dir = path.dirname(filePath);\n    return this.create(fname, dir, useChecksum);\n  },\n\n  create: function (cacheId, _path, useChecksum) {\n    var fs = require('fs');\n    var flatCache = require('flat-cache');\n    var cache = flatCache.load(cacheId, _path);\n    var normalizedEntries = {};\n\n    var removeNotFoundFiles = function removeNotFoundFiles() {\n      const cachedEntries = cache.keys();\n      // remove not found entries\n      cachedEntries.forEach(function remover(fPath) {\n        try {\n          fs.statSync(fPath);\n        } catch (err) {\n          if (err.code === 'ENOENT') {\n            cache.removeKey(fPath);\n          }\n        }\n      });\n    };\n\n    removeNotFoundFiles();\n\n    return {\n      /**\n       * the flat cache storage used to persist the metadata of the `files\n       * @type {Object}\n       */\n      cache: cache,\n\n      /**\n       * Given a buffer, calculate md5 hash of its content.\n       * @method getHash\n       * @param  {Buffer} buffer   buffer to calculate hash on\n       * @return {String}          content hash digest\n       */\n      getHash: function (buffer) {\n        return crypto.createHash('md5').update(buffer).digest('hex');\n      },\n\n      /**\n       * Return whether or not a file has changed since last time reconcile was called.\n       * @method hasFileChanged\n       * @param  {String}  file  the filepath to check\n       * @return {Boolean}       wheter or not the file has changed\n       */\n      hasFileChanged: function (file) {\n        return this.getFileDescriptor(file).changed;\n      },\n\n      /**\n       * given an array of file paths it return and object with three arrays:\n       *  - changedFiles: Files that changed since previous run\n       *  - notChangedFiles: Files that haven't change\n       *  - notFoundFiles: Files that were not found, probably deleted\n       *\n       * @param  {Array} files the files to analyze and compare to the previous seen files\n       * @return {[type]}       [description]\n       */\n      analyzeFiles: function (files) {\n        var me = this;\n        files = files || [];\n\n        var res = {\n          changedFiles: [],\n          notFoundFiles: [],\n          notChangedFiles: [],\n        };\n\n        me.normalizeEntries(files).forEach(function (entry) {\n          if (entry.changed) {\n            res.changedFiles.push(entry.key);\n            return;\n          }\n          if (entry.notFound) {\n            res.notFoundFiles.push(entry.key);\n            return;\n          }\n          res.notChangedFiles.push(entry.key);\n        });\n        return res;\n      },\n\n      getFileDescriptor: function (file) {\n        var fstat;\n\n        try {\n          fstat = fs.statSync(file);\n        } catch (ex) {\n          this.removeEntry(file);\n          return { key: file, notFound: true, err: ex };\n        }\n\n        if (useChecksum) {\n          return this._getFileDescriptorUsingChecksum(file);\n        }\n\n        return this._getFileDescriptorUsingMtimeAndSize(file, fstat);\n      },\n\n      _getFileDescriptorUsingMtimeAndSize: function (file, fstat) {\n        var meta = cache.getKey(file);\n        var cacheExists = !!meta;\n\n        var cSize = fstat.size;\n        var cTime = fstat.mtime.getTime();\n\n        var isDifferentDate;\n        var isDifferentSize;\n\n        if (!meta) {\n          meta = { size: cSize, mtime: cTime };\n        } else {\n          isDifferentDate = cTime !== meta.mtime;\n          isDifferentSize = cSize !== meta.size;\n        }\n\n        var nEntry = (normalizedEntries[file] = {\n          key: file,\n          changed: !cacheExists || isDifferentDate || isDifferentSize,\n          meta: meta,\n        });\n\n        return nEntry;\n      },\n\n      _getFileDescriptorUsingChecksum: function (file) {\n        var meta = cache.getKey(file);\n        var cacheExists = !!meta;\n\n        var contentBuffer;\n        try {\n          contentBuffer = fs.readFileSync(file);\n        } catch (ex) {\n          contentBuffer = '';\n        }\n\n        var isDifferent = true;\n        var hash = this.getHash(contentBuffer);\n\n        if (!meta) {\n          meta = { hash: hash };\n        } else {\n          isDifferent = hash !== meta.hash;\n        }\n\n        var nEntry = (normalizedEntries[file] = {\n          key: file,\n          changed: !cacheExists || isDifferent,\n          meta: meta,\n        });\n\n        return nEntry;\n      },\n\n      /**\n       * Return the list o the files that changed compared\n       * against the ones stored in the cache\n       *\n       * @method getUpdated\n       * @param files {Array} the array of files to compare against the ones in the cache\n       * @returns {Array}\n       */\n      getUpdatedFiles: function (files) {\n        var me = this;\n        files = files || [];\n\n        return me\n          .normalizeEntries(files)\n          .filter(function (entry) {\n            return entry.changed;\n          })\n          .map(function (entry) {\n            return entry.key;\n          });\n      },\n\n      /**\n       * return the list of files\n       * @method normalizeEntries\n       * @param files\n       * @returns {*}\n       */\n      normalizeEntries: function (files) {\n        files = files || [];\n\n        var me = this;\n        var nEntries = files.map(function (file) {\n          return me.getFileDescriptor(file);\n        });\n\n        //normalizeEntries = nEntries;\n        return nEntries;\n      },\n\n      /**\n       * Remove an entry from the file-entry-cache. Useful to force the file to still be considered\n       * modified the next time the process is run\n       *\n       * @method removeEntry\n       * @param entryName\n       */\n      removeEntry: function (entryName) {\n        delete normalizedEntries[entryName];\n        cache.removeKey(entryName);\n      },\n\n      /**\n       * Delete the cache file from the disk\n       * @method deleteCacheFile\n       */\n      deleteCacheFile: function () {\n        cache.removeCacheFile();\n      },\n\n      /**\n       * remove the cache from the file and clear the memory cache\n       */\n      destroy: function () {\n        normalizedEntries = {};\n        cache.destroy();\n      },\n\n      _getMetaForFileUsingCheckSum: function (cacheEntry) {\n        var contentBuffer = fs.readFileSync(cacheEntry.key);\n        var hash = this.getHash(contentBuffer);\n        var meta = Object.assign(cacheEntry.meta, { hash: hash });\n        delete meta.size;\n        delete meta.mtime;\n        return meta;\n      },\n\n      _getMetaForFileUsingMtimeAndSize: function (cacheEntry) {\n        var stat = fs.statSync(cacheEntry.key);\n        var meta = Object.assign(cacheEntry.meta, {\n          size: stat.size,\n          mtime: stat.mtime.getTime(),\n        });\n        delete meta.hash;\n        return meta;\n      },\n\n      /**\n       * Sync the files and persist them to the cache\n       * @method reconcile\n       */\n      reconcile: function (noPrune) {\n        removeNotFoundFiles();\n\n        noPrune = typeof noPrune === 'undefined' ? true : noPrune;\n\n        var entries = normalizedEntries;\n        var keys = Object.keys(entries);\n\n        if (keys.length === 0) {\n          return;\n        }\n\n        var me = this;\n\n        keys.forEach(function (entryName) {\n          var cacheEntry = entries[entryName];\n\n          try {\n            var meta = useChecksum\n              ? me._getMetaForFileUsingCheckSum(cacheEntry)\n              : me._getMetaForFileUsingMtimeAndSize(cacheEntry);\n            cache.setKey(entryName, meta);\n          } catch (err) {\n            // if the file does not exists we don't save it\n            // other errors are just thrown\n            if (err.code !== 'ENOENT') {\n              throw err;\n            }\n          }\n        });\n\n        cache.save(noPrune);\n      },\n    };\n  },\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}