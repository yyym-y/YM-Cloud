{"ast":null,"code":"/**\n * @fileoverview Rule to require or disallow newlines between statements\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nrequire(\"core-js/modules/es.array.push.js\");\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst LT = `[${Array.from(astUtils.LINEBREAKS).join(\"\")}]`;\nconst PADDING_LINE_SEQUENCE = new RegExp(String.raw`^(\\s*?${LT})\\s*${LT}(\\s*;?)$`, \"u\");\nconst CJS_EXPORT = /^(?:module\\s*\\.\\s*)?exports(?:\\s*\\.|\\s*\\[|$)/u;\nconst CJS_IMPORT = /^require\\(/u;\n\n/**\n * Creates tester which check if a node starts with specific keyword.\n * @param {string} keyword The keyword to test.\n * @returns {Object} the created tester.\n * @private\n */\nfunction newKeywordTester(keyword) {\n  return {\n    test: (node, sourceCode) => sourceCode.getFirstToken(node).value === keyword\n  };\n}\n\n/**\n * Creates tester which check if a node starts with specific keyword and spans a single line.\n * @param {string} keyword The keyword to test.\n * @returns {Object} the created tester.\n * @private\n */\nfunction newSinglelineKeywordTester(keyword) {\n  return {\n    test: (node, sourceCode) => node.loc.start.line === node.loc.end.line && sourceCode.getFirstToken(node).value === keyword\n  };\n}\n\n/**\n * Creates tester which check if a node starts with specific keyword and spans multiple lines.\n * @param {string} keyword The keyword to test.\n * @returns {Object} the created tester.\n * @private\n */\nfunction newMultilineKeywordTester(keyword) {\n  return {\n    test: (node, sourceCode) => node.loc.start.line !== node.loc.end.line && sourceCode.getFirstToken(node).value === keyword\n  };\n}\n\n/**\n * Creates tester which check if a node is specific type.\n * @param {string} type The node type to test.\n * @returns {Object} the created tester.\n * @private\n */\nfunction newNodeTypeTester(type) {\n  return {\n    test: node => node.type === type\n  };\n}\n\n/**\n * Checks the given node is an expression statement of IIFE.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} `true` if the node is an expression statement of IIFE.\n * @private\n */\nfunction isIIFEStatement(node) {\n  if (node.type === \"ExpressionStatement\") {\n    let call = astUtils.skipChainExpression(node.expression);\n    if (call.type === \"UnaryExpression\") {\n      call = astUtils.skipChainExpression(call.argument);\n    }\n    return call.type === \"CallExpression\" && astUtils.isFunction(call.callee);\n  }\n  return false;\n}\n\n/**\n * Checks whether the given node is a block-like statement.\n * This checks the last token of the node is the closing brace of a block.\n * @param {SourceCode} sourceCode The source code to get tokens.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} `true` if the node is a block-like statement.\n * @private\n */\nfunction isBlockLikeStatement(sourceCode, node) {\n  // do-while with a block is a block-like statement.\n  if (node.type === \"DoWhileStatement\" && node.body.type === \"BlockStatement\") {\n    return true;\n  }\n\n  /*\n   * IIFE is a block-like statement specially from\n   * JSCS#disallowPaddingNewLinesAfterBlocks.\n   */\n  if (isIIFEStatement(node)) {\n    return true;\n  }\n\n  // Checks the last token is a closing brace of blocks.\n  const lastToken = sourceCode.getLastToken(node, astUtils.isNotSemicolonToken);\n  const belongingNode = lastToken && astUtils.isClosingBraceToken(lastToken) ? sourceCode.getNodeByRangeIndex(lastToken.range[0]) : null;\n  return Boolean(belongingNode) && (belongingNode.type === \"BlockStatement\" || belongingNode.type === \"SwitchStatement\");\n}\n\n/**\n * Check whether the given node is a directive or not.\n * @param {ASTNode} node The node to check.\n * @param {SourceCode} sourceCode The source code object to get tokens.\n * @returns {boolean} `true` if the node is a directive.\n */\nfunction isDirective(node, sourceCode) {\n  return node.type === \"ExpressionStatement\" && (node.parent.type === \"Program\" || node.parent.type === \"BlockStatement\" && astUtils.isFunction(node.parent.parent)) && node.expression.type === \"Literal\" && typeof node.expression.value === \"string\" && !astUtils.isParenthesised(sourceCode, node.expression);\n}\n\n/**\n * Check whether the given node is a part of directive prologue or not.\n * @param {ASTNode} node The node to check.\n * @param {SourceCode} sourceCode The source code object to get tokens.\n * @returns {boolean} `true` if the node is a part of directive prologue.\n */\nfunction isDirectivePrologue(node, sourceCode) {\n  if (isDirective(node, sourceCode)) {\n    for (const sibling of node.parent.body) {\n      if (sibling === node) {\n        break;\n      }\n      if (!isDirective(sibling, sourceCode)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return false;\n}\n\n/**\n * Gets the actual last token.\n *\n * If a semicolon is semicolon-less style's semicolon, this ignores it.\n * For example:\n *\n *     foo()\n *     ;[1, 2, 3].forEach(bar)\n * @param {SourceCode} sourceCode The source code to get tokens.\n * @param {ASTNode} node The node to get.\n * @returns {Token} The actual last token.\n * @private\n */\nfunction getActualLastToken(sourceCode, node) {\n  const semiToken = sourceCode.getLastToken(node);\n  const prevToken = sourceCode.getTokenBefore(semiToken);\n  const nextToken = sourceCode.getTokenAfter(semiToken);\n  const isSemicolonLessStyle = Boolean(prevToken && nextToken && prevToken.range[0] >= node.range[0] && astUtils.isSemicolonToken(semiToken) && semiToken.loc.start.line !== prevToken.loc.end.line && semiToken.loc.end.line === nextToken.loc.start.line);\n  return isSemicolonLessStyle ? prevToken : semiToken;\n}\n\n/**\n * This returns the concatenation of the first 2 captured strings.\n * @param {string} _ Unused. Whole matched string.\n * @param {string} trailingSpaces The trailing spaces of the first line.\n * @param {string} indentSpaces The indentation spaces of the last line.\n * @returns {string} The concatenation of trailingSpaces and indentSpaces.\n * @private\n */\nfunction replacerToRemovePaddingLines(_, trailingSpaces, indentSpaces) {\n  return trailingSpaces + indentSpaces;\n}\n\n/**\n * Check and report statements for `any` configuration.\n * It does nothing.\n * @returns {void}\n * @private\n */\nfunction verifyForAny() {}\n\n/**\n * Check and report statements for `never` configuration.\n * This autofix removes blank lines between the given 2 statements.\n * However, if comments exist between 2 blank lines, it does not remove those\n * blank lines automatically.\n * @param {RuleContext} context The rule context to report.\n * @param {ASTNode} _ Unused. The previous node to check.\n * @param {ASTNode} nextNode The next node to check.\n * @param {Array<Token[]>} paddingLines The array of token pairs that blank\n * lines exist between the pair.\n * @returns {void}\n * @private\n */\nfunction verifyForNever(context, _, nextNode, paddingLines) {\n  if (paddingLines.length === 0) {\n    return;\n  }\n  context.report({\n    node: nextNode,\n    messageId: \"unexpectedBlankLine\",\n    fix(fixer) {\n      if (paddingLines.length >= 2) {\n        return null;\n      }\n      const prevToken = paddingLines[0][0];\n      const nextToken = paddingLines[0][1];\n      const start = prevToken.range[1];\n      const end = nextToken.range[0];\n      const text = context.getSourceCode().text.slice(start, end).replace(PADDING_LINE_SEQUENCE, replacerToRemovePaddingLines);\n      return fixer.replaceTextRange([start, end], text);\n    }\n  });\n}\n\n/**\n * Check and report statements for `always` configuration.\n * This autofix inserts a blank line between the given 2 statements.\n * If the `prevNode` has trailing comments, it inserts a blank line after the\n * trailing comments.\n * @param {RuleContext} context The rule context to report.\n * @param {ASTNode} prevNode The previous node to check.\n * @param {ASTNode} nextNode The next node to check.\n * @param {Array<Token[]>} paddingLines The array of token pairs that blank\n * lines exist between the pair.\n * @returns {void}\n * @private\n */\nfunction verifyForAlways(context, prevNode, nextNode, paddingLines) {\n  if (paddingLines.length > 0) {\n    return;\n  }\n  context.report({\n    node: nextNode,\n    messageId: \"expectedBlankLine\",\n    fix(fixer) {\n      const sourceCode = context.getSourceCode();\n      let prevToken = getActualLastToken(sourceCode, prevNode);\n      const nextToken = sourceCode.getFirstTokenBetween(prevToken, nextNode, {\n        includeComments: true,\n        /**\n         * Skip the trailing comments of the previous node.\n         * This inserts a blank line after the last trailing comment.\n         *\n         * For example:\n         *\n         *     foo(); // trailing comment.\n         *     // comment.\n         *     bar();\n         *\n         * Get fixed to:\n         *\n         *     foo(); // trailing comment.\n         *\n         *     // comment.\n         *     bar();\n         * @param {Token} token The token to check.\n         * @returns {boolean} `true` if the token is not a trailing comment.\n         * @private\n         */\n        filter(token) {\n          if (astUtils.isTokenOnSameLine(prevToken, token)) {\n            prevToken = token;\n            return false;\n          }\n          return true;\n        }\n      }) || nextNode;\n      const insertText = astUtils.isTokenOnSameLine(prevToken, nextToken) ? \"\\n\\n\" : \"\\n\";\n      return fixer.insertTextAfter(prevToken, insertText);\n    }\n  });\n}\n\n/**\n * Types of blank lines.\n * `any`, `never`, and `always` are defined.\n * Those have `verify` method to check and report statements.\n * @private\n */\nconst PaddingTypes = {\n  any: {\n    verify: verifyForAny\n  },\n  never: {\n    verify: verifyForNever\n  },\n  always: {\n    verify: verifyForAlways\n  }\n};\n\n/**\n * Types of statements.\n * Those have `test` method to check it matches to the given statement.\n * @private\n */\nconst StatementTypes = {\n  \"*\": {\n    test: () => true\n  },\n  \"block-like\": {\n    test: (node, sourceCode) => isBlockLikeStatement(sourceCode, node)\n  },\n  \"cjs-export\": {\n    test: (node, sourceCode) => node.type === \"ExpressionStatement\" && node.expression.type === \"AssignmentExpression\" && CJS_EXPORT.test(sourceCode.getText(node.expression.left))\n  },\n  \"cjs-import\": {\n    test: (node, sourceCode) => node.type === \"VariableDeclaration\" && node.declarations.length > 0 && Boolean(node.declarations[0].init) && CJS_IMPORT.test(sourceCode.getText(node.declarations[0].init))\n  },\n  directive: {\n    test: isDirectivePrologue\n  },\n  expression: {\n    test: (node, sourceCode) => node.type === \"ExpressionStatement\" && !isDirectivePrologue(node, sourceCode)\n  },\n  iife: {\n    test: isIIFEStatement\n  },\n  \"multiline-block-like\": {\n    test: (node, sourceCode) => node.loc.start.line !== node.loc.end.line && isBlockLikeStatement(sourceCode, node)\n  },\n  \"multiline-expression\": {\n    test: (node, sourceCode) => node.loc.start.line !== node.loc.end.line && node.type === \"ExpressionStatement\" && !isDirectivePrologue(node, sourceCode)\n  },\n  \"multiline-const\": newMultilineKeywordTester(\"const\"),\n  \"multiline-let\": newMultilineKeywordTester(\"let\"),\n  \"multiline-var\": newMultilineKeywordTester(\"var\"),\n  \"singleline-const\": newSinglelineKeywordTester(\"const\"),\n  \"singleline-let\": newSinglelineKeywordTester(\"let\"),\n  \"singleline-var\": newSinglelineKeywordTester(\"var\"),\n  block: newNodeTypeTester(\"BlockStatement\"),\n  empty: newNodeTypeTester(\"EmptyStatement\"),\n  function: newNodeTypeTester(\"FunctionDeclaration\"),\n  break: newKeywordTester(\"break\"),\n  case: newKeywordTester(\"case\"),\n  class: newKeywordTester(\"class\"),\n  const: newKeywordTester(\"const\"),\n  continue: newKeywordTester(\"continue\"),\n  debugger: newKeywordTester(\"debugger\"),\n  default: newKeywordTester(\"default\"),\n  do: newKeywordTester(\"do\"),\n  export: newKeywordTester(\"export\"),\n  for: newKeywordTester(\"for\"),\n  if: newKeywordTester(\"if\"),\n  import: newKeywordTester(\"import\"),\n  let: newKeywordTester(\"let\"),\n  return: newKeywordTester(\"return\"),\n  switch: newKeywordTester(\"switch\"),\n  throw: newKeywordTester(\"throw\"),\n  try: newKeywordTester(\"try\"),\n  var: newKeywordTester(\"var\"),\n  while: newKeywordTester(\"while\"),\n  with: newKeywordTester(\"with\")\n};\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"require or disallow padding lines between statements\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/padding-line-between-statements\"\n    },\n    fixable: \"whitespace\",\n    schema: {\n      definitions: {\n        paddingType: {\n          enum: Object.keys(PaddingTypes)\n        },\n        statementType: {\n          anyOf: [{\n            enum: Object.keys(StatementTypes)\n          }, {\n            type: \"array\",\n            items: {\n              enum: Object.keys(StatementTypes)\n            },\n            minItems: 1,\n            uniqueItems: true,\n            additionalItems: false\n          }]\n        }\n      },\n      type: \"array\",\n      items: {\n        type: \"object\",\n        properties: {\n          blankLine: {\n            $ref: \"#/definitions/paddingType\"\n          },\n          prev: {\n            $ref: \"#/definitions/statementType\"\n          },\n          next: {\n            $ref: \"#/definitions/statementType\"\n          }\n        },\n        additionalProperties: false,\n        required: [\"blankLine\", \"prev\", \"next\"]\n      },\n      additionalItems: false\n    },\n    messages: {\n      unexpectedBlankLine: \"Unexpected blank line before this statement.\",\n      expectedBlankLine: \"Expected blank line before this statement.\"\n    }\n  },\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const configureList = context.options || [];\n    let scopeInfo = null;\n\n    /**\n     * Processes to enter to new scope.\n     * This manages the current previous statement.\n     * @returns {void}\n     * @private\n     */\n    function enterScope() {\n      scopeInfo = {\n        upper: scopeInfo,\n        prevNode: null\n      };\n    }\n\n    /**\n     * Processes to exit from the current scope.\n     * @returns {void}\n     * @private\n     */\n    function exitScope() {\n      scopeInfo = scopeInfo.upper;\n    }\n\n    /**\n     * Checks whether the given node matches the given type.\n     * @param {ASTNode} node The statement node to check.\n     * @param {string|string[]} type The statement type to check.\n     * @returns {boolean} `true` if the statement node matched the type.\n     * @private\n     */\n    function match(node, type) {\n      let innerStatementNode = node;\n      while (innerStatementNode.type === \"LabeledStatement\") {\n        innerStatementNode = innerStatementNode.body;\n      }\n      if (Array.isArray(type)) {\n        return type.some(match.bind(null, innerStatementNode));\n      }\n      return StatementTypes[type].test(innerStatementNode, sourceCode);\n    }\n\n    /**\n     * Finds the last matched configure from configureList.\n     * @param {ASTNode} prevNode The previous statement to match.\n     * @param {ASTNode} nextNode The current statement to match.\n     * @returns {Object} The tester of the last matched configure.\n     * @private\n     */\n    function getPaddingType(prevNode, nextNode) {\n      for (let i = configureList.length - 1; i >= 0; --i) {\n        const configure = configureList[i];\n        const matched = match(prevNode, configure.prev) && match(nextNode, configure.next);\n        if (matched) {\n          return PaddingTypes[configure.blankLine];\n        }\n      }\n      return PaddingTypes.any;\n    }\n\n    /**\n     * Gets padding line sequences between the given 2 statements.\n     * Comments are separators of the padding line sequences.\n     * @param {ASTNode} prevNode The previous statement to count.\n     * @param {ASTNode} nextNode The current statement to count.\n     * @returns {Array<Token[]>} The array of token pairs.\n     * @private\n     */\n    function getPaddingLineSequences(prevNode, nextNode) {\n      const pairs = [];\n      let prevToken = getActualLastToken(sourceCode, prevNode);\n      if (nextNode.loc.start.line - prevToken.loc.end.line >= 2) {\n        do {\n          const token = sourceCode.getTokenAfter(prevToken, {\n            includeComments: true\n          });\n          if (token.loc.start.line - prevToken.loc.end.line >= 2) {\n            pairs.push([prevToken, token]);\n          }\n          prevToken = token;\n        } while (prevToken.range[0] < nextNode.range[0]);\n      }\n      return pairs;\n    }\n\n    /**\n     * Verify padding lines between the given node and the previous node.\n     * @param {ASTNode} node The node to verify.\n     * @returns {void}\n     * @private\n     */\n    function verify(node) {\n      const parentType = node.parent.type;\n      const validParent = astUtils.STATEMENT_LIST_PARENTS.has(parentType) || parentType === \"SwitchStatement\";\n      if (!validParent) {\n        return;\n      }\n\n      // Save this node as the current previous statement.\n      const prevNode = scopeInfo.prevNode;\n\n      // Verify.\n      if (prevNode) {\n        const type = getPaddingType(prevNode, node);\n        const paddingLines = getPaddingLineSequences(prevNode, node);\n        type.verify(context, prevNode, node, paddingLines);\n      }\n      scopeInfo.prevNode = node;\n    }\n\n    /**\n     * Verify padding lines between the given node and the previous node.\n     * Then process to enter to new scope.\n     * @param {ASTNode} node The node to verify.\n     * @returns {void}\n     * @private\n     */\n    function verifyThenEnterScope(node) {\n      verify(node);\n      enterScope();\n    }\n    return {\n      Program: enterScope,\n      BlockStatement: enterScope,\n      SwitchStatement: enterScope,\n      \"Program:exit\": exitScope,\n      \"BlockStatement:exit\": exitScope,\n      \"SwitchStatement:exit\": exitScope,\n      \":statement\": verify,\n      SwitchCase: verifyThenEnterScope,\n      \"SwitchCase:exit\": exitScope\n    };\n  }\n};","map":{"version":3,"names":["require","astUtils","LT","Array","from","LINEBREAKS","join","PADDING_LINE_SEQUENCE","RegExp","String","raw","CJS_EXPORT","CJS_IMPORT","newKeywordTester","keyword","test","node","sourceCode","getFirstToken","value","newSinglelineKeywordTester","loc","start","line","end","newMultilineKeywordTester","newNodeTypeTester","type","isIIFEStatement","call","skipChainExpression","expression","argument","isFunction","callee","isBlockLikeStatement","body","lastToken","getLastToken","isNotSemicolonToken","belongingNode","isClosingBraceToken","getNodeByRangeIndex","range","Boolean","isDirective","parent","isParenthesised","isDirectivePrologue","sibling","getActualLastToken","semiToken","prevToken","getTokenBefore","nextToken","getTokenAfter","isSemicolonLessStyle","isSemicolonToken","replacerToRemovePaddingLines","_","trailingSpaces","indentSpaces","verifyForAny","verifyForNever","context","nextNode","paddingLines","length","report","messageId","fix","fixer","text","getSourceCode","slice","replace","replaceTextRange","verifyForAlways","prevNode","getFirstTokenBetween","includeComments","filter","token","isTokenOnSameLine","insertText","insertTextAfter","PaddingTypes","any","verify","never","always","StatementTypes","getText","left","declarations","init","directive","iife","block","empty","function","break","case","class","const","continue","debugger","default","do","export","for","if","import","let","return","switch","throw","try","var","while","with","module","exports","meta","docs","description","category","recommended","url","fixable","schema","definitions","paddingType","enum","Object","keys","statementType","anyOf","items","minItems","uniqueItems","additionalItems","properties","blankLine","$ref","prev","next","additionalProperties","required","messages","unexpectedBlankLine","expectedBlankLine","create","configureList","options","scopeInfo","enterScope","upper","exitScope","match","innerStatementNode","isArray","some","bind","getPaddingType","i","configure","matched","getPaddingLineSequences","pairs","push","parentType","validParent","STATEMENT_LIST_PARENTS","has","verifyThenEnterScope","Program","BlockStatement","SwitchStatement","SwitchCase"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/padding-line-between-statements.js"],"sourcesContent":["/**\n * @fileoverview Rule to require or disallow newlines between statements\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst LT = `[${Array.from(astUtils.LINEBREAKS).join(\"\")}]`;\nconst PADDING_LINE_SEQUENCE = new RegExp(\n    String.raw`^(\\s*?${LT})\\s*${LT}(\\s*;?)$`,\n    \"u\"\n);\nconst CJS_EXPORT = /^(?:module\\s*\\.\\s*)?exports(?:\\s*\\.|\\s*\\[|$)/u;\nconst CJS_IMPORT = /^require\\(/u;\n\n/**\n * Creates tester which check if a node starts with specific keyword.\n * @param {string} keyword The keyword to test.\n * @returns {Object} the created tester.\n * @private\n */\nfunction newKeywordTester(keyword) {\n    return {\n        test: (node, sourceCode) =>\n            sourceCode.getFirstToken(node).value === keyword\n    };\n}\n\n/**\n * Creates tester which check if a node starts with specific keyword and spans a single line.\n * @param {string} keyword The keyword to test.\n * @returns {Object} the created tester.\n * @private\n */\nfunction newSinglelineKeywordTester(keyword) {\n    return {\n        test: (node, sourceCode) =>\n            node.loc.start.line === node.loc.end.line &&\n            sourceCode.getFirstToken(node).value === keyword\n    };\n}\n\n/**\n * Creates tester which check if a node starts with specific keyword and spans multiple lines.\n * @param {string} keyword The keyword to test.\n * @returns {Object} the created tester.\n * @private\n */\nfunction newMultilineKeywordTester(keyword) {\n    return {\n        test: (node, sourceCode) =>\n            node.loc.start.line !== node.loc.end.line &&\n            sourceCode.getFirstToken(node).value === keyword\n    };\n}\n\n/**\n * Creates tester which check if a node is specific type.\n * @param {string} type The node type to test.\n * @returns {Object} the created tester.\n * @private\n */\nfunction newNodeTypeTester(type) {\n    return {\n        test: node =>\n            node.type === type\n    };\n}\n\n/**\n * Checks the given node is an expression statement of IIFE.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} `true` if the node is an expression statement of IIFE.\n * @private\n */\nfunction isIIFEStatement(node) {\n    if (node.type === \"ExpressionStatement\") {\n        let call = astUtils.skipChainExpression(node.expression);\n\n        if (call.type === \"UnaryExpression\") {\n            call = astUtils.skipChainExpression(call.argument);\n        }\n        return call.type === \"CallExpression\" && astUtils.isFunction(call.callee);\n    }\n    return false;\n}\n\n/**\n * Checks whether the given node is a block-like statement.\n * This checks the last token of the node is the closing brace of a block.\n * @param {SourceCode} sourceCode The source code to get tokens.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} `true` if the node is a block-like statement.\n * @private\n */\nfunction isBlockLikeStatement(sourceCode, node) {\n\n    // do-while with a block is a block-like statement.\n    if (node.type === \"DoWhileStatement\" && node.body.type === \"BlockStatement\") {\n        return true;\n    }\n\n    /*\n     * IIFE is a block-like statement specially from\n     * JSCS#disallowPaddingNewLinesAfterBlocks.\n     */\n    if (isIIFEStatement(node)) {\n        return true;\n    }\n\n    // Checks the last token is a closing brace of blocks.\n    const lastToken = sourceCode.getLastToken(node, astUtils.isNotSemicolonToken);\n    const belongingNode = lastToken && astUtils.isClosingBraceToken(lastToken)\n        ? sourceCode.getNodeByRangeIndex(lastToken.range[0])\n        : null;\n\n    return Boolean(belongingNode) && (\n        belongingNode.type === \"BlockStatement\" ||\n        belongingNode.type === \"SwitchStatement\"\n    );\n}\n\n/**\n * Check whether the given node is a directive or not.\n * @param {ASTNode} node The node to check.\n * @param {SourceCode} sourceCode The source code object to get tokens.\n * @returns {boolean} `true` if the node is a directive.\n */\nfunction isDirective(node, sourceCode) {\n    return (\n        node.type === \"ExpressionStatement\" &&\n        (\n            node.parent.type === \"Program\" ||\n            (\n                node.parent.type === \"BlockStatement\" &&\n                astUtils.isFunction(node.parent.parent)\n            )\n        ) &&\n        node.expression.type === \"Literal\" &&\n        typeof node.expression.value === \"string\" &&\n        !astUtils.isParenthesised(sourceCode, node.expression)\n    );\n}\n\n/**\n * Check whether the given node is a part of directive prologue or not.\n * @param {ASTNode} node The node to check.\n * @param {SourceCode} sourceCode The source code object to get tokens.\n * @returns {boolean} `true` if the node is a part of directive prologue.\n */\nfunction isDirectivePrologue(node, sourceCode) {\n    if (isDirective(node, sourceCode)) {\n        for (const sibling of node.parent.body) {\n            if (sibling === node) {\n                break;\n            }\n            if (!isDirective(sibling, sourceCode)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return false;\n}\n\n/**\n * Gets the actual last token.\n *\n * If a semicolon is semicolon-less style's semicolon, this ignores it.\n * For example:\n *\n *     foo()\n *     ;[1, 2, 3].forEach(bar)\n * @param {SourceCode} sourceCode The source code to get tokens.\n * @param {ASTNode} node The node to get.\n * @returns {Token} The actual last token.\n * @private\n */\nfunction getActualLastToken(sourceCode, node) {\n    const semiToken = sourceCode.getLastToken(node);\n    const prevToken = sourceCode.getTokenBefore(semiToken);\n    const nextToken = sourceCode.getTokenAfter(semiToken);\n    const isSemicolonLessStyle = Boolean(\n        prevToken &&\n        nextToken &&\n        prevToken.range[0] >= node.range[0] &&\n        astUtils.isSemicolonToken(semiToken) &&\n        semiToken.loc.start.line !== prevToken.loc.end.line &&\n        semiToken.loc.end.line === nextToken.loc.start.line\n    );\n\n    return isSemicolonLessStyle ? prevToken : semiToken;\n}\n\n/**\n * This returns the concatenation of the first 2 captured strings.\n * @param {string} _ Unused. Whole matched string.\n * @param {string} trailingSpaces The trailing spaces of the first line.\n * @param {string} indentSpaces The indentation spaces of the last line.\n * @returns {string} The concatenation of trailingSpaces and indentSpaces.\n * @private\n */\nfunction replacerToRemovePaddingLines(_, trailingSpaces, indentSpaces) {\n    return trailingSpaces + indentSpaces;\n}\n\n/**\n * Check and report statements for `any` configuration.\n * It does nothing.\n * @returns {void}\n * @private\n */\nfunction verifyForAny() {\n}\n\n/**\n * Check and report statements for `never` configuration.\n * This autofix removes blank lines between the given 2 statements.\n * However, if comments exist between 2 blank lines, it does not remove those\n * blank lines automatically.\n * @param {RuleContext} context The rule context to report.\n * @param {ASTNode} _ Unused. The previous node to check.\n * @param {ASTNode} nextNode The next node to check.\n * @param {Array<Token[]>} paddingLines The array of token pairs that blank\n * lines exist between the pair.\n * @returns {void}\n * @private\n */\nfunction verifyForNever(context, _, nextNode, paddingLines) {\n    if (paddingLines.length === 0) {\n        return;\n    }\n\n    context.report({\n        node: nextNode,\n        messageId: \"unexpectedBlankLine\",\n        fix(fixer) {\n            if (paddingLines.length >= 2) {\n                return null;\n            }\n\n            const prevToken = paddingLines[0][0];\n            const nextToken = paddingLines[0][1];\n            const start = prevToken.range[1];\n            const end = nextToken.range[0];\n            const text = context.getSourceCode().text\n                .slice(start, end)\n                .replace(PADDING_LINE_SEQUENCE, replacerToRemovePaddingLines);\n\n            return fixer.replaceTextRange([start, end], text);\n        }\n    });\n}\n\n/**\n * Check and report statements for `always` configuration.\n * This autofix inserts a blank line between the given 2 statements.\n * If the `prevNode` has trailing comments, it inserts a blank line after the\n * trailing comments.\n * @param {RuleContext} context The rule context to report.\n * @param {ASTNode} prevNode The previous node to check.\n * @param {ASTNode} nextNode The next node to check.\n * @param {Array<Token[]>} paddingLines The array of token pairs that blank\n * lines exist between the pair.\n * @returns {void}\n * @private\n */\nfunction verifyForAlways(context, prevNode, nextNode, paddingLines) {\n    if (paddingLines.length > 0) {\n        return;\n    }\n\n    context.report({\n        node: nextNode,\n        messageId: \"expectedBlankLine\",\n        fix(fixer) {\n            const sourceCode = context.getSourceCode();\n            let prevToken = getActualLastToken(sourceCode, prevNode);\n            const nextToken = sourceCode.getFirstTokenBetween(\n                prevToken,\n                nextNode,\n                {\n                    includeComments: true,\n\n                    /**\n                     * Skip the trailing comments of the previous node.\n                     * This inserts a blank line after the last trailing comment.\n                     *\n                     * For example:\n                     *\n                     *     foo(); // trailing comment.\n                     *     // comment.\n                     *     bar();\n                     *\n                     * Get fixed to:\n                     *\n                     *     foo(); // trailing comment.\n                     *\n                     *     // comment.\n                     *     bar();\n                     * @param {Token} token The token to check.\n                     * @returns {boolean} `true` if the token is not a trailing comment.\n                     * @private\n                     */\n                    filter(token) {\n                        if (astUtils.isTokenOnSameLine(prevToken, token)) {\n                            prevToken = token;\n                            return false;\n                        }\n                        return true;\n                    }\n                }\n            ) || nextNode;\n            const insertText = astUtils.isTokenOnSameLine(prevToken, nextToken)\n                ? \"\\n\\n\"\n                : \"\\n\";\n\n            return fixer.insertTextAfter(prevToken, insertText);\n        }\n    });\n}\n\n/**\n * Types of blank lines.\n * `any`, `never`, and `always` are defined.\n * Those have `verify` method to check and report statements.\n * @private\n */\nconst PaddingTypes = {\n    any: { verify: verifyForAny },\n    never: { verify: verifyForNever },\n    always: { verify: verifyForAlways }\n};\n\n/**\n * Types of statements.\n * Those have `test` method to check it matches to the given statement.\n * @private\n */\nconst StatementTypes = {\n    \"*\": { test: () => true },\n    \"block-like\": {\n        test: (node, sourceCode) => isBlockLikeStatement(sourceCode, node)\n    },\n    \"cjs-export\": {\n        test: (node, sourceCode) =>\n            node.type === \"ExpressionStatement\" &&\n            node.expression.type === \"AssignmentExpression\" &&\n            CJS_EXPORT.test(sourceCode.getText(node.expression.left))\n    },\n    \"cjs-import\": {\n        test: (node, sourceCode) =>\n            node.type === \"VariableDeclaration\" &&\n            node.declarations.length > 0 &&\n            Boolean(node.declarations[0].init) &&\n            CJS_IMPORT.test(sourceCode.getText(node.declarations[0].init))\n    },\n    directive: {\n        test: isDirectivePrologue\n    },\n    expression: {\n        test: (node, sourceCode) =>\n            node.type === \"ExpressionStatement\" &&\n            !isDirectivePrologue(node, sourceCode)\n    },\n    iife: {\n        test: isIIFEStatement\n    },\n    \"multiline-block-like\": {\n        test: (node, sourceCode) =>\n            node.loc.start.line !== node.loc.end.line &&\n            isBlockLikeStatement(sourceCode, node)\n    },\n    \"multiline-expression\": {\n        test: (node, sourceCode) =>\n            node.loc.start.line !== node.loc.end.line &&\n            node.type === \"ExpressionStatement\" &&\n            !isDirectivePrologue(node, sourceCode)\n    },\n\n    \"multiline-const\": newMultilineKeywordTester(\"const\"),\n    \"multiline-let\": newMultilineKeywordTester(\"let\"),\n    \"multiline-var\": newMultilineKeywordTester(\"var\"),\n    \"singleline-const\": newSinglelineKeywordTester(\"const\"),\n    \"singleline-let\": newSinglelineKeywordTester(\"let\"),\n    \"singleline-var\": newSinglelineKeywordTester(\"var\"),\n\n    block: newNodeTypeTester(\"BlockStatement\"),\n    empty: newNodeTypeTester(\"EmptyStatement\"),\n    function: newNodeTypeTester(\"FunctionDeclaration\"),\n\n    break: newKeywordTester(\"break\"),\n    case: newKeywordTester(\"case\"),\n    class: newKeywordTester(\"class\"),\n    const: newKeywordTester(\"const\"),\n    continue: newKeywordTester(\"continue\"),\n    debugger: newKeywordTester(\"debugger\"),\n    default: newKeywordTester(\"default\"),\n    do: newKeywordTester(\"do\"),\n    export: newKeywordTester(\"export\"),\n    for: newKeywordTester(\"for\"),\n    if: newKeywordTester(\"if\"),\n    import: newKeywordTester(\"import\"),\n    let: newKeywordTester(\"let\"),\n    return: newKeywordTester(\"return\"),\n    switch: newKeywordTester(\"switch\"),\n    throw: newKeywordTester(\"throw\"),\n    try: newKeywordTester(\"try\"),\n    var: newKeywordTester(\"var\"),\n    while: newKeywordTester(\"while\"),\n    with: newKeywordTester(\"with\")\n};\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"require or disallow padding lines between statements\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/padding-line-between-statements\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: {\n            definitions: {\n                paddingType: {\n                    enum: Object.keys(PaddingTypes)\n                },\n                statementType: {\n                    anyOf: [\n                        { enum: Object.keys(StatementTypes) },\n                        {\n                            type: \"array\",\n                            items: { enum: Object.keys(StatementTypes) },\n                            minItems: 1,\n                            uniqueItems: true,\n                            additionalItems: false\n                        }\n                    ]\n                }\n            },\n            type: \"array\",\n            items: {\n                type: \"object\",\n                properties: {\n                    blankLine: { $ref: \"#/definitions/paddingType\" },\n                    prev: { $ref: \"#/definitions/statementType\" },\n                    next: { $ref: \"#/definitions/statementType\" }\n                },\n                additionalProperties: false,\n                required: [\"blankLine\", \"prev\", \"next\"]\n            },\n            additionalItems: false\n        },\n\n        messages: {\n            unexpectedBlankLine: \"Unexpected blank line before this statement.\",\n            expectedBlankLine: \"Expected blank line before this statement.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const configureList = context.options || [];\n        let scopeInfo = null;\n\n        /**\n         * Processes to enter to new scope.\n         * This manages the current previous statement.\n         * @returns {void}\n         * @private\n         */\n        function enterScope() {\n            scopeInfo = {\n                upper: scopeInfo,\n                prevNode: null\n            };\n        }\n\n        /**\n         * Processes to exit from the current scope.\n         * @returns {void}\n         * @private\n         */\n        function exitScope() {\n            scopeInfo = scopeInfo.upper;\n        }\n\n        /**\n         * Checks whether the given node matches the given type.\n         * @param {ASTNode} node The statement node to check.\n         * @param {string|string[]} type The statement type to check.\n         * @returns {boolean} `true` if the statement node matched the type.\n         * @private\n         */\n        function match(node, type) {\n            let innerStatementNode = node;\n\n            while (innerStatementNode.type === \"LabeledStatement\") {\n                innerStatementNode = innerStatementNode.body;\n            }\n            if (Array.isArray(type)) {\n                return type.some(match.bind(null, innerStatementNode));\n            }\n            return StatementTypes[type].test(innerStatementNode, sourceCode);\n        }\n\n        /**\n         * Finds the last matched configure from configureList.\n         * @param {ASTNode} prevNode The previous statement to match.\n         * @param {ASTNode} nextNode The current statement to match.\n         * @returns {Object} The tester of the last matched configure.\n         * @private\n         */\n        function getPaddingType(prevNode, nextNode) {\n            for (let i = configureList.length - 1; i >= 0; --i) {\n                const configure = configureList[i];\n                const matched =\n                    match(prevNode, configure.prev) &&\n                    match(nextNode, configure.next);\n\n                if (matched) {\n                    return PaddingTypes[configure.blankLine];\n                }\n            }\n            return PaddingTypes.any;\n        }\n\n        /**\n         * Gets padding line sequences between the given 2 statements.\n         * Comments are separators of the padding line sequences.\n         * @param {ASTNode} prevNode The previous statement to count.\n         * @param {ASTNode} nextNode The current statement to count.\n         * @returns {Array<Token[]>} The array of token pairs.\n         * @private\n         */\n        function getPaddingLineSequences(prevNode, nextNode) {\n            const pairs = [];\n            let prevToken = getActualLastToken(sourceCode, prevNode);\n\n            if (nextNode.loc.start.line - prevToken.loc.end.line >= 2) {\n                do {\n                    const token = sourceCode.getTokenAfter(\n                        prevToken,\n                        { includeComments: true }\n                    );\n\n                    if (token.loc.start.line - prevToken.loc.end.line >= 2) {\n                        pairs.push([prevToken, token]);\n                    }\n                    prevToken = token;\n\n                } while (prevToken.range[0] < nextNode.range[0]);\n            }\n\n            return pairs;\n        }\n\n        /**\n         * Verify padding lines between the given node and the previous node.\n         * @param {ASTNode} node The node to verify.\n         * @returns {void}\n         * @private\n         */\n        function verify(node) {\n            const parentType = node.parent.type;\n            const validParent =\n                astUtils.STATEMENT_LIST_PARENTS.has(parentType) ||\n                parentType === \"SwitchStatement\";\n\n            if (!validParent) {\n                return;\n            }\n\n            // Save this node as the current previous statement.\n            const prevNode = scopeInfo.prevNode;\n\n            // Verify.\n            if (prevNode) {\n                const type = getPaddingType(prevNode, node);\n                const paddingLines = getPaddingLineSequences(prevNode, node);\n\n                type.verify(context, prevNode, node, paddingLines);\n            }\n\n            scopeInfo.prevNode = node;\n        }\n\n        /**\n         * Verify padding lines between the given node and the previous node.\n         * Then process to enter to new scope.\n         * @param {ASTNode} node The node to verify.\n         * @returns {void}\n         * @private\n         */\n        function verifyThenEnterScope(node) {\n            verify(node);\n            enterScope();\n        }\n\n        return {\n            Program: enterScope,\n            BlockStatement: enterScope,\n            SwitchStatement: enterScope,\n            \"Program:exit\": exitScope,\n            \"BlockStatement:exit\": exitScope,\n            \"SwitchStatement:exit\": exitScope,\n\n            \":statement\": verify,\n\n            SwitchCase: verifyThenEnterScope,\n            \"SwitchCase:exit\": exitScope\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}