{"ast":null,"code":"/**\n * @fileoverview Config Comment Parser\n * @author Nicholas C. Zakas\n */\n\n/* eslint-disable class-methods-use-this*/\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst levn = require(\"levn\"),\n  ConfigOps = require(\"@eslint/eslintrc/lib/shared/config-ops\");\nconst debug = require(\"debug\")(\"eslint:config-comment-parser\");\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * Object to parse ESLint configuration comments inside JavaScript files.\n * @name ConfigCommentParser\n */\nmodule.exports = class ConfigCommentParser {\n  /**\n   * Parses a list of \"name:string_value\" or/and \"name\" options divided by comma or\n   * whitespace. Used for \"global\" and \"exported\" comments.\n   * @param {string} string The string to parse.\n   * @param {Comment} comment The comment node which has the string.\n   * @returns {Object} Result map object of names and string values, or null values if no value was provided\n   */\n  parseStringConfig(string, comment) {\n    debug(\"Parsing String config\");\n    const items = {};\n\n    // Collapse whitespace around `:` and `,` to make parsing easier\n    const trimmedString = string.replace(/\\s*([:,])\\s*/gu, \"$1\");\n    trimmedString.split(/\\s|,+/u).forEach(name => {\n      if (!name) {\n        return;\n      }\n\n      // value defaults to null (if not provided), e.g: \"foo\" => [\"foo\", null]\n      const [key, value = null] = name.split(\":\");\n      items[key] = {\n        value,\n        comment\n      };\n    });\n    return items;\n  }\n\n  /**\n   * Parses a JSON-like config.\n   * @param {string} string The string to parse.\n   * @param {Object} location Start line and column of comments for potential error message.\n   * @returns {({success: true, config: Object}|{success: false, error: Problem})} Result map object\n   */\n  parseJsonConfig(string, location) {\n    debug(\"Parsing JSON config\");\n    let items = {};\n\n    // Parses a JSON-like comment by the same way as parsing CLI option.\n    try {\n      items = levn.parse(\"Object\", string) || {};\n\n      // Some tests say that it should ignore invalid comments such as `/*eslint no-alert:abc*/`.\n      // Also, commaless notations have invalid severity:\n      //     \"no-alert: 2 no-console: 2\" --> {\"no-alert\": \"2 no-console: 2\"}\n      // Should ignore that case as well.\n      if (ConfigOps.isEverySeverityValid(items)) {\n        return {\n          success: true,\n          config: items\n        };\n      }\n    } catch {\n      debug(\"Levn parsing failed; falling back to manual parsing.\");\n\n      // ignore to parse the string by a fallback.\n    }\n\n    /*\n     * Optionator cannot parse commaless notations.\n     * But we are supporting that. So this is a fallback for that.\n     */\n    items = {};\n    const normalizedString = string.replace(/([-a-zA-Z0-9/]+):/gu, \"\\\"$1\\\":\").replace(/(\\]|[0-9])\\s+(?=\")/u, \"$1,\");\n    try {\n      items = JSON.parse(`{${normalizedString}}`);\n    } catch (ex) {\n      debug(\"Manual parsing failed.\");\n      return {\n        success: false,\n        error: {\n          ruleId: null,\n          fatal: true,\n          severity: 2,\n          message: `Failed to parse JSON from '${normalizedString}': ${ex.message}`,\n          line: location.start.line,\n          column: location.start.column + 1\n        }\n      };\n    }\n    return {\n      success: true,\n      config: items\n    };\n  }\n\n  /**\n   * Parses a config of values separated by comma.\n   * @param {string} string The string to parse.\n   * @returns {Object} Result map of values and true values\n   */\n  parseListConfig(string) {\n    debug(\"Parsing list config\");\n    const items = {};\n\n    // Collapse whitespace around commas\n    string.replace(/\\s*,\\s*/gu, \",\").split(/,+/u).forEach(name => {\n      const trimmedName = name.trim();\n      if (trimmedName) {\n        items[trimmedName] = true;\n      }\n    });\n    return items;\n  }\n};","map":{"version":3,"names":["levn","require","ConfigOps","debug","module","exports","ConfigCommentParser","parseStringConfig","string","comment","items","trimmedString","replace","split","forEach","name","key","value","parseJsonConfig","location","parse","isEverySeverityValid","success","config","normalizedString","JSON","ex","error","ruleId","fatal","severity","message","line","start","column","parseListConfig","trimmedName","trim"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/linter/config-comment-parser.js"],"sourcesContent":["/**\n * @fileoverview Config Comment Parser\n * @author Nicholas C. Zakas\n */\n\n/* eslint-disable class-methods-use-this*/\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst levn = require(\"levn\"),\n    ConfigOps = require(\"@eslint/eslintrc/lib/shared/config-ops\");\n\nconst debug = require(\"debug\")(\"eslint:config-comment-parser\");\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * Object to parse ESLint configuration comments inside JavaScript files.\n * @name ConfigCommentParser\n */\nmodule.exports = class ConfigCommentParser {\n\n    /**\n     * Parses a list of \"name:string_value\" or/and \"name\" options divided by comma or\n     * whitespace. Used for \"global\" and \"exported\" comments.\n     * @param {string} string The string to parse.\n     * @param {Comment} comment The comment node which has the string.\n     * @returns {Object} Result map object of names and string values, or null values if no value was provided\n     */\n    parseStringConfig(string, comment) {\n        debug(\"Parsing String config\");\n\n        const items = {};\n\n        // Collapse whitespace around `:` and `,` to make parsing easier\n        const trimmedString = string.replace(/\\s*([:,])\\s*/gu, \"$1\");\n\n        trimmedString.split(/\\s|,+/u).forEach(name => {\n            if (!name) {\n                return;\n            }\n\n            // value defaults to null (if not provided), e.g: \"foo\" => [\"foo\", null]\n            const [key, value = null] = name.split(\":\");\n\n            items[key] = { value, comment };\n        });\n        return items;\n    }\n\n    /**\n     * Parses a JSON-like config.\n     * @param {string} string The string to parse.\n     * @param {Object} location Start line and column of comments for potential error message.\n     * @returns {({success: true, config: Object}|{success: false, error: Problem})} Result map object\n     */\n    parseJsonConfig(string, location) {\n        debug(\"Parsing JSON config\");\n\n        let items = {};\n\n        // Parses a JSON-like comment by the same way as parsing CLI option.\n        try {\n            items = levn.parse(\"Object\", string) || {};\n\n            // Some tests say that it should ignore invalid comments such as `/*eslint no-alert:abc*/`.\n            // Also, commaless notations have invalid severity:\n            //     \"no-alert: 2 no-console: 2\" --> {\"no-alert\": \"2 no-console: 2\"}\n            // Should ignore that case as well.\n            if (ConfigOps.isEverySeverityValid(items)) {\n                return {\n                    success: true,\n                    config: items\n                };\n            }\n        } catch {\n\n            debug(\"Levn parsing failed; falling back to manual parsing.\");\n\n            // ignore to parse the string by a fallback.\n        }\n\n        /*\n         * Optionator cannot parse commaless notations.\n         * But we are supporting that. So this is a fallback for that.\n         */\n        items = {};\n        const normalizedString = string.replace(/([-a-zA-Z0-9/]+):/gu, \"\\\"$1\\\":\").replace(/(\\]|[0-9])\\s+(?=\")/u, \"$1,\");\n\n        try {\n            items = JSON.parse(`{${normalizedString}}`);\n        } catch (ex) {\n            debug(\"Manual parsing failed.\");\n\n            return {\n                success: false,\n                error: {\n                    ruleId: null,\n                    fatal: true,\n                    severity: 2,\n                    message: `Failed to parse JSON from '${normalizedString}': ${ex.message}`,\n                    line: location.start.line,\n                    column: location.start.column + 1\n                }\n            };\n\n        }\n\n        return {\n            success: true,\n            config: items\n        };\n    }\n\n    /**\n     * Parses a config of values separated by comma.\n     * @param {string} string The string to parse.\n     * @returns {Object} Result map of values and true values\n     */\n    parseListConfig(string) {\n        debug(\"Parsing list config\");\n\n        const items = {};\n\n        // Collapse whitespace around commas\n        string.replace(/\\s*,\\s*/gu, \",\").split(/,+/u).forEach(name => {\n            const trimmedName = name.trim();\n\n            if (trimmedName) {\n                items[trimmedName] = true;\n            }\n        });\n        return items;\n    }\n\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}