{"ast":null,"code":"/**\n * @fileoverview Disallow redundant return statements\n * @author Teddy Katz\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nrequire(\"core-js/modules/es.array.push.js\");\nconst astUtils = require(\"./utils/ast-utils\"),\n  FixTracker = require(\"./utils/fix-tracker\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Removes the given element from the array.\n * @param {Array} array The source array to remove.\n * @param {any} element The target item to remove.\n * @returns {void}\n */\nfunction remove(array, element) {\n  const index = array.indexOf(element);\n  if (index !== -1) {\n    array.splice(index, 1);\n  }\n}\n\n/**\n * Checks whether it can remove the given return statement or not.\n * @param {ASTNode} node The return statement node to check.\n * @returns {boolean} `true` if the node is removable.\n */\nfunction isRemovable(node) {\n  return astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type);\n}\n\n/**\n * Checks whether the given return statement is in a `finally` block or not.\n * @param {ASTNode} node The return statement node to check.\n * @returns {boolean} `true` if the node is in a `finally` block.\n */\nfunction isInFinally(node) {\n  for (let currentNode = node; currentNode && currentNode.parent && !astUtils.isFunction(currentNode); currentNode = currentNode.parent) {\n    if (currentNode.parent.type === \"TryStatement\" && currentNode.parent.finalizer === currentNode) {\n      return true;\n    }\n  }\n  return false;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow redundant return statements\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-useless-return\"\n    },\n    fixable: \"code\",\n    schema: [],\n    messages: {\n      unnecessaryReturn: \"Unnecessary return statement.\"\n    }\n  },\n  create(context) {\n    const segmentInfoMap = new WeakMap();\n    const usedUnreachableSegments = new WeakSet();\n    const sourceCode = context.getSourceCode();\n    let scopeInfo = null;\n\n    /**\n     * Checks whether the given segment is terminated by a return statement or not.\n     * @param {CodePathSegment} segment The segment to check.\n     * @returns {boolean} `true` if the segment is terminated by a return statement, or if it's still a part of unreachable.\n     */\n    function isReturned(segment) {\n      const info = segmentInfoMap.get(segment);\n      return !info || info.returned;\n    }\n\n    /**\n     * Collects useless return statements from the given previous segments.\n     *\n     * A previous segment may be an unreachable segment.\n     * In that case, the information object of the unreachable segment is not\n     * initialized because `onCodePathSegmentStart` event is not notified for\n     * unreachable segments.\n     * This goes to the previous segments of the unreachable segment recursively\n     * if the unreachable segment was generated by a return statement. Otherwise,\n     * this ignores the unreachable segment.\n     *\n     * This behavior would simulate code paths for the case that the return\n     * statement does not exist.\n     * @param {ASTNode[]} uselessReturns The collected return statements.\n     * @param {CodePathSegment[]} prevSegments The previous segments to traverse.\n     * @param {WeakSet<CodePathSegment>} [providedTraversedSegments] A set of segments that have already been traversed in this call\n     * @returns {ASTNode[]} `uselessReturns`.\n     */\n    function getUselessReturns(uselessReturns, prevSegments, providedTraversedSegments) {\n      const traversedSegments = providedTraversedSegments || new WeakSet();\n      for (const segment of prevSegments) {\n        if (!segment.reachable) {\n          if (!traversedSegments.has(segment)) {\n            traversedSegments.add(segment);\n            getUselessReturns(uselessReturns, segment.allPrevSegments.filter(isReturned), traversedSegments);\n          }\n          continue;\n        }\n        uselessReturns.push(...segmentInfoMap.get(segment).uselessReturns);\n      }\n      return uselessReturns;\n    }\n\n    /**\n     * Removes the return statements on the given segment from the useless return\n     * statement list.\n     *\n     * This segment may be an unreachable segment.\n     * In that case, the information object of the unreachable segment is not\n     * initialized because `onCodePathSegmentStart` event is not notified for\n     * unreachable segments.\n     * This goes to the previous segments of the unreachable segment recursively\n     * if the unreachable segment was generated by a return statement. Otherwise,\n     * this ignores the unreachable segment.\n     *\n     * This behavior would simulate code paths for the case that the return\n     * statement does not exist.\n     * @param {CodePathSegment} segment The segment to get return statements.\n     * @returns {void}\n     */\n    function markReturnStatementsOnSegmentAsUsed(segment) {\n      if (!segment.reachable) {\n        usedUnreachableSegments.add(segment);\n        segment.allPrevSegments.filter(isReturned).filter(prevSegment => !usedUnreachableSegments.has(prevSegment)).forEach(markReturnStatementsOnSegmentAsUsed);\n        return;\n      }\n      const info = segmentInfoMap.get(segment);\n      for (const node of info.uselessReturns) {\n        remove(scopeInfo.uselessReturns, node);\n      }\n      info.uselessReturns = [];\n    }\n\n    /**\n     * Removes the return statements on the current segments from the useless\n     * return statement list.\n     *\n     * This function will be called at every statement except FunctionDeclaration,\n     * BlockStatement, and BreakStatement.\n     *\n     * - FunctionDeclarations are always executed whether it's returned or not.\n     * - BlockStatements do nothing.\n     * - BreakStatements go the next merely.\n     * @returns {void}\n     */\n    function markReturnStatementsOnCurrentSegmentsAsUsed() {\n      scopeInfo.codePath.currentSegments.forEach(markReturnStatementsOnSegmentAsUsed);\n    }\n\n    //----------------------------------------------------------------------\n    // Public\n    //----------------------------------------------------------------------\n\n    return {\n      // Makes and pushs a new scope information.\n      onCodePathStart(codePath) {\n        scopeInfo = {\n          upper: scopeInfo,\n          uselessReturns: [],\n          codePath\n        };\n      },\n      // Reports useless return statements if exist.\n      onCodePathEnd() {\n        for (const node of scopeInfo.uselessReturns) {\n          context.report({\n            node,\n            loc: node.loc,\n            messageId: \"unnecessaryReturn\",\n            fix(fixer) {\n              if (isRemovable(node) && !sourceCode.getCommentsInside(node).length) {\n                /*\n                 * Extend the replacement range to include the\n                 * entire function to avoid conflicting with\n                 * no-else-return.\n                 * https://github.com/eslint/eslint/issues/8026\n                 */\n                return new FixTracker(fixer, sourceCode).retainEnclosingFunction(node).remove(node);\n              }\n              return null;\n            }\n          });\n        }\n        scopeInfo = scopeInfo.upper;\n      },\n      /*\n       * Initializes segments.\n       * NOTE: This event is notified for only reachable segments.\n       */\n      onCodePathSegmentStart(segment) {\n        const info = {\n          uselessReturns: getUselessReturns([], segment.allPrevSegments),\n          returned: false\n        };\n\n        // Stores the info.\n        segmentInfoMap.set(segment, info);\n      },\n      // Adds ReturnStatement node to check whether it's useless or not.\n      ReturnStatement(node) {\n        if (node.argument) {\n          markReturnStatementsOnCurrentSegmentsAsUsed();\n        }\n        if (node.argument || astUtils.isInLoop(node) || isInFinally(node) ||\n        // Ignore `return` statements in unreachable places (https://github.com/eslint/eslint/issues/11647).\n        !scopeInfo.codePath.currentSegments.some(s => s.reachable)) {\n          return;\n        }\n        for (const segment of scopeInfo.codePath.currentSegments) {\n          const info = segmentInfoMap.get(segment);\n          if (info) {\n            info.uselessReturns.push(node);\n            info.returned = true;\n          }\n        }\n        scopeInfo.uselessReturns.push(node);\n      },\n      /*\n       * Registers for all statement nodes except FunctionDeclaration, BlockStatement, BreakStatement.\n       * Removes return statements of the current segments from the useless return statement list.\n       */\n      ClassDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,\n      ContinueStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      DebuggerStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      DoWhileStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      EmptyStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      ExpressionStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      ForInStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      ForOfStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      ForStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      IfStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      ImportDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,\n      LabeledStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      SwitchStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      ThrowStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      TryStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      VariableDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,\n      WhileStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      WithStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      ExportNamedDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,\n      ExportDefaultDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,\n      ExportAllDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed\n    };\n  }\n};","map":{"version":3,"names":["require","astUtils","FixTracker","remove","array","element","index","indexOf","splice","isRemovable","node","STATEMENT_LIST_PARENTS","has","parent","type","isInFinally","currentNode","isFunction","finalizer","module","exports","meta","docs","description","category","recommended","url","fixable","schema","messages","unnecessaryReturn","create","context","segmentInfoMap","WeakMap","usedUnreachableSegments","WeakSet","sourceCode","getSourceCode","scopeInfo","isReturned","segment","info","get","returned","getUselessReturns","uselessReturns","prevSegments","providedTraversedSegments","traversedSegments","reachable","add","allPrevSegments","filter","push","markReturnStatementsOnSegmentAsUsed","prevSegment","forEach","markReturnStatementsOnCurrentSegmentsAsUsed","codePath","currentSegments","onCodePathStart","upper","onCodePathEnd","report","loc","messageId","fix","fixer","getCommentsInside","length","retainEnclosingFunction","onCodePathSegmentStart","set","ReturnStatement","argument","isInLoop","some","s","ClassDeclaration","ContinueStatement","DebuggerStatement","DoWhileStatement","EmptyStatement","ExpressionStatement","ForInStatement","ForOfStatement","ForStatement","IfStatement","ImportDeclaration","LabeledStatement","SwitchStatement","ThrowStatement","TryStatement","VariableDeclaration","WhileStatement","WithStatement","ExportNamedDeclaration","ExportDefaultDeclaration","ExportAllDeclaration"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/no-useless-return.js"],"sourcesContent":["/**\n * @fileoverview Disallow redundant return statements\n * @author Teddy Katz\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"),\n    FixTracker = require(\"./utils/fix-tracker\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Removes the given element from the array.\n * @param {Array} array The source array to remove.\n * @param {any} element The target item to remove.\n * @returns {void}\n */\nfunction remove(array, element) {\n    const index = array.indexOf(element);\n\n    if (index !== -1) {\n        array.splice(index, 1);\n    }\n}\n\n/**\n * Checks whether it can remove the given return statement or not.\n * @param {ASTNode} node The return statement node to check.\n * @returns {boolean} `true` if the node is removable.\n */\nfunction isRemovable(node) {\n    return astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type);\n}\n\n/**\n * Checks whether the given return statement is in a `finally` block or not.\n * @param {ASTNode} node The return statement node to check.\n * @returns {boolean} `true` if the node is in a `finally` block.\n */\nfunction isInFinally(node) {\n    for (\n        let currentNode = node;\n        currentNode && currentNode.parent && !astUtils.isFunction(currentNode);\n        currentNode = currentNode.parent\n    ) {\n        if (currentNode.parent.type === \"TryStatement\" && currentNode.parent.finalizer === currentNode) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow redundant return statements\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-useless-return\"\n        },\n\n        fixable: \"code\",\n        schema: [],\n\n        messages: {\n            unnecessaryReturn: \"Unnecessary return statement.\"\n        }\n    },\n\n    create(context) {\n        const segmentInfoMap = new WeakMap();\n        const usedUnreachableSegments = new WeakSet();\n        const sourceCode = context.getSourceCode();\n        let scopeInfo = null;\n\n        /**\n         * Checks whether the given segment is terminated by a return statement or not.\n         * @param {CodePathSegment} segment The segment to check.\n         * @returns {boolean} `true` if the segment is terminated by a return statement, or if it's still a part of unreachable.\n         */\n        function isReturned(segment) {\n            const info = segmentInfoMap.get(segment);\n\n            return !info || info.returned;\n        }\n\n        /**\n         * Collects useless return statements from the given previous segments.\n         *\n         * A previous segment may be an unreachable segment.\n         * In that case, the information object of the unreachable segment is not\n         * initialized because `onCodePathSegmentStart` event is not notified for\n         * unreachable segments.\n         * This goes to the previous segments of the unreachable segment recursively\n         * if the unreachable segment was generated by a return statement. Otherwise,\n         * this ignores the unreachable segment.\n         *\n         * This behavior would simulate code paths for the case that the return\n         * statement does not exist.\n         * @param {ASTNode[]} uselessReturns The collected return statements.\n         * @param {CodePathSegment[]} prevSegments The previous segments to traverse.\n         * @param {WeakSet<CodePathSegment>} [providedTraversedSegments] A set of segments that have already been traversed in this call\n         * @returns {ASTNode[]} `uselessReturns`.\n         */\n        function getUselessReturns(uselessReturns, prevSegments, providedTraversedSegments) {\n            const traversedSegments = providedTraversedSegments || new WeakSet();\n\n            for (const segment of prevSegments) {\n                if (!segment.reachable) {\n                    if (!traversedSegments.has(segment)) {\n                        traversedSegments.add(segment);\n                        getUselessReturns(\n                            uselessReturns,\n                            segment.allPrevSegments.filter(isReturned),\n                            traversedSegments\n                        );\n                    }\n                    continue;\n                }\n\n                uselessReturns.push(...segmentInfoMap.get(segment).uselessReturns);\n            }\n\n            return uselessReturns;\n        }\n\n        /**\n         * Removes the return statements on the given segment from the useless return\n         * statement list.\n         *\n         * This segment may be an unreachable segment.\n         * In that case, the information object of the unreachable segment is not\n         * initialized because `onCodePathSegmentStart` event is not notified for\n         * unreachable segments.\n         * This goes to the previous segments of the unreachable segment recursively\n         * if the unreachable segment was generated by a return statement. Otherwise,\n         * this ignores the unreachable segment.\n         *\n         * This behavior would simulate code paths for the case that the return\n         * statement does not exist.\n         * @param {CodePathSegment} segment The segment to get return statements.\n         * @returns {void}\n         */\n        function markReturnStatementsOnSegmentAsUsed(segment) {\n            if (!segment.reachable) {\n                usedUnreachableSegments.add(segment);\n                segment.allPrevSegments\n                    .filter(isReturned)\n                    .filter(prevSegment => !usedUnreachableSegments.has(prevSegment))\n                    .forEach(markReturnStatementsOnSegmentAsUsed);\n                return;\n            }\n\n            const info = segmentInfoMap.get(segment);\n\n            for (const node of info.uselessReturns) {\n                remove(scopeInfo.uselessReturns, node);\n            }\n            info.uselessReturns = [];\n        }\n\n        /**\n         * Removes the return statements on the current segments from the useless\n         * return statement list.\n         *\n         * This function will be called at every statement except FunctionDeclaration,\n         * BlockStatement, and BreakStatement.\n         *\n         * - FunctionDeclarations are always executed whether it's returned or not.\n         * - BlockStatements do nothing.\n         * - BreakStatements go the next merely.\n         * @returns {void}\n         */\n        function markReturnStatementsOnCurrentSegmentsAsUsed() {\n            scopeInfo\n                .codePath\n                .currentSegments\n                .forEach(markReturnStatementsOnSegmentAsUsed);\n        }\n\n        //----------------------------------------------------------------------\n        // Public\n        //----------------------------------------------------------------------\n\n        return {\n\n            // Makes and pushs a new scope information.\n            onCodePathStart(codePath) {\n                scopeInfo = {\n                    upper: scopeInfo,\n                    uselessReturns: [],\n                    codePath\n                };\n            },\n\n            // Reports useless return statements if exist.\n            onCodePathEnd() {\n                for (const node of scopeInfo.uselessReturns) {\n                    context.report({\n                        node,\n                        loc: node.loc,\n                        messageId: \"unnecessaryReturn\",\n                        fix(fixer) {\n                            if (isRemovable(node) && !sourceCode.getCommentsInside(node).length) {\n\n                                /*\n                                 * Extend the replacement range to include the\n                                 * entire function to avoid conflicting with\n                                 * no-else-return.\n                                 * https://github.com/eslint/eslint/issues/8026\n                                 */\n                                return new FixTracker(fixer, sourceCode)\n                                    .retainEnclosingFunction(node)\n                                    .remove(node);\n                            }\n                            return null;\n                        }\n                    });\n                }\n\n                scopeInfo = scopeInfo.upper;\n            },\n\n            /*\n             * Initializes segments.\n             * NOTE: This event is notified for only reachable segments.\n             */\n            onCodePathSegmentStart(segment) {\n                const info = {\n                    uselessReturns: getUselessReturns([], segment.allPrevSegments),\n                    returned: false\n                };\n\n                // Stores the info.\n                segmentInfoMap.set(segment, info);\n            },\n\n            // Adds ReturnStatement node to check whether it's useless or not.\n            ReturnStatement(node) {\n                if (node.argument) {\n                    markReturnStatementsOnCurrentSegmentsAsUsed();\n                }\n                if (\n                    node.argument ||\n                    astUtils.isInLoop(node) ||\n                    isInFinally(node) ||\n\n                    // Ignore `return` statements in unreachable places (https://github.com/eslint/eslint/issues/11647).\n                    !scopeInfo.codePath.currentSegments.some(s => s.reachable)\n                ) {\n                    return;\n                }\n\n                for (const segment of scopeInfo.codePath.currentSegments) {\n                    const info = segmentInfoMap.get(segment);\n\n                    if (info) {\n                        info.uselessReturns.push(node);\n                        info.returned = true;\n                    }\n                }\n                scopeInfo.uselessReturns.push(node);\n            },\n\n            /*\n             * Registers for all statement nodes except FunctionDeclaration, BlockStatement, BreakStatement.\n             * Removes return statements of the current segments from the useless return statement list.\n             */\n            ClassDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ContinueStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            DebuggerStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            DoWhileStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            EmptyStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ExpressionStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ForInStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ForOfStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ForStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            IfStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ImportDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,\n            LabeledStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            SwitchStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ThrowStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            TryStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            VariableDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,\n            WhileStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            WithStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ExportNamedDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ExportDefaultDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ExportAllDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}