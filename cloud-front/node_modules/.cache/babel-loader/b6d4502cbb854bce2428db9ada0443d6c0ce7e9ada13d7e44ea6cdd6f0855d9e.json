{"ast":null,"code":"/**\n * @fileoverview Rule to flag statements that use != and == instead of !== and ===\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require the use of `===` and `!==`\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/eqeqeq\"\n    },\n    schema: {\n      anyOf: [{\n        type: \"array\",\n        items: [{\n          enum: [\"always\"]\n        }, {\n          type: \"object\",\n          properties: {\n            null: {\n              enum: [\"always\", \"never\", \"ignore\"]\n            }\n          },\n          additionalProperties: false\n        }],\n        additionalItems: false\n      }, {\n        type: \"array\",\n        items: [{\n          enum: [\"smart\", \"allow-null\"]\n        }],\n        additionalItems: false\n      }]\n    },\n    fixable: \"code\",\n    messages: {\n      unexpected: \"Expected '{{expectedOperator}}' and instead saw '{{actualOperator}}'.\"\n    }\n  },\n  create(context) {\n    const config = context.options[0] || \"always\";\n    const options = context.options[1] || {};\n    const sourceCode = context.getSourceCode();\n    const nullOption = config === \"always\" ? options.null || \"always\" : \"ignore\";\n    const enforceRuleForNull = nullOption === \"always\";\n    const enforceInverseRuleForNull = nullOption === \"never\";\n\n    /**\n     * Checks if an expression is a typeof expression\n     * @param  {ASTNode} node The node to check\n     * @returns {boolean} if the node is a typeof expression\n     */\n    function isTypeOf(node) {\n      return node.type === \"UnaryExpression\" && node.operator === \"typeof\";\n    }\n\n    /**\n     * Checks if either operand of a binary expression is a typeof operation\n     * @param {ASTNode} node The node to check\n     * @returns {boolean} if one of the operands is typeof\n     * @private\n     */\n    function isTypeOfBinary(node) {\n      return isTypeOf(node.left) || isTypeOf(node.right);\n    }\n\n    /**\n     * Checks if operands are literals of the same type (via typeof)\n     * @param {ASTNode} node The node to check\n     * @returns {boolean} if operands are of same type\n     * @private\n     */\n    function areLiteralsAndSameType(node) {\n      return node.left.type === \"Literal\" && node.right.type === \"Literal\" && typeof node.left.value === typeof node.right.value;\n    }\n\n    /**\n     * Checks if one of the operands is a literal null\n     * @param {ASTNode} node The node to check\n     * @returns {boolean} if operands are null\n     * @private\n     */\n    function isNullCheck(node) {\n      return astUtils.isNullLiteral(node.right) || astUtils.isNullLiteral(node.left);\n    }\n\n    /**\n     * Reports a message for this rule.\n     * @param {ASTNode} node The binary expression node that was checked\n     * @param {string} expectedOperator The operator that was expected (either '==', '!=', '===', or '!==')\n     * @returns {void}\n     * @private\n     */\n    function report(node, expectedOperator) {\n      const operatorToken = sourceCode.getFirstTokenBetween(node.left, node.right, token => token.value === node.operator);\n      context.report({\n        node,\n        loc: operatorToken.loc,\n        messageId: \"unexpected\",\n        data: {\n          expectedOperator,\n          actualOperator: node.operator\n        },\n        fix(fixer) {\n          // If the comparison is a `typeof` comparison or both sides are literals with the same type, then it's safe to fix.\n          if (isTypeOfBinary(node) || areLiteralsAndSameType(node)) {\n            return fixer.replaceText(operatorToken, expectedOperator);\n          }\n          return null;\n        }\n      });\n    }\n    return {\n      BinaryExpression(node) {\n        const isNull = isNullCheck(node);\n        if (node.operator !== \"==\" && node.operator !== \"!=\") {\n          if (enforceInverseRuleForNull && isNull) {\n            report(node, node.operator.slice(0, -1));\n          }\n          return;\n        }\n        if (config === \"smart\" && (isTypeOfBinary(node) || areLiteralsAndSameType(node) || isNull)) {\n          return;\n        }\n        if (!enforceRuleForNull && isNull) {\n          return;\n        }\n        report(node, `${node.operator}=`);\n      }\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","module","exports","meta","type","docs","description","category","recommended","url","schema","anyOf","items","enum","properties","null","additionalProperties","additionalItems","fixable","messages","unexpected","create","context","config","options","sourceCode","getSourceCode","nullOption","enforceRuleForNull","enforceInverseRuleForNull","isTypeOf","node","operator","isTypeOfBinary","left","right","areLiteralsAndSameType","value","isNullCheck","isNullLiteral","report","expectedOperator","operatorToken","getFirstTokenBetween","token","loc","messageId","data","actualOperator","fix","fixer","replaceText","BinaryExpression","isNull","slice"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/eqeqeq.js"],"sourcesContent":["/**\n * @fileoverview Rule to flag statements that use != and == instead of !== and ===\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require the use of `===` and `!==`\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/eqeqeq\"\n        },\n\n        schema: {\n            anyOf: [\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"always\"]\n                        },\n                        {\n                            type: \"object\",\n                            properties: {\n                                null: {\n                                    enum: [\"always\", \"never\", \"ignore\"]\n                                }\n                            },\n                            additionalProperties: false\n                        }\n                    ],\n                    additionalItems: false\n                },\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"smart\", \"allow-null\"]\n                        }\n                    ],\n                    additionalItems: false\n                }\n            ]\n        },\n\n        fixable: \"code\",\n\n        messages: {\n            unexpected: \"Expected '{{expectedOperator}}' and instead saw '{{actualOperator}}'.\"\n        }\n    },\n\n    create(context) {\n        const config = context.options[0] || \"always\";\n        const options = context.options[1] || {};\n        const sourceCode = context.getSourceCode();\n\n        const nullOption = (config === \"always\")\n            ? options.null || \"always\"\n            : \"ignore\";\n        const enforceRuleForNull = (nullOption === \"always\");\n        const enforceInverseRuleForNull = (nullOption === \"never\");\n\n        /**\n         * Checks if an expression is a typeof expression\n         * @param  {ASTNode} node The node to check\n         * @returns {boolean} if the node is a typeof expression\n         */\n        function isTypeOf(node) {\n            return node.type === \"UnaryExpression\" && node.operator === \"typeof\";\n        }\n\n        /**\n         * Checks if either operand of a binary expression is a typeof operation\n         * @param {ASTNode} node The node to check\n         * @returns {boolean} if one of the operands is typeof\n         * @private\n         */\n        function isTypeOfBinary(node) {\n            return isTypeOf(node.left) || isTypeOf(node.right);\n        }\n\n        /**\n         * Checks if operands are literals of the same type (via typeof)\n         * @param {ASTNode} node The node to check\n         * @returns {boolean} if operands are of same type\n         * @private\n         */\n        function areLiteralsAndSameType(node) {\n            return node.left.type === \"Literal\" && node.right.type === \"Literal\" &&\n                    typeof node.left.value === typeof node.right.value;\n        }\n\n        /**\n         * Checks if one of the operands is a literal null\n         * @param {ASTNode} node The node to check\n         * @returns {boolean} if operands are null\n         * @private\n         */\n        function isNullCheck(node) {\n            return astUtils.isNullLiteral(node.right) || astUtils.isNullLiteral(node.left);\n        }\n\n        /**\n         * Reports a message for this rule.\n         * @param {ASTNode} node The binary expression node that was checked\n         * @param {string} expectedOperator The operator that was expected (either '==', '!=', '===', or '!==')\n         * @returns {void}\n         * @private\n         */\n        function report(node, expectedOperator) {\n            const operatorToken = sourceCode.getFirstTokenBetween(\n                node.left,\n                node.right,\n                token => token.value === node.operator\n            );\n\n            context.report({\n                node,\n                loc: operatorToken.loc,\n                messageId: \"unexpected\",\n                data: { expectedOperator, actualOperator: node.operator },\n                fix(fixer) {\n\n                    // If the comparison is a `typeof` comparison or both sides are literals with the same type, then it's safe to fix.\n                    if (isTypeOfBinary(node) || areLiteralsAndSameType(node)) {\n                        return fixer.replaceText(operatorToken, expectedOperator);\n                    }\n                    return null;\n                }\n            });\n        }\n\n        return {\n            BinaryExpression(node) {\n                const isNull = isNullCheck(node);\n\n                if (node.operator !== \"==\" && node.operator !== \"!=\") {\n                    if (enforceInverseRuleForNull && isNull) {\n                        report(node, node.operator.slice(0, -1));\n                    }\n                    return;\n                }\n\n                if (config === \"smart\" && (isTypeOfBinary(node) ||\n                        areLiteralsAndSameType(node) || isNull)) {\n                    return;\n                }\n\n                if (!enforceRuleForNull && isNull) {\n                    return;\n                }\n\n                report(node, `${node.operator}=`);\n            }\n        };\n\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}