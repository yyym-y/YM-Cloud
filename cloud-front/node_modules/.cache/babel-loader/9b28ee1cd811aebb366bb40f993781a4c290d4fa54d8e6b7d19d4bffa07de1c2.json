{"ast":null,"code":"/**\n * @fileoverview Rule to disallow unnecessary computed property keys in object literals\n * @author Burak Yigit Kaya\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow unnecessary computed property keys in objects and classes\",\n      category: \"ECMAScript 6\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-useless-computed-key\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        enforceForClassMembers: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    fixable: \"code\",\n    messages: {\n      unnecessarilyComputedProperty: \"Unnecessarily computed property [{{property}}] found.\"\n    }\n  },\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const enforceForClassMembers = context.options[0] && context.options[0].enforceForClassMembers;\n\n    /**\n     * Reports a given node if it violated this rule.\n     * @param {ASTNode} node The node to check.\n     * @returns {void}\n     */\n    function check(node) {\n      if (!node.computed) {\n        return;\n      }\n      const key = node.key,\n        nodeType = typeof key.value;\n      let allowedKey;\n      if (node.type === \"MethodDefinition\") {\n        allowedKey = node.static ? \"prototype\" : \"constructor\";\n      } else {\n        allowedKey = \"__proto__\";\n      }\n      if (key.type === \"Literal\" && (nodeType === \"string\" || nodeType === \"number\") && key.value !== allowedKey) {\n        context.report({\n          node,\n          messageId: \"unnecessarilyComputedProperty\",\n          data: {\n            property: sourceCode.getText(key)\n          },\n          fix(fixer) {\n            const leftSquareBracket = sourceCode.getTokenBefore(key, astUtils.isOpeningBracketToken);\n            const rightSquareBracket = sourceCode.getTokenAfter(key, astUtils.isClosingBracketToken);\n\n            // If there are comments between the brackets and the property name, don't do a fix.\n            if (sourceCode.commentsExistBetween(leftSquareBracket, rightSquareBracket)) {\n              return null;\n            }\n            const tokenBeforeLeftBracket = sourceCode.getTokenBefore(leftSquareBracket);\n\n            // Insert a space before the key to avoid changing identifiers, e.g. ({ get[2]() {} }) to ({ get2() {} })\n            const needsSpaceBeforeKey = tokenBeforeLeftBracket.range[1] === leftSquareBracket.range[0] && !astUtils.canTokensBeAdjacent(tokenBeforeLeftBracket, sourceCode.getFirstToken(key));\n            const replacementKey = (needsSpaceBeforeKey ? \" \" : \"\") + key.raw;\n            return fixer.replaceTextRange([leftSquareBracket.range[0], rightSquareBracket.range[1]], replacementKey);\n          }\n        });\n      }\n    }\n\n    /**\n     * A no-op function to act as placeholder for checking a node when the `enforceForClassMembers` option is `false`.\n     * @returns {void}\n     * @private\n     */\n    function noop() {}\n    return {\n      Property: check,\n      MethodDefinition: enforceForClassMembers ? check : noop\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","module","exports","meta","type","docs","description","category","recommended","url","schema","properties","enforceForClassMembers","default","additionalProperties","fixable","messages","unnecessarilyComputedProperty","create","context","sourceCode","getSourceCode","options","check","node","computed","key","nodeType","value","allowedKey","static","report","messageId","data","property","getText","fix","fixer","leftSquareBracket","getTokenBefore","isOpeningBracketToken","rightSquareBracket","getTokenAfter","isClosingBracketToken","commentsExistBetween","tokenBeforeLeftBracket","needsSpaceBeforeKey","range","canTokensBeAdjacent","getFirstToken","replacementKey","raw","replaceTextRange","noop","Property","MethodDefinition"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/no-useless-computed-key.js"],"sourcesContent":["/**\n * @fileoverview Rule to disallow unnecessary computed property keys in object literals\n * @author Burak Yigit Kaya\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow unnecessary computed property keys in objects and classes\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-useless-computed-key\"\n        },\n\n        schema: [{\n            type: \"object\",\n            properties: {\n                enforceForClassMembers: {\n                    type: \"boolean\",\n                    default: false\n                }\n            },\n            additionalProperties: false\n        }],\n        fixable: \"code\",\n\n        messages: {\n            unnecessarilyComputedProperty: \"Unnecessarily computed property [{{property}}] found.\"\n        }\n    },\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const enforceForClassMembers = context.options[0] && context.options[0].enforceForClassMembers;\n\n        /**\n         * Reports a given node if it violated this rule.\n         * @param {ASTNode} node The node to check.\n         * @returns {void}\n         */\n        function check(node) {\n            if (!node.computed) {\n                return;\n            }\n\n            const key = node.key,\n                nodeType = typeof key.value;\n\n            let allowedKey;\n\n            if (node.type === \"MethodDefinition\") {\n                allowedKey = node.static ? \"prototype\" : \"constructor\";\n            } else {\n                allowedKey = \"__proto__\";\n            }\n\n            if (key.type === \"Literal\" && (nodeType === \"string\" || nodeType === \"number\") && key.value !== allowedKey) {\n                context.report({\n                    node,\n                    messageId: \"unnecessarilyComputedProperty\",\n                    data: { property: sourceCode.getText(key) },\n                    fix(fixer) {\n                        const leftSquareBracket = sourceCode.getTokenBefore(key, astUtils.isOpeningBracketToken);\n                        const rightSquareBracket = sourceCode.getTokenAfter(key, astUtils.isClosingBracketToken);\n\n                        // If there are comments between the brackets and the property name, don't do a fix.\n                        if (sourceCode.commentsExistBetween(leftSquareBracket, rightSquareBracket)) {\n                            return null;\n                        }\n\n                        const tokenBeforeLeftBracket = sourceCode.getTokenBefore(leftSquareBracket);\n\n                        // Insert a space before the key to avoid changing identifiers, e.g. ({ get[2]() {} }) to ({ get2() {} })\n                        const needsSpaceBeforeKey = tokenBeforeLeftBracket.range[1] === leftSquareBracket.range[0] &&\n                            !astUtils.canTokensBeAdjacent(tokenBeforeLeftBracket, sourceCode.getFirstToken(key));\n\n                        const replacementKey = (needsSpaceBeforeKey ? \" \" : \"\") + key.raw;\n\n                        return fixer.replaceTextRange([leftSquareBracket.range[0], rightSquareBracket.range[1]], replacementKey);\n                    }\n                });\n            }\n        }\n\n        /**\n         * A no-op function to act as placeholder for checking a node when the `enforceForClassMembers` option is `false`.\n         * @returns {void}\n         * @private\n         */\n        function noop() {}\n\n        return {\n            Property: check,\n            MethodDefinition: enforceForClassMembers ? check : noop\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}