{"ast":null,"code":"require(\"core-js/modules/es.array.push.js\");\nmodule.exports = minimatch;\nminimatch.Minimatch = Minimatch;\nvar path = function () {\n  try {\n    return require('path');\n  } catch (e) {}\n}() || {\n  sep: '/'\n};\nminimatch.sep = path.sep;\nvar GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};\nvar expand = require('brace-expansion');\nvar plTypes = {\n  '!': {\n    open: '(?:(?!(?:',\n    close: '))[^/]*?)'\n  },\n  '?': {\n    open: '(?:',\n    close: ')?'\n  },\n  '+': {\n    open: '(?:',\n    close: ')+'\n  },\n  '*': {\n    open: '(?:',\n    close: ')*'\n  },\n  '@': {\n    open: '(?:',\n    close: ')'\n  }\n};\n\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nvar qmark = '[^/]';\n\n// * => any number of characters\nvar star = qmark + '*?';\n\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nvar twoStarDot = '(?:(?!(?:\\\\\\/|^)(?:\\\\.{1,2})($|\\\\\\/)).)*?';\n\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nvar twoStarNoDot = '(?:(?!(?:\\\\\\/|^)\\\\.).)*?';\n\n// characters that need to be escaped in RegExp.\nvar reSpecials = charSet('().*{}+?[]^$\\\\!');\n\n// \"abc\" -> { a:true, b:true, c:true }\nfunction charSet(s) {\n  return s.split('').reduce(function (set, c) {\n    set[c] = true;\n    return set;\n  }, {});\n}\n\n// normalizes slashes.\nvar slashSplit = /\\/+/;\nminimatch.filter = filter;\nfunction filter(pattern, options) {\n  options = options || {};\n  return function (p, i, list) {\n    return minimatch(p, pattern, options);\n  };\n}\nfunction ext(a, b) {\n  b = b || {};\n  var t = {};\n  Object.keys(a).forEach(function (k) {\n    t[k] = a[k];\n  });\n  Object.keys(b).forEach(function (k) {\n    t[k] = b[k];\n  });\n  return t;\n}\nminimatch.defaults = function (def) {\n  if (!def || typeof def !== 'object' || !Object.keys(def).length) {\n    return minimatch;\n  }\n  var orig = minimatch;\n  var m = function minimatch(p, pattern, options) {\n    return orig(p, pattern, ext(def, options));\n  };\n  m.Minimatch = function Minimatch(pattern, options) {\n    return new orig.Minimatch(pattern, ext(def, options));\n  };\n  m.Minimatch.defaults = function defaults(options) {\n    return orig.defaults(ext(def, options)).Minimatch;\n  };\n  m.filter = function filter(pattern, options) {\n    return orig.filter(pattern, ext(def, options));\n  };\n  m.defaults = function defaults(options) {\n    return orig.defaults(ext(def, options));\n  };\n  m.makeRe = function makeRe(pattern, options) {\n    return orig.makeRe(pattern, ext(def, options));\n  };\n  m.braceExpand = function braceExpand(pattern, options) {\n    return orig.braceExpand(pattern, ext(def, options));\n  };\n  m.match = function (list, pattern, options) {\n    return orig.match(list, pattern, ext(def, options));\n  };\n  return m;\n};\nMinimatch.defaults = function (def) {\n  return minimatch.defaults(def).Minimatch;\n};\nfunction minimatch(p, pattern, options) {\n  assertValidPattern(pattern);\n  if (!options) options = {};\n\n  // shortcut: comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    return false;\n  }\n  return new Minimatch(pattern, options).match(p);\n}\nfunction Minimatch(pattern, options) {\n  if (!(this instanceof Minimatch)) {\n    return new Minimatch(pattern, options);\n  }\n  assertValidPattern(pattern);\n  if (!options) options = {};\n  pattern = pattern.trim();\n\n  // windows support: need to use /, not \\\n  if (!options.allowWindowsEscape && path.sep !== '/') {\n    pattern = pattern.split(path.sep).join('/');\n  }\n  this.options = options;\n  this.set = [];\n  this.pattern = pattern;\n  this.regexp = null;\n  this.negate = false;\n  this.comment = false;\n  this.empty = false;\n  this.partial = !!options.partial;\n\n  // make the set of regexps etc.\n  this.make();\n}\nMinimatch.prototype.debug = function () {};\nMinimatch.prototype.make = make;\nfunction make() {\n  var pattern = this.pattern;\n  var options = this.options;\n\n  // empty patterns and comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    this.comment = true;\n    return;\n  }\n  if (!pattern) {\n    this.empty = true;\n    return;\n  }\n\n  // step 1: figure out negation, etc.\n  this.parseNegate();\n\n  // step 2: expand braces\n  var set = this.globSet = this.braceExpand();\n  if (options.debug) this.debug = function debug() {\n    console.error.apply(console, arguments);\n  };\n  this.debug(this.pattern, set);\n\n  // step 3: now we have a set, so turn each one into a series of path-portion\n  // matching patterns.\n  // These will be regexps, except in the case of \"**\", which is\n  // set to the GLOBSTAR object for globstar behavior,\n  // and will not contain any / characters\n  set = this.globParts = set.map(function (s) {\n    return s.split(slashSplit);\n  });\n  this.debug(this.pattern, set);\n\n  // glob --> regexps\n  set = set.map(function (s, si, set) {\n    return s.map(this.parse, this);\n  }, this);\n  this.debug(this.pattern, set);\n\n  // filter out everything that didn't compile properly.\n  set = set.filter(function (s) {\n    return s.indexOf(false) === -1;\n  });\n  this.debug(this.pattern, set);\n  this.set = set;\n}\nMinimatch.prototype.parseNegate = parseNegate;\nfunction parseNegate() {\n  var pattern = this.pattern;\n  var negate = false;\n  var options = this.options;\n  var negateOffset = 0;\n  if (options.nonegate) return;\n  for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === '!'; i++) {\n    negate = !negate;\n    negateOffset++;\n  }\n  if (negateOffset) this.pattern = pattern.substr(negateOffset);\n  this.negate = negate;\n}\n\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nminimatch.braceExpand = function (pattern, options) {\n  return braceExpand(pattern, options);\n};\nMinimatch.prototype.braceExpand = braceExpand;\nfunction braceExpand(pattern, options) {\n  if (!options) {\n    if (this instanceof Minimatch) {\n      options = this.options;\n    } else {\n      options = {};\n    }\n  }\n  pattern = typeof pattern === 'undefined' ? this.pattern : pattern;\n  assertValidPattern(pattern);\n\n  // Thanks to Yeting Li <https://github.com/yetingli> for\n  // improving this regexp to avoid a ReDOS vulnerability.\n  if (options.nobrace || !/\\{(?:(?!\\{).)*\\}/.test(pattern)) {\n    // shortcut. no need to expand.\n    return [pattern];\n  }\n  return expand(pattern);\n}\nvar MAX_PATTERN_LENGTH = 1024 * 64;\nvar assertValidPattern = function (pattern) {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('invalid pattern');\n  }\n  if (pattern.length > MAX_PATTERN_LENGTH) {\n    throw new TypeError('pattern is too long');\n  }\n};\n\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\nMinimatch.prototype.parse = parse;\nvar SUBPARSE = {};\nfunction parse(pattern, isSub) {\n  assertValidPattern(pattern);\n  var options = this.options;\n\n  // shortcuts\n  if (pattern === '**') {\n    if (!options.noglobstar) return GLOBSTAR;else pattern = '*';\n  }\n  if (pattern === '') return '';\n  var re = '';\n  var hasMagic = !!options.nocase;\n  var escaping = false;\n  // ? => one single character\n  var patternListStack = [];\n  var negativeLists = [];\n  var stateChar;\n  var inClass = false;\n  var reClassStart = -1;\n  var classStart = -1;\n  // . and .. never match anything that doesn't start with .,\n  // even when options.dot is set.\n  var patternStart = pattern.charAt(0) === '.' ? '' // anything\n  // not (start or / followed by . or .. followed by / or end)\n  : options.dot ? '(?!(?:^|\\\\\\/)\\\\.{1,2}(?:$|\\\\\\/))' : '(?!\\\\.)';\n  var self = this;\n  function clearStateChar() {\n    if (stateChar) {\n      // we had some state-tracking character\n      // that wasn't consumed by this pass.\n      switch (stateChar) {\n        case '*':\n          re += star;\n          hasMagic = true;\n          break;\n        case '?':\n          re += qmark;\n          hasMagic = true;\n          break;\n        default:\n          re += '\\\\' + stateChar;\n          break;\n      }\n      self.debug('clearStateChar %j %j', stateChar, re);\n      stateChar = false;\n    }\n  }\n  for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {\n    this.debug('%s\\t%s %s %j', pattern, i, re, c);\n\n    // skip over any that are escaped.\n    if (escaping && reSpecials[c]) {\n      re += '\\\\' + c;\n      escaping = false;\n      continue;\n    }\n    switch (c) {\n      /* istanbul ignore next */\n      case '/':\n        {\n          // completely not allowed, even escaped.\n          // Should already be path-split by now.\n          return false;\n        }\n      case '\\\\':\n        clearStateChar();\n        escaping = true;\n        continue;\n\n      // the various stateChar values\n      // for the \"extglob\" stuff.\n      case '?':\n      case '*':\n      case '+':\n      case '@':\n      case '!':\n        this.debug('%s\\t%s %s %j <-- stateChar', pattern, i, re, c);\n\n        // all of those are literals inside a class, except that\n        // the glob [!a] means [^a] in regexp\n        if (inClass) {\n          this.debug('  in class');\n          if (c === '!' && i === classStart + 1) c = '^';\n          re += c;\n          continue;\n        }\n\n        // if we already have a stateChar, then it means\n        // that there was something like ** or +? in there.\n        // Handle the stateChar, then proceed with this one.\n        self.debug('call clearStateChar %j', stateChar);\n        clearStateChar();\n        stateChar = c;\n        // if extglob is disabled, then +(asdf|foo) isn't a thing.\n        // just clear the statechar *now*, rather than even diving into\n        // the patternList stuff.\n        if (options.noext) clearStateChar();\n        continue;\n      case '(':\n        if (inClass) {\n          re += '(';\n          continue;\n        }\n        if (!stateChar) {\n          re += '\\\\(';\n          continue;\n        }\n        patternListStack.push({\n          type: stateChar,\n          start: i - 1,\n          reStart: re.length,\n          open: plTypes[stateChar].open,\n          close: plTypes[stateChar].close\n        });\n        // negation is (?:(?!js)[^/]*)\n        re += stateChar === '!' ? '(?:(?!(?:' : '(?:';\n        this.debug('plType %j %j', stateChar, re);\n        stateChar = false;\n        continue;\n      case ')':\n        if (inClass || !patternListStack.length) {\n          re += '\\\\)';\n          continue;\n        }\n        clearStateChar();\n        hasMagic = true;\n        var pl = patternListStack.pop();\n        // negation is (?:(?!js)[^/]*)\n        // The others are (?:<pattern>)<type>\n        re += pl.close;\n        if (pl.type === '!') {\n          negativeLists.push(pl);\n        }\n        pl.reEnd = re.length;\n        continue;\n      case '|':\n        if (inClass || !patternListStack.length || escaping) {\n          re += '\\\\|';\n          escaping = false;\n          continue;\n        }\n        clearStateChar();\n        re += '|';\n        continue;\n\n      // these are mostly the same in regexp and glob\n      case '[':\n        // swallow any state-tracking char before the [\n        clearStateChar();\n        if (inClass) {\n          re += '\\\\' + c;\n          continue;\n        }\n        inClass = true;\n        classStart = i;\n        reClassStart = re.length;\n        re += c;\n        continue;\n      case ']':\n        //  a right bracket shall lose its special\n        //  meaning and represent itself in\n        //  a bracket expression if it occurs\n        //  first in the list.  -- POSIX.2 2.8.3.2\n        if (i === classStart + 1 || !inClass) {\n          re += '\\\\' + c;\n          escaping = false;\n          continue;\n        }\n\n        // handle the case where we left a class open.\n        // \"[z-a]\" is valid, equivalent to \"\\[z-a\\]\"\n        // split where the last [ was, make sure we don't have\n        // an invalid re. if so, re-walk the contents of the\n        // would-be class to re-translate any characters that\n        // were passed through as-is\n        // TODO: It would probably be faster to determine this\n        // without a try/catch and a new RegExp, but it's tricky\n        // to do safely.  For now, this is safe and works.\n        var cs = pattern.substring(classStart + 1, i);\n        try {\n          RegExp('[' + cs + ']');\n        } catch (er) {\n          // not a valid class!\n          var sp = this.parse(cs, SUBPARSE);\n          re = re.substr(0, reClassStart) + '\\\\[' + sp[0] + '\\\\]';\n          hasMagic = hasMagic || sp[1];\n          inClass = false;\n          continue;\n        }\n\n        // finish up the class.\n        hasMagic = true;\n        inClass = false;\n        re += c;\n        continue;\n      default:\n        // swallow any state char that wasn't consumed\n        clearStateChar();\n        if (escaping) {\n          // no need\n          escaping = false;\n        } else if (reSpecials[c] && !(c === '^' && inClass)) {\n          re += '\\\\';\n        }\n        re += c;\n    } // switch\n  } // for\n\n  // handle the case where we left a class open.\n  // \"[abc\" is valid, equivalent to \"\\[abc\"\n  if (inClass) {\n    // split where the last [ was, and escape it\n    // this is a huge pita.  We now have to re-walk\n    // the contents of the would-be class to re-translate\n    // any characters that were passed through as-is\n    cs = pattern.substr(classStart + 1);\n    sp = this.parse(cs, SUBPARSE);\n    re = re.substr(0, reClassStart) + '\\\\[' + sp[0];\n    hasMagic = hasMagic || sp[1];\n  }\n\n  // handle the case where we had a +( thing at the *end*\n  // of the pattern.\n  // each pattern list stack adds 3 chars, and we need to go through\n  // and escape any | chars that were passed through as-is for the regexp.\n  // Go through and escape them, taking care not to double-escape any\n  // | chars that were already escaped.\n  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {\n    var tail = re.slice(pl.reStart + pl.open.length);\n    this.debug('setting tail', re, pl);\n    // maybe some even number of \\, then maybe 1 \\, followed by a |\n    tail = tail.replace(/((?:\\\\{2}){0,64})(\\\\?)\\|/g, function (_, $1, $2) {\n      if (!$2) {\n        // the | isn't already escaped, so escape it.\n        $2 = '\\\\';\n      }\n\n      // need to escape all those slashes *again*, without escaping the\n      // one that we need for escaping the | character.  As it works out,\n      // escaping an even number of slashes can be done by simply repeating\n      // it exactly after itself.  That's why this trick works.\n      //\n      // I am sorry that you have to see this.\n      return $1 + $1 + $2 + '|';\n    });\n    this.debug('tail=%j\\n   %s', tail, tail, pl, re);\n    var t = pl.type === '*' ? star : pl.type === '?' ? qmark : '\\\\' + pl.type;\n    hasMagic = true;\n    re = re.slice(0, pl.reStart) + t + '\\\\(' + tail;\n  }\n\n  // handle trailing things that only matter at the very end.\n  clearStateChar();\n  if (escaping) {\n    // trailing \\\\\n    re += '\\\\\\\\';\n  }\n\n  // only need to apply the nodot start if the re starts with\n  // something that could conceivably capture a dot\n  var addPatternStart = false;\n  switch (re.charAt(0)) {\n    case '[':\n    case '.':\n    case '(':\n      addPatternStart = true;\n  }\n\n  // Hack to work around lack of negative lookbehind in JS\n  // A pattern like: *.!(x).!(y|z) needs to ensure that a name\n  // like 'a.xyz.yz' doesn't match.  So, the first negative\n  // lookahead, has to look ALL the way ahead, to the end of\n  // the pattern.\n  for (var n = negativeLists.length - 1; n > -1; n--) {\n    var nl = negativeLists[n];\n    var nlBefore = re.slice(0, nl.reStart);\n    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);\n    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);\n    var nlAfter = re.slice(nl.reEnd);\n    nlLast += nlAfter;\n\n    // Handle nested stuff like *(*.js|!(*.json)), where open parens\n    // mean that we should *not* include the ) in the bit that is considered\n    // \"after\" the negated section.\n    var openParensBefore = nlBefore.split('(').length - 1;\n    var cleanAfter = nlAfter;\n    for (i = 0; i < openParensBefore; i++) {\n      cleanAfter = cleanAfter.replace(/\\)[+*?]?/, '');\n    }\n    nlAfter = cleanAfter;\n    var dollar = '';\n    if (nlAfter === '' && isSub !== SUBPARSE) {\n      dollar = '$';\n    }\n    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;\n    re = newRe;\n  }\n\n  // if the re is not \"\" at this point, then we need to make sure\n  // it doesn't match against an empty path part.\n  // Otherwise a/* will match a/, which it should not.\n  if (re !== '' && hasMagic) {\n    re = '(?=.)' + re;\n  }\n  if (addPatternStart) {\n    re = patternStart + re;\n  }\n\n  // parsing just a piece of a larger pattern.\n  if (isSub === SUBPARSE) {\n    return [re, hasMagic];\n  }\n\n  // skip the regexp for non-magical patterns\n  // unescape anything in it, though, so that it'll be\n  // an exact match against a file etc.\n  if (!hasMagic) {\n    return globUnescape(pattern);\n  }\n  var flags = options.nocase ? 'i' : '';\n  try {\n    var regExp = new RegExp('^' + re + '$', flags);\n  } catch (er) /* istanbul ignore next - should be impossible */{\n    // If it was an invalid regular expression, then it can't match\n    // anything.  This trick looks for a character after the end of\n    // the string, which is of course impossible, except in multi-line\n    // mode, but it's not a /m regex.\n    return new RegExp('$.');\n  }\n  regExp._glob = pattern;\n  regExp._src = re;\n  return regExp;\n}\nminimatch.makeRe = function (pattern, options) {\n  return new Minimatch(pattern, options || {}).makeRe();\n};\nMinimatch.prototype.makeRe = makeRe;\nfunction makeRe() {\n  if (this.regexp || this.regexp === false) return this.regexp;\n\n  // at this point, this.set is a 2d array of partial\n  // pattern strings, or \"**\".\n  //\n  // It's better to use .match().  This function shouldn't\n  // be used, really, but it's pretty convenient sometimes,\n  // when you just want to work with a regex.\n  var set = this.set;\n  if (!set.length) {\n    this.regexp = false;\n    return this.regexp;\n  }\n  var options = this.options;\n  var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;\n  var flags = options.nocase ? 'i' : '';\n  var re = set.map(function (pattern) {\n    return pattern.map(function (p) {\n      return p === GLOBSTAR ? twoStar : typeof p === 'string' ? regExpEscape(p) : p._src;\n    }).join('\\\\\\/');\n  }).join('|');\n\n  // must match entire pattern\n  // ending in a * or ** will make it less strict.\n  re = '^(?:' + re + ')$';\n\n  // can match anything, as long as it's not this.\n  if (this.negate) re = '^(?!' + re + ').*$';\n  try {\n    this.regexp = new RegExp(re, flags);\n  } catch (ex) /* istanbul ignore next - should be impossible */{\n    this.regexp = false;\n  }\n  return this.regexp;\n}\nminimatch.match = function (list, pattern, options) {\n  options = options || {};\n  var mm = new Minimatch(pattern, options);\n  list = list.filter(function (f) {\n    return mm.match(f);\n  });\n  if (mm.options.nonull && !list.length) {\n    list.push(pattern);\n  }\n  return list;\n};\nMinimatch.prototype.match = function match(f, partial) {\n  if (typeof partial === 'undefined') partial = this.partial;\n  this.debug('match', f, this.pattern);\n  // short-circuit in the case of busted things.\n  // comments, etc.\n  if (this.comment) return false;\n  if (this.empty) return f === '';\n  if (f === '/' && partial) return true;\n  var options = this.options;\n\n  // windows: need to use /, not \\\n  if (path.sep !== '/') {\n    f = f.split(path.sep).join('/');\n  }\n\n  // treat the test path as a set of pathparts.\n  f = f.split(slashSplit);\n  this.debug(this.pattern, 'split', f);\n\n  // just ONE of the pattern sets in this.set needs to match\n  // in order for it to be valid.  If negating, then just one\n  // match means that we have failed.\n  // Either way, return on the first hit.\n\n  var set = this.set;\n  this.debug(this.pattern, 'set', set);\n\n  // Find the basename of the path by looking for the last non-empty segment\n  var filename;\n  var i;\n  for (i = f.length - 1; i >= 0; i--) {\n    filename = f[i];\n    if (filename) break;\n  }\n  for (i = 0; i < set.length; i++) {\n    var pattern = set[i];\n    var file = f;\n    if (options.matchBase && pattern.length === 1) {\n      file = [filename];\n    }\n    var hit = this.matchOne(file, pattern, partial);\n    if (hit) {\n      if (options.flipNegate) return true;\n      return !this.negate;\n    }\n  }\n\n  // didn't get any hits.  this is success if it's a negative\n  // pattern, failure otherwise.\n  if (options.flipNegate) return false;\n  return this.negate;\n};\n\n// set partial to true to test if, for example,\n// \"/a/b\" matches the start of \"/*/b/*/d\"\n// Partial means, if you run out of file before you run\n// out of pattern, then that's fine, as long as all\n// the parts match.\nMinimatch.prototype.matchOne = function (file, pattern, partial) {\n  var options = this.options;\n  this.debug('matchOne', {\n    'this': this,\n    file: file,\n    pattern: pattern\n  });\n  this.debug('matchOne', file.length, pattern.length);\n  for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {\n    this.debug('matchOne loop');\n    var p = pattern[pi];\n    var f = file[fi];\n    this.debug(pattern, p, f);\n\n    // should be impossible.\n    // some invalid regexp stuff in the set.\n    /* istanbul ignore if */\n    if (p === false) return false;\n    if (p === GLOBSTAR) {\n      this.debug('GLOBSTAR', [pattern, p, f]);\n\n      // \"**\"\n      // a/**/b/**/c would match the following:\n      // a/b/x/y/z/c\n      // a/x/y/z/b/c\n      // a/b/x/b/x/c\n      // a/b/c\n      // To do this, take the rest of the pattern after\n      // the **, and see if it would match the file remainder.\n      // If so, return success.\n      // If not, the ** \"swallows\" a segment, and try again.\n      // This is recursively awful.\n      //\n      // a/**/b/**/c matching a/b/x/y/z/c\n      // - a matches a\n      // - doublestar\n      //   - matchOne(b/x/y/z/c, b/**/c)\n      //     - b matches b\n      //     - doublestar\n      //       - matchOne(x/y/z/c, c) -> no\n      //       - matchOne(y/z/c, c) -> no\n      //       - matchOne(z/c, c) -> no\n      //       - matchOne(c, c) yes, hit\n      var fr = fi;\n      var pr = pi + 1;\n      if (pr === pl) {\n        this.debug('** at the end');\n        // a ** at the end will just swallow the rest.\n        // We have found a match.\n        // however, it will not swallow /.x, unless\n        // options.dot is set.\n        // . and .. are *never* matched by **, for explosively\n        // exponential reasons.\n        for (; fi < fl; fi++) {\n          if (file[fi] === '.' || file[fi] === '..' || !options.dot && file[fi].charAt(0) === '.') return false;\n        }\n        return true;\n      }\n\n      // ok, let's see if we can swallow whatever we can.\n      while (fr < fl) {\n        var swallowee = file[fr];\n        this.debug('\\nglobstar while', file, fr, pattern, pr, swallowee);\n\n        // XXX remove this slice.  Just pass the start index.\n        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n          this.debug('globstar found match!', fr, fl, swallowee);\n          // found a match.\n          return true;\n        } else {\n          // can't swallow \".\" or \"..\" ever.\n          // can only swallow \".foo\" when explicitly asked.\n          if (swallowee === '.' || swallowee === '..' || !options.dot && swallowee.charAt(0) === '.') {\n            this.debug('dot detected!', file, fr, pattern, pr);\n            break;\n          }\n\n          // ** swallows a segment, and continue.\n          this.debug('globstar swallow a segment, and continue');\n          fr++;\n        }\n      }\n\n      // no match was found.\n      // However, in partial mode, we can't say this is necessarily over.\n      // If there's more *pattern* left, then\n      /* istanbul ignore if */\n      if (partial) {\n        // ran out of file\n        this.debug('\\n>>> no match, partial?', file, fr, pattern, pr);\n        if (fr === fl) return true;\n      }\n      return false;\n    }\n\n    // something other than **\n    // non-magic patterns just have to match exactly\n    // patterns with magic have been turned into regexps.\n    var hit;\n    if (typeof p === 'string') {\n      hit = f === p;\n      this.debug('string match', p, f, hit);\n    } else {\n      hit = f.match(p);\n      this.debug('pattern match', p, f, hit);\n    }\n    if (!hit) return false;\n  }\n\n  // Note: ending in / means that we'll get a final \"\"\n  // at the end of the pattern.  This can only match a\n  // corresponding \"\" at the end of the file.\n  // If the file ends in /, then it can only match a\n  // a pattern that ends in /, unless the pattern just\n  // doesn't have any more for it. But, a/b/ should *not*\n  // match \"a/b/*\", even though \"\" matches against the\n  // [^/]*? pattern, except in partial mode, where it might\n  // simply not be reached yet.\n  // However, a/b/ should still satisfy a/*\n\n  // now either we fell off the end of the pattern, or we're done.\n  if (fi === fl && pi === pl) {\n    // ran out of pattern and filename at the same time.\n    // an exact hit!\n    return true;\n  } else if (fi === fl) {\n    // ran out of file, but still had pattern left.\n    // this is ok if we're doing the match as part of\n    // a glob fs traversal.\n    return partial;\n  } else /* istanbul ignore else */if (pi === pl) {\n      // ran out of pattern, still have file left.\n      // this is only acceptable if we're on the very last\n      // empty segment of a file with a trailing slash.\n      // a/* should match a/b/\n      return fi === fl - 1 && file[fi] === '';\n    }\n\n  // should be unreachable.\n  /* istanbul ignore next */\n  throw new Error('wtf?');\n};\n\n// replace stuff like \\* with *\nfunction globUnescape(s) {\n  return s.replace(/\\\\(.)/g, '$1');\n}\nfunction regExpEscape(s) {\n  return s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n}","map":{"version":3,"names":["module","exports","minimatch","Minimatch","path","require","e","sep","GLOBSTAR","expand","plTypes","open","close","qmark","star","twoStarDot","twoStarNoDot","reSpecials","charSet","s","split","reduce","set","c","slashSplit","filter","pattern","options","p","i","list","ext","a","b","t","Object","keys","forEach","k","defaults","def","length","orig","m","makeRe","braceExpand","match","assertValidPattern","nocomment","charAt","trim","allowWindowsEscape","join","regexp","negate","comment","empty","partial","make","prototype","debug","parseNegate","globSet","console","error","apply","arguments","globParts","map","si","parse","indexOf","negateOffset","nonegate","l","substr","nobrace","test","MAX_PATTERN_LENGTH","TypeError","SUBPARSE","isSub","noglobstar","re","hasMagic","nocase","escaping","patternListStack","negativeLists","stateChar","inClass","reClassStart","classStart","patternStart","dot","self","clearStateChar","len","noext","push","type","start","reStart","pl","pop","reEnd","cs","substring","RegExp","er","sp","tail","slice","replace","_","$1","$2","addPatternStart","n","nl","nlBefore","nlFirst","nlLast","nlAfter","openParensBefore","cleanAfter","dollar","newRe","globUnescape","flags","regExp","_glob","_src","twoStar","regExpEscape","ex","mm","f","nonull","filename","file","matchBase","hit","matchOne","flipNegate","fi","pi","fl","fr","pr","swallowee","Error"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/minimatch/minimatch.js"],"sourcesContent":["module.exports = minimatch\nminimatch.Minimatch = Minimatch\n\nvar path = (function () { try { return require('path') } catch (e) {}}()) || {\n  sep: '/'\n}\nminimatch.sep = path.sep\n\nvar GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}\nvar expand = require('brace-expansion')\n\nvar plTypes = {\n  '!': { open: '(?:(?!(?:', close: '))[^/]*?)'},\n  '?': { open: '(?:', close: ')?' },\n  '+': { open: '(?:', close: ')+' },\n  '*': { open: '(?:', close: ')*' },\n  '@': { open: '(?:', close: ')' }\n}\n\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nvar qmark = '[^/]'\n\n// * => any number of characters\nvar star = qmark + '*?'\n\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nvar twoStarDot = '(?:(?!(?:\\\\\\/|^)(?:\\\\.{1,2})($|\\\\\\/)).)*?'\n\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nvar twoStarNoDot = '(?:(?!(?:\\\\\\/|^)\\\\.).)*?'\n\n// characters that need to be escaped in RegExp.\nvar reSpecials = charSet('().*{}+?[]^$\\\\!')\n\n// \"abc\" -> { a:true, b:true, c:true }\nfunction charSet (s) {\n  return s.split('').reduce(function (set, c) {\n    set[c] = true\n    return set\n  }, {})\n}\n\n// normalizes slashes.\nvar slashSplit = /\\/+/\n\nminimatch.filter = filter\nfunction filter (pattern, options) {\n  options = options || {}\n  return function (p, i, list) {\n    return minimatch(p, pattern, options)\n  }\n}\n\nfunction ext (a, b) {\n  b = b || {}\n  var t = {}\n  Object.keys(a).forEach(function (k) {\n    t[k] = a[k]\n  })\n  Object.keys(b).forEach(function (k) {\n    t[k] = b[k]\n  })\n  return t\n}\n\nminimatch.defaults = function (def) {\n  if (!def || typeof def !== 'object' || !Object.keys(def).length) {\n    return minimatch\n  }\n\n  var orig = minimatch\n\n  var m = function minimatch (p, pattern, options) {\n    return orig(p, pattern, ext(def, options))\n  }\n\n  m.Minimatch = function Minimatch (pattern, options) {\n    return new orig.Minimatch(pattern, ext(def, options))\n  }\n  m.Minimatch.defaults = function defaults (options) {\n    return orig.defaults(ext(def, options)).Minimatch\n  }\n\n  m.filter = function filter (pattern, options) {\n    return orig.filter(pattern, ext(def, options))\n  }\n\n  m.defaults = function defaults (options) {\n    return orig.defaults(ext(def, options))\n  }\n\n  m.makeRe = function makeRe (pattern, options) {\n    return orig.makeRe(pattern, ext(def, options))\n  }\n\n  m.braceExpand = function braceExpand (pattern, options) {\n    return orig.braceExpand(pattern, ext(def, options))\n  }\n\n  m.match = function (list, pattern, options) {\n    return orig.match(list, pattern, ext(def, options))\n  }\n\n  return m\n}\n\nMinimatch.defaults = function (def) {\n  return minimatch.defaults(def).Minimatch\n}\n\nfunction minimatch (p, pattern, options) {\n  assertValidPattern(pattern)\n\n  if (!options) options = {}\n\n  // shortcut: comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    return false\n  }\n\n  return new Minimatch(pattern, options).match(p)\n}\n\nfunction Minimatch (pattern, options) {\n  if (!(this instanceof Minimatch)) {\n    return new Minimatch(pattern, options)\n  }\n\n  assertValidPattern(pattern)\n\n  if (!options) options = {}\n\n  pattern = pattern.trim()\n\n  // windows support: need to use /, not \\\n  if (!options.allowWindowsEscape && path.sep !== '/') {\n    pattern = pattern.split(path.sep).join('/')\n  }\n\n  this.options = options\n  this.set = []\n  this.pattern = pattern\n  this.regexp = null\n  this.negate = false\n  this.comment = false\n  this.empty = false\n  this.partial = !!options.partial\n\n  // make the set of regexps etc.\n  this.make()\n}\n\nMinimatch.prototype.debug = function () {}\n\nMinimatch.prototype.make = make\nfunction make () {\n  var pattern = this.pattern\n  var options = this.options\n\n  // empty patterns and comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    this.comment = true\n    return\n  }\n  if (!pattern) {\n    this.empty = true\n    return\n  }\n\n  // step 1: figure out negation, etc.\n  this.parseNegate()\n\n  // step 2: expand braces\n  var set = this.globSet = this.braceExpand()\n\n  if (options.debug) this.debug = function debug() { console.error.apply(console, arguments) }\n\n  this.debug(this.pattern, set)\n\n  // step 3: now we have a set, so turn each one into a series of path-portion\n  // matching patterns.\n  // These will be regexps, except in the case of \"**\", which is\n  // set to the GLOBSTAR object for globstar behavior,\n  // and will not contain any / characters\n  set = this.globParts = set.map(function (s) {\n    return s.split(slashSplit)\n  })\n\n  this.debug(this.pattern, set)\n\n  // glob --> regexps\n  set = set.map(function (s, si, set) {\n    return s.map(this.parse, this)\n  }, this)\n\n  this.debug(this.pattern, set)\n\n  // filter out everything that didn't compile properly.\n  set = set.filter(function (s) {\n    return s.indexOf(false) === -1\n  })\n\n  this.debug(this.pattern, set)\n\n  this.set = set\n}\n\nMinimatch.prototype.parseNegate = parseNegate\nfunction parseNegate () {\n  var pattern = this.pattern\n  var negate = false\n  var options = this.options\n  var negateOffset = 0\n\n  if (options.nonegate) return\n\n  for (var i = 0, l = pattern.length\n    ; i < l && pattern.charAt(i) === '!'\n    ; i++) {\n    negate = !negate\n    negateOffset++\n  }\n\n  if (negateOffset) this.pattern = pattern.substr(negateOffset)\n  this.negate = negate\n}\n\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nminimatch.braceExpand = function (pattern, options) {\n  return braceExpand(pattern, options)\n}\n\nMinimatch.prototype.braceExpand = braceExpand\n\nfunction braceExpand (pattern, options) {\n  if (!options) {\n    if (this instanceof Minimatch) {\n      options = this.options\n    } else {\n      options = {}\n    }\n  }\n\n  pattern = typeof pattern === 'undefined'\n    ? this.pattern : pattern\n\n  assertValidPattern(pattern)\n\n  // Thanks to Yeting Li <https://github.com/yetingli> for\n  // improving this regexp to avoid a ReDOS vulnerability.\n  if (options.nobrace || !/\\{(?:(?!\\{).)*\\}/.test(pattern)) {\n    // shortcut. no need to expand.\n    return [pattern]\n  }\n\n  return expand(pattern)\n}\n\nvar MAX_PATTERN_LENGTH = 1024 * 64\nvar assertValidPattern = function (pattern) {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('invalid pattern')\n  }\n\n  if (pattern.length > MAX_PATTERN_LENGTH) {\n    throw new TypeError('pattern is too long')\n  }\n}\n\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\nMinimatch.prototype.parse = parse\nvar SUBPARSE = {}\nfunction parse (pattern, isSub) {\n  assertValidPattern(pattern)\n\n  var options = this.options\n\n  // shortcuts\n  if (pattern === '**') {\n    if (!options.noglobstar)\n      return GLOBSTAR\n    else\n      pattern = '*'\n  }\n  if (pattern === '') return ''\n\n  var re = ''\n  var hasMagic = !!options.nocase\n  var escaping = false\n  // ? => one single character\n  var patternListStack = []\n  var negativeLists = []\n  var stateChar\n  var inClass = false\n  var reClassStart = -1\n  var classStart = -1\n  // . and .. never match anything that doesn't start with .,\n  // even when options.dot is set.\n  var patternStart = pattern.charAt(0) === '.' ? '' // anything\n  // not (start or / followed by . or .. followed by / or end)\n  : options.dot ? '(?!(?:^|\\\\\\/)\\\\.{1,2}(?:$|\\\\\\/))'\n  : '(?!\\\\.)'\n  var self = this\n\n  function clearStateChar () {\n    if (stateChar) {\n      // we had some state-tracking character\n      // that wasn't consumed by this pass.\n      switch (stateChar) {\n        case '*':\n          re += star\n          hasMagic = true\n        break\n        case '?':\n          re += qmark\n          hasMagic = true\n        break\n        default:\n          re += '\\\\' + stateChar\n        break\n      }\n      self.debug('clearStateChar %j %j', stateChar, re)\n      stateChar = false\n    }\n  }\n\n  for (var i = 0, len = pattern.length, c\n    ; (i < len) && (c = pattern.charAt(i))\n    ; i++) {\n    this.debug('%s\\t%s %s %j', pattern, i, re, c)\n\n    // skip over any that are escaped.\n    if (escaping && reSpecials[c]) {\n      re += '\\\\' + c\n      escaping = false\n      continue\n    }\n\n    switch (c) {\n      /* istanbul ignore next */\n      case '/': {\n        // completely not allowed, even escaped.\n        // Should already be path-split by now.\n        return false\n      }\n\n      case '\\\\':\n        clearStateChar()\n        escaping = true\n      continue\n\n      // the various stateChar values\n      // for the \"extglob\" stuff.\n      case '?':\n      case '*':\n      case '+':\n      case '@':\n      case '!':\n        this.debug('%s\\t%s %s %j <-- stateChar', pattern, i, re, c)\n\n        // all of those are literals inside a class, except that\n        // the glob [!a] means [^a] in regexp\n        if (inClass) {\n          this.debug('  in class')\n          if (c === '!' && i === classStart + 1) c = '^'\n          re += c\n          continue\n        }\n\n        // if we already have a stateChar, then it means\n        // that there was something like ** or +? in there.\n        // Handle the stateChar, then proceed with this one.\n        self.debug('call clearStateChar %j', stateChar)\n        clearStateChar()\n        stateChar = c\n        // if extglob is disabled, then +(asdf|foo) isn't a thing.\n        // just clear the statechar *now*, rather than even diving into\n        // the patternList stuff.\n        if (options.noext) clearStateChar()\n      continue\n\n      case '(':\n        if (inClass) {\n          re += '('\n          continue\n        }\n\n        if (!stateChar) {\n          re += '\\\\('\n          continue\n        }\n\n        patternListStack.push({\n          type: stateChar,\n          start: i - 1,\n          reStart: re.length,\n          open: plTypes[stateChar].open,\n          close: plTypes[stateChar].close\n        })\n        // negation is (?:(?!js)[^/]*)\n        re += stateChar === '!' ? '(?:(?!(?:' : '(?:'\n        this.debug('plType %j %j', stateChar, re)\n        stateChar = false\n      continue\n\n      case ')':\n        if (inClass || !patternListStack.length) {\n          re += '\\\\)'\n          continue\n        }\n\n        clearStateChar()\n        hasMagic = true\n        var pl = patternListStack.pop()\n        // negation is (?:(?!js)[^/]*)\n        // The others are (?:<pattern>)<type>\n        re += pl.close\n        if (pl.type === '!') {\n          negativeLists.push(pl)\n        }\n        pl.reEnd = re.length\n      continue\n\n      case '|':\n        if (inClass || !patternListStack.length || escaping) {\n          re += '\\\\|'\n          escaping = false\n          continue\n        }\n\n        clearStateChar()\n        re += '|'\n      continue\n\n      // these are mostly the same in regexp and glob\n      case '[':\n        // swallow any state-tracking char before the [\n        clearStateChar()\n\n        if (inClass) {\n          re += '\\\\' + c\n          continue\n        }\n\n        inClass = true\n        classStart = i\n        reClassStart = re.length\n        re += c\n      continue\n\n      case ']':\n        //  a right bracket shall lose its special\n        //  meaning and represent itself in\n        //  a bracket expression if it occurs\n        //  first in the list.  -- POSIX.2 2.8.3.2\n        if (i === classStart + 1 || !inClass) {\n          re += '\\\\' + c\n          escaping = false\n          continue\n        }\n\n        // handle the case where we left a class open.\n        // \"[z-a]\" is valid, equivalent to \"\\[z-a\\]\"\n        // split where the last [ was, make sure we don't have\n        // an invalid re. if so, re-walk the contents of the\n        // would-be class to re-translate any characters that\n        // were passed through as-is\n        // TODO: It would probably be faster to determine this\n        // without a try/catch and a new RegExp, but it's tricky\n        // to do safely.  For now, this is safe and works.\n        var cs = pattern.substring(classStart + 1, i)\n        try {\n          RegExp('[' + cs + ']')\n        } catch (er) {\n          // not a valid class!\n          var sp = this.parse(cs, SUBPARSE)\n          re = re.substr(0, reClassStart) + '\\\\[' + sp[0] + '\\\\]'\n          hasMagic = hasMagic || sp[1]\n          inClass = false\n          continue\n        }\n\n        // finish up the class.\n        hasMagic = true\n        inClass = false\n        re += c\n      continue\n\n      default:\n        // swallow any state char that wasn't consumed\n        clearStateChar()\n\n        if (escaping) {\n          // no need\n          escaping = false\n        } else if (reSpecials[c]\n          && !(c === '^' && inClass)) {\n          re += '\\\\'\n        }\n\n        re += c\n\n    } // switch\n  } // for\n\n  // handle the case where we left a class open.\n  // \"[abc\" is valid, equivalent to \"\\[abc\"\n  if (inClass) {\n    // split where the last [ was, and escape it\n    // this is a huge pita.  We now have to re-walk\n    // the contents of the would-be class to re-translate\n    // any characters that were passed through as-is\n    cs = pattern.substr(classStart + 1)\n    sp = this.parse(cs, SUBPARSE)\n    re = re.substr(0, reClassStart) + '\\\\[' + sp[0]\n    hasMagic = hasMagic || sp[1]\n  }\n\n  // handle the case where we had a +( thing at the *end*\n  // of the pattern.\n  // each pattern list stack adds 3 chars, and we need to go through\n  // and escape any | chars that were passed through as-is for the regexp.\n  // Go through and escape them, taking care not to double-escape any\n  // | chars that were already escaped.\n  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {\n    var tail = re.slice(pl.reStart + pl.open.length)\n    this.debug('setting tail', re, pl)\n    // maybe some even number of \\, then maybe 1 \\, followed by a |\n    tail = tail.replace(/((?:\\\\{2}){0,64})(\\\\?)\\|/g, function (_, $1, $2) {\n      if (!$2) {\n        // the | isn't already escaped, so escape it.\n        $2 = '\\\\'\n      }\n\n      // need to escape all those slashes *again*, without escaping the\n      // one that we need for escaping the | character.  As it works out,\n      // escaping an even number of slashes can be done by simply repeating\n      // it exactly after itself.  That's why this trick works.\n      //\n      // I am sorry that you have to see this.\n      return $1 + $1 + $2 + '|'\n    })\n\n    this.debug('tail=%j\\n   %s', tail, tail, pl, re)\n    var t = pl.type === '*' ? star\n      : pl.type === '?' ? qmark\n      : '\\\\' + pl.type\n\n    hasMagic = true\n    re = re.slice(0, pl.reStart) + t + '\\\\(' + tail\n  }\n\n  // handle trailing things that only matter at the very end.\n  clearStateChar()\n  if (escaping) {\n    // trailing \\\\\n    re += '\\\\\\\\'\n  }\n\n  // only need to apply the nodot start if the re starts with\n  // something that could conceivably capture a dot\n  var addPatternStart = false\n  switch (re.charAt(0)) {\n    case '[': case '.': case '(': addPatternStart = true\n  }\n\n  // Hack to work around lack of negative lookbehind in JS\n  // A pattern like: *.!(x).!(y|z) needs to ensure that a name\n  // like 'a.xyz.yz' doesn't match.  So, the first negative\n  // lookahead, has to look ALL the way ahead, to the end of\n  // the pattern.\n  for (var n = negativeLists.length - 1; n > -1; n--) {\n    var nl = negativeLists[n]\n\n    var nlBefore = re.slice(0, nl.reStart)\n    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8)\n    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd)\n    var nlAfter = re.slice(nl.reEnd)\n\n    nlLast += nlAfter\n\n    // Handle nested stuff like *(*.js|!(*.json)), where open parens\n    // mean that we should *not* include the ) in the bit that is considered\n    // \"after\" the negated section.\n    var openParensBefore = nlBefore.split('(').length - 1\n    var cleanAfter = nlAfter\n    for (i = 0; i < openParensBefore; i++) {\n      cleanAfter = cleanAfter.replace(/\\)[+*?]?/, '')\n    }\n    nlAfter = cleanAfter\n\n    var dollar = ''\n    if (nlAfter === '' && isSub !== SUBPARSE) {\n      dollar = '$'\n    }\n    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast\n    re = newRe\n  }\n\n  // if the re is not \"\" at this point, then we need to make sure\n  // it doesn't match against an empty path part.\n  // Otherwise a/* will match a/, which it should not.\n  if (re !== '' && hasMagic) {\n    re = '(?=.)' + re\n  }\n\n  if (addPatternStart) {\n    re = patternStart + re\n  }\n\n  // parsing just a piece of a larger pattern.\n  if (isSub === SUBPARSE) {\n    return [re, hasMagic]\n  }\n\n  // skip the regexp for non-magical patterns\n  // unescape anything in it, though, so that it'll be\n  // an exact match against a file etc.\n  if (!hasMagic) {\n    return globUnescape(pattern)\n  }\n\n  var flags = options.nocase ? 'i' : ''\n  try {\n    var regExp = new RegExp('^' + re + '$', flags)\n  } catch (er) /* istanbul ignore next - should be impossible */ {\n    // If it was an invalid regular expression, then it can't match\n    // anything.  This trick looks for a character after the end of\n    // the string, which is of course impossible, except in multi-line\n    // mode, but it's not a /m regex.\n    return new RegExp('$.')\n  }\n\n  regExp._glob = pattern\n  regExp._src = re\n\n  return regExp\n}\n\nminimatch.makeRe = function (pattern, options) {\n  return new Minimatch(pattern, options || {}).makeRe()\n}\n\nMinimatch.prototype.makeRe = makeRe\nfunction makeRe () {\n  if (this.regexp || this.regexp === false) return this.regexp\n\n  // at this point, this.set is a 2d array of partial\n  // pattern strings, or \"**\".\n  //\n  // It's better to use .match().  This function shouldn't\n  // be used, really, but it's pretty convenient sometimes,\n  // when you just want to work with a regex.\n  var set = this.set\n\n  if (!set.length) {\n    this.regexp = false\n    return this.regexp\n  }\n  var options = this.options\n\n  var twoStar = options.noglobstar ? star\n    : options.dot ? twoStarDot\n    : twoStarNoDot\n  var flags = options.nocase ? 'i' : ''\n\n  var re = set.map(function (pattern) {\n    return pattern.map(function (p) {\n      return (p === GLOBSTAR) ? twoStar\n      : (typeof p === 'string') ? regExpEscape(p)\n      : p._src\n    }).join('\\\\\\/')\n  }).join('|')\n\n  // must match entire pattern\n  // ending in a * or ** will make it less strict.\n  re = '^(?:' + re + ')$'\n\n  // can match anything, as long as it's not this.\n  if (this.negate) re = '^(?!' + re + ').*$'\n\n  try {\n    this.regexp = new RegExp(re, flags)\n  } catch (ex) /* istanbul ignore next - should be impossible */ {\n    this.regexp = false\n  }\n  return this.regexp\n}\n\nminimatch.match = function (list, pattern, options) {\n  options = options || {}\n  var mm = new Minimatch(pattern, options)\n  list = list.filter(function (f) {\n    return mm.match(f)\n  })\n  if (mm.options.nonull && !list.length) {\n    list.push(pattern)\n  }\n  return list\n}\n\nMinimatch.prototype.match = function match (f, partial) {\n  if (typeof partial === 'undefined') partial = this.partial\n  this.debug('match', f, this.pattern)\n  // short-circuit in the case of busted things.\n  // comments, etc.\n  if (this.comment) return false\n  if (this.empty) return f === ''\n\n  if (f === '/' && partial) return true\n\n  var options = this.options\n\n  // windows: need to use /, not \\\n  if (path.sep !== '/') {\n    f = f.split(path.sep).join('/')\n  }\n\n  // treat the test path as a set of pathparts.\n  f = f.split(slashSplit)\n  this.debug(this.pattern, 'split', f)\n\n  // just ONE of the pattern sets in this.set needs to match\n  // in order for it to be valid.  If negating, then just one\n  // match means that we have failed.\n  // Either way, return on the first hit.\n\n  var set = this.set\n  this.debug(this.pattern, 'set', set)\n\n  // Find the basename of the path by looking for the last non-empty segment\n  var filename\n  var i\n  for (i = f.length - 1; i >= 0; i--) {\n    filename = f[i]\n    if (filename) break\n  }\n\n  for (i = 0; i < set.length; i++) {\n    var pattern = set[i]\n    var file = f\n    if (options.matchBase && pattern.length === 1) {\n      file = [filename]\n    }\n    var hit = this.matchOne(file, pattern, partial)\n    if (hit) {\n      if (options.flipNegate) return true\n      return !this.negate\n    }\n  }\n\n  // didn't get any hits.  this is success if it's a negative\n  // pattern, failure otherwise.\n  if (options.flipNegate) return false\n  return this.negate\n}\n\n// set partial to true to test if, for example,\n// \"/a/b\" matches the start of \"/*/b/*/d\"\n// Partial means, if you run out of file before you run\n// out of pattern, then that's fine, as long as all\n// the parts match.\nMinimatch.prototype.matchOne = function (file, pattern, partial) {\n  var options = this.options\n\n  this.debug('matchOne',\n    { 'this': this, file: file, pattern: pattern })\n\n  this.debug('matchOne', file.length, pattern.length)\n\n  for (var fi = 0,\n      pi = 0,\n      fl = file.length,\n      pl = pattern.length\n      ; (fi < fl) && (pi < pl)\n      ; fi++, pi++) {\n    this.debug('matchOne loop')\n    var p = pattern[pi]\n    var f = file[fi]\n\n    this.debug(pattern, p, f)\n\n    // should be impossible.\n    // some invalid regexp stuff in the set.\n    /* istanbul ignore if */\n    if (p === false) return false\n\n    if (p === GLOBSTAR) {\n      this.debug('GLOBSTAR', [pattern, p, f])\n\n      // \"**\"\n      // a/**/b/**/c would match the following:\n      // a/b/x/y/z/c\n      // a/x/y/z/b/c\n      // a/b/x/b/x/c\n      // a/b/c\n      // To do this, take the rest of the pattern after\n      // the **, and see if it would match the file remainder.\n      // If so, return success.\n      // If not, the ** \"swallows\" a segment, and try again.\n      // This is recursively awful.\n      //\n      // a/**/b/**/c matching a/b/x/y/z/c\n      // - a matches a\n      // - doublestar\n      //   - matchOne(b/x/y/z/c, b/**/c)\n      //     - b matches b\n      //     - doublestar\n      //       - matchOne(x/y/z/c, c) -> no\n      //       - matchOne(y/z/c, c) -> no\n      //       - matchOne(z/c, c) -> no\n      //       - matchOne(c, c) yes, hit\n      var fr = fi\n      var pr = pi + 1\n      if (pr === pl) {\n        this.debug('** at the end')\n        // a ** at the end will just swallow the rest.\n        // We have found a match.\n        // however, it will not swallow /.x, unless\n        // options.dot is set.\n        // . and .. are *never* matched by **, for explosively\n        // exponential reasons.\n        for (; fi < fl; fi++) {\n          if (file[fi] === '.' || file[fi] === '..' ||\n            (!options.dot && file[fi].charAt(0) === '.')) return false\n        }\n        return true\n      }\n\n      // ok, let's see if we can swallow whatever we can.\n      while (fr < fl) {\n        var swallowee = file[fr]\n\n        this.debug('\\nglobstar while', file, fr, pattern, pr, swallowee)\n\n        // XXX remove this slice.  Just pass the start index.\n        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n          this.debug('globstar found match!', fr, fl, swallowee)\n          // found a match.\n          return true\n        } else {\n          // can't swallow \".\" or \"..\" ever.\n          // can only swallow \".foo\" when explicitly asked.\n          if (swallowee === '.' || swallowee === '..' ||\n            (!options.dot && swallowee.charAt(0) === '.')) {\n            this.debug('dot detected!', file, fr, pattern, pr)\n            break\n          }\n\n          // ** swallows a segment, and continue.\n          this.debug('globstar swallow a segment, and continue')\n          fr++\n        }\n      }\n\n      // no match was found.\n      // However, in partial mode, we can't say this is necessarily over.\n      // If there's more *pattern* left, then\n      /* istanbul ignore if */\n      if (partial) {\n        // ran out of file\n        this.debug('\\n>>> no match, partial?', file, fr, pattern, pr)\n        if (fr === fl) return true\n      }\n      return false\n    }\n\n    // something other than **\n    // non-magic patterns just have to match exactly\n    // patterns with magic have been turned into regexps.\n    var hit\n    if (typeof p === 'string') {\n      hit = f === p\n      this.debug('string match', p, f, hit)\n    } else {\n      hit = f.match(p)\n      this.debug('pattern match', p, f, hit)\n    }\n\n    if (!hit) return false\n  }\n\n  // Note: ending in / means that we'll get a final \"\"\n  // at the end of the pattern.  This can only match a\n  // corresponding \"\" at the end of the file.\n  // If the file ends in /, then it can only match a\n  // a pattern that ends in /, unless the pattern just\n  // doesn't have any more for it. But, a/b/ should *not*\n  // match \"a/b/*\", even though \"\" matches against the\n  // [^/]*? pattern, except in partial mode, where it might\n  // simply not be reached yet.\n  // However, a/b/ should still satisfy a/*\n\n  // now either we fell off the end of the pattern, or we're done.\n  if (fi === fl && pi === pl) {\n    // ran out of pattern and filename at the same time.\n    // an exact hit!\n    return true\n  } else if (fi === fl) {\n    // ran out of file, but still had pattern left.\n    // this is ok if we're doing the match as part of\n    // a glob fs traversal.\n    return partial\n  } else /* istanbul ignore else */ if (pi === pl) {\n    // ran out of pattern, still have file left.\n    // this is only acceptable if we're on the very last\n    // empty segment of a file with a trailing slash.\n    // a/* should match a/b/\n    return (fi === fl - 1) && (file[fi] === '')\n  }\n\n  // should be unreachable.\n  /* istanbul ignore next */\n  throw new Error('wtf?')\n}\n\n// replace stuff like \\* with *\nfunction globUnescape (s) {\n  return s.replace(/\\\\(.)/g, '$1')\n}\n\nfunction regExpEscape (s) {\n  return s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}