{"ast":null,"code":"/**\n * @fileoverview Rule to flag use of parseInt without a radix argument\n * @author James Allardice\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst MODE_ALWAYS = \"always\",\n  MODE_AS_NEEDED = \"as-needed\";\nconst validRadixValues = new Set(Array.from({\n  length: 37 - 2\n}, (_, index) => index + 2));\n\n/**\n * Checks whether a given variable is shadowed or not.\n * @param {eslint-scope.Variable} variable A variable to check.\n * @returns {boolean} `true` if the variable is shadowed.\n */\nfunction isShadowed(variable) {\n  return variable.defs.length >= 1;\n}\n\n/**\n * Checks whether a given node is a MemberExpression of `parseInt` method or not.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node is a MemberExpression of `parseInt`\n *      method.\n */\nfunction isParseIntMethod(node) {\n  return node.type === \"MemberExpression\" && !node.computed && node.property.type === \"Identifier\" && node.property.name === \"parseInt\";\n}\n\n/**\n * Checks whether a given node is a valid value of radix or not.\n *\n * The following values are invalid.\n *\n * - A literal except integers between 2 and 36.\n * - undefined.\n * @param {ASTNode} radix A node of radix to check.\n * @returns {boolean} `true` if the node is valid.\n */\nfunction isValidRadix(radix) {\n  return !(radix.type === \"Literal\" && !validRadixValues.has(radix.value) || radix.type === \"Identifier\" && radix.name === \"undefined\");\n}\n\n/**\n * Checks whether a given node is a default value of radix or not.\n * @param {ASTNode} radix A node of radix to check.\n * @returns {boolean} `true` if the node is the literal node of `10`.\n */\nfunction isDefaultRadix(radix) {\n  return radix.type === \"Literal\" && radix.value === 10;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"enforce the consistent use of the radix argument when using `parseInt()`\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/radix\",\n      suggestion: true\n    },\n    schema: [{\n      enum: [\"always\", \"as-needed\"]\n    }],\n    messages: {\n      missingParameters: \"Missing parameters.\",\n      redundantRadix: \"Redundant radix parameter.\",\n      missingRadix: \"Missing radix parameter.\",\n      invalidRadix: \"Invalid radix parameter, must be an integer between 2 and 36.\",\n      addRadixParameter10: \"Add radix parameter `10` for parsing decimal numbers.\"\n    }\n  },\n  create(context) {\n    const mode = context.options[0] || MODE_ALWAYS;\n\n    /**\n     * Checks the arguments of a given CallExpression node and reports it if it\n     * offends this rule.\n     * @param {ASTNode} node A CallExpression node to check.\n     * @returns {void}\n     */\n    function checkArguments(node) {\n      const args = node.arguments;\n      switch (args.length) {\n        case 0:\n          context.report({\n            node,\n            messageId: \"missingParameters\"\n          });\n          break;\n        case 1:\n          if (mode === MODE_ALWAYS) {\n            context.report({\n              node,\n              messageId: \"missingRadix\",\n              suggest: [{\n                messageId: \"addRadixParameter10\",\n                fix(fixer) {\n                  const sourceCode = context.getSourceCode();\n                  const tokens = sourceCode.getTokens(node);\n                  const lastToken = tokens[tokens.length - 1]; // Parenthesis.\n                  const secondToLastToken = tokens[tokens.length - 2]; // May or may not be a comma.\n                  const hasTrailingComma = secondToLastToken.type === \"Punctuator\" && secondToLastToken.value === \",\";\n                  return fixer.insertTextBefore(lastToken, hasTrailingComma ? \" 10,\" : \", 10\");\n                }\n              }]\n            });\n          }\n          break;\n        default:\n          if (mode === MODE_AS_NEEDED && isDefaultRadix(args[1])) {\n            context.report({\n              node,\n              messageId: \"redundantRadix\"\n            });\n          } else if (!isValidRadix(args[1])) {\n            context.report({\n              node,\n              messageId: \"invalidRadix\"\n            });\n          }\n          break;\n      }\n    }\n    return {\n      \"Program:exit\"() {\n        const scope = context.getScope();\n        let variable;\n\n        // Check `parseInt()`\n        variable = astUtils.getVariableByName(scope, \"parseInt\");\n        if (variable && !isShadowed(variable)) {\n          variable.references.forEach(reference => {\n            const node = reference.identifier;\n            if (astUtils.isCallee(node)) {\n              checkArguments(node.parent);\n            }\n          });\n        }\n\n        // Check `Number.parseInt()`\n        variable = astUtils.getVariableByName(scope, \"Number\");\n        if (variable && !isShadowed(variable)) {\n          variable.references.forEach(reference => {\n            const node = reference.identifier.parent;\n            const maybeCallee = node.parent.type === \"ChainExpression\" ? node.parent : node;\n            if (isParseIntMethod(node) && astUtils.isCallee(maybeCallee)) {\n              checkArguments(maybeCallee.parent);\n            }\n          });\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","MODE_ALWAYS","MODE_AS_NEEDED","validRadixValues","Set","Array","from","length","_","index","isShadowed","variable","defs","isParseIntMethod","node","type","computed","property","name","isValidRadix","radix","has","value","isDefaultRadix","module","exports","meta","docs","description","category","recommended","url","suggestion","schema","enum","messages","missingParameters","redundantRadix","missingRadix","invalidRadix","addRadixParameter10","create","context","mode","options","checkArguments","args","arguments","report","messageId","suggest","fix","fixer","sourceCode","getSourceCode","tokens","getTokens","lastToken","secondToLastToken","hasTrailingComma","insertTextBefore","Program:exit","scope","getScope","getVariableByName","references","forEach","reference","identifier","isCallee","parent","maybeCallee"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/radix.js"],"sourcesContent":["/**\n * @fileoverview Rule to flag use of parseInt without a radix argument\n * @author James Allardice\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst MODE_ALWAYS = \"always\",\n    MODE_AS_NEEDED = \"as-needed\";\n\nconst validRadixValues = new Set(Array.from({ length: 37 - 2 }, (_, index) => index + 2));\n\n/**\n * Checks whether a given variable is shadowed or not.\n * @param {eslint-scope.Variable} variable A variable to check.\n * @returns {boolean} `true` if the variable is shadowed.\n */\nfunction isShadowed(variable) {\n    return variable.defs.length >= 1;\n}\n\n/**\n * Checks whether a given node is a MemberExpression of `parseInt` method or not.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node is a MemberExpression of `parseInt`\n *      method.\n */\nfunction isParseIntMethod(node) {\n    return (\n        node.type === \"MemberExpression\" &&\n        !node.computed &&\n        node.property.type === \"Identifier\" &&\n        node.property.name === \"parseInt\"\n    );\n}\n\n/**\n * Checks whether a given node is a valid value of radix or not.\n *\n * The following values are invalid.\n *\n * - A literal except integers between 2 and 36.\n * - undefined.\n * @param {ASTNode} radix A node of radix to check.\n * @returns {boolean} `true` if the node is valid.\n */\nfunction isValidRadix(radix) {\n    return !(\n        (radix.type === \"Literal\" && !validRadixValues.has(radix.value)) ||\n        (radix.type === \"Identifier\" && radix.name === \"undefined\")\n    );\n}\n\n/**\n * Checks whether a given node is a default value of radix or not.\n * @param {ASTNode} radix A node of radix to check.\n * @returns {boolean} `true` if the node is the literal node of `10`.\n */\nfunction isDefaultRadix(radix) {\n    return radix.type === \"Literal\" && radix.value === 10;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce the consistent use of the radix argument when using `parseInt()`\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/radix\",\n            suggestion: true\n        },\n\n        schema: [\n            {\n                enum: [\"always\", \"as-needed\"]\n            }\n        ],\n\n        messages: {\n            missingParameters: \"Missing parameters.\",\n            redundantRadix: \"Redundant radix parameter.\",\n            missingRadix: \"Missing radix parameter.\",\n            invalidRadix: \"Invalid radix parameter, must be an integer between 2 and 36.\",\n            addRadixParameter10: \"Add radix parameter `10` for parsing decimal numbers.\"\n        }\n    },\n\n    create(context) {\n        const mode = context.options[0] || MODE_ALWAYS;\n\n        /**\n         * Checks the arguments of a given CallExpression node and reports it if it\n         * offends this rule.\n         * @param {ASTNode} node A CallExpression node to check.\n         * @returns {void}\n         */\n        function checkArguments(node) {\n            const args = node.arguments;\n\n            switch (args.length) {\n                case 0:\n                    context.report({\n                        node,\n                        messageId: \"missingParameters\"\n                    });\n                    break;\n\n                case 1:\n                    if (mode === MODE_ALWAYS) {\n                        context.report({\n                            node,\n                            messageId: \"missingRadix\",\n                            suggest: [\n                                {\n                                    messageId: \"addRadixParameter10\",\n                                    fix(fixer) {\n                                        const sourceCode = context.getSourceCode();\n                                        const tokens = sourceCode.getTokens(node);\n                                        const lastToken = tokens[tokens.length - 1]; // Parenthesis.\n                                        const secondToLastToken = tokens[tokens.length - 2]; // May or may not be a comma.\n                                        const hasTrailingComma = secondToLastToken.type === \"Punctuator\" && secondToLastToken.value === \",\";\n\n                                        return fixer.insertTextBefore(lastToken, hasTrailingComma ? \" 10,\" : \", 10\");\n                                    }\n                                }\n                            ]\n                        });\n                    }\n                    break;\n\n                default:\n                    if (mode === MODE_AS_NEEDED && isDefaultRadix(args[1])) {\n                        context.report({\n                            node,\n                            messageId: \"redundantRadix\"\n                        });\n                    } else if (!isValidRadix(args[1])) {\n                        context.report({\n                            node,\n                            messageId: \"invalidRadix\"\n                        });\n                    }\n                    break;\n            }\n        }\n\n        return {\n            \"Program:exit\"() {\n                const scope = context.getScope();\n                let variable;\n\n                // Check `parseInt()`\n                variable = astUtils.getVariableByName(scope, \"parseInt\");\n                if (variable && !isShadowed(variable)) {\n                    variable.references.forEach(reference => {\n                        const node = reference.identifier;\n\n                        if (astUtils.isCallee(node)) {\n                            checkArguments(node.parent);\n                        }\n                    });\n                }\n\n                // Check `Number.parseInt()`\n                variable = astUtils.getVariableByName(scope, \"Number\");\n                if (variable && !isShadowed(variable)) {\n                    variable.references.forEach(reference => {\n                        const node = reference.identifier.parent;\n                        const maybeCallee = node.parent.type === \"ChainExpression\"\n                            ? node.parent\n                            : node;\n\n                        if (isParseIntMethod(node) && astUtils.isCallee(maybeCallee)) {\n                            checkArguments(maybeCallee.parent);\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}