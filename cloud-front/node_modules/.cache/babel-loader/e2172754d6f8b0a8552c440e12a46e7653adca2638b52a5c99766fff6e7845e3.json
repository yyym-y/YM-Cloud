{"ast":null,"code":"/**\n * @fileoverview Rule to disallow unnecessary labels\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow unnecessary labels\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-extra-label\"\n    },\n    schema: [],\n    fixable: \"code\",\n    messages: {\n      unexpected: \"This label '{{name}}' is unnecessary.\"\n    }\n  },\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    let scopeInfo = null;\n\n    /**\n     * Creates a new scope with a breakable statement.\n     * @param {ASTNode} node A node to create. This is a BreakableStatement.\n     * @returns {void}\n     */\n    function enterBreakableStatement(node) {\n      scopeInfo = {\n        label: node.parent.type === \"LabeledStatement\" ? node.parent.label : null,\n        breakable: true,\n        upper: scopeInfo\n      };\n    }\n\n    /**\n     * Removes the top scope of the stack.\n     * @returns {void}\n     */\n    function exitBreakableStatement() {\n      scopeInfo = scopeInfo.upper;\n    }\n\n    /**\n     * Creates a new scope with a labeled statement.\n     *\n     * This ignores it if the body is a breakable statement.\n     * In this case it's handled in the `enterBreakableStatement` function.\n     * @param {ASTNode} node A node to create. This is a LabeledStatement.\n     * @returns {void}\n     */\n    function enterLabeledStatement(node) {\n      if (!astUtils.isBreakableStatement(node.body)) {\n        scopeInfo = {\n          label: node.label,\n          breakable: false,\n          upper: scopeInfo\n        };\n      }\n    }\n\n    /**\n     * Removes the top scope of the stack.\n     *\n     * This ignores it if the body is a breakable statement.\n     * In this case it's handled in the `exitBreakableStatement` function.\n     * @param {ASTNode} node A node. This is a LabeledStatement.\n     * @returns {void}\n     */\n    function exitLabeledStatement(node) {\n      if (!astUtils.isBreakableStatement(node.body)) {\n        scopeInfo = scopeInfo.upper;\n      }\n    }\n\n    /**\n     * Reports a given control node if it's unnecessary.\n     * @param {ASTNode} node A node. This is a BreakStatement or a\n     *      ContinueStatement.\n     * @returns {void}\n     */\n    function reportIfUnnecessary(node) {\n      if (!node.label) {\n        return;\n      }\n      const labelNode = node.label;\n      for (let info = scopeInfo; info !== null; info = info.upper) {\n        if (info.breakable || info.label && info.label.name === labelNode.name) {\n          if (info.breakable && info.label && info.label.name === labelNode.name) {\n            context.report({\n              node: labelNode,\n              messageId: \"unexpected\",\n              data: labelNode,\n              fix(fixer) {\n                const breakOrContinueToken = sourceCode.getFirstToken(node);\n                if (sourceCode.commentsExistBetween(breakOrContinueToken, labelNode)) {\n                  return null;\n                }\n                return fixer.removeRange([breakOrContinueToken.range[1], labelNode.range[1]]);\n              }\n            });\n          }\n          return;\n        }\n      }\n    }\n    return {\n      WhileStatement: enterBreakableStatement,\n      \"WhileStatement:exit\": exitBreakableStatement,\n      DoWhileStatement: enterBreakableStatement,\n      \"DoWhileStatement:exit\": exitBreakableStatement,\n      ForStatement: enterBreakableStatement,\n      \"ForStatement:exit\": exitBreakableStatement,\n      ForInStatement: enterBreakableStatement,\n      \"ForInStatement:exit\": exitBreakableStatement,\n      ForOfStatement: enterBreakableStatement,\n      \"ForOfStatement:exit\": exitBreakableStatement,\n      SwitchStatement: enterBreakableStatement,\n      \"SwitchStatement:exit\": exitBreakableStatement,\n      LabeledStatement: enterLabeledStatement,\n      \"LabeledStatement:exit\": exitLabeledStatement,\n      BreakStatement: reportIfUnnecessary,\n      ContinueStatement: reportIfUnnecessary\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","module","exports","meta","type","docs","description","category","recommended","url","schema","fixable","messages","unexpected","create","context","sourceCode","getSourceCode","scopeInfo","enterBreakableStatement","node","label","parent","breakable","upper","exitBreakableStatement","enterLabeledStatement","isBreakableStatement","body","exitLabeledStatement","reportIfUnnecessary","labelNode","info","name","report","messageId","data","fix","fixer","breakOrContinueToken","getFirstToken","commentsExistBetween","removeRange","range","WhileStatement","DoWhileStatement","ForStatement","ForInStatement","ForOfStatement","SwitchStatement","LabeledStatement","BreakStatement","ContinueStatement"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/no-extra-label.js"],"sourcesContent":["/**\n * @fileoverview Rule to disallow unnecessary labels\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow unnecessary labels\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-extra-label\"\n        },\n\n        schema: [],\n        fixable: \"code\",\n\n        messages: {\n            unexpected: \"This label '{{name}}' is unnecessary.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        let scopeInfo = null;\n\n        /**\n         * Creates a new scope with a breakable statement.\n         * @param {ASTNode} node A node to create. This is a BreakableStatement.\n         * @returns {void}\n         */\n        function enterBreakableStatement(node) {\n            scopeInfo = {\n                label: node.parent.type === \"LabeledStatement\" ? node.parent.label : null,\n                breakable: true,\n                upper: scopeInfo\n            };\n        }\n\n        /**\n         * Removes the top scope of the stack.\n         * @returns {void}\n         */\n        function exitBreakableStatement() {\n            scopeInfo = scopeInfo.upper;\n        }\n\n        /**\n         * Creates a new scope with a labeled statement.\n         *\n         * This ignores it if the body is a breakable statement.\n         * In this case it's handled in the `enterBreakableStatement` function.\n         * @param {ASTNode} node A node to create. This is a LabeledStatement.\n         * @returns {void}\n         */\n        function enterLabeledStatement(node) {\n            if (!astUtils.isBreakableStatement(node.body)) {\n                scopeInfo = {\n                    label: node.label,\n                    breakable: false,\n                    upper: scopeInfo\n                };\n            }\n        }\n\n        /**\n         * Removes the top scope of the stack.\n         *\n         * This ignores it if the body is a breakable statement.\n         * In this case it's handled in the `exitBreakableStatement` function.\n         * @param {ASTNode} node A node. This is a LabeledStatement.\n         * @returns {void}\n         */\n        function exitLabeledStatement(node) {\n            if (!astUtils.isBreakableStatement(node.body)) {\n                scopeInfo = scopeInfo.upper;\n            }\n        }\n\n        /**\n         * Reports a given control node if it's unnecessary.\n         * @param {ASTNode} node A node. This is a BreakStatement or a\n         *      ContinueStatement.\n         * @returns {void}\n         */\n        function reportIfUnnecessary(node) {\n            if (!node.label) {\n                return;\n            }\n\n            const labelNode = node.label;\n\n            for (let info = scopeInfo; info !== null; info = info.upper) {\n                if (info.breakable || info.label && info.label.name === labelNode.name) {\n                    if (info.breakable && info.label && info.label.name === labelNode.name) {\n                        context.report({\n                            node: labelNode,\n                            messageId: \"unexpected\",\n                            data: labelNode,\n                            fix(fixer) {\n                                const breakOrContinueToken = sourceCode.getFirstToken(node);\n\n                                if (sourceCode.commentsExistBetween(breakOrContinueToken, labelNode)) {\n                                    return null;\n                                }\n\n                                return fixer.removeRange([breakOrContinueToken.range[1], labelNode.range[1]]);\n                            }\n                        });\n                    }\n                    return;\n                }\n            }\n        }\n\n        return {\n            WhileStatement: enterBreakableStatement,\n            \"WhileStatement:exit\": exitBreakableStatement,\n            DoWhileStatement: enterBreakableStatement,\n            \"DoWhileStatement:exit\": exitBreakableStatement,\n            ForStatement: enterBreakableStatement,\n            \"ForStatement:exit\": exitBreakableStatement,\n            ForInStatement: enterBreakableStatement,\n            \"ForInStatement:exit\": exitBreakableStatement,\n            ForOfStatement: enterBreakableStatement,\n            \"ForOfStatement:exit\": exitBreakableStatement,\n            SwitchStatement: enterBreakableStatement,\n            \"SwitchStatement:exit\": exitBreakableStatement,\n            LabeledStatement: enterLabeledStatement,\n            \"LabeledStatement:exit\": exitLabeledStatement,\n            BreakStatement: reportIfUnnecessary,\n            ContinueStatement: reportIfUnnecessary\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}