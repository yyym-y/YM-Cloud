{"ast":null,"code":"/**\n * @fileoverview Source code for spaced-comments rule\n * @author Gyandeep Singh\n */\n\"use strict\";\n\nconst escapeRegExp = require(\"escape-string-regexp\");\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Escapes the control characters of a given string.\n * @param {string} s A string to escape.\n * @returns {string} An escaped string.\n */\nfunction escape(s) {\n  return `(?:${escapeRegExp(s)})`;\n}\n\n/**\n * Escapes the control characters of a given string.\n * And adds a repeat flag.\n * @param {string} s A string to escape.\n * @returns {string} An escaped string.\n */\nfunction escapeAndRepeat(s) {\n  return `${escape(s)}+`;\n}\n\n/**\n * Parses `markers` option.\n * If markers don't include `\"*\"`, this adds `\"*\"` to allow JSDoc comments.\n * @param {string[]} [markers] A marker list.\n * @returns {string[]} A marker list.\n */\nfunction parseMarkersOption(markers) {\n  // `*` is a marker for JSDoc comments.\n  if (markers.indexOf(\"*\") === -1) {\n    return markers.concat(\"*\");\n  }\n  return markers;\n}\n\n/**\n * Creates string pattern for exceptions.\n * Generated pattern:\n *\n * 1. A space or an exception pattern sequence.\n * @param {string[]} exceptions An exception pattern list.\n * @returns {string} A regular expression string for exceptions.\n */\nfunction createExceptionsPattern(exceptions) {\n  let pattern = \"\";\n\n  /*\n   * A space or an exception pattern sequence.\n   * []                 ==> \"\\s\"\n   * [\"-\"]              ==> \"(?:\\s|\\-+$)\"\n   * [\"-\", \"=\"]         ==> \"(?:\\s|(?:\\-+|=+)$)\"\n   * [\"-\", \"=\", \"--==\"] ==> \"(?:\\s|(?:\\-+|=+|(?:\\-\\-==)+)$)\" ==> https://jex.im/regulex/#!embed=false&flags=&re=(%3F%3A%5Cs%7C(%3F%3A%5C-%2B%7C%3D%2B%7C(%3F%3A%5C-%5C-%3D%3D)%2B)%24)\n   */\n  if (exceptions.length === 0) {\n    // a space.\n    pattern += \"\\\\s\";\n  } else {\n    // a space or...\n    pattern += \"(?:\\\\s|\";\n    if (exceptions.length === 1) {\n      // a sequence of the exception pattern.\n      pattern += escapeAndRepeat(exceptions[0]);\n    } else {\n      // a sequence of one of the exception patterns.\n      pattern += \"(?:\";\n      pattern += exceptions.map(escapeAndRepeat).join(\"|\");\n      pattern += \")\";\n    }\n    pattern += `(?:$|[${Array.from(astUtils.LINEBREAKS).join(\"\")}]))`;\n  }\n  return pattern;\n}\n\n/**\n * Creates RegExp object for `always` mode.\n * Generated pattern for beginning of comment:\n *\n * 1. First, a marker or nothing.\n * 2. Next, a space or an exception pattern sequence.\n * @param {string[]} markers A marker list.\n * @param {string[]} exceptions An exception pattern list.\n * @returns {RegExp} A RegExp object for the beginning of a comment in `always` mode.\n */\nfunction createAlwaysStylePattern(markers, exceptions) {\n  let pattern = \"^\";\n\n  /*\n   * A marker or nothing.\n   * [\"*\"]            ==> \"\\*?\"\n   * [\"*\", \"!\"]       ==> \"(?:\\*|!)?\"\n   * [\"*\", \"/\", \"!<\"] ==> \"(?:\\*|\\/|(?:!<))?\" ==> https://jex.im/regulex/#!embed=false&flags=&re=(%3F%3A%5C*%7C%5C%2F%7C(%3F%3A!%3C))%3F\n   */\n  if (markers.length === 1) {\n    // the marker.\n    pattern += escape(markers[0]);\n  } else {\n    // one of markers.\n    pattern += \"(?:\";\n    pattern += markers.map(escape).join(\"|\");\n    pattern += \")\";\n  }\n  pattern += \"?\"; // or nothing.\n  pattern += createExceptionsPattern(exceptions);\n  return new RegExp(pattern, \"u\");\n}\n\n/**\n * Creates RegExp object for `never` mode.\n * Generated pattern for beginning of comment:\n *\n * 1. First, a marker or nothing (captured).\n * 2. Next, a space or a tab.\n * @param {string[]} markers A marker list.\n * @returns {RegExp} A RegExp object for `never` mode.\n */\nfunction createNeverStylePattern(markers) {\n  const pattern = `^(${markers.map(escape).join(\"|\")})?[ \\t]+`;\n  return new RegExp(pattern, \"u\");\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"enforce consistent spacing after the `//` or `/*` in a comment\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/spaced-comment\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      enum: [\"always\", \"never\"]\n    }, {\n      type: \"object\",\n      properties: {\n        exceptions: {\n          type: \"array\",\n          items: {\n            type: \"string\"\n          }\n        },\n        markers: {\n          type: \"array\",\n          items: {\n            type: \"string\"\n          }\n        },\n        line: {\n          type: \"object\",\n          properties: {\n            exceptions: {\n              type: \"array\",\n              items: {\n                type: \"string\"\n              }\n            },\n            markers: {\n              type: \"array\",\n              items: {\n                type: \"string\"\n              }\n            }\n          },\n          additionalProperties: false\n        },\n        block: {\n          type: \"object\",\n          properties: {\n            exceptions: {\n              type: \"array\",\n              items: {\n                type: \"string\"\n              }\n            },\n            markers: {\n              type: \"array\",\n              items: {\n                type: \"string\"\n              }\n            },\n            balanced: {\n              type: \"boolean\",\n              default: false\n            }\n          },\n          additionalProperties: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unexpectedSpaceAfterMarker: \"Unexpected space or tab after marker ({{refChar}}) in comment.\",\n      expectedExceptionAfter: \"Expected exception block, space or tab after '{{refChar}}' in comment.\",\n      unexpectedSpaceBefore: \"Unexpected space or tab before '*/' in comment.\",\n      unexpectedSpaceAfter: \"Unexpected space or tab after '{{refChar}}' in comment.\",\n      expectedSpaceBefore: \"Expected space or tab before '*/' in comment.\",\n      expectedSpaceAfter: \"Expected space or tab after '{{refChar}}' in comment.\"\n    }\n  },\n  create(context) {\n    const sourceCode = context.getSourceCode();\n\n    // Unless the first option is never, require a space\n    const requireSpace = context.options[0] !== \"never\";\n\n    /*\n     * Parse the second options.\n     * If markers don't include `\"*\"`, it's added automatically for JSDoc\n     * comments.\n     */\n    const config = context.options[1] || {};\n    const balanced = config.block && config.block.balanced;\n    const styleRules = [\"block\", \"line\"].reduce((rule, type) => {\n      const markers = parseMarkersOption(config[type] && config[type].markers || config.markers || []);\n      const exceptions = config[type] && config[type].exceptions || config.exceptions || [];\n      const endNeverPattern = \"[ \\t]+$\";\n\n      // Create RegExp object for valid patterns.\n      rule[type] = {\n        beginRegex: requireSpace ? createAlwaysStylePattern(markers, exceptions) : createNeverStylePattern(markers),\n        endRegex: balanced && requireSpace ? new RegExp(`${createExceptionsPattern(exceptions)}$`, \"u\") : new RegExp(endNeverPattern, \"u\"),\n        hasExceptions: exceptions.length > 0,\n        captureMarker: new RegExp(`^(${markers.map(escape).join(\"|\")})`, \"u\"),\n        markers: new Set(markers)\n      };\n      return rule;\n    }, {});\n\n    /**\n     * Reports a beginning spacing error with an appropriate message.\n     * @param {ASTNode} node A comment node to check.\n     * @param {string} messageId An error message to report.\n     * @param {Array} match An array of match results for markers.\n     * @param {string} refChar Character used for reference in the error message.\n     * @returns {void}\n     */\n    function reportBegin(node, messageId, match, refChar) {\n      const type = node.type.toLowerCase(),\n        commentIdentifier = type === \"block\" ? \"/*\" : \"//\";\n      context.report({\n        node,\n        fix(fixer) {\n          const start = node.range[0];\n          let end = start + 2;\n          if (requireSpace) {\n            if (match) {\n              end += match[0].length;\n            }\n            return fixer.insertTextAfterRange([start, end], \" \");\n          }\n          end += match[0].length;\n          return fixer.replaceTextRange([start, end], commentIdentifier + (match[1] ? match[1] : \"\"));\n        },\n        messageId,\n        data: {\n          refChar\n        }\n      });\n    }\n\n    /**\n     * Reports an ending spacing error with an appropriate message.\n     * @param {ASTNode} node A comment node to check.\n     * @param {string} messageId An error message to report.\n     * @param {string} match An array of the matched whitespace characters.\n     * @returns {void}\n     */\n    function reportEnd(node, messageId, match) {\n      context.report({\n        node,\n        fix(fixer) {\n          if (requireSpace) {\n            return fixer.insertTextAfterRange([node.range[0], node.range[1] - 2], \" \");\n          }\n          const end = node.range[1] - 2,\n            start = end - match[0].length;\n          return fixer.replaceTextRange([start, end], \"\");\n        },\n        messageId\n      });\n    }\n\n    /**\n     * Reports a given comment if it's invalid.\n     * @param {ASTNode} node a comment node to check.\n     * @returns {void}\n     */\n    function checkCommentForSpace(node) {\n      const type = node.type.toLowerCase(),\n        rule = styleRules[type],\n        commentIdentifier = type === \"block\" ? \"/*\" : \"//\";\n\n      // Ignores empty comments and comments that consist only of a marker.\n      if (node.value.length === 0 || rule.markers.has(node.value)) {\n        return;\n      }\n      const beginMatch = rule.beginRegex.exec(node.value);\n      const endMatch = rule.endRegex.exec(node.value);\n\n      // Checks.\n      if (requireSpace) {\n        if (!beginMatch) {\n          const hasMarker = rule.captureMarker.exec(node.value);\n          const marker = hasMarker ? commentIdentifier + hasMarker[0] : commentIdentifier;\n          if (rule.hasExceptions) {\n            reportBegin(node, \"expectedExceptionAfter\", hasMarker, marker);\n          } else {\n            reportBegin(node, \"expectedSpaceAfter\", hasMarker, marker);\n          }\n        }\n        if (balanced && type === \"block\" && !endMatch) {\n          reportEnd(node, \"expectedSpaceBefore\");\n        }\n      } else {\n        if (beginMatch) {\n          if (!beginMatch[1]) {\n            reportBegin(node, \"unexpectedSpaceAfter\", beginMatch, commentIdentifier);\n          } else {\n            reportBegin(node, \"unexpectedSpaceAfterMarker\", beginMatch, beginMatch[1]);\n          }\n        }\n        if (balanced && type === \"block\" && endMatch) {\n          reportEnd(node, \"unexpectedSpaceBefore\", endMatch);\n        }\n      }\n    }\n    return {\n      Program() {\n        const comments = sourceCode.getAllComments();\n        comments.filter(token => token.type !== \"Shebang\").forEach(checkCommentForSpace);\n      }\n    };\n  }\n};","map":{"version":3,"names":["escapeRegExp","require","astUtils","escape","s","escapeAndRepeat","parseMarkersOption","markers","indexOf","concat","createExceptionsPattern","exceptions","pattern","length","map","join","Array","from","LINEBREAKS","createAlwaysStylePattern","RegExp","createNeverStylePattern","module","exports","meta","type","docs","description","category","recommended","url","fixable","schema","enum","properties","items","line","additionalProperties","block","balanced","default","messages","unexpectedSpaceAfterMarker","expectedExceptionAfter","unexpectedSpaceBefore","unexpectedSpaceAfter","expectedSpaceBefore","expectedSpaceAfter","create","context","sourceCode","getSourceCode","requireSpace","options","config","styleRules","reduce","rule","endNeverPattern","beginRegex","endRegex","hasExceptions","captureMarker","Set","reportBegin","node","messageId","match","refChar","toLowerCase","commentIdentifier","report","fix","fixer","start","range","end","insertTextAfterRange","replaceTextRange","data","reportEnd","checkCommentForSpace","value","has","beginMatch","exec","endMatch","hasMarker","marker","Program","comments","getAllComments","filter","token","forEach"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/spaced-comment.js"],"sourcesContent":["/**\n * @fileoverview Source code for spaced-comments rule\n * @author Gyandeep Singh\n */\n\"use strict\";\n\nconst escapeRegExp = require(\"escape-string-regexp\");\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Escapes the control characters of a given string.\n * @param {string} s A string to escape.\n * @returns {string} An escaped string.\n */\nfunction escape(s) {\n    return `(?:${escapeRegExp(s)})`;\n}\n\n/**\n * Escapes the control characters of a given string.\n * And adds a repeat flag.\n * @param {string} s A string to escape.\n * @returns {string} An escaped string.\n */\nfunction escapeAndRepeat(s) {\n    return `${escape(s)}+`;\n}\n\n/**\n * Parses `markers` option.\n * If markers don't include `\"*\"`, this adds `\"*\"` to allow JSDoc comments.\n * @param {string[]} [markers] A marker list.\n * @returns {string[]} A marker list.\n */\nfunction parseMarkersOption(markers) {\n\n    // `*` is a marker for JSDoc comments.\n    if (markers.indexOf(\"*\") === -1) {\n        return markers.concat(\"*\");\n    }\n\n    return markers;\n}\n\n/**\n * Creates string pattern for exceptions.\n * Generated pattern:\n *\n * 1. A space or an exception pattern sequence.\n * @param {string[]} exceptions An exception pattern list.\n * @returns {string} A regular expression string for exceptions.\n */\nfunction createExceptionsPattern(exceptions) {\n    let pattern = \"\";\n\n    /*\n     * A space or an exception pattern sequence.\n     * []                 ==> \"\\s\"\n     * [\"-\"]              ==> \"(?:\\s|\\-+$)\"\n     * [\"-\", \"=\"]         ==> \"(?:\\s|(?:\\-+|=+)$)\"\n     * [\"-\", \"=\", \"--==\"] ==> \"(?:\\s|(?:\\-+|=+|(?:\\-\\-==)+)$)\" ==> https://jex.im/regulex/#!embed=false&flags=&re=(%3F%3A%5Cs%7C(%3F%3A%5C-%2B%7C%3D%2B%7C(%3F%3A%5C-%5C-%3D%3D)%2B)%24)\n     */\n    if (exceptions.length === 0) {\n\n        // a space.\n        pattern += \"\\\\s\";\n    } else {\n\n        // a space or...\n        pattern += \"(?:\\\\s|\";\n\n        if (exceptions.length === 1) {\n\n            // a sequence of the exception pattern.\n            pattern += escapeAndRepeat(exceptions[0]);\n        } else {\n\n            // a sequence of one of the exception patterns.\n            pattern += \"(?:\";\n            pattern += exceptions.map(escapeAndRepeat).join(\"|\");\n            pattern += \")\";\n        }\n        pattern += `(?:$|[${Array.from(astUtils.LINEBREAKS).join(\"\")}]))`;\n    }\n\n    return pattern;\n}\n\n/**\n * Creates RegExp object for `always` mode.\n * Generated pattern for beginning of comment:\n *\n * 1. First, a marker or nothing.\n * 2. Next, a space or an exception pattern sequence.\n * @param {string[]} markers A marker list.\n * @param {string[]} exceptions An exception pattern list.\n * @returns {RegExp} A RegExp object for the beginning of a comment in `always` mode.\n */\nfunction createAlwaysStylePattern(markers, exceptions) {\n    let pattern = \"^\";\n\n    /*\n     * A marker or nothing.\n     * [\"*\"]            ==> \"\\*?\"\n     * [\"*\", \"!\"]       ==> \"(?:\\*|!)?\"\n     * [\"*\", \"/\", \"!<\"] ==> \"(?:\\*|\\/|(?:!<))?\" ==> https://jex.im/regulex/#!embed=false&flags=&re=(%3F%3A%5C*%7C%5C%2F%7C(%3F%3A!%3C))%3F\n     */\n    if (markers.length === 1) {\n\n        // the marker.\n        pattern += escape(markers[0]);\n    } else {\n\n        // one of markers.\n        pattern += \"(?:\";\n        pattern += markers.map(escape).join(\"|\");\n        pattern += \")\";\n    }\n\n    pattern += \"?\"; // or nothing.\n    pattern += createExceptionsPattern(exceptions);\n\n    return new RegExp(pattern, \"u\");\n}\n\n/**\n * Creates RegExp object for `never` mode.\n * Generated pattern for beginning of comment:\n *\n * 1. First, a marker or nothing (captured).\n * 2. Next, a space or a tab.\n * @param {string[]} markers A marker list.\n * @returns {RegExp} A RegExp object for `never` mode.\n */\nfunction createNeverStylePattern(markers) {\n    const pattern = `^(${markers.map(escape).join(\"|\")})?[ \\t]+`;\n\n    return new RegExp(pattern, \"u\");\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce consistent spacing after the `//` or `/*` in a comment\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/spaced-comment\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                enum: [\"always\", \"never\"]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    exceptions: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        }\n                    },\n                    markers: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        }\n                    },\n                    line: {\n                        type: \"object\",\n                        properties: {\n                            exceptions: {\n                                type: \"array\",\n                                items: {\n                                    type: \"string\"\n                                }\n                            },\n                            markers: {\n                                type: \"array\",\n                                items: {\n                                    type: \"string\"\n                                }\n                            }\n                        },\n                        additionalProperties: false\n                    },\n                    block: {\n                        type: \"object\",\n                        properties: {\n                            exceptions: {\n                                type: \"array\",\n                                items: {\n                                    type: \"string\"\n                                }\n                            },\n                            markers: {\n                                type: \"array\",\n                                items: {\n                                    type: \"string\"\n                                }\n                            },\n                            balanced: {\n                                type: \"boolean\",\n                                default: false\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            unexpectedSpaceAfterMarker: \"Unexpected space or tab after marker ({{refChar}}) in comment.\",\n            expectedExceptionAfter: \"Expected exception block, space or tab after '{{refChar}}' in comment.\",\n            unexpectedSpaceBefore: \"Unexpected space or tab before '*/' in comment.\",\n            unexpectedSpaceAfter: \"Unexpected space or tab after '{{refChar}}' in comment.\",\n            expectedSpaceBefore: \"Expected space or tab before '*/' in comment.\",\n            expectedSpaceAfter: \"Expected space or tab after '{{refChar}}' in comment.\"\n        }\n    },\n\n    create(context) {\n\n        const sourceCode = context.getSourceCode();\n\n        // Unless the first option is never, require a space\n        const requireSpace = context.options[0] !== \"never\";\n\n        /*\n         * Parse the second options.\n         * If markers don't include `\"*\"`, it's added automatically for JSDoc\n         * comments.\n         */\n        const config = context.options[1] || {};\n        const balanced = config.block && config.block.balanced;\n\n        const styleRules = [\"block\", \"line\"].reduce((rule, type) => {\n            const markers = parseMarkersOption(config[type] && config[type].markers || config.markers || []);\n            const exceptions = config[type] && config[type].exceptions || config.exceptions || [];\n            const endNeverPattern = \"[ \\t]+$\";\n\n            // Create RegExp object for valid patterns.\n            rule[type] = {\n                beginRegex: requireSpace ? createAlwaysStylePattern(markers, exceptions) : createNeverStylePattern(markers),\n                endRegex: balanced && requireSpace ? new RegExp(`${createExceptionsPattern(exceptions)}$`, \"u\") : new RegExp(endNeverPattern, \"u\"),\n                hasExceptions: exceptions.length > 0,\n                captureMarker: new RegExp(`^(${markers.map(escape).join(\"|\")})`, \"u\"),\n                markers: new Set(markers)\n            };\n\n            return rule;\n        }, {});\n\n        /**\n         * Reports a beginning spacing error with an appropriate message.\n         * @param {ASTNode} node A comment node to check.\n         * @param {string} messageId An error message to report.\n         * @param {Array} match An array of match results for markers.\n         * @param {string} refChar Character used for reference in the error message.\n         * @returns {void}\n         */\n        function reportBegin(node, messageId, match, refChar) {\n            const type = node.type.toLowerCase(),\n                commentIdentifier = type === \"block\" ? \"/*\" : \"//\";\n\n            context.report({\n                node,\n                fix(fixer) {\n                    const start = node.range[0];\n                    let end = start + 2;\n\n                    if (requireSpace) {\n                        if (match) {\n                            end += match[0].length;\n                        }\n                        return fixer.insertTextAfterRange([start, end], \" \");\n                    }\n                    end += match[0].length;\n                    return fixer.replaceTextRange([start, end], commentIdentifier + (match[1] ? match[1] : \"\"));\n\n                },\n                messageId,\n                data: { refChar }\n            });\n        }\n\n        /**\n         * Reports an ending spacing error with an appropriate message.\n         * @param {ASTNode} node A comment node to check.\n         * @param {string} messageId An error message to report.\n         * @param {string} match An array of the matched whitespace characters.\n         * @returns {void}\n         */\n        function reportEnd(node, messageId, match) {\n            context.report({\n                node,\n                fix(fixer) {\n                    if (requireSpace) {\n                        return fixer.insertTextAfterRange([node.range[0], node.range[1] - 2], \" \");\n                    }\n                    const end = node.range[1] - 2,\n                        start = end - match[0].length;\n\n                    return fixer.replaceTextRange([start, end], \"\");\n\n                },\n                messageId\n            });\n        }\n\n        /**\n         * Reports a given comment if it's invalid.\n         * @param {ASTNode} node a comment node to check.\n         * @returns {void}\n         */\n        function checkCommentForSpace(node) {\n            const type = node.type.toLowerCase(),\n                rule = styleRules[type],\n                commentIdentifier = type === \"block\" ? \"/*\" : \"//\";\n\n            // Ignores empty comments and comments that consist only of a marker.\n            if (node.value.length === 0 || rule.markers.has(node.value)) {\n                return;\n            }\n\n            const beginMatch = rule.beginRegex.exec(node.value);\n            const endMatch = rule.endRegex.exec(node.value);\n\n            // Checks.\n            if (requireSpace) {\n                if (!beginMatch) {\n                    const hasMarker = rule.captureMarker.exec(node.value);\n                    const marker = hasMarker ? commentIdentifier + hasMarker[0] : commentIdentifier;\n\n                    if (rule.hasExceptions) {\n                        reportBegin(node, \"expectedExceptionAfter\", hasMarker, marker);\n                    } else {\n                        reportBegin(node, \"expectedSpaceAfter\", hasMarker, marker);\n                    }\n                }\n\n                if (balanced && type === \"block\" && !endMatch) {\n                    reportEnd(node, \"expectedSpaceBefore\");\n                }\n            } else {\n                if (beginMatch) {\n                    if (!beginMatch[1]) {\n                        reportBegin(node, \"unexpectedSpaceAfter\", beginMatch, commentIdentifier);\n                    } else {\n                        reportBegin(node, \"unexpectedSpaceAfterMarker\", beginMatch, beginMatch[1]);\n                    }\n                }\n\n                if (balanced && type === \"block\" && endMatch) {\n                    reportEnd(node, \"unexpectedSpaceBefore\", endMatch);\n                }\n            }\n        }\n\n        return {\n            Program() {\n                const comments = sourceCode.getAllComments();\n\n                comments.filter(token => token.type !== \"Shebang\").forEach(checkCommentForSpace);\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}