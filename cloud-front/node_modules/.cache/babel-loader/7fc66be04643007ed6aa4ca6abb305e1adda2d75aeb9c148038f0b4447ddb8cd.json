{"ast":null,"code":"/**\n * @fileoverview Rule to check for the usage of var.\n * @author Jamund Ferguson\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Check whether a given variable is a global variable or not.\n * @param {eslint-scope.Variable} variable The variable to check.\n * @returns {boolean} `true` if the variable is a global variable.\n */\nfunction isGlobal(variable) {\n  return Boolean(variable.scope) && variable.scope.type === \"global\";\n}\n\n/**\n * Finds the nearest function scope or global scope walking up the scope\n * hierarchy.\n * @param {eslint-scope.Scope} scope The scope to traverse.\n * @returns {eslint-scope.Scope} a function scope or global scope containing the given\n *      scope.\n */\nfunction getEnclosingFunctionScope(scope) {\n  let currentScope = scope;\n  while (currentScope.type !== \"function\" && currentScope.type !== \"global\") {\n    currentScope = currentScope.upper;\n  }\n  return currentScope;\n}\n\n/**\n * Checks whether the given variable has any references from a more specific\n * function expression (i.e. a closure).\n * @param {eslint-scope.Variable} variable A variable to check.\n * @returns {boolean} `true` if the variable is used from a closure.\n */\nfunction isReferencedInClosure(variable) {\n  const enclosingFunctionScope = getEnclosingFunctionScope(variable.scope);\n  return variable.references.some(reference => getEnclosingFunctionScope(reference.from) !== enclosingFunctionScope);\n}\n\n/**\n * Checks whether the given node is the assignee of a loop.\n * @param {ASTNode} node A VariableDeclaration node to check.\n * @returns {boolean} `true` if the declaration is assigned as part of loop\n *      iteration.\n */\nfunction isLoopAssignee(node) {\n  return (node.parent.type === \"ForOfStatement\" || node.parent.type === \"ForInStatement\") && node === node.parent.left;\n}\n\n/**\n * Checks whether the given variable declaration is immediately initialized.\n * @param {ASTNode} node A VariableDeclaration node to check.\n * @returns {boolean} `true` if the declaration has an initializer.\n */\nfunction isDeclarationInitialized(node) {\n  return node.declarations.every(declarator => declarator.init !== null);\n}\nconst SCOPE_NODE_TYPE = /^(?:Program|BlockStatement|SwitchStatement|ForStatement|ForInStatement|ForOfStatement)$/u;\n\n/**\n * Gets the scope node which directly contains a given node.\n * @param {ASTNode} node A node to get. This is a `VariableDeclaration` or\n *      an `Identifier`.\n * @returns {ASTNode} A scope node. This is one of `Program`, `BlockStatement`,\n *      `SwitchStatement`, `ForStatement`, `ForInStatement`, and\n *      `ForOfStatement`.\n */\nfunction getScopeNode(node) {\n  for (let currentNode = node; currentNode; currentNode = currentNode.parent) {\n    if (SCOPE_NODE_TYPE.test(currentNode.type)) {\n      return currentNode;\n    }\n  }\n\n  /* istanbul ignore next : unreachable */\n  return null;\n}\n\n/**\n * Checks whether a given variable is redeclared or not.\n * @param {eslint-scope.Variable} variable A variable to check.\n * @returns {boolean} `true` if the variable is redeclared.\n */\nfunction isRedeclared(variable) {\n  return variable.defs.length >= 2;\n}\n\n/**\n * Checks whether a given variable is used from outside of the specified scope.\n * @param {ASTNode} scopeNode A scope node to check.\n * @returns {Function} The predicate function which checks whether a given\n *      variable is used from outside of the specified scope.\n */\nfunction isUsedFromOutsideOf(scopeNode) {\n  /**\n   * Checks whether a given reference is inside of the specified scope or not.\n   * @param {eslint-scope.Reference} reference A reference to check.\n   * @returns {boolean} `true` if the reference is inside of the specified\n   *      scope.\n   */\n  function isOutsideOfScope(reference) {\n    const scope = scopeNode.range;\n    const id = reference.identifier.range;\n    return id[0] < scope[0] || id[1] > scope[1];\n  }\n  return function (variable) {\n    return variable.references.some(isOutsideOfScope);\n  };\n}\n\n/**\n * Creates the predicate function which checks whether a variable has their references in TDZ.\n *\n * The predicate function would return `true`:\n *\n * - if a reference is before the declarator. E.g. (var a = b, b = 1;)(var {a = b, b} = {};)\n * - if a reference is in the expression of their default value.  E.g. (var {a = a} = {};)\n * - if a reference is in the expression of their initializer.  E.g. (var a = a;)\n * @param {ASTNode} node The initializer node of VariableDeclarator.\n * @returns {Function} The predicate function.\n * @private\n */\nfunction hasReferenceInTDZ(node) {\n  const initStart = node.range[0];\n  const initEnd = node.range[1];\n  return variable => {\n    const id = variable.defs[0].name;\n    const idStart = id.range[0];\n    const defaultValue = id.parent.type === \"AssignmentPattern\" ? id.parent.right : null;\n    const defaultStart = defaultValue && defaultValue.range[0];\n    const defaultEnd = defaultValue && defaultValue.range[1];\n    return variable.references.some(reference => {\n      const start = reference.identifier.range[0];\n      const end = reference.identifier.range[1];\n      return !reference.init && (start < idStart || defaultValue !== null && start >= defaultStart && end <= defaultEnd || start >= initStart && end <= initEnd);\n    });\n  };\n}\n\n/**\n * Checks whether a given variable has name that is allowed for 'var' declarations,\n * but disallowed for `let` declarations.\n * @param {eslint-scope.Variable} variable The variable to check.\n * @returns {boolean} `true` if the variable has a disallowed name.\n */\nfunction hasNameDisallowedForLetDeclarations(variable) {\n  return variable.name === \"let\";\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require `let` or `const` instead of `var`\",\n      category: \"ECMAScript 6\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-var\"\n    },\n    schema: [],\n    fixable: \"code\",\n    messages: {\n      unexpectedVar: \"Unexpected var, use let or const instead.\"\n    }\n  },\n  create(context) {\n    const sourceCode = context.getSourceCode();\n\n    /**\n     * Checks whether the variables which are defined by the given declarator node have their references in TDZ.\n     * @param {ASTNode} declarator The VariableDeclarator node to check.\n     * @returns {boolean} `true` if one of the variables which are defined by the given declarator node have their references in TDZ.\n     */\n    function hasSelfReferenceInTDZ(declarator) {\n      if (!declarator.init) {\n        return false;\n      }\n      const variables = context.getDeclaredVariables(declarator);\n      return variables.some(hasReferenceInTDZ(declarator.init));\n    }\n\n    /**\n     * Checks whether it can fix a given variable declaration or not.\n     * It cannot fix if the following cases:\n     *\n     * - A variable is a global variable.\n     * - A variable is declared on a SwitchCase node.\n     * - A variable is redeclared.\n     * - A variable is used from outside the scope.\n     * - A variable is used from a closure within a loop.\n     * - A variable might be used before it is assigned within a loop.\n     * - A variable might be used in TDZ.\n     * - A variable is declared in statement position (e.g. a single-line `IfStatement`)\n     * - A variable has name that is disallowed for `let` declarations.\n     *\n     * ## A variable is declared on a SwitchCase node.\n     *\n     * If this rule modifies 'var' declarations on a SwitchCase node, it\n     * would generate the warnings of 'no-case-declarations' rule. And the\n     * 'eslint:recommended' preset includes 'no-case-declarations' rule, so\n     * this rule doesn't modify those declarations.\n     *\n     * ## A variable is redeclared.\n     *\n     * The language spec disallows redeclarations of `let` declarations.\n     * Those variables would cause syntax errors.\n     *\n     * ## A variable is used from outside the scope.\n     *\n     * The language spec disallows accesses from outside of the scope for\n     * `let` declarations. Those variables would cause reference errors.\n     *\n     * ## A variable is used from a closure within a loop.\n     *\n     * A `var` declaration within a loop shares the same variable instance\n     * across all loop iterations, while a `let` declaration creates a new\n     * instance for each iteration. This means if a variable in a loop is\n     * referenced by any closure, changing it from `var` to `let` would\n     * change the behavior in a way that is generally unsafe.\n     *\n     * ## A variable might be used before it is assigned within a loop.\n     *\n     * Within a loop, a `let` declaration without an initializer will be\n     * initialized to null, while a `var` declaration will retain its value\n     * from the previous iteration, so it is only safe to change `var` to\n     * `let` if we can statically determine that the variable is always\n     * assigned a value before its first access in the loop body. To keep\n     * the implementation simple, we only convert `var` to `let` within\n     * loops when the variable is a loop assignee or the declaration has an\n     * initializer.\n     * @param {ASTNode} node A variable declaration node to check.\n     * @returns {boolean} `true` if it can fix the node.\n     */\n    function canFix(node) {\n      const variables = context.getDeclaredVariables(node);\n      const scopeNode = getScopeNode(node);\n      if (node.parent.type === \"SwitchCase\" || node.declarations.some(hasSelfReferenceInTDZ) || variables.some(isGlobal) || variables.some(isRedeclared) || variables.some(isUsedFromOutsideOf(scopeNode)) || variables.some(hasNameDisallowedForLetDeclarations)) {\n        return false;\n      }\n      if (astUtils.isInLoop(node)) {\n        if (variables.some(isReferencedInClosure)) {\n          return false;\n        }\n        if (!isLoopAssignee(node) && !isDeclarationInitialized(node)) {\n          return false;\n        }\n      }\n      if (!isLoopAssignee(node) && !(node.parent.type === \"ForStatement\" && node.parent.init === node) && !astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type)) {\n        // If the declaration is not in a block, e.g. `if (foo) var bar = 1;`, then it can't be fixed.\n        return false;\n      }\n      return true;\n    }\n\n    /**\n     * Reports a given variable declaration node.\n     * @param {ASTNode} node A variable declaration node to report.\n     * @returns {void}\n     */\n    function report(node) {\n      context.report({\n        node,\n        messageId: \"unexpectedVar\",\n        fix(fixer) {\n          const varToken = sourceCode.getFirstToken(node, {\n            filter: t => t.value === \"var\"\n          });\n          return canFix(node) ? fixer.replaceText(varToken, \"let\") : null;\n        }\n      });\n    }\n    return {\n      \"VariableDeclaration:exit\"(node) {\n        if (node.kind === \"var\") {\n          report(node);\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","isGlobal","variable","Boolean","scope","type","getEnclosingFunctionScope","currentScope","upper","isReferencedInClosure","enclosingFunctionScope","references","some","reference","from","isLoopAssignee","node","parent","left","isDeclarationInitialized","declarations","every","declarator","init","SCOPE_NODE_TYPE","getScopeNode","currentNode","test","isRedeclared","defs","length","isUsedFromOutsideOf","scopeNode","isOutsideOfScope","range","id","identifier","hasReferenceInTDZ","initStart","initEnd","name","idStart","defaultValue","right","defaultStart","defaultEnd","start","end","hasNameDisallowedForLetDeclarations","module","exports","meta","docs","description","category","recommended","url","schema","fixable","messages","unexpectedVar","create","context","sourceCode","getSourceCode","hasSelfReferenceInTDZ","variables","getDeclaredVariables","canFix","isInLoop","STATEMENT_LIST_PARENTS","has","report","messageId","fix","fixer","varToken","getFirstToken","filter","t","value","replaceText","VariableDeclaration:exit","kind"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/no-var.js"],"sourcesContent":["/**\n * @fileoverview Rule to check for the usage of var.\n * @author Jamund Ferguson\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Check whether a given variable is a global variable or not.\n * @param {eslint-scope.Variable} variable The variable to check.\n * @returns {boolean} `true` if the variable is a global variable.\n */\nfunction isGlobal(variable) {\n    return Boolean(variable.scope) && variable.scope.type === \"global\";\n}\n\n/**\n * Finds the nearest function scope or global scope walking up the scope\n * hierarchy.\n * @param {eslint-scope.Scope} scope The scope to traverse.\n * @returns {eslint-scope.Scope} a function scope or global scope containing the given\n *      scope.\n */\nfunction getEnclosingFunctionScope(scope) {\n    let currentScope = scope;\n\n    while (currentScope.type !== \"function\" && currentScope.type !== \"global\") {\n        currentScope = currentScope.upper;\n    }\n    return currentScope;\n}\n\n/**\n * Checks whether the given variable has any references from a more specific\n * function expression (i.e. a closure).\n * @param {eslint-scope.Variable} variable A variable to check.\n * @returns {boolean} `true` if the variable is used from a closure.\n */\nfunction isReferencedInClosure(variable) {\n    const enclosingFunctionScope = getEnclosingFunctionScope(variable.scope);\n\n    return variable.references.some(reference =>\n        getEnclosingFunctionScope(reference.from) !== enclosingFunctionScope);\n}\n\n/**\n * Checks whether the given node is the assignee of a loop.\n * @param {ASTNode} node A VariableDeclaration node to check.\n * @returns {boolean} `true` if the declaration is assigned as part of loop\n *      iteration.\n */\nfunction isLoopAssignee(node) {\n    return (node.parent.type === \"ForOfStatement\" || node.parent.type === \"ForInStatement\") &&\n        node === node.parent.left;\n}\n\n/**\n * Checks whether the given variable declaration is immediately initialized.\n * @param {ASTNode} node A VariableDeclaration node to check.\n * @returns {boolean} `true` if the declaration has an initializer.\n */\nfunction isDeclarationInitialized(node) {\n    return node.declarations.every(declarator => declarator.init !== null);\n}\n\nconst SCOPE_NODE_TYPE = /^(?:Program|BlockStatement|SwitchStatement|ForStatement|ForInStatement|ForOfStatement)$/u;\n\n/**\n * Gets the scope node which directly contains a given node.\n * @param {ASTNode} node A node to get. This is a `VariableDeclaration` or\n *      an `Identifier`.\n * @returns {ASTNode} A scope node. This is one of `Program`, `BlockStatement`,\n *      `SwitchStatement`, `ForStatement`, `ForInStatement`, and\n *      `ForOfStatement`.\n */\nfunction getScopeNode(node) {\n    for (let currentNode = node; currentNode; currentNode = currentNode.parent) {\n        if (SCOPE_NODE_TYPE.test(currentNode.type)) {\n            return currentNode;\n        }\n    }\n\n    /* istanbul ignore next : unreachable */\n    return null;\n}\n\n/**\n * Checks whether a given variable is redeclared or not.\n * @param {eslint-scope.Variable} variable A variable to check.\n * @returns {boolean} `true` if the variable is redeclared.\n */\nfunction isRedeclared(variable) {\n    return variable.defs.length >= 2;\n}\n\n/**\n * Checks whether a given variable is used from outside of the specified scope.\n * @param {ASTNode} scopeNode A scope node to check.\n * @returns {Function} The predicate function which checks whether a given\n *      variable is used from outside of the specified scope.\n */\nfunction isUsedFromOutsideOf(scopeNode) {\n\n    /**\n     * Checks whether a given reference is inside of the specified scope or not.\n     * @param {eslint-scope.Reference} reference A reference to check.\n     * @returns {boolean} `true` if the reference is inside of the specified\n     *      scope.\n     */\n    function isOutsideOfScope(reference) {\n        const scope = scopeNode.range;\n        const id = reference.identifier.range;\n\n        return id[0] < scope[0] || id[1] > scope[1];\n    }\n\n    return function(variable) {\n        return variable.references.some(isOutsideOfScope);\n    };\n}\n\n/**\n * Creates the predicate function which checks whether a variable has their references in TDZ.\n *\n * The predicate function would return `true`:\n *\n * - if a reference is before the declarator. E.g. (var a = b, b = 1;)(var {a = b, b} = {};)\n * - if a reference is in the expression of their default value.  E.g. (var {a = a} = {};)\n * - if a reference is in the expression of their initializer.  E.g. (var a = a;)\n * @param {ASTNode} node The initializer node of VariableDeclarator.\n * @returns {Function} The predicate function.\n * @private\n */\nfunction hasReferenceInTDZ(node) {\n    const initStart = node.range[0];\n    const initEnd = node.range[1];\n\n    return variable => {\n        const id = variable.defs[0].name;\n        const idStart = id.range[0];\n        const defaultValue = (id.parent.type === \"AssignmentPattern\" ? id.parent.right : null);\n        const defaultStart = defaultValue && defaultValue.range[0];\n        const defaultEnd = defaultValue && defaultValue.range[1];\n\n        return variable.references.some(reference => {\n            const start = reference.identifier.range[0];\n            const end = reference.identifier.range[1];\n\n            return !reference.init && (\n                start < idStart ||\n                (defaultValue !== null && start >= defaultStart && end <= defaultEnd) ||\n                (start >= initStart && end <= initEnd)\n            );\n        });\n    };\n}\n\n/**\n * Checks whether a given variable has name that is allowed for 'var' declarations,\n * but disallowed for `let` declarations.\n * @param {eslint-scope.Variable} variable The variable to check.\n * @returns {boolean} `true` if the variable has a disallowed name.\n */\nfunction hasNameDisallowedForLetDeclarations(variable) {\n    return variable.name === \"let\";\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require `let` or `const` instead of `var`\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-var\"\n        },\n\n        schema: [],\n        fixable: \"code\",\n\n        messages: {\n            unexpectedVar: \"Unexpected var, use let or const instead.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Checks whether the variables which are defined by the given declarator node have their references in TDZ.\n         * @param {ASTNode} declarator The VariableDeclarator node to check.\n         * @returns {boolean} `true` if one of the variables which are defined by the given declarator node have their references in TDZ.\n         */\n        function hasSelfReferenceInTDZ(declarator) {\n            if (!declarator.init) {\n                return false;\n            }\n            const variables = context.getDeclaredVariables(declarator);\n\n            return variables.some(hasReferenceInTDZ(declarator.init));\n        }\n\n        /**\n         * Checks whether it can fix a given variable declaration or not.\n         * It cannot fix if the following cases:\n         *\n         * - A variable is a global variable.\n         * - A variable is declared on a SwitchCase node.\n         * - A variable is redeclared.\n         * - A variable is used from outside the scope.\n         * - A variable is used from a closure within a loop.\n         * - A variable might be used before it is assigned within a loop.\n         * - A variable might be used in TDZ.\n         * - A variable is declared in statement position (e.g. a single-line `IfStatement`)\n         * - A variable has name that is disallowed for `let` declarations.\n         *\n         * ## A variable is declared on a SwitchCase node.\n         *\n         * If this rule modifies 'var' declarations on a SwitchCase node, it\n         * would generate the warnings of 'no-case-declarations' rule. And the\n         * 'eslint:recommended' preset includes 'no-case-declarations' rule, so\n         * this rule doesn't modify those declarations.\n         *\n         * ## A variable is redeclared.\n         *\n         * The language spec disallows redeclarations of `let` declarations.\n         * Those variables would cause syntax errors.\n         *\n         * ## A variable is used from outside the scope.\n         *\n         * The language spec disallows accesses from outside of the scope for\n         * `let` declarations. Those variables would cause reference errors.\n         *\n         * ## A variable is used from a closure within a loop.\n         *\n         * A `var` declaration within a loop shares the same variable instance\n         * across all loop iterations, while a `let` declaration creates a new\n         * instance for each iteration. This means if a variable in a loop is\n         * referenced by any closure, changing it from `var` to `let` would\n         * change the behavior in a way that is generally unsafe.\n         *\n         * ## A variable might be used before it is assigned within a loop.\n         *\n         * Within a loop, a `let` declaration without an initializer will be\n         * initialized to null, while a `var` declaration will retain its value\n         * from the previous iteration, so it is only safe to change `var` to\n         * `let` if we can statically determine that the variable is always\n         * assigned a value before its first access in the loop body. To keep\n         * the implementation simple, we only convert `var` to `let` within\n         * loops when the variable is a loop assignee or the declaration has an\n         * initializer.\n         * @param {ASTNode} node A variable declaration node to check.\n         * @returns {boolean} `true` if it can fix the node.\n         */\n        function canFix(node) {\n            const variables = context.getDeclaredVariables(node);\n            const scopeNode = getScopeNode(node);\n\n            if (node.parent.type === \"SwitchCase\" ||\n                node.declarations.some(hasSelfReferenceInTDZ) ||\n                variables.some(isGlobal) ||\n                variables.some(isRedeclared) ||\n                variables.some(isUsedFromOutsideOf(scopeNode)) ||\n                variables.some(hasNameDisallowedForLetDeclarations)\n            ) {\n                return false;\n            }\n\n            if (astUtils.isInLoop(node)) {\n                if (variables.some(isReferencedInClosure)) {\n                    return false;\n                }\n                if (!isLoopAssignee(node) && !isDeclarationInitialized(node)) {\n                    return false;\n                }\n            }\n\n            if (\n                !isLoopAssignee(node) &&\n                !(node.parent.type === \"ForStatement\" && node.parent.init === node) &&\n                !astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type)\n            ) {\n\n                // If the declaration is not in a block, e.g. `if (foo) var bar = 1;`, then it can't be fixed.\n                return false;\n            }\n\n            return true;\n        }\n\n        /**\n         * Reports a given variable declaration node.\n         * @param {ASTNode} node A variable declaration node to report.\n         * @returns {void}\n         */\n        function report(node) {\n            context.report({\n                node,\n                messageId: \"unexpectedVar\",\n\n                fix(fixer) {\n                    const varToken = sourceCode.getFirstToken(node, { filter: t => t.value === \"var\" });\n\n                    return canFix(node)\n                        ? fixer.replaceText(varToken, \"let\")\n                        : null;\n                }\n            });\n        }\n\n        return {\n            \"VariableDeclaration:exit\"(node) {\n                if (node.kind === \"var\") {\n                    report(node);\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}