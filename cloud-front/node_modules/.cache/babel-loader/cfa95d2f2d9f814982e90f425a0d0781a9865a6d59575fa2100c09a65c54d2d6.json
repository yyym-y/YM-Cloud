{"ast":null,"code":"/**\n * @fileoverview Rule to enforce location of semicolons.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst SELECTOR = `:matches(${[\"BreakStatement\", \"ContinueStatement\", \"DebuggerStatement\", \"DoWhileStatement\", \"ExportAllDeclaration\", \"ExportDefaultDeclaration\", \"ExportNamedDeclaration\", \"ExpressionStatement\", \"ImportDeclaration\", \"ReturnStatement\", \"ThrowStatement\", \"VariableDeclaration\"].join(\",\")})`;\n\n/**\n * Get the child node list of a given node.\n * This returns `Program#body`, `BlockStatement#body`, or `SwitchCase#consequent`.\n * This is used to check whether a node is the first/last child.\n * @param {Node} node A node to get child node list.\n * @returns {Node[]|null} The child node list.\n */\nfunction getChildren(node) {\n  const t = node.type;\n  if (t === \"BlockStatement\" || t === \"Program\") {\n    return node.body;\n  }\n  if (t === \"SwitchCase\") {\n    return node.consequent;\n  }\n  return null;\n}\n\n/**\n * Check whether a given node is the last statement in the parent block.\n * @param {Node} node A node to check.\n * @returns {boolean} `true` if the node is the last statement in the parent block.\n */\nfunction isLastChild(node) {\n  const t = node.parent.type;\n  if (t === \"IfStatement\" && node.parent.consequent === node && node.parent.alternate) {\n    // before `else` keyword.\n    return true;\n  }\n  if (t === \"DoWhileStatement\") {\n    // before `while` keyword.\n    return true;\n  }\n  const nodeList = getChildren(node.parent);\n  return nodeList !== null && nodeList[nodeList.length - 1] === node; // before `}` or etc.\n}\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce location of semicolons\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/semi-style\"\n    },\n    schema: [{\n      enum: [\"last\", \"first\"]\n    }],\n    fixable: \"whitespace\",\n    messages: {\n      expectedSemiColon: \"Expected this semicolon to be at {{pos}}.\"\n    }\n  },\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const option = context.options[0] || \"last\";\n\n    /**\n     * Check the given semicolon token.\n     * @param {Token} semiToken The semicolon token to check.\n     * @param {\"first\"|\"last\"} expected The expected location to check.\n     * @returns {void}\n     */\n    function check(semiToken, expected) {\n      const prevToken = sourceCode.getTokenBefore(semiToken);\n      const nextToken = sourceCode.getTokenAfter(semiToken);\n      const prevIsSameLine = !prevToken || astUtils.isTokenOnSameLine(prevToken, semiToken);\n      const nextIsSameLine = !nextToken || astUtils.isTokenOnSameLine(semiToken, nextToken);\n      if (expected === \"last\" && !prevIsSameLine || expected === \"first\" && !nextIsSameLine) {\n        context.report({\n          loc: semiToken.loc,\n          messageId: \"expectedSemiColon\",\n          data: {\n            pos: expected === \"last\" ? \"the end of the previous line\" : \"the beginning of the next line\"\n          },\n          fix(fixer) {\n            if (prevToken && nextToken && sourceCode.commentsExistBetween(prevToken, nextToken)) {\n              return null;\n            }\n            const start = prevToken ? prevToken.range[1] : semiToken.range[0];\n            const end = nextToken ? nextToken.range[0] : semiToken.range[1];\n            const text = expected === \"last\" ? \";\\n\" : \"\\n;\";\n            return fixer.replaceTextRange([start, end], text);\n          }\n        });\n      }\n    }\n    return {\n      [SELECTOR](node) {\n        if (option === \"first\" && isLastChild(node)) {\n          return;\n        }\n        const lastToken = sourceCode.getLastToken(node);\n        if (astUtils.isSemicolonToken(lastToken)) {\n          check(lastToken, option);\n        }\n      },\n      ForStatement(node) {\n        const firstSemi = node.init && sourceCode.getTokenAfter(node.init, astUtils.isSemicolonToken);\n        const secondSemi = node.test && sourceCode.getTokenAfter(node.test, astUtils.isSemicolonToken);\n        if (firstSemi) {\n          check(firstSemi, \"last\");\n        }\n        if (secondSemi) {\n          check(secondSemi, \"last\");\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["astUtils","require","SELECTOR","join","getChildren","node","t","type","body","consequent","isLastChild","parent","alternate","nodeList","length","module","exports","meta","docs","description","category","recommended","url","schema","enum","fixable","messages","expectedSemiColon","create","context","sourceCode","getSourceCode","option","options","check","semiToken","expected","prevToken","getTokenBefore","nextToken","getTokenAfter","prevIsSameLine","isTokenOnSameLine","nextIsSameLine","report","loc","messageId","data","pos","fix","fixer","commentsExistBetween","start","range","end","text","replaceTextRange","lastToken","getLastToken","isSemicolonToken","ForStatement","firstSemi","init","secondSemi","test"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/semi-style.js"],"sourcesContent":["/**\n * @fileoverview Rule to enforce location of semicolons.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst SELECTOR = `:matches(${\n    [\n        \"BreakStatement\", \"ContinueStatement\", \"DebuggerStatement\",\n        \"DoWhileStatement\", \"ExportAllDeclaration\",\n        \"ExportDefaultDeclaration\", \"ExportNamedDeclaration\",\n        \"ExpressionStatement\", \"ImportDeclaration\", \"ReturnStatement\",\n        \"ThrowStatement\", \"VariableDeclaration\"\n    ].join(\",\")\n})`;\n\n/**\n * Get the child node list of a given node.\n * This returns `Program#body`, `BlockStatement#body`, or `SwitchCase#consequent`.\n * This is used to check whether a node is the first/last child.\n * @param {Node} node A node to get child node list.\n * @returns {Node[]|null} The child node list.\n */\nfunction getChildren(node) {\n    const t = node.type;\n\n    if (t === \"BlockStatement\" || t === \"Program\") {\n        return node.body;\n    }\n    if (t === \"SwitchCase\") {\n        return node.consequent;\n    }\n    return null;\n}\n\n/**\n * Check whether a given node is the last statement in the parent block.\n * @param {Node} node A node to check.\n * @returns {boolean} `true` if the node is the last statement in the parent block.\n */\nfunction isLastChild(node) {\n    const t = node.parent.type;\n\n    if (t === \"IfStatement\" && node.parent.consequent === node && node.parent.alternate) { // before `else` keyword.\n        return true;\n    }\n    if (t === \"DoWhileStatement\") { // before `while` keyword.\n        return true;\n    }\n    const nodeList = getChildren(node.parent);\n\n    return nodeList !== null && nodeList[nodeList.length - 1] === node; // before `}` or etc.\n}\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce location of semicolons\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/semi-style\"\n        },\n\n        schema: [{ enum: [\"last\", \"first\"] }],\n        fixable: \"whitespace\",\n\n        messages: {\n            expectedSemiColon: \"Expected this semicolon to be at {{pos}}.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const option = context.options[0] || \"last\";\n\n        /**\n         * Check the given semicolon token.\n         * @param {Token} semiToken The semicolon token to check.\n         * @param {\"first\"|\"last\"} expected The expected location to check.\n         * @returns {void}\n         */\n        function check(semiToken, expected) {\n            const prevToken = sourceCode.getTokenBefore(semiToken);\n            const nextToken = sourceCode.getTokenAfter(semiToken);\n            const prevIsSameLine = !prevToken || astUtils.isTokenOnSameLine(prevToken, semiToken);\n            const nextIsSameLine = !nextToken || astUtils.isTokenOnSameLine(semiToken, nextToken);\n\n            if ((expected === \"last\" && !prevIsSameLine) || (expected === \"first\" && !nextIsSameLine)) {\n                context.report({\n                    loc: semiToken.loc,\n                    messageId: \"expectedSemiColon\",\n                    data: {\n                        pos: (expected === \"last\")\n                            ? \"the end of the previous line\"\n                            : \"the beginning of the next line\"\n                    },\n                    fix(fixer) {\n                        if (prevToken && nextToken && sourceCode.commentsExistBetween(prevToken, nextToken)) {\n                            return null;\n                        }\n\n                        const start = prevToken ? prevToken.range[1] : semiToken.range[0];\n                        const end = nextToken ? nextToken.range[0] : semiToken.range[1];\n                        const text = (expected === \"last\") ? \";\\n\" : \"\\n;\";\n\n                        return fixer.replaceTextRange([start, end], text);\n                    }\n                });\n            }\n        }\n\n        return {\n            [SELECTOR](node) {\n                if (option === \"first\" && isLastChild(node)) {\n                    return;\n                }\n\n                const lastToken = sourceCode.getLastToken(node);\n\n                if (astUtils.isSemicolonToken(lastToken)) {\n                    check(lastToken, option);\n                }\n            },\n\n            ForStatement(node) {\n                const firstSemi = node.init && sourceCode.getTokenAfter(node.init, astUtils.isSemicolonToken);\n                const secondSemi = node.test && sourceCode.getTokenAfter(node.test, astUtils.isSemicolonToken);\n\n                if (firstSemi) {\n                    check(firstSemi, \"last\");\n                }\n                if (secondSemi) {\n                    check(secondSemi, \"last\");\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}