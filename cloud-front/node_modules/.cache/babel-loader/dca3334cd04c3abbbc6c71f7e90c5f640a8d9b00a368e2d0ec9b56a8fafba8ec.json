{"ast":null,"code":"/**\n * @fileoverview An object that caches and applies source code fixes.\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nrequire(\"core-js/modules/es.array.push.js\");\nconst debug = require(\"debug\")(\"eslint:source-code-fixer\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst BOM = \"\\uFEFF\";\n\n/**\n * Compares items in a messages array by range.\n * @param {Message} a The first message.\n * @param {Message} b The second message.\n * @returns {int} -1 if a comes before b, 1 if a comes after b, 0 if equal.\n * @private\n */\nfunction compareMessagesByFixRange(a, b) {\n  return a.fix.range[0] - b.fix.range[0] || a.fix.range[1] - b.fix.range[1];\n}\n\n/**\n * Compares items in a messages array by line and column.\n * @param {Message} a The first message.\n * @param {Message} b The second message.\n * @returns {int} -1 if a comes before b, 1 if a comes after b, 0 if equal.\n * @private\n */\nfunction compareMessagesByLocation(a, b) {\n  return a.line - b.line || a.column - b.column;\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * Utility for apply fixes to source code.\n * @constructor\n */\nfunction SourceCodeFixer() {\n  Object.freeze(this);\n}\n\n/**\n * Applies the fixes specified by the messages to the given text. Tries to be\n * smart about the fixes and won't apply fixes over the same area in the text.\n * @param {string} sourceText The text to apply the changes to.\n * @param {Message[]} messages The array of messages reported by ESLint.\n * @param {boolean|Function} [shouldFix=true] Determines whether each message should be fixed\n * @returns {Object} An object containing the fixed text and any unfixed messages.\n */\nSourceCodeFixer.applyFixes = function (sourceText, messages, shouldFix) {\n  debug(\"Applying fixes\");\n  if (shouldFix === false) {\n    debug(\"shouldFix parameter was false, not attempting fixes\");\n    return {\n      fixed: false,\n      messages,\n      output: sourceText\n    };\n  }\n\n  // clone the array\n  const remainingMessages = [],\n    fixes = [],\n    bom = sourceText.startsWith(BOM) ? BOM : \"\",\n    text = bom ? sourceText.slice(1) : sourceText;\n  let lastPos = Number.NEGATIVE_INFINITY,\n    output = bom;\n\n  /**\n   * Try to use the 'fix' from a problem.\n   * @param   {Message} problem The message object to apply fixes from\n   * @returns {boolean}         Whether fix was successfully applied\n   */\n  function attemptFix(problem) {\n    const fix = problem.fix;\n    const start = fix.range[0];\n    const end = fix.range[1];\n\n    // Remain it as a problem if it's overlapped or it's a negative range\n    if (lastPos >= start || start > end) {\n      remainingMessages.push(problem);\n      return false;\n    }\n\n    // Remove BOM.\n    if (start < 0 && end >= 0 || start === 0 && fix.text.startsWith(BOM)) {\n      output = \"\";\n    }\n\n    // Make output to this fix.\n    output += text.slice(Math.max(0, lastPos), Math.max(0, start));\n    output += fix.text;\n    lastPos = end;\n    return true;\n  }\n  messages.forEach(problem => {\n    if (Object.prototype.hasOwnProperty.call(problem, \"fix\")) {\n      fixes.push(problem);\n    } else {\n      remainingMessages.push(problem);\n    }\n  });\n  if (fixes.length) {\n    debug(\"Found fixes to apply\");\n    let fixesWereApplied = false;\n    for (const problem of fixes.sort(compareMessagesByFixRange)) {\n      if (typeof shouldFix !== \"function\" || shouldFix(problem)) {\n        attemptFix(problem);\n\n        /*\n         * The only time attemptFix will fail is if a previous fix was\n         * applied which conflicts with it.  So we can mark this as true.\n         */\n        fixesWereApplied = true;\n      } else {\n        remainingMessages.push(problem);\n      }\n    }\n    output += text.slice(Math.max(0, lastPos));\n    return {\n      fixed: fixesWereApplied,\n      messages: remainingMessages.sort(compareMessagesByLocation),\n      output\n    };\n  }\n  debug(\"No fixes to apply\");\n  return {\n    fixed: false,\n    messages,\n    output: bom + text\n  };\n};\nmodule.exports = SourceCodeFixer;","map":{"version":3,"names":["require","debug","BOM","compareMessagesByFixRange","a","b","fix","range","compareMessagesByLocation","line","column","SourceCodeFixer","Object","freeze","applyFixes","sourceText","messages","shouldFix","fixed","output","remainingMessages","fixes","bom","startsWith","text","slice","lastPos","Number","NEGATIVE_INFINITY","attemptFix","problem","start","end","push","Math","max","forEach","prototype","hasOwnProperty","call","length","fixesWereApplied","sort","module","exports"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/linter/source-code-fixer.js"],"sourcesContent":["/**\n * @fileoverview An object that caches and applies source code fixes.\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst debug = require(\"debug\")(\"eslint:source-code-fixer\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst BOM = \"\\uFEFF\";\n\n/**\n * Compares items in a messages array by range.\n * @param {Message} a The first message.\n * @param {Message} b The second message.\n * @returns {int} -1 if a comes before b, 1 if a comes after b, 0 if equal.\n * @private\n */\nfunction compareMessagesByFixRange(a, b) {\n    return a.fix.range[0] - b.fix.range[0] || a.fix.range[1] - b.fix.range[1];\n}\n\n/**\n * Compares items in a messages array by line and column.\n * @param {Message} a The first message.\n * @param {Message} b The second message.\n * @returns {int} -1 if a comes before b, 1 if a comes after b, 0 if equal.\n * @private\n */\nfunction compareMessagesByLocation(a, b) {\n    return a.line - b.line || a.column - b.column;\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * Utility for apply fixes to source code.\n * @constructor\n */\nfunction SourceCodeFixer() {\n    Object.freeze(this);\n}\n\n/**\n * Applies the fixes specified by the messages to the given text. Tries to be\n * smart about the fixes and won't apply fixes over the same area in the text.\n * @param {string} sourceText The text to apply the changes to.\n * @param {Message[]} messages The array of messages reported by ESLint.\n * @param {boolean|Function} [shouldFix=true] Determines whether each message should be fixed\n * @returns {Object} An object containing the fixed text and any unfixed messages.\n */\nSourceCodeFixer.applyFixes = function(sourceText, messages, shouldFix) {\n    debug(\"Applying fixes\");\n\n    if (shouldFix === false) {\n        debug(\"shouldFix parameter was false, not attempting fixes\");\n        return {\n            fixed: false,\n            messages,\n            output: sourceText\n        };\n    }\n\n    // clone the array\n    const remainingMessages = [],\n        fixes = [],\n        bom = sourceText.startsWith(BOM) ? BOM : \"\",\n        text = bom ? sourceText.slice(1) : sourceText;\n    let lastPos = Number.NEGATIVE_INFINITY,\n        output = bom;\n\n    /**\n     * Try to use the 'fix' from a problem.\n     * @param   {Message} problem The message object to apply fixes from\n     * @returns {boolean}         Whether fix was successfully applied\n     */\n    function attemptFix(problem) {\n        const fix = problem.fix;\n        const start = fix.range[0];\n        const end = fix.range[1];\n\n        // Remain it as a problem if it's overlapped or it's a negative range\n        if (lastPos >= start || start > end) {\n            remainingMessages.push(problem);\n            return false;\n        }\n\n        // Remove BOM.\n        if ((start < 0 && end >= 0) || (start === 0 && fix.text.startsWith(BOM))) {\n            output = \"\";\n        }\n\n        // Make output to this fix.\n        output += text.slice(Math.max(0, lastPos), Math.max(0, start));\n        output += fix.text;\n        lastPos = end;\n        return true;\n    }\n\n    messages.forEach(problem => {\n        if (Object.prototype.hasOwnProperty.call(problem, \"fix\")) {\n            fixes.push(problem);\n        } else {\n            remainingMessages.push(problem);\n        }\n    });\n\n    if (fixes.length) {\n        debug(\"Found fixes to apply\");\n        let fixesWereApplied = false;\n\n        for (const problem of fixes.sort(compareMessagesByFixRange)) {\n            if (typeof shouldFix !== \"function\" || shouldFix(problem)) {\n                attemptFix(problem);\n\n                /*\n                 * The only time attemptFix will fail is if a previous fix was\n                 * applied which conflicts with it.  So we can mark this as true.\n                 */\n                fixesWereApplied = true;\n            } else {\n                remainingMessages.push(problem);\n            }\n        }\n        output += text.slice(Math.max(0, lastPos));\n\n        return {\n            fixed: fixesWereApplied,\n            messages: remainingMessages.sort(compareMessagesByLocation),\n            output\n        };\n    }\n\n    debug(\"No fixes to apply\");\n    return {\n        fixed: false,\n        messages,\n        output: bom + text\n    };\n\n};\n\nmodule.exports = SourceCodeFixer;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}