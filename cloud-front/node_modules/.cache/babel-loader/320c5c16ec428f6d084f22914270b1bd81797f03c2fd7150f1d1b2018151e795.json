{"ast":null,"code":"/**\n * @fileoverview Disallow reassignment of function parameters.\n * @author Nat Burns\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\nconst stopNodePattern = /(?:Statement|Declaration|Function(?:Expression)?|Program)$/u;\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow reassigning `function` parameters\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-param-reassign\"\n    },\n    schema: [{\n      oneOf: [{\n        type: \"object\",\n        properties: {\n          props: {\n            enum: [false]\n          }\n        },\n        additionalProperties: false\n      }, {\n        type: \"object\",\n        properties: {\n          props: {\n            enum: [true]\n          },\n          ignorePropertyModificationsFor: {\n            type: \"array\",\n            items: {\n              type: \"string\"\n            },\n            uniqueItems: true\n          },\n          ignorePropertyModificationsForRegex: {\n            type: \"array\",\n            items: {\n              type: \"string\"\n            },\n            uniqueItems: true\n          }\n        },\n        additionalProperties: false\n      }]\n    }],\n    messages: {\n      assignmentToFunctionParam: \"Assignment to function parameter '{{name}}'.\",\n      assignmentToFunctionParamProp: \"Assignment to property of function parameter '{{name}}'.\"\n    }\n  },\n  create(context) {\n    const props = context.options[0] && context.options[0].props;\n    const ignoredPropertyAssignmentsFor = context.options[0] && context.options[0].ignorePropertyModificationsFor || [];\n    const ignoredPropertyAssignmentsForRegex = context.options[0] && context.options[0].ignorePropertyModificationsForRegex || [];\n\n    /**\n     * Checks whether or not the reference modifies properties of its variable.\n     * @param {Reference} reference A reference to check.\n     * @returns {boolean} Whether or not the reference modifies properties of its variable.\n     */\n    function isModifyingProp(reference) {\n      let node = reference.identifier;\n      let parent = node.parent;\n      while (parent && (!stopNodePattern.test(parent.type) || parent.type === \"ForInStatement\" || parent.type === \"ForOfStatement\")) {\n        switch (parent.type) {\n          // e.g. foo.a = 0;\n          case \"AssignmentExpression\":\n            return parent.left === node;\n\n          // e.g. ++foo.a;\n          case \"UpdateExpression\":\n            return true;\n\n          // e.g. delete foo.a;\n          case \"UnaryExpression\":\n            if (parent.operator === \"delete\") {\n              return true;\n            }\n            break;\n\n          // e.g. for (foo.a in b) {}\n          case \"ForInStatement\":\n          case \"ForOfStatement\":\n            if (parent.left === node) {\n              return true;\n            }\n\n            // this is a stop node for parent.right and parent.body\n            return false;\n\n          // EXCLUDES: e.g. cache.get(foo.a).b = 0;\n          case \"CallExpression\":\n            if (parent.callee !== node) {\n              return false;\n            }\n            break;\n\n          // EXCLUDES: e.g. cache[foo.a] = 0;\n          case \"MemberExpression\":\n            if (parent.property === node) {\n              return false;\n            }\n            break;\n\n          // EXCLUDES: e.g. ({ [foo]: a }) = bar;\n          case \"Property\":\n            if (parent.key === node) {\n              return false;\n            }\n            break;\n\n          // EXCLUDES: e.g. (foo ? a : b).c = bar;\n          case \"ConditionalExpression\":\n            if (parent.test === node) {\n              return false;\n            }\n            break;\n\n          // no default\n        }\n\n        node = parent;\n        parent = node.parent;\n      }\n      return false;\n    }\n\n    /**\n     * Tests that an identifier name matches any of the ignored property assignments.\n     * First we test strings in ignoredPropertyAssignmentsFor.\n     * Then we instantiate and test RegExp objects from ignoredPropertyAssignmentsForRegex strings.\n     * @param {string} identifierName A string that describes the name of an identifier to\n     * ignore property assignments for.\n     * @returns {boolean} Whether the string matches an ignored property assignment regular expression or not.\n     */\n    function isIgnoredPropertyAssignment(identifierName) {\n      return ignoredPropertyAssignmentsFor.includes(identifierName) || ignoredPropertyAssignmentsForRegex.some(ignored => new RegExp(ignored, \"u\").test(identifierName));\n    }\n\n    /**\n     * Reports a reference if is non initializer and writable.\n     * @param {Reference} reference A reference to check.\n     * @param {int} index The index of the reference in the references.\n     * @param {Reference[]} references The array that the reference belongs to.\n     * @returns {void}\n     */\n    function checkReference(reference, index, references) {\n      const identifier = reference.identifier;\n      if (identifier && !reference.init && (\n      /*\n       * Destructuring assignments can have multiple default value,\n       * so possibly there are multiple writeable references for the same identifier.\n       */\n      index === 0 || references[index - 1].identifier !== identifier)) {\n        if (reference.isWrite()) {\n          context.report({\n            node: identifier,\n            messageId: \"assignmentToFunctionParam\",\n            data: {\n              name: identifier.name\n            }\n          });\n        } else if (props && isModifyingProp(reference) && !isIgnoredPropertyAssignment(identifier.name)) {\n          context.report({\n            node: identifier,\n            messageId: \"assignmentToFunctionParamProp\",\n            data: {\n              name: identifier.name\n            }\n          });\n        }\n      }\n    }\n\n    /**\n     * Finds and reports references that are non initializer and writable.\n     * @param {Variable} variable A variable to check.\n     * @returns {void}\n     */\n    function checkVariable(variable) {\n      if (variable.defs[0].type === \"Parameter\") {\n        variable.references.forEach(checkReference);\n      }\n    }\n\n    /**\n     * Checks parameters of a given function node.\n     * @param {ASTNode} node A function node to check.\n     * @returns {void}\n     */\n    function checkForFunction(node) {\n      context.getDeclaredVariables(node).forEach(checkVariable);\n    }\n    return {\n      // `:exit` is needed for the `node.parent` property of identifier nodes.\n      \"FunctionDeclaration:exit\": checkForFunction,\n      \"FunctionExpression:exit\": checkForFunction,\n      \"ArrowFunctionExpression:exit\": checkForFunction\n    };\n  }\n};","map":{"version":3,"names":["stopNodePattern","module","exports","meta","type","docs","description","category","recommended","url","schema","oneOf","properties","props","enum","additionalProperties","ignorePropertyModificationsFor","items","uniqueItems","ignorePropertyModificationsForRegex","messages","assignmentToFunctionParam","assignmentToFunctionParamProp","create","context","options","ignoredPropertyAssignmentsFor","ignoredPropertyAssignmentsForRegex","isModifyingProp","reference","node","identifier","parent","test","left","operator","callee","property","key","isIgnoredPropertyAssignment","identifierName","includes","some","ignored","RegExp","checkReference","index","references","init","isWrite","report","messageId","data","name","checkVariable","variable","defs","forEach","checkForFunction","getDeclaredVariables"],"sources":["D:/Project/YM~Cloud/cloud-front/node_modules/eslint/lib/rules/no-param-reassign.js"],"sourcesContent":["/**\n * @fileoverview Disallow reassignment of function parameters.\n * @author Nat Burns\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst stopNodePattern = /(?:Statement|Declaration|Function(?:Expression)?|Program)$/u;\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow reassigning `function` parameters\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-param-reassign\"\n        },\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        type: \"object\",\n                        properties: {\n                            props: {\n                                enum: [false]\n                            }\n                        },\n                        additionalProperties: false\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            props: {\n                                enum: [true]\n                            },\n                            ignorePropertyModificationsFor: {\n                                type: \"array\",\n                                items: {\n                                    type: \"string\"\n                                },\n                                uniqueItems: true\n                            },\n                            ignorePropertyModificationsForRegex: {\n                                type: \"array\",\n                                items: {\n                                    type: \"string\"\n                                },\n                                uniqueItems: true\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ],\n\n        messages: {\n            assignmentToFunctionParam: \"Assignment to function parameter '{{name}}'.\",\n            assignmentToFunctionParamProp: \"Assignment to property of function parameter '{{name}}'.\"\n        }\n    },\n\n    create(context) {\n        const props = context.options[0] && context.options[0].props;\n        const ignoredPropertyAssignmentsFor = context.options[0] && context.options[0].ignorePropertyModificationsFor || [];\n        const ignoredPropertyAssignmentsForRegex = context.options[0] && context.options[0].ignorePropertyModificationsForRegex || [];\n\n        /**\n         * Checks whether or not the reference modifies properties of its variable.\n         * @param {Reference} reference A reference to check.\n         * @returns {boolean} Whether or not the reference modifies properties of its variable.\n         */\n        function isModifyingProp(reference) {\n            let node = reference.identifier;\n            let parent = node.parent;\n\n            while (parent && (!stopNodePattern.test(parent.type) ||\n                    parent.type === \"ForInStatement\" || parent.type === \"ForOfStatement\")) {\n                switch (parent.type) {\n\n                    // e.g. foo.a = 0;\n                    case \"AssignmentExpression\":\n                        return parent.left === node;\n\n                    // e.g. ++foo.a;\n                    case \"UpdateExpression\":\n                        return true;\n\n                    // e.g. delete foo.a;\n                    case \"UnaryExpression\":\n                        if (parent.operator === \"delete\") {\n                            return true;\n                        }\n                        break;\n\n                    // e.g. for (foo.a in b) {}\n                    case \"ForInStatement\":\n                    case \"ForOfStatement\":\n                        if (parent.left === node) {\n                            return true;\n                        }\n\n                        // this is a stop node for parent.right and parent.body\n                        return false;\n\n                    // EXCLUDES: e.g. cache.get(foo.a).b = 0;\n                    case \"CallExpression\":\n                        if (parent.callee !== node) {\n                            return false;\n                        }\n                        break;\n\n                    // EXCLUDES: e.g. cache[foo.a] = 0;\n                    case \"MemberExpression\":\n                        if (parent.property === node) {\n                            return false;\n                        }\n                        break;\n\n                    // EXCLUDES: e.g. ({ [foo]: a }) = bar;\n                    case \"Property\":\n                        if (parent.key === node) {\n                            return false;\n                        }\n\n                        break;\n\n                    // EXCLUDES: e.g. (foo ? a : b).c = bar;\n                    case \"ConditionalExpression\":\n                        if (parent.test === node) {\n                            return false;\n                        }\n\n                        break;\n\n                    // no default\n                }\n\n                node = parent;\n                parent = node.parent;\n            }\n\n            return false;\n        }\n\n        /**\n         * Tests that an identifier name matches any of the ignored property assignments.\n         * First we test strings in ignoredPropertyAssignmentsFor.\n         * Then we instantiate and test RegExp objects from ignoredPropertyAssignmentsForRegex strings.\n         * @param {string} identifierName A string that describes the name of an identifier to\n         * ignore property assignments for.\n         * @returns {boolean} Whether the string matches an ignored property assignment regular expression or not.\n         */\n        function isIgnoredPropertyAssignment(identifierName) {\n            return ignoredPropertyAssignmentsFor.includes(identifierName) ||\n                ignoredPropertyAssignmentsForRegex.some(ignored => new RegExp(ignored, \"u\").test(identifierName));\n        }\n\n        /**\n         * Reports a reference if is non initializer and writable.\n         * @param {Reference} reference A reference to check.\n         * @param {int} index The index of the reference in the references.\n         * @param {Reference[]} references The array that the reference belongs to.\n         * @returns {void}\n         */\n        function checkReference(reference, index, references) {\n            const identifier = reference.identifier;\n\n            if (identifier &&\n                !reference.init &&\n\n                /*\n                 * Destructuring assignments can have multiple default value,\n                 * so possibly there are multiple writeable references for the same identifier.\n                 */\n                (index === 0 || references[index - 1].identifier !== identifier)\n            ) {\n                if (reference.isWrite()) {\n                    context.report({\n                        node: identifier,\n                        messageId: \"assignmentToFunctionParam\",\n                        data: { name: identifier.name }\n                    });\n                } else if (props && isModifyingProp(reference) && !isIgnoredPropertyAssignment(identifier.name)) {\n                    context.report({\n                        node: identifier,\n                        messageId: \"assignmentToFunctionParamProp\",\n                        data: { name: identifier.name }\n                    });\n                }\n            }\n        }\n\n        /**\n         * Finds and reports references that are non initializer and writable.\n         * @param {Variable} variable A variable to check.\n         * @returns {void}\n         */\n        function checkVariable(variable) {\n            if (variable.defs[0].type === \"Parameter\") {\n                variable.references.forEach(checkReference);\n            }\n        }\n\n        /**\n         * Checks parameters of a given function node.\n         * @param {ASTNode} node A function node to check.\n         * @returns {void}\n         */\n        function checkForFunction(node) {\n            context.getDeclaredVariables(node).forEach(checkVariable);\n        }\n\n        return {\n\n            // `:exit` is needed for the `node.parent` property of identifier nodes.\n            \"FunctionDeclaration:exit\": checkForFunction,\n            \"FunctionExpression:exit\": checkForFunction,\n            \"ArrowFunctionExpression:exit\": checkForFunction\n        };\n\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}